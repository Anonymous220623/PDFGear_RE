// Decompiled with JetBrains decompiler
// Type: Syncfusion.DocIO.DLS.Convertors.DocxParser
// Assembly: Syncfusion.DocIO.Base, Version=19.3460.0.57, Culture=neutral, PublicKeyToken=3d67ed1f87d44c89
// MVID: 5B963185-A109-4004-8296-CCBE35E10BFD
// Assembly location: C:\Program Files\PDFgear\Syncfusion.DocIO.Base.dll

using Syncfusion.CompoundFile.DocIO;
using Syncfusion.CompoundFile.DocIO.Native;
using Syncfusion.Compression.Zip;
using Syncfusion.DocIO.ReaderWriter;
using Syncfusion.DocIO.ReaderWriter.Biff_Records;
using Syncfusion.DocIO.ReaderWriter.DataStreamParser.Escher;
using Syncfusion.DocIO.ReaderWriter.Security;
using Syncfusion.Layouting;
using Syncfusion.Office;
using Syncfusion.OfficeChart;
using Syncfusion.OfficeChart.Implementation;
using Syncfusion.OfficeChart.Implementation.Charts;
using Syncfusion.OfficeChart.Implementation.XmlSerialization;
using Syncfusion.OfficeChart.Implementation.XmlSerialization.Charts;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;

#nullable disable
namespace Syncfusion.DocIO.DLS.Convertors;

internal class DocxParser : DocumentParser
{
  private const char NONBREAK_HYPHEN = '\u001E';
  private string m_nameSpace = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
  private string m_strictNameSpace = "http://purl.oclc.org/ooxml/wordprocessingml/main";
  private string m_strictANameSpace = "http://purl.oclc.org/ooxml/drawingml/main";
  private Regex m_isFloatValue = new Regex("^.*\\d+(\\.*\\d+)*$");
  private Regex m_hasAlphabet = new Regex("^[^ A-Za-z_@/#&+-]*$");
  private ZipArchive m_docArchive;
  private XmlReader m_reader;
  private WordDocument m_doc;
  private string m_majorFontName;
  private string m_minorFontName;
  private string m_majorLatinFontName = string.Empty;
  private string m_majorEaFontName = string.Empty;
  private string m_majorCsFontName = string.Empty;
  private string m_minorLatinFontName = string.Empty;
  private string m_minorEaFontName = string.Empty;
  private string m_minorCsFontName = string.Empty;
  private float m_gutter;
  private string m_currentFile = string.Empty;
  private Dictionary<string, string> m_linkStyleNames;
  private Dictionary<string, string> m_baseStyleNames;
  private Dictionary<string, DictionaryEntry> m_docRelations;
  private Dictionary<string, DictionaryEntry> m_fontTableRelations;
  private Dictionary<string, DictionaryEntry> m_settingsRelations;
  private Dictionary<string, bool> m_isExternalHyperlink;
  private List<DocxParser.BookmarkInfo> m_bookmarkNames;
  private Dictionary<string, Dictionary<string, DictionaryEntry>> m_hfRelations;
  private Dictionary<string, WPicture> m_pictureBullet;
  private Dictionary<string, string> m_abstractListStyles;
  private Dictionary<string, string> m_overrideListStyles;
  private WCharacterFormat m_currentRunFormat;
  private List<DictionaryEntry> m_footnote;
  private List<DictionaryEntry> m_endnote;
  private Stack<WField> m_fieldStack;
  private Stack<RevisionType> m_trackchangeStack = new Stack<RevisionType>();
  private Stack<Revision> m_trackchangeRevisionDetails = new Stack<Revision>();
  private RevisionType m_trackChangeType = RevisionType.None;
  private Revision moveRevision;
  private Revision contentRevision;
  private string m_revAuthorName = string.Empty;
  private DateTime m_revDateTime;
  private string m_name = string.Empty;
  private BiDirectionalOverride m_biDirectionalOverride;
  private List<Entity> m_bookMarkCollection;
  private List<Entity> m_breakCollection;
  private List<Entity> m_altChunkCollection;
  private List<Entity> m_editableRangeCollection;
  private WCommentMark m_postCommMark;
  private Dictionary<string, WComment> m_comments;
  private List<WCommentExtended> m_commentsEx;
  private Stack<WComment> m_commStack;
  private short m_gridCount;
  private short m_gridSpan;
  private Dictionary<string, int> m_imageIds;
  private Dictionary<string, byte[]> m_svgDataDict;
  private string m_appVersion = string.Empty;
  private string m_documentPath;
  private List<FontFamilyNameRecord> m_fontFamilyRecords = new List<FontFamilyNameRecord>();
  private byte m_flags;
  private string m_firstInvalidNumId;
  private byte m_bFlags;
  private byte m_bFlags4;
  private List<BlockContentControl> m_blockControls;
  private List<InlineContentControl> m_inlineControls;
  private List<WTableCell> m_cellControls;
  private Dictionary<string, DictionaryEntry> m_chartRelations;
  private AutoShapeHelper m_autoShapeHelper;
  private long shapeID = 1;

  private Dictionary<string, DictionaryEntry> ChartRelations
  {
    get
    {
      if (this.m_chartRelations == null)
        this.m_chartRelations = new Dictionary<string, DictionaryEntry>();
      return this.m_chartRelations;
    }
  }

  private bool IsInFootnote
  {
    get => ((int) this.m_bFlags & 1) != 0;
    set => this.m_bFlags = (byte) ((int) this.m_bFlags & 254 | (value ? 1 : 0));
  }

  private bool IsInEndnote
  {
    get => ((int) this.m_bFlags & 2) >> 1 != 0;
    set => this.m_bFlags = (byte) ((int) this.m_bFlags & 253 | (value ? 1 : 0) << 1);
  }

  private bool IsInComments
  {
    get => ((int) this.m_bFlags & 4) >> 2 != 0;
    set => this.m_bFlags = (byte) ((int) this.m_bFlags & 251 | (value ? 1 : 0) << 2);
  }

  private bool IsWord2003ML
  {
    get => ((int) this.m_bFlags & 16 /*0x10*/) >> 4 != 0;
    set => this.m_bFlags = (byte) ((int) this.m_bFlags & 239 | (value ? 1 : 0) << 4);
  }

  private bool IsStrict
  {
    get => ((int) this.m_bFlags4 & 1) != 0;
    set => this.m_bFlags4 = (byte) ((int) this.m_bFlags4 & 254 | (value ? 1 : 0));
  }

  private Dictionary<string, int> ImageIds
  {
    get
    {
      if (this.m_imageIds == null)
        this.m_imageIds = new Dictionary<string, int>();
      return this.m_imageIds;
    }
  }

  private Dictionary<string, byte[]> SvgDataDict
  {
    get
    {
      if (this.m_svgDataDict == null)
        this.m_svgDataDict = new Dictionary<string, byte[]>();
      return this.m_svgDataDict;
    }
  }

  private List<BlockContentControl> BlockContentControls
  {
    get
    {
      if (this.m_blockControls == null)
        this.m_blockControls = new List<BlockContentControl>();
      return this.m_blockControls;
    }
  }

  private List<InlineContentControl> InlineContentControls
  {
    get
    {
      if (this.m_inlineControls == null)
        this.m_inlineControls = new List<InlineContentControl>();
      return this.m_inlineControls;
    }
  }

  private List<WTableCell> CellContentControls
  {
    get
    {
      if (this.m_cellControls == null)
        this.m_cellControls = new List<WTableCell>();
      return this.m_cellControls;
    }
  }

  private Dictionary<string, WComment> Comments => this.m_comments;

  private List<Entity> AltChunkCollection
  {
    get
    {
      if (this.m_altChunkCollection == null)
        this.m_altChunkCollection = new List<Entity>();
      return this.m_altChunkCollection;
    }
  }

  private List<Entity> BookMarkCollection
  {
    get
    {
      if (this.m_bookMarkCollection == null)
        this.m_bookMarkCollection = new List<Entity>();
      return this.m_bookMarkCollection;
    }
  }

  private List<Entity> BreakCollection
  {
    get
    {
      if (this.m_breakCollection == null)
        this.m_breakCollection = new List<Entity>();
      return this.m_breakCollection;
    }
  }

  private List<Entity> EditableRangeCollection
  {
    get
    {
      if (this.m_editableRangeCollection == null)
        this.m_editableRangeCollection = new List<Entity>();
      return this.m_editableRangeCollection;
    }
  }

  private Stack<WComment> CommentsStack
  {
    get
    {
      if (this.m_commStack == null)
        this.m_commStack = new Stack<WComment>();
      return this.m_commStack;
    }
  }

  private WComment CurrentComment
  {
    get
    {
      return this.m_commStack != null && this.m_commStack.Count > 0 ? this.m_commStack.Peek() : (WComment) null;
    }
  }

  private Stack<WField> FieldStack
  {
    get
    {
      if (this.m_fieldStack == null)
        this.m_fieldStack = new Stack<WField>();
      return this.m_fieldStack;
    }
  }

  private WField CurrentField
  {
    get
    {
      return this.m_fieldStack != null && this.m_fieldStack.Count > 0 ? this.m_fieldStack.Peek() : (WField) null;
    }
  }

  private List<DictionaryEntry> Footnote
  {
    get
    {
      if (this.m_footnote == null || this.m_footnote.Count == 0)
        this.m_footnote = new List<DictionaryEntry>();
      return this.m_footnote;
    }
  }

  private List<DictionaryEntry> Endnote
  {
    get
    {
      if (this.m_endnote == null)
        this.m_endnote = new List<DictionaryEntry>();
      return this.m_endnote;
    }
  }

  private Dictionary<string, string> OverrideListStyleNames
  {
    get
    {
      if (this.m_overrideListStyles == null)
        this.m_overrideListStyles = new Dictionary<string, string>();
      return this.m_overrideListStyles;
    }
  }

  private Dictionary<string, string> AbstractListStyleNames
  {
    get
    {
      if (this.m_abstractListStyles == null)
        this.m_abstractListStyles = new Dictionary<string, string>();
      return this.m_abstractListStyles;
    }
  }

  private Dictionary<string, WPicture> PictureBullet
  {
    get
    {
      if (this.m_pictureBullet == null)
        this.m_pictureBullet = new Dictionary<string, WPicture>();
      return this.m_pictureBullet;
    }
  }

  private Dictionary<string, DictionaryEntry> DocumentRelations
  {
    get
    {
      if (this.m_docRelations == null)
        this.m_docRelations = new Dictionary<string, DictionaryEntry>();
      return this.m_docRelations;
    }
  }

  private Dictionary<string, DictionaryEntry> FontTableRelations
  {
    get
    {
      if (this.m_fontTableRelations == null)
        this.m_fontTableRelations = new Dictionary<string, DictionaryEntry>();
      return this.m_fontTableRelations;
    }
  }

  private Dictionary<string, DictionaryEntry> SettingsRelations
  {
    get
    {
      if (this.m_settingsRelations == null)
        this.m_settingsRelations = new Dictionary<string, DictionaryEntry>();
      return this.m_settingsRelations;
    }
  }

  private Dictionary<string, bool> IsExternalHyperlink
  {
    get
    {
      if (this.m_isExternalHyperlink == null)
        this.m_isExternalHyperlink = new Dictionary<string, bool>();
      return this.m_isExternalHyperlink;
    }
  }

  private List<DocxParser.BookmarkInfo> BookmarkNames
  {
    get
    {
      if (this.m_bookmarkNames == null)
        this.m_bookmarkNames = new List<DocxParser.BookmarkInfo>();
      return this.m_bookmarkNames;
    }
  }

  private Dictionary<string, Dictionary<string, DictionaryEntry>> HFRelations
  {
    get
    {
      if (this.m_hfRelations == null)
        this.m_hfRelations = new Dictionary<string, Dictionary<string, DictionaryEntry>>();
      return this.m_hfRelations;
    }
  }

  private Dictionary<string, string> BaseStyleNames
  {
    get
    {
      if (this.m_baseStyleNames == null)
        this.m_baseStyleNames = new Dictionary<string, string>();
      return this.m_baseStyleNames;
    }
  }

  private Dictionary<string, string> StyleNameId => this.m_doc.StyleNameIds;

  private Dictionary<string, string> LinkStyleNames
  {
    get
    {
      if (this.m_linkStyleNames == null)
        this.m_linkStyleNames = new Dictionary<string, string>();
      return this.m_linkStyleNames;
    }
  }

  private string AppVersion
  {
    get
    {
      if (this.StartsWithExt(this.m_appVersion, "12"))
        return "Word2007";
      if (this.StartsWithExt(this.m_appVersion, "14"))
        return "Word2010";
      if (this.StartsWithExt(this.m_appVersion, "15"))
        return "Word2013";
      return this.StartsWithExt(this.m_appVersion, "16") ? "WordLatest" : "Docx";
    }
    set => this.m_appVersion = value;
  }

  private AutoShapeHelper AutoShapeHelper
  {
    get
    {
      if (this.m_autoShapeHelper == null)
        this.m_autoShapeHelper = new AutoShapeHelper();
      return this.m_autoShapeHelper;
    }
  }

  private bool IsSDTHasSectionBreak
  {
    get => ((int) this.m_flags & 64 /*0x40*/) >> 6 != 0;
    set => this.m_flags = (byte) ((int) this.m_flags & 191 | (value ? 1 : 0) << 6);
  }

  private bool IsRowChangeFormat
  {
    get => ((int) this.m_flags & 1) != 0;
    set => this.m_flags = (byte) ((int) this.m_flags & 254 | (value ? 1 : 0));
  }

  private bool IsCellChangeFormat
  {
    get => ((int) this.m_flags & 2) >> 1 != 0;
    set => this.m_flags = (byte) ((int) this.m_flags & 253 | (value ? 1 : 0) << 1);
  }

  private bool IsTableChangeFormat
  {
    get => ((int) this.m_flags & 4) >> 2 != 0;
    set => this.m_flags = (byte) ((int) this.m_flags & 251 | (value ? 1 : 0) << 2);
  }

  private bool IsHyperLinkField
  {
    get => ((int) this.m_flags & 8) >> 3 != 0;
    set => this.m_flags = (byte) ((int) this.m_flags & 247 | (value ? 1 : 0) << 3);
  }

  private bool IsFirstInvalidNumID
  {
    get => ((int) this.m_flags & 32 /*0x20*/) >> 5 != 0;
    set => this.m_flags = (byte) ((int) this.m_flags & 223 | (value ? 1 : 0) << 5);
  }

  private bool IsNeedToApplyParaFormat
  {
    get => ((int) this.m_flags & 16 /*0x10*/) >> 4 != 0;
    set => this.m_flags = (byte) ((int) this.m_flags & 239 | (value ? 1 : 0) << 4);
  }

  private bool PreserveSpace
  {
    get => ((int) this.m_bFlags & 8) >> 3 != 0;
    set => this.m_bFlags = (byte) ((int) this.m_bFlags & 247 | (value ? 1 : 0) << 3);
  }

  internal WordDocument Read(string fileName, WordDocument document)
  {
    this.m_docArchive = new ZipArchive();
    if (fileName == null || fileName.Length == 0)
      throw new ArgumentOutOfRangeException("inputFileName");
    using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read))
    {
      if (document.CheckForEncryption((Stream) fileStream))
        this.m_docArchive.Open(this.DecryptDocumentStream((Stream) fileStream, document), false);
      else
        this.m_docArchive.Open((Stream) fileStream, false);
      document.Password = (string) null;
    }
    this.m_doc = document;
    this.Read(document, false);
    this.Close();
    return document;
  }

  internal WordDocument ReadWordML(string fileName, WordDocument document)
  {
    return fileName != null && fileName.Length != 0 ? this.ReadWordML((Stream) new FileStream(fileName, FileMode.Open, FileAccess.Read), document) : throw new ArgumentOutOfRangeException("inputFileName");
  }

  internal WordDocument ReadWord2003Xml(Stream stream, WordDocument document)
  {
    this.m_doc = document;
    XmlReader reader = UtilityMethods.CreateReader(stream);
    if (reader == null)
      throw new Exception("reader");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "wordDocument")
      throw new NotSupportedException("The Specified file is not a Word 2003 XML file");
    if (reader.IsEmptyElement)
      return document;
    string attribute = reader.GetAttribute("xml:space");
    if (!string.IsNullOrEmpty(attribute))
      this.PreserveSpace = attribute == "preserve";
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return document;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "wordDocument")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "DocumentProperties":
            this.ParseWord2003DocumentProperties(reader);
            break;
          case "CustomDocumentProperties":
            this.ParseWord2003CustomDocumentproperties(reader);
            break;
          case "fonts":
            this.ParseFontTable(reader);
            break;
          case "lists":
            this.ParseNumberings(reader);
            break;
          case "styles":
            this.ParseStyles(reader);
            break;
          case "shapeDefaults":
            reader.Skip();
            flag = true;
            break;
          case "docPr":
            this.ParseWord2003DocPr(reader);
            break;
          case "body":
            this.m_doc.AddSection();
            if (this.m_doc.Sections.Count == 1)
              this.m_doc.LastSection.PageSetup.InitializeDocxPageSetup();
            this.ParseBody(reader, (IEntity) null, false, false, false);
            break;
          default:
            flag = true;
            reader.Skip();
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    this.Close();
    return document;
  }

  private void ReadAndSkipWhiteSpaces(XmlReader reader)
  {
    reader.Read();
    this.SkipWhitespaces(reader);
  }

  internal void OpenFlatOPC(Stream docStream)
  {
    XmlReader reader = UtilityMethods.CreateReader(docStream);
    if (reader == null)
      throw new Exception("reader");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "package" || reader.NamespaceURI != "http://schemas.microsoft.com/office/2006/xmlPackage")
      throw new NotSupportedException("The Specified file is not a Word XML document file.");
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "package")
    {
      if (reader.NodeType == XmlNodeType.Element && reader.LocalName == "part")
      {
        string attribute = reader.GetAttribute("name", "http://schemas.microsoft.com/office/2006/xmlPackage");
        reader.GetAttribute("contentType", "http://schemas.microsoft.com/office/2006/xmlPackage");
        if (this.StartsWithExt(attribute, "/"))
        {
          this.ReadAndSkipWhiteSpaces(reader);
          if (reader.NodeType == XmlNodeType.Element && reader.LocalName == "xmlData")
          {
            this.ReadAndSkipWhiteSpaces(reader);
            if (reader.Name == "mso-contentType")
              this.ReadAndSkipWhiteSpaces(reader);
            string name = reader.Name;
            string localName2 = reader.LocalName;
            XmlNodeType nodeType = reader.NodeType;
            Stream data = (Stream) this.ReadSingleNodeIntoStream(reader);
            if (!reader.IsEmptyElement)
            {
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                if (nodeType == XmlNodeType.Element)
                  this.m_docArchive.AddItem(attribute.Remove(0, 1), data, false, FileAttributes.Normal);
              }
              else if (name == "ax:ocx")
                this.m_docArchive.AddItem(attribute.Remove(0, 1), data, false, FileAttributes.Normal);
            }
            else if (name == "ax:ocx")
              this.m_docArchive.AddItem(attribute.Remove(0, 1), data, false, FileAttributes.Normal);
          }
          else if (reader.NodeType == XmlNodeType.Element && reader.LocalName == "binaryData")
          {
            if (!reader.IsEmptyElement)
            {
              string localName3 = reader.LocalName;
              reader.Read();
              if (!(localName3 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                string s = this.Read2003ImageBase64String(reader, localName3);
                if (!string.IsNullOrEmpty(s))
                {
                  MemoryStream memoryStream = new MemoryStream();
                  BinaryWriter binaryWriter = new BinaryWriter((Stream) memoryStream);
                  byte[] buffer = Convert.FromBase64String(s);
                  binaryWriter.Write(buffer);
                  binaryWriter.Flush();
                  this.m_docArchive.AddItem(attribute.Remove(0, 1), (Stream) memoryStream, false, FileAttributes.Normal);
                }
              }
              else
                reader.Skip();
            }
            else
              reader.Skip();
          }
          else
            reader.Skip();
        }
      }
      else
        this.ReadAndSkipWhiteSpaces(reader);
    }
  }

  internal WordDocument Read(Stream docStream, WordDocument document)
  {
    this.m_docArchive = new ZipArchive();
    if (document.CheckForEncryption(docStream))
      this.m_docArchive.Open(this.DecryptDocumentStream(docStream, document), false);
    else
      this.m_docArchive.Open(docStream, false);
    document.Password = (string) null;
    this.m_doc = document;
    this.Read(document, false);
    this.Close();
    return document;
  }

  internal WordDocument ReadWordML(Stream docStream, WordDocument document)
  {
    XmlReader reader = UtilityMethods.CreateReader(docStream);
    if (reader == null)
      throw new Exception("reader");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    this.m_doc = document;
    if (reader.LocalName == "wordDocument")
    {
      this.IsWord2003ML = true;
      this.m_nameSpace = "http://schemas.microsoft.com/office/word/2003/wordml";
      document.Settings.CompatibilityMode = CompatibilityMode.Word2003;
      document = this.ReadWord2003Xml(docStream, document);
      this.IsWord2003ML = false;
      this.m_nameSpace = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
      return document;
    }
    this.m_docArchive = new ZipArchive();
    this.OpenFlatOPC(docStream);
    this.Read(document, true);
    this.Close();
    return document;
  }

  private Stream DecryptDocumentStream(Stream stream, WordDocument doc)
  {
    if (stream == null)
      throw new ArgumentNullException(nameof (stream));
    Stream stream1 = (Stream) new MemoryStream();
    bool flag = false;
    using (ICompoundFile compoundFile = doc.CreateCompoundFile(stream))
    {
      ICompoundStorage rootStorage = compoundFile.RootStorage;
      SecurityHelper.EncrytionType encryptionType = new SecurityHelper().GetEncryptionType(rootStorage);
      if (encryptionType != SecurityHelper.EncrytionType.None)
      {
        if (doc.Password == null)
          throw new ArgumentException("Document is encrypted, password is needed to open the document");
        switch (encryptionType)
        {
          case SecurityHelper.EncrytionType.Standard:
            flag = true;
            StandardDecryptor standardDecryptor = new StandardDecryptor();
            standardDecryptor.Initialize(rootStorage);
            if (!standardDecryptor.CheckPassword(doc.Password))
              throw new Exception($"Specified password \"{doc.Password}\" is incorrect!");
            stream1 = standardDecryptor.Decrypt();
            break;
          case SecurityHelper.EncrytionType.Agile:
            flag = true;
            AgileDecryptor agileDecryptor = new AgileDecryptor();
            agileDecryptor.Initialize(rootStorage);
            if (!agileDecryptor.CheckPassword(doc.Password))
              throw new Exception($"Specified password \"{doc.Password}\" is incorrect!");
            stream1 = agileDecryptor.Decrypt();
            break;
        }
      }
    }
    if (!flag)
      throw new ApplicationException("Wrong Word version");
    return stream1;
  }

  private void Read(WordDocument document, bool isFlatOPC)
  {
    document.Settings.SetCompatibilityModeValue(CompatibilityMode.Word2007);
    document.DocxPackage = new Package();
    document.DocxPackage.Load(this.m_docArchive);
    this.m_docArchive.Close();
    this.m_docArchive = (ZipArchive) null;
    if (document.DocxPackage == null || !document.DocxPackage.XmlPartContainers.ContainsKey("word/") || (isFlatOPC ? 1 : (document.DocxPackage.XmlParts.ContainsKey("[Content_Types].xml") ? 1 : 0)) == 0)
      throw new NotSupportedException("The specified file is not a valid DOCX, DOTX, DOCM, DOTM, or WordML(XML) format file");
    if (isFlatOPC)
      this.m_documentPath = "document.xml";
    else
      this.UpdatePath(document.DocxPackage);
    this.ParseDocumentProperties(document.DocxPackage);
    if (!isFlatOPC)
      this.UpdateFormatType(document);
    this.ParseDocument(document.DocxPackage);
    if (!this.IsStrict)
      return;
    document.ActualFormatType = FormatType.StrictDocx;
  }

  private void UpdatePath(Package wordPackage)
  {
    this.m_documentPath = "document.xml";
    string pathByContentType1 = this.GetPathByContentType("application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", wordPackage);
    if (!string.IsNullOrEmpty(pathByContentType1))
      this.m_documentPath = pathByContentType1;
    string pathByContentType2 = this.GetPathByContentType("application/vnd.ms-word.document.macroEnabled.main+xml", wordPackage);
    if (!string.IsNullOrEmpty(pathByContentType2))
      this.m_documentPath = pathByContentType2;
    string pathByContentType3 = this.GetPathByContentType("application/vnd.ms-word.template.macroEnabledTemplate.main+xml", wordPackage);
    if (!string.IsNullOrEmpty(pathByContentType3))
      this.m_documentPath = pathByContentType3;
    string pathByContentType4 = this.GetPathByContentType("application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml", wordPackage);
    if (string.IsNullOrEmpty(pathByContentType4))
      return;
    this.m_documentPath = pathByContentType4;
  }

  private string GetPathByContentType(string contentType, Package wordPackage)
  {
    wordPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
    XmlReader xmlReader = XmlReader.Create(this.m_doc.DocxPackage.XmlParts["[Content_Types].xml"].DataStream);
    while (xmlReader.NodeType != XmlNodeType.Element)
      xmlReader.Read();
    if (xmlReader.LocalName != "Types")
      throw new XmlException("Expected xml tag \"Types\"");
    xmlReader.Read();
    while (xmlReader.LocalName != "Types")
    {
      if (xmlReader.LocalName == "Override" && xmlReader.HasAttributes)
      {
        string attribute1 = xmlReader.GetAttribute("ContentType");
        if (contentType == attribute1)
        {
          string attribute2 = xmlReader.GetAttribute("PartName");
          if (!string.IsNullOrEmpty(attribute2))
          {
            string[] strArray = attribute2.Split('/');
            return strArray[strArray.Length - 1];
          }
        }
      }
      xmlReader.Read();
    }
    wordPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
    return (string) null;
  }

  private string GetExtensionContentType(string extension)
  {
    this.m_doc.DocxPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
    XmlReader xmlReader = XmlReader.Create(this.m_doc.DocxPackage.XmlParts["[Content_Types].xml"].DataStream);
    while (xmlReader.NodeType != XmlNodeType.Element)
      xmlReader.Read();
    if (xmlReader.LocalName != "Types")
      throw new XmlException("Expected xml tag \"Types\"");
    xmlReader.Read();
    while (xmlReader.LocalName != "Types")
    {
      if (xmlReader.LocalName == "Default" && xmlReader.HasAttributes)
      {
        string attribute = xmlReader.GetAttribute("Extension");
        if (extension == attribute)
          return xmlReader.GetAttribute("ContentType");
      }
      xmlReader.Read();
    }
    return (string) null;
  }

  private FormatType GetFormatType(string type)
  {
    switch (this.AppVersion)
    {
      case "Word2007":
        switch (type)
        {
          case "DOCM":
            return FormatType.Word2007Docm;
          case "DOTM":
            return FormatType.Word2007Dotm;
          case "DOTX":
            return FormatType.Word2007Dotx;
          default:
            return FormatType.Word2007;
        }
      case "Word2010":
        switch (type)
        {
          case "DOCM":
            return FormatType.Word2010Docm;
          case "DOTM":
            return FormatType.Word2010Dotm;
          case "DOTX":
            return FormatType.Word2010Dotx;
          default:
            return FormatType.Word2010;
        }
      case "Word2013":
        switch (type)
        {
          case "DOCM":
            return FormatType.Word2013Docm;
          case "DOTM":
            return FormatType.Word2013Dotm;
          case "DOTX":
            return FormatType.Word2013Dotx;
          default:
            return FormatType.Word2013;
        }
      default:
        switch (type)
        {
          case "DOCM":
            return FormatType.Docm;
          case "DOTM":
            return FormatType.Dotm;
          case "DOTX":
            return FormatType.Dotx;
          default:
            return FormatType.Docx;
        }
    }
  }

  private void UpdateFormatType(WordDocument document)
  {
    document.DocxPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
    document.ActualFormatType = this.GetFormatType("DOCX");
    XmlReader xmlReader = XmlReader.Create(document.DocxPackage.XmlParts["[Content_Types].xml"].DataStream);
    while (xmlReader.NodeType != XmlNodeType.Element)
      xmlReader.Read();
    if (xmlReader.LocalName != "Types")
      throw new XmlException("Expected xml tag \"Types\"");
    xmlReader.Read();
    while (xmlReader.LocalName != "Types")
    {
      if (xmlReader.LocalName == "Override" && xmlReader.HasAttributes)
      {
        if ("/word/" + this.m_documentPath == xmlReader.GetAttribute("PartName"))
        {
          if (xmlReader.GetAttribute("ContentType") == "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml")
          {
            document.ActualFormatType = this.GetFormatType("DOTX");
            break;
          }
          if (xmlReader.GetAttribute("ContentType") == "application/vnd.ms-word.template.macroEnabledTemplate.main+xml")
          {
            document.ActualFormatType = this.GetFormatType("DOTM");
            break;
          }
          if (xmlReader.GetAttribute("ContentType") == "application/vnd.ms-word.document.macroEnabled.main+xml")
          {
            document.ActualFormatType = this.GetFormatType("DOCM");
            break;
          }
        }
      }
      xmlReader.Read();
    }
    document.DocxPackage.XmlParts["[Content_Types].xml"].DataStream.Position = 0L;
  }

  private void ParseDocument(Package wordPackage)
  {
    PartContainer partContainer1 = wordPackage.FindPartContainer("word/");
    if (partContainer1.Relations.ContainsKey("word/_rels/fontTable.xml.rels"))
      this.ParseFontTableRelations(partContainer1.Relations["word/_rels/fontTable.xml.rels"].DataStream);
    if (partContainer1.Relations.ContainsKey($"word/_rels/{this.m_documentPath}.rels"))
      this.ParseDocumentRelations(partContainer1.Relations[$"word/_rels/{this.m_documentPath}.rels"].DataStream);
    PartContainer partContainer2 = wordPackage.FindPartContainer("word/theme/");
    if (partContainer2.XmlParts.ContainsKey("theme1.xml"))
    {
      this.ParseThemes(partContainer2.XmlParts["theme1.xml"].DataStream);
      this.m_doc.DocHasThemes = true;
    }
    PartContainer partContainer3 = wordPackage.FindPartContainer("word/");
    string key1 = "numbering.xml";
    if (!partContainer3.XmlParts.ContainsKey(key1))
    {
      foreach (KeyValuePair<string, Part> xmlPart in partContainer3.XmlParts)
      {
        if (xmlPart.Key.Contains("numbering"))
        {
          key1 = xmlPart.Key;
          break;
        }
      }
    }
    if (partContainer3.XmlParts.ContainsKey(key1))
    {
      Part xmlPart = partContainer3.XmlParts[key1];
      if (xmlPart != null && xmlPart.DataStream != null && xmlPart.DataStream.Length > 0L)
      {
        this.m_reader = UtilityMethods.CreateReader(xmlPart.DataStream);
        this.ParseNumberings(this.m_reader);
        this.m_reader.Close();
      }
    }
    string key2 = "styles.xml";
    if (!partContainer3.XmlParts.ContainsKey(key2))
    {
      foreach (KeyValuePair<string, Part> xmlPart in partContainer3.XmlParts)
      {
        if (xmlPart.Key.Contains("styles"))
        {
          key2 = xmlPart.Key;
          break;
        }
      }
    }
    if (partContainer3.XmlParts.ContainsKey(key2))
    {
      this.m_doc.HasStyleSheets = true;
      this.m_reader = UtilityMethods.CreateReader(partContainer3.XmlParts[key2].DataStream);
      this.ParseStyles(this.m_reader);
      this.m_reader.Close();
    }
    if (partContainer3.XmlParts.ContainsKey("footnotes.xml"))
      this.ParseFootnotePart(true);
    if (partContainer3.XmlParts.ContainsKey("endnotes.xml"))
      this.ParseFootnotePart(false);
    if (partContainer3.Relations.ContainsKey("word/_rels/settings.xml.rels"))
      this.ParseSettingsRelations(partContainer3.Relations["word/_rels/settings.xml.rels"].DataStream);
    if (partContainer3.XmlParts.ContainsKey("settings.xml"))
      this.ParseSettings(partContainer3.XmlParts["settings.xml"].DataStream);
    if (partContainer3.XmlParts.ContainsKey("comments.xml"))
      this.ParseComments();
    foreach (string key3 in partContainer3.XmlParts.Keys)
    {
      if (key3 == this.m_documentPath)
      {
        this.ParseDocument(partContainer3.XmlParts[this.m_documentPath].DataStream);
        break;
      }
    }
    this.m_doc.Settings.IsOptimizedForBrowser = false;
    if (partContainer3.XmlParts.ContainsKey("commentsExtended.xml"))
    {
      Part part = this.FindPart("word/", "commentsExtended.xml");
      if (part != null && part.DataStream != null && part.DataStream.Length > 0L)
      {
        this.m_reader = UtilityMethods.CreateReader(part.DataStream);
        this.ParseCommentsExtended(this.m_reader);
        this.m_reader.Close();
        this.m_doc.Comments.SetParentParaIDAndIsResolved();
      }
    }
    if (partContainer3.XmlParts.ContainsKey("webSettings.xml"))
      this.ParseWebSettings(partContainer3.XmlParts["webSettings.xml"].DataStream);
    if (partContainer3.XmlParts.ContainsKey("fontTable.xml"))
      this.ParseFontTable(partContainer3.XmlParts["fontTable.xml"].DataStream);
    if (partContainer3.XmlParts.ContainsKey("vbaProject.bin"))
      this.ParseVbaProject(partContainer3.XmlParts["vbaProject.bin"].DataStream);
    if (partContainer3.XmlParts.ContainsKey("vbaProjectSignature.bin"))
      this.ParseVbaProjectSignature(partContainer3.XmlParts["vbaProjectSignature.bin"].DataStream);
    if (partContainer3.XmlParts.ContainsKey("vbaProjectSignatureAgile.bin"))
      this.ParseVbaProjectSignatureAgile(partContainer3.XmlParts["vbaProjectSignatureAgile.bin"].DataStream);
    if (partContainer3.XmlParts.ContainsKey("vbaData.xml"))
      this.ParseVbaData(partContainer3.XmlParts["vbaData.xml"].DataStream);
    PartContainer partContainer4 = this.m_doc.DocxPackage.FindPartContainer("customUI/");
    if (partContainer4.XmlParts.ContainsKey("customUI.xml"))
      this.m_doc.CustomUIPartContainer = partContainer4;
    PartContainer partContainer5 = this.m_doc.DocxPackage.FindPartContainer("userCustomization/");
    if (partContainer5.XmlParts.ContainsKey("customUI.xml"))
      this.m_doc.UserCustomizationPartContainer = partContainer5;
    PartContainer partContainer6 = this.m_doc.DocxPackage.FindPartContainer("customXml/");
    if (partContainer6.Name == "customXml/")
    {
      this.m_doc.CustomXMLContainer = partContainer6;
      this.BindCustomXmlData(partContainer6);
    }
    if (this.m_doc.m_AltChunkOwner == null)
      return;
    this.BindCustomXmlData(this.m_doc.m_AltChunkOwner.DocxPackage.FindPartContainer("customXml/").Clone());
  }

  private void BindCustomXmlData(PartContainer partContainer)
  {
    if (this.BlockContentControls.Count > 0 || this.InlineContentControls.Count > 0 || this.CellContentControls.Count > 0)
      this.MapContentControl(partContainer);
    this.ParseMetaDataProperties(partContainer);
  }

  private void ParseMetaDataProperties(PartContainer partContainer)
  {
    XmlDocument xmlDocument1 = (XmlDocument) null;
    XmlDocument contentTypeSchemaProperties = (XmlDocument) null;
    if (partContainer.XmlParts.Count <= 0)
      return;
    foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
    {
      string key = xmlPart.Key;
      if (!(key == "") && partContainer.XmlParts[key].DataStream.Length != 0L)
      {
        Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[key].DataStream);
        XmlDocument xmlDocument2 = new XmlDocument();
        using (XmlTextReader reader = new XmlTextReader(input))
          xmlDocument2.Load((XmlReader) reader);
        XmlElement documentElement = xmlDocument2.DocumentElement;
        if (documentElement.LocalName == "properties" && documentElement.HasChildNodes && documentElement.FirstChild.Name == "documentManagement")
        {
          this.m_doc.m_metaXmlItem = key;
          contentTypeSchemaProperties = xmlDocument2;
        }
        if (documentElement.LocalName == "contentTypeSchema")
          xmlDocument1 = xmlDocument2;
      }
    }
    if (xmlDocument1 == null || contentTypeSchemaProperties == null)
      return;
    this.m_doc.m_contentTypeProperties = new MetaProperty().ParseMetaProperty(xmlDocument1.DocumentElement, contentTypeSchemaProperties);
  }

  private void ResetControls(
    PartContainer partContainer,
    Dictionary<string, List<InlineContentControl>> resultInlineControls,
    Dictionary<string, List<BlockContentControl>> resultBlockControls,
    Dictionary<string, List<WTableCell>> resultCellControls)
  {
    string key = string.Empty;
    foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
    {
      if (xmlPart.Key.Contains("Props"))
        key = xmlPart.Key;
    }
    if (partContainer.XmlParts.Count != 0 && !(key != string.Empty))
      return;
    if (this.BlockContentControls.Count > 0)
    {
      resultBlockControls.Add(key, this.BlockContentControls);
      this.ResetBlockControlWithMappedItem(partContainer, resultBlockControls);
    }
    if (this.InlineContentControls.Count > 0)
    {
      resultInlineControls.Add(key, this.InlineContentControls);
      this.ResetInlineControlWithMappedItem(partContainer, resultInlineControls);
    }
    if (this.CellContentControls.Count <= 0)
      return;
    resultCellControls.Add(key, this.CellContentControls);
    this.ResetCellControlWithMappedItem(partContainer, resultCellControls);
  }

  internal void MapContentControl(PartContainer partContainer)
  {
    Dictionary<string, List<InlineContentControl>> resultInlineControls = new Dictionary<string, List<InlineContentControl>>();
    Dictionary<string, List<BlockContentControl>> resultBlockControls = new Dictionary<string, List<BlockContentControl>>();
    Dictionary<string, List<WTableCell>> resultCellControls = new Dictionary<string, List<WTableCell>>();
    if (partContainer.XmlParts.Count == 0 || partContainer.XmlParts.Count == 2)
    {
      this.ResetControls(partContainer, resultInlineControls, resultBlockControls, resultCellControls);
    }
    else
    {
      foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
      {
        string key = xmlPart.Key;
        if (key.Contains("Props") && partContainer.XmlParts[xmlPart.Key].DataStream.Length > 0L)
        {
          List<InlineContentControl> inlineContentControlList = new List<InlineContentControl>();
          List<BlockContentControl> blockContentControlList = new List<BlockContentControl>();
          List<WTableCell> wtableCellList = new List<WTableCell>();
          Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[xmlPart.Key].DataStream);
          XmlDocument xmlDocument = new XmlDocument();
          using (XmlTextReader reader = new XmlTextReader(input))
          {
            reader.Namespaces = false;
            xmlDocument.Load((XmlReader) reader);
          }
          XmlElement documentElement = xmlDocument.DocumentElement;
          if (documentElement != null)
          {
            foreach (XmlAttribute attribute in (XmlNamedNodeMap) documentElement.Attributes)
            {
              if (attribute.Name.Contains("itemID"))
              {
                foreach (InlineContentControl inlineContentControl in this.InlineContentControls)
                {
                  if (attribute.Value.Equals(inlineContentControl.ContentControlProperties.XmlMapping.StoreItemID))
                    inlineContentControlList.Add(inlineContentControl);
                  else if (!string.IsNullOrEmpty(inlineContentControl.ContentControlProperties.XmlMapping.XPath) && (string.IsNullOrEmpty(inlineContentControl.ContentControlProperties.XmlMapping.StoreItemID) || this.m_doc != null && this.m_doc.m_AltChunkOwner != null))
                    inlineContentControlList.Add(inlineContentControl);
                }
                foreach (BlockContentControl blockContentControl in this.BlockContentControls)
                {
                  if (attribute.Value.Equals(blockContentControl.ContentControlProperties.XmlMapping.StoreItemID))
                    blockContentControlList.Add(blockContentControl);
                  else if (!string.IsNullOrEmpty(blockContentControl.ContentControlProperties.XmlMapping.XPath) && string.IsNullOrEmpty(blockContentControl.ContentControlProperties.XmlMapping.StoreItemID) || this.m_doc != null && this.m_doc.m_AltChunkOwner != null)
                    blockContentControlList.Add(blockContentControl);
                }
                foreach (WTableCell cellContentControl in this.CellContentControls)
                {
                  if (attribute.Value.Equals(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.StoreItemID))
                    wtableCellList.Add(cellContentControl);
                  else if (!string.IsNullOrEmpty(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.XPath) && string.IsNullOrEmpty(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.StoreItemID) || this.m_doc != null && this.m_doc.m_AltChunkOwner != null)
                    wtableCellList.Add(cellContentControl);
                }
              }
            }
          }
          if (inlineContentControlList.Count > 0)
            resultInlineControls.Add(key, inlineContentControlList);
          if (blockContentControlList.Count > 0)
            resultBlockControls.Add(key, blockContentControlList);
          if (wtableCellList.Count > 0)
            resultCellControls.Add(key, wtableCellList);
        }
      }
      List<BlockContentControl> matchedContentControl1 = this.GetIdMisMatchedContentControl(resultBlockControls, this.BlockContentControls);
      if (matchedContentControl1.Count > 0)
        resultBlockControls.Add("", matchedContentControl1);
      if (resultBlockControls.Count > 0)
        this.ResetBlockControlWithMappedItem(partContainer, resultBlockControls);
      matchedContentControl1.Clear();
      List<InlineContentControl> matchedContentControl2 = this.GetIdMisMatchedContentControl(resultInlineControls);
      if (matchedContentControl2.Count > 0)
        resultInlineControls.Add("", matchedContentControl2);
      if (resultInlineControls.Count > 0)
        this.ResetInlineControlWithMappedItem(partContainer, resultInlineControls);
      matchedContentControl2.Clear();
      List<WTableCell> matchedContentControl3 = this.GetIdMisMatchedContentControl(resultCellControls);
      if (matchedContentControl3.Count > 0)
        resultCellControls.Add("", matchedContentControl3);
      if (resultCellControls.Count > 0)
        this.ResetCellControlWithMappedItem(partContainer, resultCellControls);
      matchedContentControl3.Clear();
    }
  }

  private List<BlockContentControl> GetIdMisMatchedContentControl(
    Dictionary<string, List<BlockContentControl>> resultBlockControls,
    List<BlockContentControl> ContentControls)
  {
    List<BlockContentControl> matchedContentControl = new List<BlockContentControl>();
    foreach (BlockContentControl contentControl in ContentControls)
    {
      if (!string.IsNullOrEmpty(contentControl.ContentControlProperties.XmlMapping.XPath) && !string.IsNullOrEmpty(contentControl.ContentControlProperties.XmlMapping.StoreItemID))
      {
        bool flag = false;
        foreach (KeyValuePair<string, List<BlockContentControl>> resultBlockControl in resultBlockControls)
        {
          foreach (BlockContentControl blockContentControl in resultBlockControl.Value)
          {
            if (blockContentControl == contentControl)
              flag = true;
          }
        }
        if (!flag)
          matchedContentControl.Add(contentControl);
      }
    }
    return matchedContentControl;
  }

  private List<WTableCell> GetIdMisMatchedContentControl(
    Dictionary<string, List<WTableCell>> resultCellControls)
  {
    List<WTableCell> matchedContentControl = new List<WTableCell>();
    foreach (WTableCell cellContentControl in this.CellContentControls)
    {
      if (!string.IsNullOrEmpty(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.XPath) && !string.IsNullOrEmpty(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.StoreItemID))
      {
        bool flag = false;
        foreach (KeyValuePair<string, List<WTableCell>> resultCellControl in resultCellControls)
        {
          foreach (WTableCell wtableCell in resultCellControl.Value)
          {
            if (wtableCell == cellContentControl)
              flag = true;
          }
        }
        if (!flag)
          matchedContentControl.Add(cellContentControl);
      }
    }
    return matchedContentControl;
  }

  private List<InlineContentControl> GetIdMisMatchedContentControl(
    Dictionary<string, List<InlineContentControl>> resultInlineControls)
  {
    List<InlineContentControl> matchedContentControl = new List<InlineContentControl>();
    foreach (InlineContentControl inlineContentControl1 in this.InlineContentControls)
    {
      if (!string.IsNullOrEmpty(inlineContentControl1.ContentControlProperties.XmlMapping.XPath) && !string.IsNullOrEmpty(inlineContentControl1.ContentControlProperties.XmlMapping.StoreItemID))
      {
        bool flag = false;
        foreach (KeyValuePair<string, List<InlineContentControl>> resultInlineControl in resultInlineControls)
        {
          foreach (InlineContentControl inlineContentControl2 in resultInlineControl.Value)
          {
            if (inlineContentControl2 == inlineContentControl1)
              flag = true;
          }
        }
        if (!flag)
          matchedContentControl.Add(inlineContentControl1);
      }
    }
    return matchedContentControl;
  }

  private void ResetCellControlWithMappedItem(
    PartContainer partContainer,
    Dictionary<string, List<WTableCell>> resultCellControls)
  {
    foreach (KeyValuePair<string, List<WTableCell>> resultCellControl in resultCellControls)
    {
      if (partContainer.XmlParts.Count == 0)
      {
        this.ResetCellControls(resultCellControl, (XmlElement) null);
      }
      else
      {
        foreach (string key in partContainer.XmlParts.Keys)
        {
          if (resultCellControl.Key.Replace("Props", "") == key || partContainer.XmlParts.Keys.Count % 2 != 0 || resultCellControl.Key == "")
            this.ResetCellControls(resultCellControl, this.GetXmlElement(key, partContainer));
        }
      }
    }
  }

  private void ResetCellControls(
    KeyValuePair<string, List<WTableCell>> control,
    XmlElement rootElement)
  {
    foreach (WTableCell wtableCell in control.Value)
    {
      if (!string.IsNullOrEmpty(wtableCell.ContentControl.ContentControlProperties.XmlMapping.XPath))
      {
        bool isDocProperty = false;
        List<string> listPath = this.GetListPath(wtableCell.ContentControl.ContentControlProperties.XmlMapping.XPath, ref isDocProperty);
        if (isDocProperty)
          this.SetCoreProperty((object) wtableCell, listPath);
        else if (rootElement != null)
        {
          if (listPath.Count == 1)
            this.ProcessRootElement(listPath, rootElement, wtableCell);
          else
            this.ProcessChildNodes(listPath, rootElement.ChildNodes, wtableCell);
        }
      }
    }
  }

  private void ResetBlockControlWithMappedItem(
    PartContainer partContainer,
    Dictionary<string, List<BlockContentControl>> resultBlockControls)
  {
    foreach (KeyValuePair<string, List<BlockContentControl>> resultBlockControl in resultBlockControls)
    {
      if (partContainer.XmlParts.Count == 0)
      {
        this.ResetBlockControls(resultBlockControl, (XmlElement) null);
      }
      else
      {
        foreach (string key in partContainer.XmlParts.Keys)
        {
          if (resultBlockControl.Key == "" || resultBlockControl.Key.Replace("Props", "") == key || partContainer.XmlParts.Keys.Count % 2 != 0)
            this.ResetBlockControls(resultBlockControl, this.GetXmlElement(key, partContainer));
        }
      }
    }
  }

  private void ResetBlockControls(
    KeyValuePair<string, List<BlockContentControl>> blockControl,
    XmlElement rootElement)
  {
    foreach (BlockContentControl blockContentControl in blockControl.Value)
    {
      if (!string.IsNullOrEmpty(blockContentControl.ContentControlProperties.XmlMapping.XPath))
      {
        bool isDocProperty = false;
        List<string> listPath = this.GetListPath(blockContentControl.ContentControlProperties.XmlMapping.XPath, ref isDocProperty);
        if (isDocProperty)
          this.SetCoreProperty((object) blockContentControl, listPath);
        else if (rootElement != null)
        {
          if (listPath.Count == 1)
            this.ProcessRootElement(listPath, rootElement, blockContentControl);
          else
            this.ProcessChildNodes(listPath, rootElement.ChildNodes, blockContentControl);
        }
      }
    }
  }

  private void SetCoreProperty(object control, List<string> xPathList)
  {
    foreach (string xPath in xPathList)
    {
      if (!xPath.Contains("coreProperties"))
      {
        int startIndex = 0;
        int endIndex = 0;
        string str = this.GetPathIndex(xPath, ref startIndex, ref endIndex);
        if (startIndex != -1 && endIndex != -1 || startIndex == -1 && endIndex == -1)
        {
          if (startIndex != -1 && endIndex != -1)
            str = str.Substring(0, startIndex);
          string text = string.Empty;
          switch (str)
          {
            case "title":
              text = this.m_doc.BuiltinDocumentProperties.Title;
              break;
            case "creator":
              text = this.m_doc.BuiltinDocumentProperties.Author;
              break;
            case "category":
              text = this.m_doc.BuiltinDocumentProperties.Category;
              break;
            case "created":
              text = Convert.ToString(this.m_doc.BuiltinDocumentProperties.CreateDate, (IFormatProvider) CultureInfo.InvariantCulture);
              break;
            case "description":
              text = this.m_doc.BuiltinDocumentProperties.Comments;
              break;
            case "keywords":
              text = this.m_doc.BuiltinDocumentProperties.Keywords;
              break;
            case "lastModifiedBy":
              text = this.m_doc.BuiltinDocumentProperties.LastAuthor;
              break;
            case "lastPrinted":
              text = Convert.ToString(this.m_doc.BuiltinDocumentProperties.LastPrinted, (IFormatProvider) CultureInfo.InvariantCulture);
              break;
            case "modified":
              text = Convert.ToString(this.m_doc.BuiltinDocumentProperties.LastSaveDate, (IFormatProvider) CultureInfo.InvariantCulture);
              break;
            case "subject":
              text = this.m_doc.BuiltinDocumentProperties.Subject;
              break;
            case "revision":
              text = this.m_doc.BuiltinDocumentProperties.RevisionNumber;
              break;
            case "contentStatus":
              text = this.m_doc.BuiltinDocumentProperties.ContentStatus;
              break;
          }
          if (!string.IsNullOrEmpty(text))
          {
            switch (control)
            {
              case BlockContentControl _:
                this.SetMappedParagraph(control as BlockContentControl, text);
                continue;
              case InlineContentControl _:
                this.SetMappedItem(control as InlineContentControl, text);
                continue;
              case WTableCell _:
                this.SetMappedCell(control as WTableCell, text);
                continue;
              default:
                continue;
            }
          }
        }
      }
    }
  }

  private void ResetInlineControlWithMappedItem(
    PartContainer partContainer,
    Dictionary<string, List<InlineContentControl>> resultInlineControls)
  {
    foreach (KeyValuePair<string, List<InlineContentControl>> resultInlineControl in resultInlineControls)
    {
      if (partContainer.XmlParts.Count == 0)
      {
        this.ResetInlineControls(resultInlineControl, (XmlElement) null);
      }
      else
      {
        foreach (string key in partContainer.XmlParts.Keys)
        {
          if (resultInlineControl.Key.Replace("Props", "") == key || partContainer.XmlParts.Keys.Count % 2 != 0 || resultInlineControl.Key == "")
            this.ResetInlineControls(resultInlineControl, this.GetXmlElement(key, partContainer));
        }
      }
    }
  }

  private void ResetInlineControls(
    KeyValuePair<string, List<InlineContentControl>> inlineControl,
    XmlElement rootElement)
  {
    foreach (InlineContentControl inlineContentControl in inlineControl.Value)
    {
      if (!string.IsNullOrEmpty(inlineContentControl.ContentControlProperties.XmlMapping.XPath))
      {
        bool isDocProperty = false;
        List<string> listPath = this.GetListPath(inlineContentControl.ContentControlProperties.XmlMapping.XPath, ref isDocProperty);
        if (isDocProperty)
          this.SetCoreProperty((object) inlineContentControl, listPath);
        else if (rootElement != null)
        {
          if (listPath.Count == 1)
            this.ProcessRootElement(listPath[0], rootElement, inlineContentControl);
          else
            this.ProcessChildNodes(listPath, rootElement.ChildNodes, inlineContentControl);
        }
      }
    }
  }

  private void ProcessRootElement(
    string xPath,
    XmlElement rootElement,
    InlineContentControl contentControl)
  {
    string empty1 = string.Empty;
    XmlElement mappedRootElement = this.GetMappedRootElement(xPath, rootElement, ref empty1);
    string name = rootElement.Name;
    if (mappedRootElement == null)
      return;
    string empty2 = string.Empty;
    if (!name.Equals(empty1) || mappedRootElement.NodeType != XmlNodeType.Element)
      return;
    foreach (ParagraphItem paragraphItem in (Syncfusion.DocIO.DLS.CollectionImpl) contentControl.ParagraphItems)
    {
      if (paragraphItem is WTextRange)
        empty2 += (paragraphItem as WTextRange).Text;
    }
    string innerText = mappedRootElement.InnerText;
    if (!empty2.Equals(innerText) && contentControl.ContentControlProperties.Type != ContentControlType.Picture)
    {
      string text = contentControl.ContentControlProperties.Multiline ? this.ReplaceAsSoftBreaks(innerText) : this.ReplaceBreakChars(innerText);
      string dateFormat = this.ConvertTextToDateFormat(contentControl.ContentControlProperties, text);
      if (contentControl.ContentControlProperties.XmlMapping.IsWordML && contentControl.ContentControlProperties.Type == ContentControlType.RichText)
        this.ConvertWordMLToText(contentControl, dateFormat);
      else
        this.SetMappedItem(contentControl, dateFormat);
    }
    else
    {
      if (contentControl.ContentControlProperties.Type != ContentControlType.Picture)
        return;
      this.SetMappedPicture(contentControl, innerText);
    }
  }

  private void ProcessRootElement(
    List<string> xPathList,
    XmlElement rootElement,
    BlockContentControl contentControl)
  {
    string empty = string.Empty;
    XmlElement mappedRootElement = this.GetMappedRootElement(xPathList[0], rootElement, ref empty);
    string name = rootElement.Name;
    if (mappedRootElement == null)
      return;
    string fromContentControl = this.GetTextFromContentControl(empty, xPathList, contentControl);
    if (!name.Equals(empty) || mappedRootElement.NodeType != XmlNodeType.Element)
      return;
    string innerText = mappedRootElement.InnerText;
    if (!fromContentControl.Equals(innerText) && contentControl.ContentControlProperties.Type != ContentControlType.Picture)
    {
      string text = contentControl.ContentControlProperties.Multiline ? this.ReplaceAsSoftBreaks(innerText) : this.ReplaceBreakChars(innerText);
      string dateFormat = this.ConvertTextToDateFormat(contentControl.ContentControlProperties, text);
      if (contentControl.ContentControlProperties.XmlMapping.IsWordML && contentControl.ContentControlProperties.Type == ContentControlType.RichText)
        this.ConvertWordMLToText(contentControl, dateFormat);
      else
        this.SetMappedParagraph(contentControl, dateFormat);
    }
    else
    {
      if (contentControl.ContentControlProperties.Type != ContentControlType.Picture)
        return;
      this.SetMappedPicture(contentControl, innerText);
    }
  }

  private void ProcessRootElement(
    List<string> xPathList,
    XmlElement rootElement,
    WTableCell contentControl)
  {
    string empty = string.Empty;
    XmlElement mappedRootElement = this.GetMappedRootElement(xPathList[0], rootElement, ref empty);
    string name = rootElement.Name;
    if (mappedRootElement == null)
      return;
    string resultText = this.GetResultText(empty, xPathList, contentControl);
    if (!name.Equals(empty) || mappedRootElement.NodeType != XmlNodeType.Element)
      return;
    string innerText = mappedRootElement.InnerText;
    if (!resultText.Equals(innerText) && contentControl.ContentControl.ContentControlProperties.Type != ContentControlType.Picture)
    {
      string text = contentControl.ContentControl.ContentControlProperties.Multiline ? this.ReplaceAsSoftBreaks(innerText) : this.ReplaceBreakChars(innerText);
      string dateFormat = this.ConvertTextToDateFormat(contentControl.ContentControl.ContentControlProperties, text);
      if (contentControl.ContentControl.ContentControlProperties.XmlMapping.IsWordML && contentControl.ContentControl.ContentControlProperties.Type == ContentControlType.RichText)
        this.ConvertWordMLToText(contentControl, dateFormat);
      else
        this.SetMappedCell(contentControl, dateFormat);
    }
    else
    {
      if (contentControl.ContentControl.ContentControlProperties.Type != ContentControlType.Picture)
        return;
      this.SetMappedPicture(contentControl, innerText);
    }
  }

  private XmlElement GetMappedRootElement(string path, XmlElement rootElement, ref string tempPath)
  {
    int startIndex = 0;
    int endIndex = 0;
    XmlElement mappedRootElement = (XmlElement) null;
    tempPath = this.GetPathIndex(path, ref startIndex, ref endIndex);
    if ((startIndex != -1 && endIndex != -1 || startIndex == -1 && endIndex == -1) && startIndex != -1 && endIndex != -1)
    {
      int num = startIndex + 1;
      tempPath = tempPath.Substring(0, num - 1);
    }
    if (rootElement.Name.Equals(tempPath))
      mappedRootElement = rootElement;
    return mappedRootElement;
  }

  private XmlElement GetXmlElement(string xmlPartsPath, PartContainer partContainer)
  {
    if (partContainer.XmlParts[xmlPartsPath].DataStream.Length <= 0L)
      return (XmlElement) null;
    Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[xmlPartsPath].DataStream);
    XmlDocument xmlDocument = new XmlDocument();
    xmlDocument.PreserveWhitespace = true;
    using (XmlTextReader reader = new XmlTextReader(input))
    {
      reader.Namespaces = false;
      xmlDocument.Load((XmlReader) reader);
    }
    return xmlDocument.DocumentElement;
  }

  private List<string> GetParamListPath(string path, ref bool isDocProperty)
  {
    if (path.Contains("//"))
      path = path.Replace("//", "");
    string[] strArray = path.Split('[', ']');
    List<string> paramListPath = new List<string>();
    foreach (string str in strArray)
    {
      if (str.Contains("@"))
        str = str.Replace("@", "");
      if (str != "")
        paramListPath.Add(str);
      if (str.ToLower().Contains("coreproperties") || str.ToLower().Contains("coverpageproperties"))
        isDocProperty = true;
    }
    return paramListPath;
  }

  private List<string> GetListPath(string path, ref bool isDocProperty)
  {
    string[] strArray = path.Split('/');
    List<string> listPath = new List<string>();
    foreach (string str in strArray)
    {
      if (str != "")
        listPath.Add(str);
      if (str.ToLower().Contains("coreproperties") || str.ToLower().Contains("coverpageproperties"))
        isDocProperty = true;
    }
    return listPath;
  }

  private List<string> GetListPath(string path)
  {
    bool isDocProperty = false;
    return this.GetListPath(path, ref isDocProperty);
  }

  private string GetPathIndex(string path, ref int startIndex, ref int endIndex)
  {
    if (path.Contains(":"))
      path = path.Substring(path.IndexOf(":") + 1);
    startIndex = path.IndexOf("[");
    endIndex = path.IndexOf("]");
    return path;
  }

  private XmlNode GetCurrentNode(
    XmlNodeList childNodes,
    XmlNode currentNode,
    ref int toIterate,
    int nodeIndex,
    string path,
    string parentInfo,
    string attributeName,
    string attributeValue)
  {
    foreach (XmlNode childNode in childNodes)
    {
      string str = childNode.Name;
      if (str.Contains(":"))
        str = str.Substring(str.IndexOf(":") + 1);
      if (str.Equals(path) && parentInfo != null && this.CheckValidNode(parentInfo, childNode))
      {
        ++toIterate;
        if (nodeIndex == toIterate || !string.IsNullOrEmpty(attributeName) && !string.IsNullOrEmpty(attributeValue) && childNode.Attributes[attributeName] != null && childNode.Attributes[attributeName].Value == attributeValue)
        {
          currentNode = childNode;
          break;
        }
      }
    }
    return currentNode;
  }

  private bool CheckValidNode(string parentOfTempPath, XmlNode node)
  {
    if (!parentOfTempPath.Contains("[@"))
      return true;
    int num = parentOfTempPath.IndexOf('[');
    string str = parentOfTempPath.Substring(0, num);
    return !(node.ParentNode.Name != str) && this.CheckNodeHasValidAttributes(this.GetAttributesOfXPath(parentOfTempPath.Substring(num)), node);
  }

  private bool CheckNodeHasValidAttributes(
    Dictionary<string, string> expectedAttributes,
    XmlNode currentNode)
  {
    foreach (KeyValuePair<string, string> expectedAttribute in expectedAttributes)
    {
      XmlAttribute attribute = currentNode.ParentNode.Attributes[expectedAttribute.Key];
      if (attribute == null || attribute.Value != expectedAttribute.Value)
        return false;
    }
    return true;
  }

  private string GetResultText(string path, List<string> xPathList, WTableCell contentControl)
  {
    string empty = string.Empty;
    if (xPathList[xPathList.Count - 1].Contains(path))
    {
      foreach (Entity childEntity1 in (Syncfusion.DocIO.DLS.CollectionImpl) contentControl.ChildEntities)
      {
        if (childEntity1 is WParagraph)
        {
          foreach (Entity childEntity2 in (Syncfusion.DocIO.DLS.CollectionImpl) (childEntity1 as WParagraph).ChildEntities)
          {
            if (childEntity2 is WTextRange)
              empty += (childEntity2 as WTextRange).Text;
          }
        }
      }
    }
    return empty;
  }

  private string GetTextFromContentControl(
    string path,
    List<string> xPathList,
    BlockContentControl contentControl)
  {
    string empty = string.Empty;
    if (xPathList[xPathList.Count - 1].Contains(path))
    {
      foreach (Entity childEntity1 in (Syncfusion.DocIO.DLS.CollectionImpl) contentControl.TextBody.ChildEntities)
      {
        if (childEntity1 is WParagraph)
        {
          foreach (Entity childEntity2 in (Syncfusion.DocIO.DLS.CollectionImpl) (childEntity1 as WParagraph).ChildEntities)
          {
            if (childEntity2 is WTextRange)
              empty += (childEntity2 as WTextRange).Text;
          }
        }
      }
    }
    return empty;
  }

  private void ProcessChildNodes(
    List<string> xPathList,
    XmlNodeList childNodes,
    WTableCell contentControl)
  {
    XmlNode currentNode = (XmlNode) null;
    int index1 = 0;
    int result = 0;
    string path = string.Empty;
    string attributeName = string.Empty;
    string attributeValue = string.Empty;
    for (int index2 = 0; index2 < xPathList.Count; ++index2)
    {
      string xPath = xPathList[index1];
      if (index1 > 0)
      {
        int startIndex = 0;
        int endIndex = 0;
        string parentInfo = index2 > 0 ? xPathList[index2 - 1] : string.Empty;
        path = this.GetPathIndex(xPath, ref startIndex, ref endIndex);
        if (startIndex != -1 && endIndex != -1 || startIndex == -1 && endIndex == -1)
        {
          if (startIndex != -1 && endIndex != -1)
          {
            int length = endIndex - (startIndex + 1);
            ++startIndex;
            if (startIndex + length <= endIndex && !int.TryParse(path.Substring(startIndex, length), NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              string str = path.Substring(startIndex, length);
              if (str.Contains("="))
              {
                attributeName = str.Contains("@") ? str.Substring(str.IndexOf("@") + 1, str.IndexOf("=") - 1) : str.Substring(0, str.IndexOf("="));
                attributeValue = str.Substring(str.IndexOf("=") + 1).Trim('\'');
              }
            }
            path = path.Substring(0, startIndex - 1);
          }
          else
            result = 1;
          int toIterate = 0;
          if (childNodes != null)
          {
            currentNode = this.GetCurrentNode(childNodes, currentNode, ref toIterate, result, path, parentInfo, attributeName, attributeValue);
            if (currentNode != null)
              childNodes = currentNode.ChildNodes;
          }
        }
      }
      ++index1;
    }
    if (currentNode == null)
      return;
    string resultText = this.GetResultText(path, xPathList, contentControl);
    if ((currentNode.Name.Contains(":") ? currentNode.Name.Substring(currentNode.Name.IndexOf(":") + 1) : currentNode.Name).Equals(path) && currentNode.NodeType == XmlNodeType.Element)
    {
      if (!resultText.Equals(currentNode.InnerText) && contentControl.ContentControl.ContentControlProperties.Type != ContentControlType.Picture)
      {
        string text = contentControl.ContentControl.ContentControlProperties.Multiline ? this.ReplaceAsSoftBreaks(currentNode.InnerText) : this.ReplaceBreakChars(currentNode.InnerText);
        string dateFormat = this.ConvertTextToDateFormat(contentControl.ContentControl.ContentControlProperties, text);
        if (contentControl.ContentControl.ContentControlProperties.XmlMapping.IsSupportWordML && contentControl.ContentControl.ContentControlProperties.Type == ContentControlType.RichText)
          this.ConvertWordMLToText(contentControl, dateFormat);
        else
          this.SetMappedCell(contentControl, dateFormat);
      }
      else if (contentControl.ContentControl.ContentControlProperties.Type == ContentControlType.Picture)
        this.SetMappedPicture(contentControl, currentNode.InnerText);
    }
    XmlAttributeCollection attributes = currentNode.Attributes;
    if (attributes == null)
      return;
    foreach (XmlAttribute xmlAttribute in (XmlNamedNodeMap) attributes)
    {
      if (xmlAttribute.Name.ToString().Contains(path.Substring(1)))
      {
        if (!resultText.Equals(xmlAttribute.Value) && contentControl.ContentControl.ContentControlProperties.Type != ContentControlType.Picture)
        {
          this.SetMappedCell(contentControl, xmlAttribute.Value);
          break;
        }
        if (contentControl.ContentControl.ContentControlProperties.Type == ContentControlType.Picture)
        {
          this.SetMappedPicture(contentControl, xmlAttribute.Value);
          break;
        }
      }
    }
  }

  private Dictionary<string, string> GetAttributesOfXPath(string secondPart)
  {
    string[] strArray1 = secondPart.Split(new char[1]{ '[' }, StringSplitOptions.RemoveEmptyEntries);
    Dictionary<string, string> attributesOfXpath = new Dictionary<string, string>();
    for (int index = 0; index < strArray1.Length; ++index)
    {
      string str1 = strArray1[index];
      int num = str1.IndexOf('@');
      string str2 = str1.Remove(0, num + 1);
      int startIndex = str2.LastIndexOf(']');
      string[] strArray2 = str2.Remove(startIndex).Split('=');
      strArray2[1] = strArray2[1].Trim();
      strArray2[1] = strArray2[1].TrimStart('\'');
      strArray2[1] = strArray2[1].TrimEnd('\'');
      attributesOfXpath.Add(strArray2[0].Trim(), strArray2[1]);
    }
    return attributesOfXpath;
  }

  private string ConvertTextToDateFormat(ContentControlProperties control, string text)
  {
    if (control.Type == ContentControlType.Date && !string.IsNullOrEmpty(control.DateDisplayFormat) && control.DateStorageFormat != ContentControlDateStorageFormat.DateStorageText && this.IsProperDateTimeFormat(ref text))
    {
      string format = control.DateDisplayFormat;
      if (format.Contains("am/pm"))
        format = format.Replace("am/pm", "tt");
      DateTime result = new DateTime();
      if (DateTime.TryParse(text, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result))
      {
        if (result.Year < 1900)
          result = new DateTime(1900, 1, 1, 12, 0, 0);
        else if (result.Year > 2411)
          result = new DateTime(2411, 12, 31 /*0x1F*/, 23, 59, 0);
        text = result.AddSeconds((double) -result.Second).ToString(format);
      }
    }
    return text;
  }

  private bool IsProperDateTimeFormat(ref string str)
  {
    bool flag = false;
    if (new Regex("^(?:[01]\\d|2[0123]):$|^(?:[012345]\\d):$").IsMatch(str))
    {
      string[] strArray = str.Split(':');
      str = int.Parse(strArray[0]) <= 23 ? strArray[0] + ":00:00" : $"00:{strArray[1]}:00";
      flag = true;
    }
    else if (new Regex("^(?:[01]\\d|2[0123]):(?:[012345]\\d)$|^(?:[01]\\d|2[0123]):(?:[012345]\\d):$|^(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
    {
      string[] strArray = str.Split(':');
      str = int.Parse(strArray[0]) <= 23 ? $"{strArray[0]}:{strArray[1]}:00" : $"00:{strArray[1]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$").IsMatch(str))
    {
      string[] strArray = str.Split('T');
      str = strArray[0];
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123])$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}T{strArray[1]}:00:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[012345]\\d)$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[012345]\\d):$").IsMatch(str))
    {
      string[] strArray = str.Split('T');
      str = int.Parse(strArray[1]) <= 23 ? $"{strArray[0]}T{strArray[1]}:00:00" : strArray[0] + "T00:00:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):(?:[012345]\\d)$|^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):(?:[012345]\\d):$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      if (int.Parse(strArray[1]) > 23)
        str = $"{strArray[0]}T00:{strArray[2]}:00";
      else
        str = $"{strArray[0]}T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])$|^\\d{4}-(0[1-9]|1[012])T$|^\\d{4}-(0[1-9]|1[012])-$").IsMatch(str))
    {
      string[] strArray = str.Split('T', '-');
      str = $"{strArray[0]}-{strArray[1]}-01";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123])$|^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123]):$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}-01T{strArray[1]}:00:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[012345]\\d)$|^\\d{4}-(0[1-9]|1[012])T(?:[012345]\\d):$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = int.Parse(strArray[1]) <= 23 ? $"{strArray[0]}-01T{strArray[1]}:00:00" : strArray[0] + "-01T00:00:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123]):(?:[012345]\\d)$|^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123]):(?:[012345]\\d):$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}-01T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      if (int.Parse(strArray[1]) > 23)
        str = $"{strArray[0]}-01T00:{strArray[2]}:00";
      else
        str = $"{strArray[0]}-01T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}-(0[1-9]|1[012])T(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}-01T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}$|^\\d{4}-$|^\\d{4}T$").IsMatch(str))
    {
      string[] strArray = str.Split('T', '-');
      str = strArray[0] + "-01-01";
      flag = true;
    }
    else if (new Regex("^\\d{4}T(?:[01]\\d|2[0123])$|^\\d{4}T(?:[01]\\d|2[0123]):$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}-01-01T{strArray[1]}:00:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}T(?:[012345]\\d)$|^\\d{4}T(?:[012345]\\d):$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = int.Parse(strArray[1]) <= 23 ? $"{strArray[0]}-01-01T{strArray[1]}:00:00" : strArray[0] + "-01-01T00:00:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}T(?:[01]\\d|2[0123]):(?:[012345]\\d)$|^\\d{4}T(?:[01]\\d|2[0123]):(?:[012345]\\d):$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}-01-01T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}T(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      if (int.Parse(strArray[1]) > 23)
        str = $"{strArray[0]}-01-01T00:{strArray[2]}:00";
      else
        str = $"{strArray[0]}-01-01T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^\\d{4}T(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
    {
      string[] strArray = str.Split('T', ':');
      str = $"{strArray[0]}-01-01T{strArray[1]}:{strArray[2]}:00";
      flag = true;
    }
    else if (new Regex("^(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d)$").IsMatch(str))
    {
      string[] strArray = str.Split(':');
      str = $"{strArray[0]}:{strArray[1]}:00";
      flag = true;
    }
    return flag;
  }

  private void SetSpacesForEmptyContentControl(ParagraphItem paraitem)
  {
    (paraitem as WTextRange).Text = "     ";
  }

  private bool HasEmptyTextInParagraph(WParagraph para)
  {
    foreach (ParagraphItem paragraphItem in (Syncfusion.DocIO.DLS.CollectionImpl) para.Items)
    {
      if (!(paragraphItem is WTextRange) || !((paragraphItem as WTextRange).Text == ""))
        return false;
    }
    return true;
  }

  private bool HasEmptyBodyItems(BodyItemCollection itemCollection)
  {
    foreach (Entity para in (Syncfusion.DocIO.DLS.CollectionImpl) itemCollection)
    {
      if (!(para is WParagraph) || !this.HasEmptyTextInParagraph(para as WParagraph))
        return false;
    }
    return true;
  }

  private WTextRange GetDefaultSpaceFromWordML(WTextBody textBody)
  {
    WParagraph lastItem = textBody.Items.LastItem as WParagraph;
    WTextRange paraitem = lastItem.ChildEntities.Count == 0 ? lastItem.AppendText("") as WTextRange : (lastItem.LastItem is WTextRange ? lastItem.LastItem as WTextRange : lastItem.AppendText("") as WTextRange);
    this.SetSpacesForEmptyContentControl((ParagraphItem) paraitem);
    return paraitem;
  }

  private void ConvertWordMLToText(InlineContentControl contentControl, string text)
  {
    if (contentControl == null || text == null)
      return;
    MemoryStream stream = (MemoryStream) null;
    if (this.IsWordML(text, ref stream))
    {
      contentControl.ContentControlProperties.XmlMapping.IsWordML = true;
      WordDocument wordDocument = new WordDocument((Stream) stream, FormatType.WordML);
      WTextBody childEntity = wordDocument.Sections[0].ChildEntities[0] as WTextBody;
      if (wordDocument.Sections.Count == 1 && (wordDocument.Sections[0].ChildEntities[0] as WTextBody).Count == 1 && (wordDocument.Sections[0].ChildEntities[0] as WTextBody).ChildEntities[0] is WParagraph)
      {
        if (contentControl.ParagraphItems.Count > 0)
          contentControl.ParagraphItems.Clear();
        contentControl.Document.IsOpening = false;
        foreach (ParagraphItem paragraphItem in (Syncfusion.DocIO.DLS.CollectionImpl) (childEntity.ChildEntities[0] as WParagraph).Items)
        {
          IEntity entity = (IEntity) paragraphItem.Clone();
          contentControl.ParagraphItems.Add(entity);
          if (this.HasEmptyTextInParagraph(childEntity.ChildEntities[0] as WParagraph))
          {
            WTextRange paraitem = contentControl.ParagraphItems.LastItem is WTextRange ? contentControl.ParagraphItems.LastItem as WTextRange : new WTextRange((IWordDocument) contentControl.Document);
            this.SetSpacesForEmptyContentControl((ParagraphItem) paraitem);
            paraitem.ApplyCharacterFormat(contentControl.ContentControlProperties.CharacterFormat);
            if (contentControl.Owner is WParagraph)
            {
              if (contentControl.OwnerParagraph.ParaStyle != null)
              {
                paraitem.CharacterFormat.ApplyBase((FormatBase) contentControl.OwnerParagraph.ParaStyle.CharacterFormat);
                break;
              }
              break;
            }
            break;
          }
          if (paragraphItem is WTextRange)
          {
            (entity as WTextRange).ApplyCharacterFormat((paragraphItem as WTextRange).CharacterFormat);
            if (contentControl.Owner is WParagraph && contentControl.OwnerParagraph.ParaStyle != null)
              (entity as WTextRange).CharacterFormat.ApplyBase((FormatBase) contentControl.OwnerParagraph.ParaStyle.CharacterFormat);
          }
        }
        contentControl.Document.IsOpening = true;
      }
      else if (wordDocument.Sections.Count == 1 && wordDocument.Sections[0].Body.Items.Count > 1 && contentControl.ContentControlProperties.Type == ContentControlType.RichText)
      {
        WParagraph ownerParagraph = contentControl.OwnerParagraph;
        int index1 = contentControl.Index;
        WParagraph wparagraph = ownerParagraph.Clone() as WParagraph;
        for (int index2 = ownerParagraph.ChildEntities.Count - 1; index2 >= index1; --index2)
          ownerParagraph.ChildEntities[index2].RemoveSelf();
        for (int index3 = 0; index3 <= index1; ++index3)
          wparagraph.ChildEntities[0].RemoveSelf();
        BlockContentControl contentControl1 = new BlockContentControl(contentControl.Document);
        WTextBody ownerTextBody = ownerParagraph.OwnerTextBody;
        int inOwnerCollection = ownerParagraph.GetIndexInOwnerCollection();
        ownerTextBody.ChildEntities.Insert(inOwnerCollection + 1, (IEntity) contentControl1);
        ownerTextBody.ChildEntities.Insert(inOwnerCollection + 2, (IEntity) wparagraph);
        this.MapWordMLToBlockContentControl(contentControl1, childEntity);
        WParagraph paragraphOfSdtContent1 = contentControl1.GetLastParagraphOfSDTContent();
        paragraphOfSdtContent1.ParagraphFormat.ClearFormatting();
        paragraphOfSdtContent1.ParagraphFormat.CopyFormat((FormatBase) ownerParagraph.ParagraphFormat);
        WParagraph paragraphOfSdtContent2 = contentControl1.GetFirstParagraphOfSDTContent();
        ownerParagraph.ParagraphFormat.ClearFormatting();
        ownerParagraph.ParagraphFormat.CopyFormat((FormatBase) paragraphOfSdtContent2.ParagraphFormat);
      }
      else
        this.SetMappedItem(contentControl, text);
      wordDocument.Close();
    }
    else
      this.SetMappedItem(contentControl, text);
    stream.Dispose();
  }

  private void MapWordMLToBlockContentControl(
    BlockContentControl contentControl,
    WTextBody textBody)
  {
    contentControl.ContentControlProperties.XmlMapping.IsWordML = true;
    if (contentControl.ChildEntities.Count > 0)
      contentControl.ChildEntities.Clear();
    foreach (Entity entity in (Syncfusion.DocIO.DLS.CollectionImpl) textBody.Items)
    {
      contentControl.ChildEntities.Add((IEntity) entity.Clone());
      if (entity is WParagraph)
        (contentControl.ChildEntities.LastItem as WParagraph).ParagraphFormat.CopyFormat((FormatBase) (entity as WParagraph).ParagraphFormat);
    }
  }

  private void ConvertWordMLToText(BlockContentControl contentControl, string text)
  {
    if (contentControl == null || text == null)
      return;
    MemoryStream stream = (MemoryStream) null;
    if (this.IsWordML(text, ref stream))
    {
      contentControl.ContentControlProperties.XmlMapping.IsWordML = true;
      WordDocument wordDocument = new WordDocument((Stream) stream, FormatType.WordML);
      if (wordDocument.Sections.Count == 1 && wordDocument.Sections[0].ChildEntities[0] is WTextBody)
      {
        WTextBody childEntity = wordDocument.Sections[0].ChildEntities[0] as WTextBody;
        contentControl.Document.IsOpening = false;
        if (this.HasEmptyBodyItems(childEntity.Items))
        {
          if (childEntity.Paragraphs.Count <= 1 && contentControl.ChildEntities.Count > 0)
          {
            WParagraph wparagraph = this.ClearContentControlExceptLastPara((Entity) contentControl);
            WTextRange defaultSpaceFromWordMl = this.GetDefaultSpaceFromWordML(childEntity);
            wparagraph.ChildEntities.Add((IEntity) defaultSpaceFromWordMl.Clone());
            contentControl.ChildEntities.Add((IEntity) wparagraph.Clone());
          }
          else if (childEntity.Paragraphs.Count == 2 && contentControl.ChildEntities.Count >= 0)
          {
            contentControl.ChildEntities.Clear();
            WParagraph paragraph = childEntity.Paragraphs[0];
            WTextRange defaultSpaceFromWordMl = this.GetDefaultSpaceFromWordML(childEntity);
            paragraph.ChildEntities.Add((IEntity) defaultSpaceFromWordMl.Clone());
            contentControl.ChildEntities.Add((IEntity) paragraph.Clone());
          }
          else if (childEntity.Paragraphs.Count <= 1 && contentControl.ChildEntities.Count == 0)
          {
            contentControl.ChildEntities.Clear();
            contentControl.TextBody.AddParagraph();
            WTextRange defaultSpaceFromWordMl = this.GetDefaultSpaceFromWordML(childEntity);
            (contentControl.ChildEntities[0] as WParagraph).ChildEntities.Add((IEntity) defaultSpaceFromWordMl.Clone());
          }
          else
          {
            if (contentControl.ChildEntities.Count > 0)
              contentControl.ChildEntities.Clear();
            for (int index = childEntity.Paragraphs.Count - 2; index >= 0; --index)
              contentControl.ChildEntities.Insert(0, (IEntity) childEntity.Paragraphs[index].Clone());
          }
        }
        else
          this.MapWordMLToBlockContentControl(contentControl, childEntity);
        contentControl.Document.IsOpening = true;
      }
      else
        this.SetMappedParagraph(contentControl, text);
      wordDocument.Close();
    }
    else
      this.SetMappedParagraph(contentControl, text);
    stream.Dispose();
  }

  private void ConvertWordMLToText(WTableCell contentControl, string text)
  {
    if (contentControl == null || text == null)
      return;
    MemoryStream stream = (MemoryStream) null;
    if (this.IsWordML(text, ref stream))
    {
      contentControl.ContentControl.ContentControlProperties.XmlMapping.IsWordML = true;
      WordDocument wordDocument = new WordDocument((Stream) stream, FormatType.WordML);
      if (wordDocument.Sections.Count == 1 && wordDocument.Sections[0].ChildEntities[0] is WTextBody)
      {
        if (contentControl.ChildEntities.Count > 0)
          contentControl.ChildEntities.Clear();
        WTextBody childEntity = wordDocument.Sections[0].ChildEntities[0] as WTextBody;
        contentControl.Document.IsOpening = false;
        foreach (Entity entity in (Syncfusion.DocIO.DLS.CollectionImpl) childEntity.Items)
        {
          contentControl.ChildEntities.Add((IEntity) entity.Clone());
          if (entity is WParagraph)
            (contentControl.ChildEntities.LastItem as WParagraph).ParagraphFormat.ApplyBase((FormatBase) (entity as WParagraph).ParagraphFormat);
        }
        contentControl.Document.IsOpening = true;
      }
      else
        this.SetMappedCell(contentControl, text);
      wordDocument.Close();
    }
    else
      this.SetMappedCell(contentControl, text);
    stream.Dispose();
  }

  private bool IsWordML(string text, ref MemoryStream stream)
  {
    try
    {
      byte[] bytes = Encoding.UTF8.GetBytes(text);
      stream = new MemoryStream(bytes);
      XmlReader reader = UtilityMethods.CreateReader((Stream) stream);
      reader.MoveToElement();
      if (!(reader.LocalName == "wordDocument"))
      {
        if (!(reader.LocalName == "package"))
          goto label_4;
      }
      return true;
    }
    catch
    {
    }
label_4:
    return false;
  }

  private void SetMappedCell(WTableCell tableCell, string text)
  {
    if (tableCell == null || text == null)
      return;
    if (text == string.Empty)
    {
      if (string.IsNullOrEmpty(tableCell.ContentControl.ContentControlProperties.PlaceHolderDocPartId) && tableCell.ContentControl.ContentControlProperties.HasPlaceHolderText && tableCell.ContentControl.ContentControlProperties.Type == ContentControlType.Text)
        return;
      text = this.GetTextForEmptyMappedContent((Entity) tableCell.ContentControl);
    }
    else
      tableCell.ContentControl.ContentControlProperties.HasPlaceHolderText = false;
    if (this.IsMapPlaceHolderFromGlossary((Entity) tableCell.ContentControl, text))
      this.MapContentFromGlossaryDocument((Entity) tableCell.ContentControl);
    else if (tableCell.LastParagraph == null)
    {
      WParagraph wparagraph = new WParagraph((IWordDocument) this.m_doc);
      wparagraph.AppendText(text);
      tableCell.ChildEntities.Add((IEntity) wparagraph);
      wparagraph.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) tableCell);
    }
    else if (tableCell.LastParagraph.Text != text)
      tableCell.LastParagraph.Text = text;
    tableCell.ContentControl.ContentControlProperties.XmlMapping.IsMapped = true;
  }

  private void SetMappedPicture(BlockContentControl contentControl, string text)
  {
    bool flag = false;
    foreach (Entity childEntity1 in (Syncfusion.DocIO.DLS.CollectionImpl) contentControl.TextBody.ChildEntities)
    {
      if (childEntity1 is WParagraph)
      {
        foreach (Entity childEntity2 in (Syncfusion.DocIO.DLS.CollectionImpl) (childEntity1 as WParagraph).ChildEntities)
        {
          if (childEntity2 is WPicture)
          {
            flag = true;
            this.MappedBase64Image(childEntity2 as WPicture, text, (Entity) contentControl);
          }
        }
      }
    }
    if (flag)
      return;
    this.MappedBase64Image((WPicture) null, text, (Entity) contentControl);
  }

  private void SetMappedPicture(InlineContentControl contentControl, string text)
  {
    bool flag = false;
    foreach (ParagraphItem paragraphItem in (Syncfusion.DocIO.DLS.CollectionImpl) contentControl.ParagraphItems)
    {
      if (paragraphItem is WPicture)
      {
        flag = true;
        this.MappedBase64Image(paragraphItem as WPicture, text, (Entity) contentControl);
      }
    }
    if (flag)
      return;
    this.MappedBase64Image((WPicture) null, text, (Entity) contentControl);
  }

  private void SetMappedPicture(WTableCell contentControl, string text)
  {
    bool flag = false;
    foreach (Entity childEntity1 in (Syncfusion.DocIO.DLS.CollectionImpl) contentControl.ChildEntities)
    {
      if (childEntity1 is WParagraph)
      {
        foreach (Entity childEntity2 in (Syncfusion.DocIO.DLS.CollectionImpl) (childEntity1 as WParagraph).ChildEntities)
        {
          if (childEntity2 is WPicture)
          {
            flag = true;
            this.MappedBase64Image(childEntity2 as WPicture, text, (Entity) contentControl);
          }
        }
      }
    }
    if (flag)
      return;
    this.MappedBase64Image((WPicture) null, text, (Entity) contentControl);
  }

  private WPicture SetDefaultPic(WPicture picture)
  {
    Image image = Image.FromStream(WPicture.GetManifestResourceStream("ImageNotFound.jpg"), true, false);
    picture.LoadImage(image);
    picture.IsDefaultPicOfContentControl = false;
    return picture;
  }

  private WPicture AppendPictureToContentControl(WPicture picture, Entity contentControl)
  {
    if (contentControl is BlockContentControl)
    {
      WParagraph wparagraph = new WParagraph((IWordDocument) contentControl.Document);
      BlockContentControl blockContentControl = contentControl as BlockContentControl;
      blockContentControl.ChildEntities.Add((IEntity) wparagraph);
      (blockContentControl.ChildEntities[0] as WParagraph).AppendPicture(picture.ImageBytes);
      picture = (blockContentControl.ChildEntities[0] as WParagraph).ChildEntities[0] as WPicture;
    }
    picture.Height = 100f;
    picture.Width = 100f;
    return picture;
  }

  private bool IsDefaultPicture(byte[] sourceImageBytes)
  {
    Stream manifestResourceStream = WPicture.GetManifestResourceStream("ImageNotFound.jpg");
    byte[] numArray;
    using (BinaryReader binaryReader = new BinaryReader(manifestResourceStream))
      numArray = binaryReader.ReadBytes((int) manifestResourceStream.Length);
    if (sourceImageBytes.Length != numArray.Length)
      return false;
    for (int index = 0; index < sourceImageBytes.Length; ++index)
    {
      if ((int) sourceImageBytes[index] != (int) numArray[index])
        return false;
    }
    return true;
  }

  private void MappedBase64Image(WPicture picture, string text, Entity contentControl)
  {
    float num1 = 0.0f;
    float num2 = 0.0f;
    try
    {
      if (picture != null)
      {
        SizeF sizeF = new SizeF();
        SizeF size = picture.Size;
        num1 = picture.Height;
        num2 = picture.Width;
        if (text == string.Empty && (contentControl.EntityType == Syncfusion.DocIO.DLS.EntityType.BlockContentControl || contentControl.EntityType == Syncfusion.DocIO.DLS.EntityType.InlineContentControl) && !this.IsDefaultPicture(picture.ImageBytes))
        {
          picture = this.SetDefaultPic(picture);
          picture.Height = 100f;
          picture.Width = 100f;
        }
        else if (text == string.Empty && (contentControl.EntityType == Syncfusion.DocIO.DLS.EntityType.BlockContentControl || contentControl.EntityType == Syncfusion.DocIO.DLS.EntityType.InlineContentControl))
        {
          picture = this.SetDefaultPic(picture);
          picture.IsDefaultPicOfContentControl = true;
          picture.Height = num1;
          picture.Width = num2;
        }
        else
        {
          byte[] imageBytes = Convert.FromBase64String(text);
          picture.LoadImage(imageBytes);
          if (picture.Size == size || !picture.LockAspectRatio)
            return;
          if ((double) picture.Size.Height > (double) size.Height || (double) picture.Size.Height == (double) size.Height && (double) picture.Size.Width < (double) size.Width)
          {
            picture.Height = num1;
            float num3 = (float) ((double) num1 / (double) picture.Size.Height * 100.0);
            picture.Width = picture.Size.Width / (100f / num3);
          }
          else
          {
            picture.Width = num2;
            float num4 = (float) ((double) num2 / (double) picture.Size.Width * 100.0);
            picture.Height = picture.Size.Height / (100f / num4);
          }
        }
      }
      else
      {
        if (!(text == string.Empty) || contentControl.EntityType != Syncfusion.DocIO.DLS.EntityType.BlockContentControl && contentControl.EntityType != Syncfusion.DocIO.DLS.EntityType.InlineContentControl)
          return;
        picture = new WPicture((IWordDocument) contentControl.Document);
        picture = this.SetDefaultPic(picture);
        picture = this.AppendPictureToContentControl(picture, contentControl);
      }
    }
    catch (Exception ex)
    {
      if (ex.Message.Trim() == "The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.")
        return;
      picture = this.SetDefaultPic(picture);
      picture.Height = num1;
      picture.Width = num2;
    }
  }

  private void ProcessChildNodes(
    List<string> xPathList,
    XmlNodeList childNodes,
    BlockContentControl contentControl)
  {
    XmlNode currentNode = (XmlNode) null;
    int index1 = 0;
    int result = 0;
    string path = string.Empty;
    string attributeName = string.Empty;
    string attributeValue = string.Empty;
    for (int index2 = 0; index2 < xPathList.Count; ++index2)
    {
      string xPath = xPathList[index1];
      if (index1 > 0)
      {
        int startIndex = 0;
        int endIndex = 0;
        string parentInfo = index2 > 0 ? xPathList[index2 - 1] : string.Empty;
        path = this.GetPathIndex(xPath, ref startIndex, ref endIndex);
        if (startIndex != -1 && endIndex != -1 || startIndex == -1 && endIndex == -1)
        {
          if (startIndex != -1 && endIndex != -1)
          {
            int length = endIndex - (startIndex + 1);
            ++startIndex;
            if (startIndex + length <= endIndex && !int.TryParse(path.Substring(startIndex, length), NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              string str = path.Substring(startIndex, length);
              if (str.Contains("="))
              {
                attributeName = str.Contains("@") ? str.Substring(str.IndexOf("@") + 1, str.IndexOf("=") - 1) : str.Substring(0, str.IndexOf("="));
                attributeValue = str.Substring(str.IndexOf("=") + 1).Trim('\'');
              }
            }
            path = path.Substring(0, startIndex - 1);
          }
          else
            result = 1;
          int toIterate = 0;
          if (childNodes != null)
          {
            currentNode = this.GetCurrentNode(childNodes, currentNode, ref toIterate, result, path, parentInfo, attributeName, attributeValue);
            if (currentNode != null)
              childNodes = currentNode.ChildNodes;
          }
        }
      }
      ++index1;
    }
    if (currentNode == null)
      return;
    string fromContentControl = this.GetTextFromContentControl(path, xPathList, contentControl);
    if ((currentNode.Name.Contains(":") ? currentNode.Name.Substring(currentNode.Name.IndexOf(":") + 1) : currentNode.Name).Equals(path) && currentNode.NodeType == XmlNodeType.Element)
    {
      if ((!fromContentControl.Equals(currentNode.InnerText) || fromContentControl == string.Empty && currentNode.InnerText == string.Empty) && contentControl.ContentControlProperties.Type != ContentControlType.Picture)
      {
        string text = contentControl.ContentControlProperties.Multiline ? this.ReplaceAsSoftBreaks(currentNode.InnerText) : this.ReplaceBreakChars(currentNode.InnerText);
        string dateFormat = this.ConvertTextToDateFormat(contentControl.ContentControlProperties, text);
        if (contentControl.ContentControlProperties.XmlMapping.IsSupportWordML && contentControl.ContentControlProperties.Type == ContentControlType.RichText)
          this.ConvertWordMLToText(contentControl, dateFormat);
        else
          this.SetMappedParagraph(contentControl, dateFormat);
      }
      else if (contentControl.ContentControlProperties.Type == ContentControlType.Picture)
        this.SetMappedPicture(contentControl, currentNode.InnerText);
    }
    XmlAttributeCollection attributes = currentNode.Attributes;
    if (attributes == null)
      return;
    foreach (XmlAttribute xmlAttribute in (XmlNamedNodeMap) attributes)
    {
      if (xmlAttribute.Name.ToString().Contains(path.Substring(1)))
      {
        if (!fromContentControl.Equals(xmlAttribute.Value) && contentControl.ContentControlProperties.Type != ContentControlType.Picture)
        {
          this.SetMappedParagraph(contentControl, currentNode.Value);
          break;
        }
        if (contentControl.ContentControlProperties.Type == ContentControlType.Picture)
        {
          this.SetMappedPicture(contentControl, currentNode.Value);
          break;
        }
      }
    }
  }

  private void SetMappedParagraph(BlockContentControl contentControl, string text)
  {
    if (contentControl == null || text == null || contentControl.TextBody == null)
      return;
    if (text == string.Empty)
    {
      if (this.SkipToMapDatabindingValue((Entity) contentControl))
        return;
      text = this.GetTextForEmptyMappedContent((Entity) contentControl);
    }
    else
      contentControl.ContentControlProperties.HasPlaceHolderText = false;
    if (this.IsMapPlaceHolderFromGlossary((Entity) contentControl, text))
      this.MapContentFromGlossaryDocument((Entity) contentControl);
    else if (contentControl.TextBody.LastParagraph == null)
    {
      WParagraph wparagraph = new WParagraph((IWordDocument) this.m_doc);
      wparagraph.AppendText(text);
      contentControl.TextBody.ChildEntities.Add((IEntity) wparagraph);
      wparagraph.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) contentControl.TextBody);
    }
    else if (contentControl.TextBody.LastParagraph.Items.Count == 1 && contentControl.TextBody.LastParagraph.Items[0] is WTextRange)
      (contentControl.TextBody.LastParagraph.Items[0] as WTextRange).Text = text;
    else if (contentControl.TextBody.LastParagraph.Text != text)
      contentControl.TextBody.LastParagraph.Text = text;
    if (contentControl.TextBody.LastParagraph != null && contentControl.TextBody.LastParagraph.Items.Count > 0 && contentControl.TextBody.LastParagraph.Items[0] is WTextRange)
    {
      WCharacterFormat characterFormat = (contentControl.TextBody.LastParagraph.Items[0] as WTextRange).CharacterFormat;
      this.UpdateFormatting(contentControl.ContentControlProperties.CharacterFormat, characterFormat);
    }
    contentControl.ContentControlProperties.XmlMapping.IsMapped = true;
  }

  private bool HasGlossaryDocument()
  {
    PartContainer partContainer = this.m_doc.DocxPackage.FindPartContainer("word/");
    if (!partContainer.XmlPartContainers.ContainsKey("glossary/"))
      return false;
    PartContainer xmlPartContainer = partContainer.XmlPartContainers["glossary/"];
    return xmlPartContainer != null && xmlPartContainer.XmlParts.ContainsKey("document.xml");
  }

  private bool IsMapPlaceHolderFromGlossary(Entity contentControl, string text)
  {
    return contentControl != null && string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(this.GetPlaceHolderName(contentControl)) && this.HasGlossaryDocument();
  }

  private bool SkipToMapDatabindingValue(Entity contentControl)
  {
    string placeHolderName = this.GetPlaceHolderName(contentControl);
    if (contentControl is BlockContentControl)
    {
      BlockContentControl blockContentControl = contentControl as BlockContentControl;
      bool flag = blockContentControl.ContentControlProperties.Type != ContentControlType.Text || this.HasEmptyBodyItems(blockContentControl.TextBody.Items);
      if (!string.IsNullOrEmpty(placeHolderName) && this.HasGlossaryDocument() && !flag || string.IsNullOrEmpty(blockContentControl.ContentControlProperties.PlaceHolderDocPartId) && blockContentControl.ContentControlProperties.HasPlaceHolderText && blockContentControl.ContentControlProperties.Type == ContentControlType.Text)
        return true;
    }
    return false;
  }

  private string GetPlaceHolderName(Entity contentControl)
  {
    switch (contentControl)
    {
      case BlockContentControl _:
        return (contentControl as BlockContentControl).ContentControlProperties.PlaceHolderDocPartId;
      case InlineContentControl _:
        return (contentControl as InlineContentControl).ContentControlProperties.PlaceHolderDocPartId;
      case CellContentControl _:
        return (contentControl as CellContentControl).ContentControlProperties.PlaceHolderDocPartId;
      default:
        return string.Empty;
    }
  }

  private void MapContentFromGlossaryDocument(Entity contentControl)
  {
    PartContainer partContainer = this.m_doc.DocxPackage.FindPartContainer("word/");
    if (partContainer.XmlPartContainers.ContainsKey("glossary/"))
      partContainer = partContainer.XmlPartContainers["glossary/"];
    XmlReader reader = UtilityMethods.CreateReader(partContainer.XmlParts["document.xml"].DataStream);
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "glossaryDocument")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool isDocPartFound = false;
    while (reader.LocalName != "glossaryDocument")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "docPart":
            this.ParseGLossaryDocPart(reader, contentControl, ref isDocPartFound);
            break;
        }
        if (!flag)
          reader.Read();
        if (isDocPartFound)
          break;
      }
      else
        reader.Read();
    }
  }

  private WParagraph ClearContentControlExceptLastPara(Entity contentControl)
  {
    WParagraph paragraphOfSdtContent = (contentControl as BlockContentControl).GetLastParagraphOfSDTContent();
    paragraphOfSdtContent.ChildEntities.Clear();
    (contentControl as BlockContentControl).TextBody.ChildEntities.Clear();
    return paragraphOfSdtContent;
  }

  private void MapParagraphsFromDocPart(
    WTextBody body,
    Entity contentControl,
    WParagraph lastParagraph,
    bool isCreateNewParaForLast)
  {
    for (int index1 = 0; index1 < body.Paragraphs.Count; ++index1)
    {
      WParagraph paragraph = body.Paragraphs[index1];
      if (index1 == body.Paragraphs.Count - 1)
      {
        if (isCreateNewParaForLast)
          (contentControl as BlockContentControl).TextBody.AddParagraph();
        else
          (contentControl as BlockContentControl).TextBody.ChildEntities.Add((IEntity) lastParagraph.Clone());
        lastParagraph = (contentControl as BlockContentControl).GetLastParagraphOfSDTContent();
        for (int index2 = paragraph.Items.Count - 1; index2 >= 0; --index2)
          lastParagraph.Items.Insert(0, (IEntity) paragraph.Items[index2]);
      }
      else
        (contentControl as BlockContentControl).TextBody.ChildEntities.Add((IEntity) paragraph.Clone());
    }
  }

  private void ParseGLossaryDocPart(
    XmlReader reader,
    Entity contentControl,
    ref bool isDocPartFound)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool flag1 = false;
    while (reader.LocalName != "docPart")
    {
      bool flag2 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "docPartBody":
            if (isDocPartFound)
            {
              switch (contentControl)
              {
                case BlockContentControl _:
                  WParagraph lastParagraph1 = (WParagraph) null;
                  WTextBody body = new WTextBody(this.m_doc.LastSection);
                  this.ParseBody(reader, (IEntity) body, false, false, false);
                  if (body.Paragraphs.Count >= 0 && (contentControl as BlockContentControl).TextBody.Paragraphs.Count > 0)
                  {
                    WParagraph lastParagraph2 = this.ClearContentControlExceptLastPara(contentControl);
                    this.MapParagraphsFromDocPart(body, contentControl, lastParagraph2, false);
                    break;
                  }
                  if (body.Paragraphs.Count > 0 && (contentControl as BlockContentControl).TextBody.Paragraphs.Count == 0)
                  {
                    this.MapParagraphsFromDocPart(body, contentControl, lastParagraph1, true);
                    break;
                  }
                  break;
                case InlineContentControl _:
                  (contentControl as InlineContentControl).ParagraphItems.Clear();
                  WTextBody wtextBody1 = new WTextBody(this.m_doc.LastSection);
                  this.ParseBody(reader, (IEntity) wtextBody1, false, false, false);
                  IEnumerator enumerator1 = wtextBody1.Paragraphs.GetEnumerator();
                  try
                  {
                    while (enumerator1.MoveNext())
                    {
                      WParagraph current = (WParagraph) enumerator1.Current;
                      for (int index = current.Items.Count - 1; index >= 0; --index)
                        (contentControl as InlineContentControl).ParagraphItems.Insert(0, (IEntity) current.Items[index]);
                    }
                    break;
                  }
                  finally
                  {
                    if (enumerator1 is IDisposable disposable)
                      disposable.Dispose();
                  }
                case CellContentControl _:
                  WTableCell ownerCell = (contentControl as CellContentControl).OwnerCell;
                  IWParagraph lastParagraph3 = (IWParagraph) (ownerCell.LastParagraph as WParagraph);
                  WTextBody wtextBody2 = new WTextBody(this.m_doc.LastSection);
                  this.ParseBody(reader, (IEntity) wtextBody2, false, false, false);
                  IWParagraph wparagraph = lastParagraph3 == null ? ownerCell.AddParagraph() : lastParagraph3;
                  wparagraph.ChildEntities.Clear();
                  IEnumerator enumerator2 = wtextBody2.Paragraphs.GetEnumerator();
                  try
                  {
                    while (enumerator2.MoveNext())
                    {
                      WParagraph current = (WParagraph) enumerator2.Current;
                      for (int index = current.Items.Count - 1; index >= 0; --index)
                        wparagraph.Items.Insert(0, (IEntity) current.Items[index]);
                    }
                    break;
                  }
                  finally
                  {
                    if (enumerator2 is IDisposable disposable)
                      disposable.Dispose();
                  }
              }
              flag1 = true;
              break;
            }
            break;
          case "docPartPr":
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              reader.Read();
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                bool flag3 = false;
                bool flag4 = false;
                while (reader.LocalName != "docPartPr")
                {
                  flag2 = false;
                  if (reader.NodeType == XmlNodeType.Element)
                  {
                    switch (reader.LocalName)
                    {
                      case "name":
                        if (!flag4)
                        {
                          string str1;
                          switch (contentControl)
                          {
                            case BlockContentControl _:
                              str1 = (contentControl as BlockContentControl).ContentControlProperties.PlaceHolderDocPartId;
                              break;
                            case InlineContentControl _:
                              str1 = (contentControl as InlineContentControl).ContentControlProperties.PlaceHolderDocPartId;
                              break;
                            case CellContentControl _:
                              str1 = (contentControl as CellContentControl).ContentControlProperties.PlaceHolderDocPartId;
                              break;
                            default:
                              str1 = string.Empty;
                              break;
                          }
                          string str2 = str1;
                          string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
                          isDocPartFound = !string.IsNullOrEmpty(attribute) && attribute == str2;
                          break;
                        }
                        break;
                      case "category":
                        flag4 = true;
                        break;
                    }
                    if (!flag3)
                      reader.Read();
                  }
                  else
                    reader.Read();
                }
                break;
              }
              break;
            }
            break;
        }
        if (!flag2)
          reader.Read();
        if (isDocPartFound && flag1)
          break;
      }
      else
        reader.Read();
    }
  }

  private string GetTextForEmptyMappedContent(Entity contentControl)
  {
    string str;
    switch (contentControl)
    {
      case null:
label_7:
        return string.Empty;
      case BlockContentControl _:
        str = (contentControl as BlockContentControl).ContentControlProperties.PlaceHolderDocPartId;
        break;
      case InlineContentControl _:
        str = (contentControl as InlineContentControl).ContentControlProperties.PlaceHolderDocPartId;
        break;
      case CellContentControl _:
        str = (contentControl as CellContentControl).ContentControlProperties.PlaceHolderDocPartId;
        break;
      default:
        str = string.Empty;
        break;
    }
    if (string.IsNullOrEmpty(str))
      return "     ";
    goto label_7;
  }

  private void UpdateFormatting(WCharacterFormat source, WCharacterFormat dest)
  {
    foreach (KeyValuePair<int, object> keyValuePair in source.PropertiesHash)
    {
      if (!dest.PropertiesHash.ContainsKey(keyValuePair.Key))
        dest.PropertiesHash.Add(keyValuePair.Key, keyValuePair.Value);
    }
  }

  private void ProcessChildNodes(
    List<string> xPathList,
    XmlNodeList childNodes,
    InlineContentControl contentControl)
  {
    XmlNode currentNode = (XmlNode) null;
    int index1 = 0;
    int result = 0;
    string path = string.Empty;
    string empty1 = string.Empty;
    string attributeName = string.Empty;
    string attributeValue = string.Empty;
    for (int index2 = 0; index2 < xPathList.Count; ++index2)
    {
      string xPath = xPathList[index1];
      if (index1 > 0)
      {
        string parentInfo = index2 > 0 ? xPathList[index2 - 1] : string.Empty;
        int startIndex = 0;
        int endIndex = 0;
        path = this.GetPathIndex(xPath, ref startIndex, ref endIndex);
        if (startIndex != -1 && endIndex != -1 || startIndex == -1 && endIndex == -1)
        {
          if (startIndex != -1 && endIndex != -1)
          {
            int length = endIndex - (startIndex + 1);
            ++startIndex;
            if (startIndex + length <= endIndex && !int.TryParse(path.Substring(startIndex, length), NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              string str = path.Substring(startIndex, length);
              if (str.Contains("="))
              {
                attributeName = str.Contains("@") ? str.Substring(str.IndexOf("@") + 1, str.IndexOf("=") - 1) : str.Substring(0, str.IndexOf("="));
                attributeValue = str.Substring(str.IndexOf("=") + 1).Trim('\'');
              }
            }
            path = path.Substring(0, startIndex - 1);
          }
          else
            result = 1;
          int toIterate = 0;
          if (childNodes != null)
          {
            currentNode = this.GetCurrentNode(childNodes, currentNode, ref toIterate, result, path, parentInfo, attributeName, attributeValue);
            if (currentNode != null)
              childNodes = currentNode.ChildNodes;
          }
        }
      }
      ++index1;
    }
    if (currentNode == null)
      return;
    string empty2 = string.Empty;
    if ((currentNode.Name.Contains(":") ? currentNode.Name.Substring(currentNode.Name.IndexOf(":") + 1) : currentNode.Name).Equals(path) && currentNode.NodeType == XmlNodeType.Element)
    {
      foreach (ParagraphItem paragraphItem in (Syncfusion.DocIO.DLS.CollectionImpl) contentControl.ParagraphItems)
      {
        if (paragraphItem is WTextRange)
          empty2 += (paragraphItem as WTextRange).Text;
      }
      if (!empty2.Equals(currentNode.InnerText) && contentControl.ContentControlProperties.Type != ContentControlType.Picture)
      {
        string text = contentControl.ContentControlProperties.Multiline ? this.ReplaceAsSoftBreaks(currentNode.InnerText) : this.ReplaceBreakChars(currentNode.InnerText);
        string dateFormat = this.ConvertTextToDateFormat(contentControl.ContentControlProperties, text);
        if (contentControl.ContentControlProperties.XmlMapping.IsSupportWordML && contentControl.ContentControlProperties.Type == ContentControlType.RichText)
          this.ConvertWordMLToText(contentControl, dateFormat);
        else
          this.SetMappedItem(contentControl, dateFormat);
      }
      else if (contentControl.ContentControlProperties.Type == ContentControlType.Picture)
        this.SetMappedPicture(contentControl, currentNode.InnerText);
    }
    XmlAttributeCollection attributes = currentNode.Attributes;
    if (attributes == null)
      return;
    foreach (XmlAttribute xmlAttribute in (XmlNamedNodeMap) attributes)
    {
      if (xmlAttribute.Name.ToString().Contains(path.Substring(1)))
      {
        if (!empty2.Equals(xmlAttribute.Value) && contentControl.ContentControlProperties.Type != ContentControlType.Picture)
        {
          this.SetMappedItem(contentControl, xmlAttribute.Value);
          break;
        }
        if (contentControl.ContentControlProperties.Type == ContentControlType.Picture)
        {
          this.SetMappedPicture(contentControl, xmlAttribute.Value);
          break;
        }
      }
    }
  }

  private void SetMappedItem(InlineContentControl contentControl, string text)
  {
    WTextRange wtextRange = (WTextRange) null;
    bool flag = false;
    if (contentControl == null || text == null)
      return;
    if (text == string.Empty)
    {
      if (string.IsNullOrEmpty(contentControl.ContentControlProperties.PlaceHolderDocPartId) && contentControl.ContentControlProperties.HasPlaceHolderText && contentControl.ContentControlProperties.Type == ContentControlType.Text)
        return;
      text = this.GetTextForEmptyMappedContent((Entity) contentControl);
    }
    else
      contentControl.ContentControlProperties.HasPlaceHolderText = false;
    if (this.IsMapPlaceHolderFromGlossary((Entity) contentControl, text))
    {
      this.MapContentFromGlossaryDocument((Entity) contentControl);
      for (int index = contentControl.ParagraphItems.Count - 1; index >= 0; --index)
      {
        if (contentControl.ParagraphItems[index] is WTextRange && !(contentControl.ParagraphItems[index] is WField))
        {
          wtextRange = contentControl.ParagraphItems[index] as WTextRange;
          break;
        }
      }
      flag = true;
    }
    else
    {
      if (contentControl.ParagraphItems.Count > 0)
        contentControl.ParagraphItems.Clear();
      wtextRange = new WTextRange((IWordDocument) this.m_doc);
      contentControl.ParagraphItems.Add((IEntity) wtextRange);
      wtextRange.Text = text;
      wtextRange.ApplyCharacterFormat(contentControl.ContentControlProperties.CharacterFormat);
    }
    if (wtextRange != null && contentControl.Owner is WParagraph && contentControl.OwnerParagraph.ParaStyle != null)
      wtextRange.CharacterFormat.ApplyBase((FormatBase) contentControl.OwnerParagraph.ParaStyle.CharacterFormat);
    InlineContentControl inlineContentControl = contentControl;
    BlockContentControl blockContentControl = (BlockContentControl) null;
    while (inlineContentControl.Owner is InlineContentControl && (inlineContentControl.Owner as InlineContentControl).ContentControlProperties.HasPlaceHolderText)
      inlineContentControl = inlineContentControl.Owner as InlineContentControl;
    if (wtextRange != null && inlineContentControl.Owner is WParagraph && (inlineContentControl.Owner as WParagraph).Owner is WTextBody && ((inlineContentControl.Owner as WParagraph).Owner as WTextBody).Owner is BlockContentControl)
    {
      blockContentControl = ((inlineContentControl.Owner as WParagraph).Owner as WTextBody).Owner as BlockContentControl;
      if (blockContentControl.ContentControlProperties.HasPlaceHolderText)
        wtextRange.ApplyCharacterFormat(blockContentControl.ContentControlProperties.CharacterFormat);
      else
        wtextRange.ApplyCharacterFormat(inlineContentControl.ContentControlProperties.CharacterFormat);
    }
    if (wtextRange != null && blockContentControl == null && !flag)
      wtextRange.ApplyCharacterFormat(inlineContentControl.ContentControlProperties.CharacterFormat);
    if (wtextRange != null && inlineContentControl.OwnerParagraph.ParaStyle != null)
      wtextRange.CharacterFormat.ApplyBase((FormatBase) inlineContentControl.OwnerParagraph.ParaStyle.CharacterFormat);
    contentControl.MappedItem = wtextRange != null ? wtextRange.Clone() as ParagraphItem : (ParagraphItem) null;
    contentControl.ContentControlProperties.XmlMapping.IsMapped = true;
  }

  private string ReplaceBreakChars(string text)
  {
    text = text.Replace(ControlChar.CrLf, string.Empty);
    text = text.Replace(ControlChar.ParagraphBreak, string.Empty);
    text = text.Replace(ControlChar.LineFeed, string.Empty);
    return text;
  }

  private string ReplaceAsSoftBreaks(string text)
  {
    text = text.Replace(ControlChar.CrLf, ControlChar.LineBreak);
    text = text.Replace(ControlChar.ParagraphBreak, ControlChar.LineBreak);
    text = text.Replace(ControlChar.LineFeed, ControlChar.LineBreak);
    return text;
  }

  private void ClearParsedImage(string imageName, string containerName)
  {
    PartContainer partContainer = this.m_doc.DocxPackage.FindPartContainer(containerName);
    if (!partContainer.XmlParts.ContainsKey(imageName))
      return;
    Part xmlPart = partContainer.XmlParts[imageName];
    partContainer.XmlParts.Remove(imageName);
    xmlPart.DataStream.Close();
  }

  private void ParseThemes(Stream stream)
  {
    XmlReader reader = UtilityMethods.CreateReader(stream);
    if (reader.NamespaceURI == this.m_strictANameSpace)
      this.IsStrict = true;
    if (reader == null)
      throw new Exception("reader");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "theme")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "theme") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "themeElements":
            this.ParseThemeElements(reader);
            break;
          case "objectDefaults":
            this.m_doc.Themes.DocxProps.Add("objectDefaults", (Stream) this.ReadSingleNodeIntoStream(reader));
            break;
          case "extLst":
            this.m_doc.Themes.DocxProps.Add("extLst", (Stream) this.ReadSingleNodeIntoStream(reader));
            break;
          case "extraClrSchemeLst":
            this.m_doc.Themes.DocxProps.Add("extraClrSchemeLst", (Stream) this.ReadSingleNodeIntoStream(reader));
            break;
          default:
            flag = true;
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseThemeElements(XmlReader reader)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (localName != "themeElements")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "themeElements") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "clrScheme":
            if (reader.HasAttributes)
              this.m_doc.Themes.ColorSchemeName = reader.GetAttribute("name");
            this.ParseSchemeColor(reader);
            break;
          case "fmtScheme":
            if (reader.HasAttributes)
              this.m_doc.Themes.FmtScheme.FmtName = reader.GetAttribute("name");
            this.ParseFormatScheme(reader);
            break;
          case "fontScheme":
            if (reader.HasAttributes)
              this.m_doc.Themes.FontScheme.FontSchemeName = reader.GetAttribute("name");
            this.ParseFontScheme(reader);
            break;
          default:
            flag = true;
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseFormatScheme(XmlReader reader)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (localName != "fmtScheme")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "fmtScheme") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "fillStyleLst":
            this.ParseFillStyleList(reader, reader.LocalName);
            break;
          case "lnStyleLst":
            this.ParseLineStyleScheme(reader);
            break;
          case "effectStyleLst":
            this.ParseEffectStyleScheme(reader);
            break;
          case "bgFillStyleLst":
            this.ParseFillStyleList(reader, reader.LocalName);
            break;
          default:
            flag = true;
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseEffectStyleScheme(XmlReader reader)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (localName != "effectStyleLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "effectStyleLst") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "effectStyle":
            EffectFormat effectList = this.ParseEffectList(reader);
            if (effectList != null)
            {
              this.m_doc.Themes.FmtScheme.EffectStyles.Add(effectList);
              break;
            }
            break;
          default:
            flag = true;
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private EffectFormat ParseEffectList(XmlReader reader)
  {
    if (reader.IsEmptyElement)
      return (EffectFormat) null;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return (EffectFormat) null;
    EffectFormat effectFormat = new EffectFormat(new Shape((IWordDocument) this.m_doc));
    if (localName != "effectStyle")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    bool flag = true;
    while (!(reader.LocalName == "effectStyle") || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "effectLst":
            this.ParseEffectListItems(reader, effectFormat);
            flag = false;
            break;
          case "scene3d":
            effectFormat.IsSceneProperties = true;
            this.ParseSceneProperties(reader, effectFormat);
            break;
          case "sp3d":
            effectFormat.IsShapeProperties = true;
            if (reader.HasAttributes)
            {
              string attribute1 = reader.GetAttribute("contourW");
              if (!string.IsNullOrEmpty(attribute1))
                effectFormat.ThreeDFormat.ContourWidth = this.GetPropertyValue(attribute1, "contourW");
              string attribute2 = reader.GetAttribute("extrusionH");
              if (!string.IsNullOrEmpty(attribute2))
                effectFormat.ThreeDFormat.ExtrusionHeight = this.GetPropertyValue(attribute2, "extrusionH");
              string attribute3 = reader.GetAttribute("z");
              if (!string.IsNullOrEmpty(attribute3))
                effectFormat.ThreeDFormat.DistanceFromGround = this.GetPropertyValue(attribute3, "z");
              string str = reader.GetAttribute("prstMaterial");
              if (!string.IsNullOrEmpty(str) && str.Length > 2)
              {
                if (str == "dkEdge")
                  str = "darkEdge";
                effectFormat.ThreeDFormat.PresetMaterialType = System.Enum.IsDefined(typeof (PresetMaterialType), (object) (char.ToUpper(str[0]).ToString() + str.Substring(1))) ? (PresetMaterialType) System.Enum.Parse(typeof (PresetMaterialType), str, true) : PresetMaterialType.None;
              }
            }
            this.ParseShapeProperties(reader, effectFormat);
            break;
          default:
            flag = false;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return effectFormat;
  }

  private float GetPropertyValue(string value, string attributeName)
  {
    float result = 0.0f;
    value = value.TrimStart(ControlChar.SpaceChar);
    if (value.EndsWith("cm"))
    {
      float.TryParse(value.Remove(value.IndexOf("cm"), 2), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      return result * 28.35f;
    }
    if (value.EndsWith("mm"))
    {
      float.TryParse(value.Remove(value.IndexOf("mm"), 2), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      return result * 2.835f;
    }
    if (value.EndsWith("pt"))
    {
      float.TryParse(value.Remove(value.IndexOf("pt"), 2), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      return result;
    }
    if (value.EndsWith("pi"))
    {
      float.TryParse(value.Remove(value.IndexOf("pi"), 2), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      return result * 12f;
    }
    float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    switch (attributeName)
    {
      case "offX":
      case "offY":
      case "cx":
      case "cy":
      case "x":
      case "y":
      case "contourW":
      case "extrusionH":
      case "z":
      case "rad":
      case "blurRad":
      case "dist":
      case "bevel":
      case "fov":
      case "w":
      case "anchor":
      case "norm":
      case "up":
      case "glow":
      case "softEdge":
      case "ln":
      case "l":
      case "t":
      case "r":
      case "b":
        return result / 12700f;
      case "sx":
      case "sy":
      case "srcRect":
        return result / 1000f;
      default:
        return result;
    }
  }

  private EffectFormat ParseShapeProperties(XmlReader reader, EffectFormat effectFormat)
  {
    if (reader.LocalName != "sp3d")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return (EffectFormat) null;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return (EffectFormat) null;
    this.SkipWhitespaces(reader);
    bool flag = true;
    while (!(reader.LocalName == "sp3d") || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "bevelB":
          case "bevelT":
            if (reader.LocalName == "bevelT")
              effectFormat.ThreeDFormat.HasBevelTop = true;
            else
              effectFormat.ThreeDFormat.HasBevelBottom = true;
            if (reader.HasAttributes)
            {
              string attribute1 = reader.GetAttribute("w");
              if (!string.IsNullOrEmpty(attribute1))
              {
                if (reader.LocalName == "bevelT")
                  effectFormat.ThreeDFormat.BevelTopWidth = this.GetPropertyValue(attribute1, "bevel");
                else
                  effectFormat.ThreeDFormat.BevelBottomWidth = this.GetPropertyValue(attribute1, "bevel");
              }
              string attribute2 = reader.GetAttribute("h");
              if (!string.IsNullOrEmpty(attribute2))
              {
                if (reader.LocalName == "bevelT")
                  effectFormat.ThreeDFormat.BevelTopHeight = this.GetPropertyValue(attribute2, "bevel");
                else
                  effectFormat.ThreeDFormat.BevelBottomHeight = this.GetPropertyValue(attribute2, "bevel");
              }
              string attribute3 = reader.GetAttribute("prst");
              if (!string.IsNullOrEmpty(attribute3) && attribute3.Length > 2)
              {
                if (reader.LocalName == "bevelT")
                  effectFormat.ThreeDFormat.BevelTPresetType = System.Enum.IsDefined(typeof (BevelPresetType), (object) (char.ToUpper(attribute3[0]).ToString() + attribute3.Substring(1))) ? (BevelPresetType) System.Enum.Parse(typeof (BevelPresetType), attribute3, true) : BevelPresetType.None;
                else
                  effectFormat.ThreeDFormat.BevelBPresetType = System.Enum.IsDefined(typeof (BevelPresetType), (object) (char.ToUpper(attribute3[0]).ToString() + attribute3.Substring(1))) ? (BevelPresetType) System.Enum.Parse(typeof (BevelPresetType), attribute3, true) : BevelPresetType.None;
              }
            }
            flag = false;
            break;
          case "extList":
            flag = false;
            break;
          case "contourClr":
          case "extrusionClr":
            if (reader.LocalName == "contourClr")
              effectFormat.ThreeDFormat.HasContourColor = true;
            else
              effectFormat.ThreeDFormat.HasExtrusionColor = true;
            uint maxValue = uint.MaxValue;
            if (reader.LocalName == "extrusionClr")
            {
              effectFormat.ThreeDFormat.ExtrusionColor = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
              if (maxValue != uint.MaxValue)
              {
                float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
                effectFormat.ThreeDFormat.ExtrusionOpacity = 1f - num;
                break;
              }
              break;
            }
            effectFormat.ThreeDFormat.ContourColor = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (maxValue != uint.MaxValue)
            {
              float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
              effectFormat.ThreeDFormat.ContourOpacity = 1f - num;
              break;
            }
            break;
          default:
            flag = false;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return effectFormat;
  }

  private EffectFormat ParseSceneProperties(XmlReader reader, EffectFormat effectFormat)
  {
    if (reader.LocalName != "scene3d")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return (EffectFormat) null;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return (EffectFormat) null;
    this.SkipWhitespaces(reader);
    bool flag = true;
    while (!(reader.LocalName == "scene3d") || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "backdrop":
            effectFormat.ThreeDFormat.HasBackdropEffect = true;
            this.ParseBackdrop(reader, effectFormat);
            break;
          case "camera":
            effectFormat.ThreeDFormat.HasCameraEffect = true;
            this.ParseCameraSettings(reader, effectFormat);
            flag = false;
            break;
          case "extLst":
            effectFormat.ThreeDFormat.DocxProps.Add("scene3d" + reader.LocalName, (Stream) this.ReadSingleNodeIntoStream(reader));
            flag = false;
            break;
          case "lightRig":
            effectFormat.ThreeDFormat.HasLightRigEffect = true;
            this.ParseLightRigSettings(reader, effectFormat);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return effectFormat;
  }

  private void ParseCameraSettings(XmlReader reader, EffectFormat effectFormat)
  {
    if (reader.LocalName != "camera")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.HasAttributes)
    {
      string attribute1 = reader.GetAttribute("fov");
      if (!string.IsNullOrEmpty(attribute1))
        effectFormat.ThreeDFormat.FieldOfView = this.GetPropertyValue(attribute1, "fov");
      string attribute2 = reader.GetAttribute("zoom");
      if (!string.IsNullOrEmpty(attribute2))
      {
        float result = 0.0f;
        bool flag = attribute2.EndsWith("%");
        if (float.TryParse(flag ? attribute2.Replace("%", "") : attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
          effectFormat.ThreeDFormat.Zoom = flag ? result * 1000f : result;
      }
      string attribute3 = reader.GetAttribute("prst");
      if (!string.IsNullOrEmpty(attribute3) && attribute3.Length > 2)
        effectFormat.ThreeDFormat.CameraPresetType = System.Enum.IsDefined(typeof (CameraPresetType), (object) (char.ToUpper(attribute3[0]).ToString() + attribute3.Substring(1))) ? (CameraPresetType) System.Enum.Parse(typeof (CameraPresetType), attribute3, true) : CameraPresetType.None;
    }
    this.SkipWhitespaces(reader);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    XmlNodeType nodeType = reader.NodeType;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.ParseScene3DRotation(reader, localName, effectFormat, nodeType);
  }

  private void ParseLightRigSettings(XmlReader reader, EffectFormat effectFormat)
  {
    if (reader.LocalName != "lightRig")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.HasAttributes)
    {
      string attribute1 = reader.GetAttribute("rig");
      if (!string.IsNullOrEmpty(attribute1) && attribute1.Length > 2)
        effectFormat.ThreeDFormat.LightRigType = System.Enum.IsDefined(typeof (LightRigType), (object) (char.ToUpper(attribute1[0]).ToString() + attribute1.Substring(1))) ? (LightRigType) System.Enum.Parse(typeof (LightRigType), attribute1, true) : LightRigType.None;
      string attribute2 = reader.GetAttribute("dir");
      if (!string.IsNullOrEmpty(attribute2) && System.Enum.IsDefined(typeof (LightRigDirection), (object) attribute2.ToUpper()))
        effectFormat.ThreeDFormat.LightRigDirection = (LightRigDirection) System.Enum.Parse(typeof (LightRigDirection), attribute2, true);
    }
    this.SkipWhitespaces(reader);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    XmlNodeType nodeType = reader.NodeType;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.ParseScene3DRotation(reader, localName, effectFormat, nodeType);
  }

  private string GetLightRigDirection(string value)
  {
    switch (value)
    {
      case "t":
        return "T";
      case "b":
        return "Bottom";
      case "bl":
        return "BottomLeft";
      case "br":
        return "BottomRight";
      case "tl":
        return "TopLeft";
      case "tr":
        return "TopRight";
      case "l":
        return "Left";
      case "r":
        return "Right";
      default:
        return (string) null;
    }
  }

  private void ParseScene3DRotation(
    XmlReader reader,
    string parentName,
    EffectFormat effectFormat,
    XmlNodeType nodeType)
  {
    string str = nodeType == XmlNodeType.Element ? parentName : reader.LocalName;
    XmlNodeType xmlNodeType = nodeType == XmlNodeType.Element ? nodeType : reader.NodeType;
    while (xmlNodeType != XmlNodeType.Element)
    {
      reader.Read();
      xmlNodeType = reader.NodeType;
      str = reader.LocalName;
    }
    if (str != parentName)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == parentName) || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "rot":
            if (reader.HasAttributes)
            {
              string attribute1 = reader.GetAttribute("lat");
              if (!string.IsNullOrEmpty(attribute1))
              {
                uint result;
                uint.TryParse(attribute1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                if (parentName == "camera")
                  effectFormat.ThreeDFormat.CameraRotationX = (float) Math.Round((double) result / 60000.0, 5);
                else
                  effectFormat.ThreeDFormat.LightRigRotationX = (float) Math.Round((double) result / 60000.0, 5);
              }
              string attribute2 = reader.GetAttribute("lon");
              if (!string.IsNullOrEmpty(attribute2))
              {
                uint result;
                uint.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                if (parentName == "camera")
                  effectFormat.ThreeDFormat.CameraRotationY = (float) Math.Round((double) result / 60000.0, 5);
                else
                  effectFormat.ThreeDFormat.LightRigRotationY = (float) Math.Round((double) result / 60000.0, 5);
              }
              string attribute3 = reader.GetAttribute("rev");
              if (!string.IsNullOrEmpty(attribute3))
              {
                uint result;
                uint.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                if (parentName == "camera")
                {
                  effectFormat.ThreeDFormat.CameraRotationZ = (float) Math.Round((double) result / 60000.0, 5);
                  break;
                }
                effectFormat.ThreeDFormat.LightRigRotationZ = (float) Math.Round((double) result / 60000.0, 5);
                break;
              }
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseBackdrop(XmlReader reader, EffectFormat effectFormat)
  {
    if (reader.LocalName != "backdrop")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    bool flag = true;
    while (!(reader.LocalName == "backdrop") || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "anchor":
            string attribute1 = reader.GetAttribute("x");
            if (!string.IsNullOrEmpty(attribute1))
              effectFormat.ThreeDFormat.BackdropAnchorX = this.GetPropertyValue(attribute1, reader.LocalName);
            string attribute2 = reader.GetAttribute("y");
            if (!string.IsNullOrEmpty(attribute2))
              effectFormat.ThreeDFormat.BackdropAnchorY = this.GetPropertyValue(attribute2, reader.LocalName);
            string attribute3 = reader.GetAttribute("z");
            if (!string.IsNullOrEmpty(attribute3))
            {
              effectFormat.ThreeDFormat.BackdropAnchorZ = this.GetPropertyValue(attribute3, reader.LocalName);
              break;
            }
            break;
          case "norm":
            string attribute4 = reader.GetAttribute("dx");
            if (!string.IsNullOrEmpty(attribute4))
              effectFormat.ThreeDFormat.BackdropNormalX = this.GetPropertyValue(attribute4, reader.LocalName);
            string attribute5 = reader.GetAttribute("dy");
            if (!string.IsNullOrEmpty(attribute5))
              effectFormat.ThreeDFormat.BackdropNormalY = this.GetPropertyValue(attribute5, reader.LocalName);
            string attribute6 = reader.GetAttribute("dz");
            if (!string.IsNullOrEmpty(attribute6))
            {
              effectFormat.ThreeDFormat.BackdropNormalZ = this.GetPropertyValue(attribute6, reader.LocalName);
              break;
            }
            break;
          case "extLst":
            effectFormat.ThreeDFormat.DocxProps.Add("sp3d" + reader.LocalName, (Stream) this.ReadSingleNodeIntoStream(reader));
            flag = false;
            break;
          case "up":
            string attribute7 = reader.GetAttribute("dx");
            if (!string.IsNullOrEmpty(attribute7))
              effectFormat.ThreeDFormat.BackdropUpX = this.GetPropertyValue(attribute7, reader.LocalName);
            string attribute8 = reader.GetAttribute("dy");
            if (!string.IsNullOrEmpty(attribute8))
              effectFormat.ThreeDFormat.BackdropUpY = this.GetPropertyValue(attribute8, reader.LocalName);
            string attribute9 = reader.GetAttribute("dz");
            if (!string.IsNullOrEmpty(attribute9))
            {
              effectFormat.ThreeDFormat.BackdropUpZ = this.GetPropertyValue(attribute9, reader.LocalName);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseEffectListItems(XmlReader reader, EffectFormat effectFormat)
  {
    if (reader.LocalName != "effectLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    uint maxValue = uint.MaxValue;
    bool flag = true;
    while (!(reader.LocalName == "effectLst") || reader.NodeType != XmlNodeType.EndElement)
    {
      effectFormat.IsEffectListItem = true;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "outerShdw":
          case "innerShdw":
            effectFormat.ShadowFormat.m_type = reader.LocalName;
            effectFormat.IsShadowEffect = true;
            this.ParseShadowEffect(reader, reader.LocalName, effectFormat);
            break;
          case "reflection":
            if (reader.HasAttributes)
            {
              effectFormat.IsReflection = true;
              this.ParseReflectionEffect(reader, effectFormat);
            }
            flag = false;
            break;
          case "glow":
            effectFormat.IsGlowEffect = true;
            if (reader.HasAttributes)
            {
              string attribute = reader.GetAttribute("rad");
              if (!string.IsNullOrEmpty(attribute))
              {
                effectFormat.GlowFormat.IsInlineRadius = true;
                effectFormat.GlowFormat.Radius = this.GetPropertyValue(attribute, reader.LocalName);
              }
            }
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              reader.Read();
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                effectFormat.GlowFormat.Color = this.ParseColor(reader, localName2, ref maxValue, localName2, true);
                effectFormat.GlowFormat.IsInlineColor = true;
                if (maxValue != uint.MaxValue)
                {
                  float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
                  effectFormat.GlowFormat.Transparency = 1f - num;
                  effectFormat.GlowFormat.IsInlineTransparency = true;
                  break;
                }
                break;
              }
              break;
            }
            break;
          case "softEdge":
            effectFormat.IsSoftEdge = true;
            if (reader.HasAttributes)
            {
              string attribute = reader.GetAttribute("rad");
              effectFormat.SoftEdgeRadius = this.GetPropertyValue(attribute, reader.LocalName);
              if ((double) effectFormat.SoftEdgeRadius == 0.0)
                effectFormat.NoSoftEdges = true;
            }
            flag = false;
            break;
          default:
            flag = false;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseFillStyleList(XmlReader reader, string localName)
  {
    if (reader.LocalName != "fillStyleLst" && reader.LocalName != "bgFillStyleLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    reader.Read();
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == localName) || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        FillFormat fillFormat = new FillFormat((Syncfusion.DocIO.DLS.ShapeBase) new Shape((IWordDocument) this.m_doc));
        switch (reader.LocalName)
        {
          case "solidFill":
            fillFormat.Fill = true;
            fillFormat.FillType = FillType.FillSolid;
            List<DictionaryEntry> colorEntries1 = new List<DictionaryEntry>();
            uint maxValue1 = uint.MaxValue;
            Color empty1 = Color.Empty;
            List<DictionaryEntry> themeFillColor = this.ParseThemeFillColor(reader, "solidFill", colorEntries1, ref maxValue1, ref empty1);
            fillFormat.Color = empty1;
            if (themeFillColor != null && themeFillColor.Count > 0)
              fillFormat.FillSchemeColorTransforms = themeFillColor;
            if (maxValue1 != uint.MaxValue)
              fillFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue1 / 65536.0, 2) * 100f;
            if (localName.Equals("fillStyleLst"))
              this.m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
            else
              this.m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
            flag = true;
            break;
          case "gradFill":
            fillFormat.Fill = true;
            fillFormat.FillType = FillType.FillGradient;
            this.ParseFormatSchemeGradientFill(reader, fillFormat.GradientFill);
            if (localName.Equals("fillStyleLst"))
              this.m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
            else
              this.m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
            flag = true;
            break;
          case "noFill":
            fillFormat.Fill = false;
            flag = true;
            fillFormat.FillType = FillType.None;
            if (localName.Equals("fillStyleLst"))
            {
              this.m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
              break;
            }
            this.m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
            break;
          case "blipFill":
            fillFormat.Fill = true;
            fillFormat.FillType = FillType.FillPicture;
            this.ParseBlipFill(reader, fillFormat);
            if (localName.Equals("fillStyleLst"))
            {
              this.m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
              break;
            }
            this.m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
            break;
          case "pattFill":
            fillFormat.FillType = FillType.FillPatterned;
            string attribute = reader.GetAttribute("prst");
            if (!string.IsNullOrEmpty(attribute))
              fillFormat.Pattern = this.GetPatternType(attribute);
            List<DictionaryEntry> colorEntries2 = new List<DictionaryEntry>();
            uint maxValue2 = uint.MaxValue;
            Color empty2 = Color.Empty;
            Color empty3 = Color.Empty;
            uint maxValue3 = uint.MaxValue;
            List<DictionaryEntry> themePatternFill = this.ParseThemePatternFill(reader, "pattFill", colorEntries2, ref empty2, ref empty3, ref maxValue2, ref maxValue3);
            if (themePatternFill != null && themePatternFill.Count > 0)
              fillFormat.FillSchemeColorTransforms = themePatternFill;
            fillFormat.Color = empty2;
            fillFormat.ForeColor = empty3;
            if (maxValue2 != uint.MaxValue)
              fillFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue2 / 65536.0, 2) * 100f;
            if (maxValue3 != uint.MaxValue)
              fillFormat.SecondaryOpacity = (float) Math.Round(1.0 - (double) maxValue3 / 65536.0, 2) * 100f;
            if (localName.Equals("fillStyleLst"))
            {
              this.m_doc.Themes.FmtScheme.FillFormats.Add(fillFormat);
              break;
            }
            this.m_doc.Themes.FmtScheme.BgFillFormats.Add(fillFormat);
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private List<DictionaryEntry> ParseThemeFillColor(
    XmlReader reader,
    string localName,
    List<DictionaryEntry> colorEntries,
    ref uint opacity,
    ref Color color)
  {
    if (reader.IsEmptyElement)
      return (List<DictionaryEntry>) null;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return (List<DictionaryEntry>) null;
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (localName1 != localName)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    color = Color.Empty;
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == localName) || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        bool flag;
        switch (reader.LocalName)
        {
          case "schemeClr":
            if (this.m_doc.Themes.SchemeColor.ContainsKey(reader.GetAttribute("val")))
            {
              color = this.ParseColor(reader, reader.LocalName, ref opacity, reader.LocalName, false);
            }
            else
            {
              color = Color.Empty;
              colorEntries = this.ParseThemeColorTransform(reader, localName);
            }
            flag = false;
            break;
          case "srgbClr":
            string attribute1 = reader.GetAttribute("val");
            color = this.GetHexColor(attribute1);
            this.ParseColorTransform(reader, "srgbClr", ref color, ref opacity);
            flag = false;
            break;
          case "scrgbClr":
            double red = Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("r")) / 100.0));
            double green = Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("g")) / 100.0));
            double blue = Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("b")) / 100.0));
            color = Color.FromArgb((int) byte.MaxValue, (int) (byte) red, (int) (byte) green, (int) (byte) blue);
            this.ParseColorTransform(reader, "scrgbClr", ref color, ref opacity);
            flag = false;
            break;
          case "prstClr":
            string attribute2 = reader.GetAttribute("val");
            color = Color.FromName(attribute2);
            this.ParseColorTransform(reader, "prstClr", ref color, ref opacity);
            flag = false;
            break;
          case "hslClr":
            double result = 0.0;
            double.TryParse(reader.GetAttribute("hue"), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
            result /= 60000.0;
            result /= 360.0;
            double luminance = this.GetPercentage(reader.GetAttribute("lum")) / 100.0;
            double saturation = this.GetPercentage(reader.GetAttribute("sat")) / 100.0;
            color = WordColor.ConvertHSLToColor(result, saturation, luminance);
            this.ParseColorTransform(reader, "hslClr", ref color, ref opacity);
            flag = false;
            break;
          case "sysClr":
            color = this.GetSystemColor(reader);
            this.ParseColorTransform(reader, "sysClr", ref color, ref opacity);
            flag = false;
            break;
          default:
            flag = false;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return colorEntries;
  }

  private List<DictionaryEntry> ParseThemeColorTransform(XmlReader reader, string parentElement)
  {
    if (reader.IsEmptyElement)
      return (List<DictionaryEntry>) null;
    string localName1 = reader.LocalName;
    reader.Read();
    if (!(localName1 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      while (reader.NodeType != XmlNodeType.Element)
      {
        reader.Read();
        flag = true;
      }
      if (localName1 != "schemeClr")
        throw new XmlException("Unexpected xml tag " + reader.LocalName);
      if (!flag)
        return this.ParseThemeColorTransformValues(reader, parentElement);
      if (!reader.IsEmptyElement)
      {
        string localName2 = reader.LocalName;
        reader.Read();
        if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
          return this.ParseThemeColorTransformValues(reader, parentElement);
      }
    }
    return (List<DictionaryEntry>) null;
  }

  private List<DictionaryEntry> ParseThemeColorTransformValues(
    XmlReader reader,
    string parentElement)
  {
    bool flag1 = false;
    List<DictionaryEntry> colorTransformValues = new List<DictionaryEntry>();
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "schemeClr") || reader.NodeType != XmlNodeType.EndElement)
    {
      flag1 = true;
      if (reader.NodeType == XmlNodeType.Element)
      {
        bool flag2;
        switch (reader.LocalName)
        {
          case "alpha":
          case "alphaMod":
          case "alphaOff":
          case "blue":
          case "blueMod":
          case "blueOff":
          case "green":
          case "greenMod":
          case "greenOff":
          case "red":
          case "redOff":
          case "redMod":
          case "hue":
          case "hueMod":
          case "hueOff":
          case "sat":
          case "satMod":
          case "satOff":
          case "lum":
          case "lumMod":
          case "lumOff":
          case "tint":
          case "shade":
            string key = (parentElement == "fgClr" || parentElement == "bgClr" ? parentElement : "") + reader.LocalName;
            if (this.IsStrict)
            {
              int result = 0;
              int.TryParse(reader.GetAttribute("val").Replace("%", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.CurrentCulture, out result);
              int num = result * 1000;
              colorTransformValues.Add(new DictionaryEntry((object) key, (object) num));
            }
            else
              colorTransformValues.Add(new DictionaryEntry((object) key, (object) reader.GetAttribute("val")));
            flag2 = false;
            break;
          case "comp":
          case "gamma":
          case "gray":
          case "invGamma":
          case "inv":
            colorTransformValues.Add(new DictionaryEntry((object) reader.LocalName, (object) string.Empty));
            flag2 = false;
            break;
          default:
            flag2 = false;
            break;
        }
        if (!flag2)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return colorTransformValues;
  }

  private void ParseFormatSchemeGradientFill(XmlReader reader, GradientFill gradientFill)
  {
    if (!reader.IsEmptyElement)
    {
      string localName1 = reader.LocalName;
      string attribute1 = reader.GetAttribute("flip");
      string attribute2 = reader.GetAttribute("rotWithShape");
      reader.Read();
      if (!(localName1 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
      {
        while (reader.NodeType != XmlNodeType.Element)
          reader.Read();
        if (localName1 != "gradFill")
          throw new XmlException("Unexpected xml tag " + reader.LocalName);
        if (!string.IsNullOrEmpty(attribute1))
          gradientFill.Flip = this.GetFlipOrientation(attribute1);
        if (!string.IsNullOrEmpty(attribute2))
          gradientFill.RotateWithShape = this.GetBoolValue(attribute2);
        this.SkipWhitespaces(reader);
        while (!(reader.LocalName == "gradFill") || reader.NodeType != XmlNodeType.EndElement)
        {
          bool flag = false;
          if (reader.NodeType == XmlNodeType.Element)
          {
            switch (reader.LocalName)
            {
              case "gsLst":
                this.ParseFormatSchemeGradientStop(reader, gradientFill);
                break;
              case "lin":
                this.ParseLinearGradient(reader, gradientFill);
                break;
              case "path":
                gradientFill.PathGradient = new PathGradient();
                string attribute3 = reader.GetAttribute("path");
                gradientFill.PathGradient.PathShade = this.GetGradientShadeType(attribute3);
                if (!reader.IsEmptyElement)
                {
                  string localName2 = reader.LocalName;
                  reader.Read();
                  if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
                  {
                    this.ParsePathGradient(reader, gradientFill.PathGradient, localName2);
                    break;
                  }
                  break;
                }
                break;
              case "tileRect":
                this.ParseTileRectangle(reader, gradientFill);
                break;
              default:
                flag = false;
                break;
            }
            if (!flag)
              reader.Read();
          }
          else
            reader.Read();
          this.SkipWhitespaces(reader);
        }
      }
      else
        gradientFill.IsEmptyElement = true;
    }
    else
      gradientFill.IsEmptyElement = true;
  }

  private List<DictionaryEntry> ParseThemePatternFill(
    XmlReader reader,
    string parentElement,
    List<DictionaryEntry> colorEntries,
    ref Color color,
    ref Color foreColor,
    ref uint opacity,
    ref uint fgOpacity)
  {
    if (reader.IsEmptyElement)
      return (List<DictionaryEntry>) null;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return (List<DictionaryEntry>) null;
    reader.Read();
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == localName2) || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      opacity = uint.MaxValue;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "fgClr":
          case "bgClr":
            Color empty = Color.Empty;
            uint maxValue = uint.MaxValue;
            colorEntries = this.ParseThemeFillColor(reader, reader.LocalName, colorEntries, ref maxValue, ref empty);
            if (reader.LocalName == "fgClr")
            {
              foreColor = empty;
              fgOpacity = maxValue;
              break;
            }
            color = empty;
            opacity = maxValue;
            break;
          default:
            flag = true;
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return colorEntries;
  }

  private void ParseFormatSchemeGradientStop(XmlReader reader, GradientFill gradientFill)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "gsLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    int num = 0;
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "gsLst") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "gs":
            string attribute = reader.GetAttribute("pos");
            GradientStop gradientStop = new GradientStop();
            double result;
            if (!string.IsNullOrEmpty(attribute))
            {
              if (this.IsStrict && attribute.EndsWith("%"))
              {
                double.TryParse(attribute.Remove(attribute.IndexOf("%")), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                gradientStop.Position = (byte) Math.Round(result);
              }
              else if (double.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
                gradientStop.Position = (byte) Math.Round(result / 1000.0);
              else if (gradientFill.GradientStops.Count == 0)
                gradientStop.Position = (byte) result;
              else
                break;
            }
            uint maxValue = uint.MaxValue;
            List<DictionaryEntry> colorEntries = new List<DictionaryEntry>();
            Color empty = Color.Empty;
            List<DictionaryEntry> themeFillColor = this.ParseThemeFillColor(reader, "gs", colorEntries, ref maxValue, ref empty);
            gradientStop.Color = empty;
            if (themeFillColor != null && themeFillColor.Count > 0)
              gradientStop.FillSchemeColorTransforms = themeFillColor;
            if (maxValue != uint.MaxValue)
              gradientStop.Opacity = (byte) Math.Round((double) maxValue / 65536.0 * 100.0);
            ++num;
            gradientFill.GradientStops.Add(gradientStop);
            break;
          default:
            flag = false;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseLineStyleScheme(XmlReader reader)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (localName1 != "lnStyleLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    Shape shape = new Shape((IWordDocument) this.m_doc);
    bool flag1 = false;
    while (!(reader.LocalName == "lnStyleLst") || reader.NodeType != XmlNodeType.EndElement)
    {
      flag1 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        LineFormat lineFormat = new LineFormat(shape);
        bool flag2;
        switch (reader.LocalName)
        {
          case "ln":
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              string attribute1 = reader.GetAttribute("w");
              string attribute2 = reader.GetAttribute("cmpd");
              string attribute3 = reader.GetAttribute("algn");
              string attribute4 = reader.GetAttribute("cap");
              reader.Read();
              bool flag3 = true;
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                if (!string.IsNullOrEmpty(attribute1))
                  lineFormat.Weight = this.GetPropertyValue(attribute1, "ln");
                if (!string.IsNullOrEmpty(attribute2))
                  lineFormat.Style = this.GetShapeOutLineStyle(attribute2);
                if (attribute3 == "in")
                  lineFormat.InsetPen = true;
                if (!string.IsNullOrEmpty(attribute4))
                  lineFormat.LineCap = this.GetLineCapStyle(attribute4);
                this.ParseLineStyle(reader, lineFormat, flag3 ? localName2 : reader.LocalName);
                this.m_doc.Themes.FmtScheme.LnStyleScheme.Add(lineFormat);
                flag2 = true;
                break;
              }
              lineFormat.Line = false;
              this.m_doc.Themes.FmtScheme.LnStyleScheme.Add(lineFormat);
              flag2 = true;
              break;
            }
            lineFormat.Line = false;
            this.m_doc.Themes.FmtScheme.LnStyleScheme.Add(lineFormat);
            flag2 = true;
            break;
          default:
            flag2 = true;
            break;
        }
        if (flag2)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseLineStyle(XmlReader reader, LineFormat lineFormat, string localName)
  {
    if (localName != "ln")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "ln") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      Color empty1;
      uint maxValue1;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "bevel":
            lineFormat.LineJoin = LineJoin.Bevel;
            goto case "custDash";
          case "miter":
            lineFormat.LineJoin = LineJoin.Miter;
            if (this.IsStrict)
            {
              int result = 0;
              int.TryParse(reader.GetAttribute("lim").Replace("%", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.CurrentCulture, out result);
              int num = result * 1000;
              lineFormat.MiterJoinLimit = num.ToString();
              goto case "custDash";
            }
            lineFormat.MiterJoinLimit = reader.GetAttribute("lim");
            goto case "custDash";
          case "round":
            lineFormat.LineJoin = LineJoin.Round;
            goto case "custDash";
          case "headEnd":
            this.ParseHeadEnd(reader, lineFormat);
            goto case "custDash";
          case "tailEnd":
            this.ParseTailEnd(reader, lineFormat);
            goto case "custDash";
          case "custDash":
            if (!flag)
            {
              reader.Read();
              break;
            }
            break;
          case "extLst":
            lineFormat.DocxProps.Add(reader.LocalName, (Stream) this.ReadSingleNodeIntoStream(reader));
            flag = true;
            goto case "custDash";
          case "prstDash":
            string attribute1 = reader.GetAttribute("val");
            if (!string.IsNullOrEmpty(attribute1))
            {
              lineFormat.DashStyle = this.GetDashStyle(attribute1);
              goto case "custDash";
            }
            goto case "custDash";
          case "solidFill":
            lineFormat.LineFormatType = LineFormatType.Solid;
            List<DictionaryEntry> colorEntries1 = new List<DictionaryEntry>();
            empty1 = Color.Empty;
            maxValue1 = uint.MaxValue;
            List<DictionaryEntry> themeFillColor = this.ParseThemeFillColor(reader, reader.LocalName, colorEntries1, ref maxValue1, ref empty1);
            if (themeFillColor != null && themeFillColor.Count > 0)
              lineFormat.LineSchemeColorTransforms = themeFillColor;
            lineFormat.Color = empty1;
            if (maxValue1 != uint.MaxValue)
            {
              lineFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue1 / 65536.0, 2) * 100f;
              goto case "custDash";
            }
            goto case "custDash";
          case "noFill":
            lineFormat.Line = false;
            lineFormat.LineFormatType = LineFormatType.None;
            goto case "custDash";
          case "gradFill":
            lineFormat.Line = true;
            lineFormat.LineFormatType = LineFormatType.Gradient;
            this.ParseFormatSchemeGradientFill(reader, lineFormat.GradientFill);
            goto case "custDash";
          case "pattFill":
            lineFormat.Line = true;
            lineFormat.LineFormatType = LineFormatType.Patterned;
            string attribute2 = reader.GetAttribute("prst");
            if (!string.IsNullOrEmpty(attribute2))
              lineFormat.Pattern = this.GetPatternType(attribute2);
            maxValue1 = uint.MaxValue;
            List<DictionaryEntry> colorEntries2 = new List<DictionaryEntry>();
            maxValue1 = uint.MaxValue;
            uint maxValue2 = uint.MaxValue;
            empty1 = Color.Empty;
            Color empty2 = Color.Empty;
            this.ParseThemePatternFill(reader, "pattFill", colorEntries2, ref empty1, ref empty2, ref maxValue1, ref maxValue2);
            lineFormat.Color = empty1;
            lineFormat.ForeColor = empty2;
            if (maxValue1 != uint.MaxValue)
            {
              lineFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue1 / 65536.0, 2) * 100f;
              goto case "custDash";
            }
            goto case "custDash";
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag = true;
              goto case "custDash";
            }
            goto case "custDash";
        }
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseFontScheme(XmlReader reader)
  {
    if (reader.LocalName != "fontScheme")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    bool flag1 = false;
    while (!(reader.LocalName == "fontScheme") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag2 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "majorFont":
          case "minorFont":
            bool IsMajorFont = reader.LocalName.Equals("majorFont");
            this.ParseFontSchemeInternal(reader, IsMajorFont, reader.LocalName);
            flag1 = false;
            break;
          default:
            flag2 = true;
            break;
        }
        if (flag2)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseFontSchemeInternal(XmlReader reader, bool IsMajorFont, string parentElement)
  {
    if (reader.LocalName != "majorFont" && reader.LocalName != "minorFont")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    reader.Read();
    this.SkipWhitespaces(reader);
    FontSchemeStruct fontSchemeStruct = new FontSchemeStruct();
    string str1 = (string) null;
    string str2 = (string) null;
    string str3 = (string) null;
    string str4 = (string) null;
    string key = (string) null;
    while (!(reader.LocalName == parentElement) || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        fontSchemeStruct.Name = reader.LocalName;
        switch (reader.LocalName)
        {
          case "latin":
          case "ea":
          case "cs":
            if (reader.HasAttributes)
            {
              while (reader.MoveToNextAttribute())
              {
                switch (reader.Name)
                {
                  case "typeface":
                    if (!string.IsNullOrEmpty(reader.Name))
                    {
                      str3 = reader.Value;
                      if (fontSchemeStruct.Name == "latin")
                      {
                        if (IsMajorFont)
                        {
                          this.m_majorFontName = str3;
                          continue;
                        }
                        this.m_minorFontName = str3;
                        continue;
                      }
                      continue;
                    }
                    continue;
                  case "charset":
                    if (!string.IsNullOrEmpty(reader.Name))
                    {
                      str1 = reader.Value;
                      continue;
                    }
                    continue;
                  case "panose":
                    if (!string.IsNullOrEmpty(reader.Name))
                    {
                      str2 = reader.Value;
                      continue;
                    }
                    continue;
                  case "pitchFamily":
                    if (!string.IsNullOrEmpty(reader.Name))
                    {
                      str4 = reader.Value;
                      continue;
                    }
                    continue;
                  default:
                    continue;
                }
              }
              fontSchemeStruct.Typeface = str3;
              fontSchemeStruct.Charset = Convert.ToByte(str1);
              fontSchemeStruct.Panose = str2;
              fontSchemeStruct.PitchFamily = Convert.ToByte(str4);
              if (IsMajorFont)
                this.m_doc.Themes.FontScheme.MajorFontScheme.FontSchemeList.Add(fontSchemeStruct);
              else
                this.m_doc.Themes.FontScheme.MinorFontScheme.FontSchemeList.Add(fontSchemeStruct);
              switch (fontSchemeStruct.Name)
              {
                case "latin":
                  if (IsMajorFont)
                  {
                    this.m_majorLatinFontName = fontSchemeStruct.Typeface;
                    break;
                  }
                  this.m_minorLatinFontName = fontSchemeStruct.Typeface;
                  break;
                case "ea":
                  if (IsMajorFont)
                  {
                    this.m_majorEaFontName = fontSchemeStruct.Typeface;
                    break;
                  }
                  this.m_minorEaFontName = fontSchemeStruct.Typeface;
                  break;
                case "cs":
                  if (IsMajorFont)
                  {
                    this.m_majorCsFontName = fontSchemeStruct.Typeface;
                    break;
                  }
                  this.m_minorCsFontName = fontSchemeStruct.Typeface;
                  break;
              }
            }
            else
              break;
            break;
          case "font":
            if (reader.HasAttributes)
            {
              while (reader.MoveToNextAttribute())
              {
                switch (reader.Name)
                {
                  case "script":
                    key = reader.Value;
                    continue;
                  case "typeface":
                    str3 = reader.Value;
                    continue;
                  default:
                    continue;
                }
              }
              if (IsMajorFont)
              {
                if (!this.m_doc.Themes.FontScheme.MajorFontScheme.FontTypeface.ContainsKey(key))
                {
                  this.m_doc.Themes.FontScheme.MajorFontScheme.FontTypeface.Add(key, str3);
                  break;
                }
                break;
              }
              if (!this.m_doc.Themes.FontScheme.MinorFontScheme.FontTypeface.ContainsKey(key))
              {
                this.m_doc.Themes.FontScheme.MinorFontScheme.FontTypeface.Add(key, str3);
                break;
              }
              break;
            }
            break;
          default:
            flag = true;
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseSchemeColor(XmlReader reader)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (localName != "clrScheme")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    uint maxValue = uint.MaxValue;
    Color empty = Color.Empty;
    while (!(reader.LocalName == "clrScheme") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "dk1":
            Color color1 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("dk1"))
              this.m_doc.Themes.SchemeColor.Add("dk1", color1);
            maxValue = uint.MaxValue;
            break;
          case "lt1":
            Color color2 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("lt1"))
              this.m_doc.Themes.SchemeColor.Add("lt1", color2);
            maxValue = uint.MaxValue;
            break;
          case "dk2":
            Color color3 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("dk2"))
              this.m_doc.Themes.SchemeColor.Add("dk2", color3);
            maxValue = uint.MaxValue;
            break;
          case "lt2":
            Color color4 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("lt2"))
              this.m_doc.Themes.SchemeColor.Add("lt2", color4);
            maxValue = uint.MaxValue;
            break;
          case "accent1":
            Color color5 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("accent1"))
              this.m_doc.Themes.SchemeColor.Add("accent1", color5);
            maxValue = uint.MaxValue;
            break;
          case "accent2":
            Color color6 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("accent2"))
              this.m_doc.Themes.SchemeColor.Add("accent2", color6);
            maxValue = uint.MaxValue;
            break;
          case "accent3":
            Color color7 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("accent3"))
              this.m_doc.Themes.SchemeColor.Add("accent3", color7);
            maxValue = uint.MaxValue;
            break;
          case "accent4":
            Color color8 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("accent4"))
              this.m_doc.Themes.SchemeColor.Add("accent4", color8);
            maxValue = uint.MaxValue;
            break;
          case "accent5":
            Color color9 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("accent5"))
              this.m_doc.Themes.SchemeColor.Add("accent5", color9);
            maxValue = uint.MaxValue;
            break;
          case "accent6":
            Color color10 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("accent6"))
              this.m_doc.Themes.SchemeColor.Add("accent6", color10);
            maxValue = uint.MaxValue;
            break;
          case "hlink":
            Color color11 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("hlink"))
              this.m_doc.Themes.SchemeColor.Add("hlink", color11);
            maxValue = uint.MaxValue;
            break;
          case "folHlink":
            Color color12 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("folHlink"))
              this.m_doc.Themes.SchemeColor.Add("folHlink", color12);
            maxValue = uint.MaxValue;
            break;
          case "phClr":
            Color color13 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (!this.m_doc.Themes.SchemeColor.ContainsKey("phClr"))
              this.m_doc.Themes.SchemeColor.Add("phClr", color13);
            maxValue = uint.MaxValue;
            break;
          default:
            flag = true;
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private string GetBaseFontName(Stream stream, bool isMajor)
  {
    string localName = isMajor ? "majorFont" : "minorFont";
    stream.Position = 0L;
    XmlReader xmlReader = XmlReader.Create(stream);
    xmlReader.ReadToFollowing(localName, "http://schemas.openxmlformats.org/drawingml/2006/main");
    if (xmlReader.EOF)
      return (string) null;
    while (xmlReader.Read())
    {
      if (xmlReader.LocalName == "latin")
      {
        string attribute = xmlReader.GetAttribute("typeface");
        if (!string.IsNullOrEmpty(attribute))
        {
          stream.Position = 0L;
          return attribute;
        }
      }
    }
    return (string) null;
  }

  private void ParseDocumentProperties(Package wordPackage)
  {
    PartContainer partContainer = wordPackage.FindPartContainer("docProps/");
    foreach (string key in partContainer.XmlParts.Keys)
    {
      Stream dataStream = partContainer.XmlParts[key].DataStream;
      switch (key)
      {
        case "app.xml":
          this.m_reader = UtilityMethods.CreateReader(dataStream);
          this.ParseAppProperties(this.m_reader);
          this.m_reader.Close();
          continue;
        case "core.xml":
          this.m_reader = UtilityMethods.CreateReader(dataStream);
          this.ParseCoreProperties(this.m_reader);
          this.m_reader.Close();
          continue;
        case "custom.xml":
          this.m_reader = UtilityMethods.CreateReader(dataStream);
          this.ParseCustomProperties(this.m_reader);
          this.m_reader.Close();
          continue;
        default:
          continue;
      }
    }
  }

  private void ParseVbaProject(Stream stream) => this.m_doc.VbaProject = stream;

  private void ParseVbaProjectSignature(Stream stream) => this.m_doc.VbaProjectSignature = stream;

  private void ParseVbaProjectSignatureAgile(Stream stream)
  {
    this.m_doc.VbaProjectSignatureAgile = stream;
  }

  private void ParseVbaData(Stream stream)
  {
    XmlReader reader = UtilityMethods.CreateReader(stream);
    if (reader == null)
      throw new Exception("reader is null");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "vbaSuppData")
      throw new XmlException("Expected xml tag \"vbaSuppData\"");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "vbaSuppData")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "mcds":
            reader.Read();
            this.ParseMacroData(reader);
            break;
          case "docEvents":
            reader.Read();
            this.ParseDocEvents(reader);
            break;
        }
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseMacroData(XmlReader reader)
  {
    if (reader == null)
      throw new Exception("reader is null");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "mcd")
      throw new XmlException("Expected xml tag \"mcd\"");
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "mcds")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "mcd":
            this.m_doc.VbaData.Add(new MacroData()
            {
              Name = reader.GetAttribute("name", "http://schemas.microsoft.com/office/word/2006/wordml"),
              Encrypt = reader.GetAttribute("bEncrypt", "http://schemas.microsoft.com/office/word/2006/wordml"),
              Cmg = reader.GetAttribute("cmg", "http://schemas.microsoft.com/office/word/2006/wordml")
            });
            break;
        }
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseDocEvents(XmlReader reader)
  {
    if (reader == null)
      throw new Exception("reader is null");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "docEvents")
    {
      if (reader.NodeType == XmlNodeType.Element)
        this.m_doc.DocEvents.Add(reader.LocalName);
      reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseFontTable(Stream stream)
  {
    XmlReader reader = UtilityMethods.CreateReader(stream);
    if (reader == null)
      throw new Exception("reader is null");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "fonts")
      throw new XmlException("Expected xml tag \"fonts\"");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "fonts")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "font":
            string attribute = reader.GetAttribute("name", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            this.ParseFontDetails(reader, attribute);
            break;
        }
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
    this.UpdateFontTable();
  }

  private void ParseFontTable(XmlReader reader)
  {
    if (reader == null)
      throw new Exception("reader is null");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "fonts")
      throw new XmlException("Expected xml tag \"fonts\"");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "fonts")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "defaultFonts":
            this.m_doc.DefCharFormat = new WCharacterFormat((IWordDocument) this.m_doc);
            int i = 0;
            for (int attributeCount = reader.AttributeCount; i < attributeCount; ++i)
            {
              reader.MoveToAttribute(i);
              switch (reader.LocalName)
              {
                case "hint":
                  switch (reader.GetAttribute(i))
                  {
                    case "cs":
                      this.m_doc.DefCharFormat.IdctHint = FontHintType.CS;
                      continue;
                    case "fareast":
                      this.m_doc.DefCharFormat.IdctHint = FontHintType.EastAsia;
                      continue;
                    default:
                      this.m_doc.DefCharFormat.IdctHint = FontHintType.Default;
                      continue;
                  }
                case "ascii":
                  string attribute = reader.GetAttribute(i);
                  this.m_doc.DefCharFormat.FontNameAscii = attribute;
                  this.m_doc.DefCharFormat.FontName = attribute;
                  break;
                case "h-ansi":
                  this.m_doc.DefCharFormat.FontNameNonFarEast = reader.GetAttribute(i);
                  break;
                case "fareast":
                  this.m_doc.DefCharFormat.FontNameFarEast = reader.GetAttribute(i);
                  break;
                case "cs":
                  this.m_doc.DefCharFormat.FontNameBidi = reader.GetAttribute(i);
                  break;
              }
            }
            break;
          case "font":
            string attribute1 = reader.GetAttribute("name", "http://schemas.microsoft.com/office/word/2003/wordml");
            this.Parse2003FontDetails(reader, attribute1);
            break;
        }
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
    this.UpdateFontTable();
  }

  private void UpdateFontTable()
  {
    this.m_doc.FFNStringTable = new FontFamilyNameStringTable();
    this.m_doc.FFNStringTable.RecordsCount = this.m_fontFamilyRecords.Count;
    int index = 0;
    foreach (FontFamilyNameRecord fontFamilyRecord in this.m_fontFamilyRecords)
    {
      this.m_doc.FFNStringTable.FontFamilyNameRecords[index] = fontFamilyRecord;
      ++index;
    }
  }

  private void Parse2003FontDetails(XmlReader reader, string fontName)
  {
    if (reader == null)
      throw new Exception("reader is null");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "font")
      throw new XmlException("Expected xml tag \"font\"");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    FontFamilyNameRecord familyNameRecord = new FontFamilyNameRecord();
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "font")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "altName":
            string attribute1 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (this.m_doc.FontSubstitutionTable.ContainsKey(fontName))
              this.m_doc.FontSubstitutionTable[fontName] = attribute1;
            else if (!string.IsNullOrEmpty(attribute1))
              this.m_doc.FontSubstitutionTable.Add(fontName, attribute1);
            familyNameRecord.AlternativeFontName = attribute1;
            break;
          case "charset":
            string attribute2 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            try
            {
              familyNameRecord.CharacterSetId = Convert.ToByte(attribute2);
              break;
            }
            catch
            {
              familyNameRecord.CharacterSetId = (byte) 1;
              break;
            }
          case "family":
            string attribute3 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute3))
            {
              switch (attribute3.ToLower())
              {
                case "auto":
                  familyNameRecord.FontFamilyID = (byte) 0;
                  break;
                case "roman":
                  familyNameRecord.FontFamilyID = (byte) 1;
                  break;
                case "swiss":
                  familyNameRecord.FontFamilyID = (byte) 2;
                  break;
                case "modern":
                  familyNameRecord.FontFamilyID = (byte) 3;
                  break;
                case "script":
                  familyNameRecord.FontFamilyID = (byte) 4;
                  break;
                case "decorative":
                  familyNameRecord.FontFamilyID = (byte) 5;
                  break;
              }
            }
            else
              break;
            break;
          case "pitch":
            string attribute4 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute4))
            {
              switch (attribute4.ToLower())
              {
                case "default":
                  familyNameRecord.PitchRequest = (byte) 0;
                  break;
                case "fixed":
                  familyNameRecord.PitchRequest = (byte) 1;
                  break;
                case "variable":
                  familyNameRecord.PitchRequest = (byte) 2;
                  break;
              }
            }
            else
              break;
            break;
          case "sig":
            string attribute5 = reader.GetAttribute("usb-0", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute5))
              familyNameRecord.SigUsb0 = this.GetBytes(attribute5);
            string attribute6 = reader.GetAttribute("usb-1", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute6))
              familyNameRecord.SigUsb1 = this.GetBytes(attribute6);
            string attribute7 = reader.GetAttribute("usb-2", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute7))
              familyNameRecord.SigUsb2 = this.GetBytes(attribute7);
            string attribute8 = reader.GetAttribute("usb-3", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute8))
              familyNameRecord.SigUsb3 = this.GetBytes(attribute8);
            string attribute9 = reader.GetAttribute("csb-0", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute9))
              familyNameRecord.SigCsb0 = this.GetBytes(attribute9);
            string attribute10 = reader.GetAttribute("csb-1", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute10))
            {
              familyNameRecord.SigCsb1 = this.GetBytes(attribute10);
              break;
            }
            break;
        }
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
    familyNameRecord.FontName = fontName;
    this.m_fontFamilyRecords.Add(familyNameRecord);
  }

  private void ParseFontDetails(XmlReader reader, string fontName)
  {
    if (reader == null)
      throw new Exception("reader is null");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "font")
      throw new XmlException("Expected xml tag \"font\"");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    FontFamilyNameRecord familyNameRecord = new FontFamilyNameRecord();
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "font")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "altName":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute1))
            {
              if (this.m_doc.FontSubstitutionTable.ContainsKey(fontName))
                this.m_doc.FontSubstitutionTable[fontName] = attribute1;
              else if (!string.IsNullOrEmpty(attribute1))
                this.m_doc.FontSubstitutionTable.Add(fontName, attribute1);
              familyNameRecord.AlternativeFontName = attribute1;
              break;
            }
            break;
          case "charset":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            int result = -1;
            familyNameRecord.CharacterSetId = !int.TryParse(attribute2, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (!int.TryParse(attribute2, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (byte) 1 : Convert.ToByte(result)) : Convert.ToByte(result);
            break;
          case "family":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute3))
            {
              switch (attribute3.ToLower())
              {
                case "auto":
                  familyNameRecord.FontFamilyID = (byte) 0;
                  break;
                case "roman":
                  familyNameRecord.FontFamilyID = (byte) 1;
                  break;
                case "swiss":
                  familyNameRecord.FontFamilyID = (byte) 2;
                  break;
                case "modern":
                  familyNameRecord.FontFamilyID = (byte) 3;
                  break;
                case "script":
                  familyNameRecord.FontFamilyID = (byte) 4;
                  break;
                case "decorative":
                  familyNameRecord.FontFamilyID = (byte) 5;
                  break;
              }
            }
            else
              break;
            break;
          case "pitch":
            string attribute4 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute4))
            {
              switch (attribute4.ToLower())
              {
                case "default":
                  familyNameRecord.PitchRequest = (byte) 0;
                  break;
                case "fixed":
                  familyNameRecord.PitchRequest = (byte) 1;
                  break;
                case "variable":
                  familyNameRecord.PitchRequest = (byte) 2;
                  break;
              }
            }
            else
              break;
            break;
          case "sig":
            string attribute5 = reader.GetAttribute("usb0", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute5))
              familyNameRecord.SigUsb0 = this.GetBytes(attribute5);
            string attribute6 = reader.GetAttribute("usb1", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute6))
              familyNameRecord.SigUsb1 = this.GetBytes(attribute6);
            string attribute7 = reader.GetAttribute("usb2", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute7))
              familyNameRecord.SigUsb2 = this.GetBytes(attribute7);
            string attribute8 = reader.GetAttribute("usb3", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute8))
              familyNameRecord.SigUsb3 = this.GetBytes(attribute8);
            string attribute9 = reader.GetAttribute("csb0", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute9))
              familyNameRecord.SigCsb0 = this.GetBytes(attribute9);
            string attribute10 = reader.GetAttribute("csb1", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute10))
            {
              familyNameRecord.SigCsb1 = this.GetBytes(attribute10);
              break;
            }
            break;
          case "embedRegular":
          case "embedBold":
          case "embedItalic":
          case "embedBoldItalic":
            string attribute11 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            if (!string.IsNullOrEmpty(attribute11))
            {
              string fileName = this.FontTableRelations[attribute11].Value.ToString();
              MemoryStream dataStream = this.m_doc.DocxPackage.FindPart(this.GetPartName(ref fileName) + fileName).DataStream as MemoryStream;
              dataStream.Position = 0L;
              MemoryStream memoryStream = new MemoryStream();
              dataStream.WriteTo((Stream) memoryStream);
              string attribute12 = reader.GetAttribute("fontKey", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
              if (!familyNameRecord.EmbedFonts.ContainsKey(reader.LocalName) && !string.IsNullOrEmpty(attribute12))
              {
                DictionaryEntry dictionaryEntry = new DictionaryEntry((object) attribute12, (object) memoryStream);
                familyNameRecord.EmbedFonts.Add(reader.LocalName, new Dictionary<string, DictionaryEntry>()
                {
                  {
                    this.FontTableRelations[attribute11].Value.ToString(),
                    dictionaryEntry
                  }
                });
                break;
              }
              string attribute13 = reader.GetAttribute("subsetted", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
              if (!familyNameRecord.EmbedFonts.ContainsKey(reader.LocalName) && !string.IsNullOrEmpty(attribute13))
              {
                familyNameRecord.IsSubsetted = true;
                DictionaryEntry dictionaryEntry = new DictionaryEntry((object) attribute13, (object) memoryStream);
                familyNameRecord.EmbedFonts.Add(reader.LocalName, new Dictionary<string, DictionaryEntry>()
                {
                  {
                    this.FontTableRelations[attribute11].Value.ToString(),
                    dictionaryEntry
                  }
                });
                break;
              }
              break;
            }
            break;
        }
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
    familyNameRecord.FontName = fontName;
    this.m_fontFamilyRecords.Add(familyNameRecord);
  }

  private byte[] GetBytes(string signature)
  {
    byte[] bytes = new byte[4];
    if (signature.Length == 8)
    {
      char[] charArray = signature.ToCharArray();
      Array.Reverse((Array) charArray);
      signature = new string(charArray);
      int startIndex = 0;
      for (int index = 0; index < 4; ++index)
      {
        bytes[index] = Convert.ToByte(signature.Substring(startIndex, 2), 16 /*0x10*/);
        startIndex += 2;
      }
    }
    return bytes;
  }

  private void ParseDocument(Stream stream)
  {
    XmlReader reader = UtilityMethods.CreateReader(stream);
    if (reader == null)
      throw new Exception("reader");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "document")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    string attribute1 = reader.GetAttribute("conformance", "http://purl.oclc.org/ooxml/wordprocessingml/main");
    string attribute2 = reader.GetAttribute("xml:space");
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (attribute1 == "strict")
      this.IsStrict = true;
    if (!string.IsNullOrEmpty(attribute2))
      this.PreserveSpace = attribute2 == "preserve";
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "document")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "background":
            this.ParseDocumentBackground(reader);
            flag = true;
            break;
          case "body":
            this.m_doc.AddSection();
            if (this.m_doc.Sections.Count == 1)
              this.m_doc.LastSection.PageSetup.InitializeDocxPageSetup();
            this.ParseBody(reader, (IEntity) null, false, true, false);
            flag = true;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private bool IsContainsDifferentKeys(WTable previousTable, WTable currentTable, int Key)
  {
    if (previousTable.TableFormat.Paddings.HasKey(Key) != currentTable.TableFormat.Paddings.HasKey(Key))
      return true;
    if (previousTable.TableFormat.Paddings.HasKey(Key))
    {
      switch (Key)
      {
        case 1:
          return (double) previousTable.TableFormat.Paddings.Left != (double) currentTable.TableFormat.Paddings.Left;
        case 2:
          return (double) previousTable.TableFormat.Paddings.Top != (double) currentTable.TableFormat.Paddings.Top;
        case 3:
          return (double) previousTable.TableFormat.Paddings.Bottom != (double) currentTable.TableFormat.Paddings.Bottom;
        case 4:
          return (double) previousTable.TableFormat.Paddings.Right != (double) currentTable.TableFormat.Paddings.Right;
      }
    }
    return false;
  }

  private bool IsTableHasSamePadding(WTable previousTable, WTable currentTable)
  {
    return !this.IsContainsDifferentKeys(previousTable, currentTable, 1) && !this.IsContainsDifferentKeys(previousTable, currentTable, 4) && !this.IsContainsDifferentKeys(previousTable, currentTable, 2) && !this.IsContainsDifferentKeys(previousTable, currentTable, 3);
  }

  private void ChangeSamePaddingTableState(WTableCell tableCell)
  {
    if (!tableCell.CellFormat.SamePaddingsAsTable)
      return;
    tableCell.CellFormat.SamePaddingsAsTable = false;
  }

  private void SetPaddingValue(WTableRow row)
  {
    for (int index = 0; index < row.Cells.Count; ++index)
    {
      WTableCell cell = row.Cells[index];
      if (!cell.CellFormat.Paddings.HasKey(1) && !row.RowFormat.Paddings.HasKey(1))
      {
        this.ChangeSamePaddingTableState(cell);
        cell.CellFormat.Paddings.Left = cell.GetLeftPadding();
      }
      if (!cell.CellFormat.Paddings.HasKey(4) && !row.RowFormat.Paddings.HasKey(4))
      {
        this.ChangeSamePaddingTableState(cell);
        cell.CellFormat.Paddings.Right = cell.GetRightPadding();
      }
      if (!cell.CellFormat.Paddings.HasKey(2) && !row.RowFormat.Paddings.HasKey(2))
      {
        this.ChangeSamePaddingTableState(cell);
        cell.CellFormat.Paddings.Top = cell.GetTopPadding();
      }
      if (!cell.CellFormat.Paddings.HasKey(3) && !row.RowFormat.Paddings.HasKey(3))
      {
        this.ChangeSamePaddingTableState(cell);
        cell.CellFormat.Paddings.Bottom = cell.GetBottomPadding();
      }
    }
  }

  private void MergeTables(WTable currentTable)
  {
    WTable previousSibling = currentTable.PreviousSibling as WTable;
    if (previousSibling.Title == null)
      previousSibling.Title = currentTable.Title;
    if (previousSibling.Description == null)
      previousSibling.Description = currentTable.Description;
    bool flag1 = !previousSibling.LastRow.IsHeader;
    bool flag2 = this.IsTableHasSamePadding(previousSibling, currentTable);
    while (currentTable.Rows.Count > 0)
    {
      WTableRow row = currentTable.Rows[0];
      if (!flag2)
        this.SetPaddingValue(row);
      previousSibling.Rows.Add(row);
      previousSibling.LastRow.HasTblPrEx = true;
      if (flag1 && previousSibling.LastRow.IsHeader)
        previousSibling.LastRow.IsHeader = false;
    }
    currentTable.OwnerTextBody.ChildEntities.Remove((IEntity) currentTable);
    previousSibling.UpdateTableGrid(false, true);
    previousSibling.UpdateGridSpan();
  }

  private bool IsNeedToMergeTables(WTable table)
  {
    if (!(table.PreviousSibling is WTable))
      return false;
    WTable previousSibling = table.PreviousSibling as WTable;
    return !table.TableFormat.WrapTextAround && !previousSibling.TableFormat.WrapTextAround && !table.IsFrame && !previousSibling.IsFrame && (previousSibling.TableGrid.Count == table.TableGrid.Count || this.IsRowHeaderEnabled(previousSibling)) && table.StyleName == previousSibling.StyleName;
  }

  private bool IsRowHeaderEnabled(WTable prevTable)
  {
    for (int index = 0; index < prevTable.ChildEntities.Count; ++index)
    {
      if ((prevTable.ChildEntities[index] as WTableRow).IsHeader)
        return true;
    }
    return false;
  }

  private void ParseBody(
    XmlReader reader,
    IEntity entity,
    bool isRunElementTextBody,
    bool isFromDocument,
    bool isMappedPictureContentControl)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    string localName1 = reader.LocalName;
    if (!reader.IsEmptyElement)
    {
      string localName2 = reader.LocalName;
      reader.Read();
      if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return;
      bool flag = false;
      this.SkipWhitespaces(reader);
      while ((!isFromDocument ? (reader.LocalName != localName1 ? 1 : 0) : (reader.LocalName == "document" || reader.LocalName == "background" ? 0 : 1)) != 0)
      {
        if (reader.NodeType == XmlNodeType.Element)
        {
          switch (reader.LocalName)
          {
            case "pPr":
              IWParagraph wparagraph1 = this.m_doc.LastSection.AddParagraph();
              this.ParseParagraphFormat(reader, wparagraph1.ParagraphFormat);
              this.IsNeedToApplyParaFormat = true;
              break;
            case "p":
              if (isRunElementTextBody)
              {
                IWParagraph lastParagraph = (IWParagraph) this.m_doc.LastParagraph;
                (lastParagraph as WParagraph).ParaId = reader.GetAttribute("paraId", "http://schemas.microsoft.com/office/word/2010/wordml");
                this.InsertPostBreakElements(lastParagraph);
                this.ParseParagraphItems(reader, lastParagraph.Items, (string) null, (IOfficeMathRunElement) null, isMappedPictureContentControl);
                this.m_doc.UpdateLastItemRevision(lastParagraph, lastParagraph.Items);
                if (!string.IsNullOrEmpty(lastParagraph.StyleName))
                  (lastParagraph as WParagraph).ApplyStyle(lastParagraph.StyleName, false);
                isRunElementTextBody = false;
                break;
              }
              if (this.IsNeedToApplyParaFormat)
              {
                IWParagraph paragraph;
                if (this.m_doc.LastParagraph == null)
                {
                  WSection previousSibling = this.m_doc.LastSection.PreviousSibling as WSection;
                  int index = previousSibling.Paragraphs.Count - 1;
                  paragraph = (IWParagraph) previousSibling.Paragraphs[index];
                }
                else
                  paragraph = (IWParagraph) this.m_doc.LastParagraph;
                this.ParseParagraphItems(reader, paragraph.Items, (string) null, (IOfficeMathRunElement) null, isMappedPictureContentControl);
                this.m_doc.UpdateLastItemRevision(paragraph, paragraph.Items);
                this.IsNeedToApplyParaFormat = false;
                break;
              }
              IWParagraph paragraph1 = this.AddParagraph(entity);
              (paragraph1 as WParagraph).ParaId = reader.GetAttribute("paraId", "http://schemas.microsoft.com/office/word/2010/wordml");
              this.AddPostElements(paragraph1);
              this.InsertPostBreakElements(paragraph1);
              this.ParseParagraphItems(reader, paragraph1.Items, (string) null, (IOfficeMathRunElement) null, isMappedPictureContentControl);
              this.m_doc.UpdateLastItemRevision(paragraph1, paragraph1.Items);
              if (paragraph1.NextSibling != null && !(paragraph1.NextSibling is AlternateChunk))
                this.UpdateNestedParaItems(paragraph1 as WParagraph);
              if (!string.IsNullOrEmpty(paragraph1.StyleName))
              {
                (paragraph1 as WParagraph).ApplyStyle(paragraph1.StyleName, false);
                break;
              }
              break;
            case "tbl":
              if (this.IsNeedToApplyParaFormat && this.m_doc.LastSection.ChildEntities.Count == 0)
                this.m_doc.LastSection.RemoveSelf();
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 11);
              IWTable wtable = this.AddTable(entity);
              wtable.TableFormat.IsAutoResized = true;
              short gridCount = this.m_gridCount;
              this.ParseTable(reader, wtable as WTable, false, reader.LocalName);
              this.m_gridCount = gridCount;
              if (wtable.Rows.Count == 0)
                (wtable.Owner as WTextBody).ChildEntities.RemoveAt((wtable as WTable).Index);
              if (this.IsNeedToMergeTables(wtable as WTable))
              {
                this.MergeTables(wtable as WTable);
                break;
              }
              break;
            case "sectPr":
              if (this.BreakCollection.Count > 0)
                this.InsertPostBreakElements(this.AddParagraph(entity));
              if (this.m_doc.LastParagraph != null)
                this.AddPostElements((IWParagraph) this.m_doc.LastParagraph);
              if (this.IsNeedToApplyParaFormat)
              {
                if (this.m_doc.LastParagraph != null)
                {
                  this.m_doc.LastParagraph.RemoveSelf();
                }
                else
                {
                  WSection previousSibling = this.m_doc.LastSection.PreviousSibling as WSection;
                  int index = previousSibling.Paragraphs.Count - 1;
                  previousSibling.Paragraphs[index].RemoveSelf();
                  this.m_doc.LastSection.RemoveSelf();
                }
                this.IsNeedToApplyParaFormat = false;
              }
              this.ParseSectionProperties(reader, (IEntity) this.m_doc.LastSection);
              break;
            case "bookmarkStart":
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 5);
              this.ParseBookmarkStart(reader, (ParagraphItemCollection) null);
              break;
            case "bookmarkEnd":
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 4);
              this.ParseBookmarkEnd(reader, entity);
              break;
            case "permStart":
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 21);
              this.ParseEditableRangeStart(reader, (ParagraphItemCollection) null);
              break;
            case "permEnd":
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 22);
              this.ParseEditableRangeEnd(reader, entity);
              break;
            case "comment":
              this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 6);
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 10);
              this.ParseComment(reader);
              break;
            case "commentRangeStart":
              this.ParseCommentRangeStart(reader, (ParagraphItemCollection) null);
              break;
            case "commentRangeEnd":
              this.ParseCommentRangeEnd(reader, (ParagraphItemCollection) null, (IEntity) null);
              break;
            case "moveToRangeEnd":
            case "moveFromRangeEnd":
              this.ParseMoveRangeEnd(reader, entity);
              this.moveRevision = (Revision) null;
              break;
            case "sdt":
              if (this.BreakCollection.Count > 0)
                this.InsertPostBreakElements(this.AddParagraph(entity));
              if (this.IsNeedToApplyParaFormat)
              {
                if (this.m_doc.LastParagraph != null)
                {
                  this.m_doc.LastParagraph.RemoveSelf();
                }
                else
                {
                  WSection previousSibling = this.m_doc.LastSection.PreviousSibling as WSection;
                  int index = previousSibling.Paragraphs.Count - 1;
                  previousSibling.Paragraphs[index].RemoveSelf();
                  this.m_doc.LastSection.RemoveSelf();
                }
                this.IsNeedToApplyParaFormat = false;
              }
              IBlockContentControl blockContentControl = this.AddStructureDocumentTagBlock(entity);
              this.ParseStructureDocumentTagBlock(reader, blockContentControl as BlockContentControl);
              if (blockContentControl.Owner != null && blockContentControl.Owner.Owner != null && blockContentControl.Owner.Owner is WSection && this.IsSDTHasSectionBreak)
              {
                this.SDTContentWithSectionBreakParagraph(blockContentControl as BlockContentControl);
                this.IsSDTHasSectionBreak = false;
                break;
              }
              break;
            case "altChunk":
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 2);
              AlternateChunk alternateChunk = this.AddAlternateChunk(entity);
              this.AddBookmark(alternateChunk);
              this.ParseAlternateChunk(reader, alternateChunk);
              break;
            case "br":
              WParagraph wparagraph2 = new WParagraph((IWordDocument) this.m_doc);
              this.ParseBreak(reader, wparagraph2.Items, (IOfficeMathRunElement) null);
              if (wparagraph2.ChildEntities.Count > 0)
              {
                this.BreakCollection.Add((Entity) wparagraph2.LastItem);
                break;
              }
              break;
            default:
              if (this.IsWord2003ML && reader.LocalName == "annotation")
              {
                switch (reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml"))
                {
                  case "Word.Bookmark.Start":
                    this.ParseBookmarkStart(reader, (ParagraphItemCollection) null);
                    break;
                  case "Word.Bookmark.End":
                    this.ParseBookmarkEnd(reader, entity);
                    break;
                  case "Word.Comment.Start":
                    this.ParseCommentRangeStart(reader, (ParagraphItemCollection) null);
                    break;
                  case "Word.Comment.End":
                    this.ParseCommentRangeEnd(reader, (ParagraphItemCollection) null, (IEntity) null);
                    break;
                }
              }
              else
                break;
              break;
          }
          if (!flag)
            reader.Read();
        }
        else
          reader.Read();
      }
    }
    else
      reader.Read();
  }

  private void UpdateNestedParaItems(WParagraph paragraph)
  {
    WParagraph nextSibling = paragraph.NextSibling as WParagraph;
    for (int index = 0; index < paragraph.ChildEntities.Count; ++index)
    {
      Entity entity = paragraph.ChildEntities[index].Clone();
      switch (entity)
      {
        case BookmarkStart _:
        case BookmarkEnd _:
          paragraph.ChildEntities.Remove((IEntity) entity);
          break;
      }
      nextSibling.ChildEntities.Insert(index, (IEntity) entity);
    }
    paragraph.ChildEntities.Clear();
    nextSibling.OwnerTextBody.ChildEntities.Add((IEntity) paragraph);
    paragraph.ParagraphFormat.NestedParaFormatting(nextSibling.ParagraphFormat);
    if (nextSibling.ListFormat.CurrentListLevel != null || paragraph.ListFormat.CurrentListLevel == null)
      return;
    nextSibling.ListFormat.ImportListFormat(paragraph.ListFormat);
  }

  internal void SDTContentWithSectionBreakParagraph(BlockContentControl sdttagblock)
  {
    WTextBody textBody = sdttagblock.TextBody;
    int count = textBody.ChildEntities.Count;
    for (int index1 = 0; index1 < textBody.ChildEntities.Count; ++index1)
    {
      if (textBody.ChildEntities[index1] is WParagraph && (textBody.ChildEntities[index1] as WParagraph).ParagraphFormat.XmlProps.ContainsKey("sectPr"))
      {
        WParagraph childEntity = textBody.ChildEntities[index1] as WParagraph;
        XmlReader reader = UtilityMethods.CreateReader(childEntity.ParagraphFormat.XmlProps["sectPr"]);
        reader.MoveToElement();
        this.ParseSectionProperties(reader, (IEntity) this.m_doc.LastSection);
        this.m_doc.AddSection();
        childEntity.ParagraphFormat.XmlProps.Remove("sectPr");
        BlockContentControl blockContentControl = sdttagblock.Clone();
        blockContentControl.TextBody.ChildEntities.Clear();
        this.m_doc.LastSection.Body.ChildEntities.Add((IEntity) blockContentControl);
        int index2 = index1 + 1;
        while (index2 < textBody.ChildEntities.Count)
        {
          if (textBody.ChildEntities[index2] is WParagraph && (textBody.ChildEntities[index2] as WParagraph).ParagraphFormat.XmlProps.ContainsKey("sectPr"))
          {
            blockContentControl.TextBody.AddParagraph();
            int index3 = 0;
            while (index3 < (textBody.ChildEntities[index2] as WParagraph).ChildEntities.Count)
              blockContentControl.TextBody.LastParagraph.ChildEntities.Add((IEntity) (textBody.ChildEntities[index2] as WParagraph).ChildEntities[index3]);
            break;
          }
          blockContentControl.TextBody.ChildEntities.Add((IEntity) textBody.ChildEntities[index2]);
        }
      }
    }
  }

  private IWParagraph AddParagraph(IEntity entity)
  {
    IWParagraph wparagraph;
    switch (entity)
    {
      case HeaderFooter _:
        wparagraph = (entity as HeaderFooter).AddParagraph();
        break;
      case WFootnote _:
        wparagraph = (entity as WFootnote).TextBody.AddParagraph();
        break;
      case WComment _:
        wparagraph = (entity as WComment).TextBody.AddParagraph();
        break;
      case BlockContentControl _:
        wparagraph = (entity as BlockContentControl).TextBody.AddParagraph();
        break;
      case WTextBody _:
        wparagraph = (entity as WTextBody).AddParagraph();
        break;
      default:
        wparagraph = this.m_doc.LastSection.AddParagraph();
        break;
    }
    return wparagraph;
  }

  private void AddPostElements(IWParagraph paragraph)
  {
    if (this.BookMarkCollection.Count > 0)
    {
      foreach (Entity bookMark in this.BookMarkCollection)
        paragraph.Items.Add((IEntity) bookMark);
      this.BookMarkCollection.Clear();
    }
    if (this.EditableRangeCollection.Count > 0)
    {
      foreach (Entity editableRange in this.EditableRangeCollection)
        paragraph.Items.Add((IEntity) editableRange);
      this.EditableRangeCollection.Clear();
    }
    if (this.m_postCommMark == null)
      return;
    paragraph.Items.Add((IEntity) this.m_postCommMark);
    this.m_postCommMark = (WCommentMark) null;
  }

  private void InsertPostBreakElements(IWParagraph paragraph)
  {
    if (this.BreakCollection.Count <= 0)
      return;
    foreach (Entity entity in this.BreakCollection)
      paragraph.Items.Insert(0, (IEntity) entity);
    this.BreakCollection.Clear();
  }

  private void AddBookmark(AlternateChunk altchunk)
  {
    if (this.BookMarkCollection.Count <= 0)
      return;
    foreach (Entity bookMark in this.BookMarkCollection)
      altchunk.AltChunkBookmarks.Add(bookMark);
    this.BookMarkCollection.Clear();
  }

  private void ParseParagraphItems(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    string endnode,
    IOfficeMathRunElement mathRunElement,
    bool isMappedPictureContentControl)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    if (endnode == null)
    {
      endnode = reader.LocalName;
      reader.Read();
    }
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    MemoryStream drawingStream = (MemoryStream) null;
    this.SkipWhitespaces(reader);
    bool isFirstNestedParaOccured = false;
    while (reader.LocalName != endnode || (reader.LocalName == "p" || reader.LocalName == "ins" || reader.LocalName == "del") && reader.NodeType == XmlNodeType.Element)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "pPr":
            WParagraph wparagraph1 = paraItems.OwnerBase as WParagraph;
            if (paraItems.Owner is InlineContentControl)
              wparagraph1 = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
            else if (paraItems.Owner is XmlParagraphItem)
              wparagraph1 = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
            else if (paraItems.Owner is XmlParagraphItem)
              wparagraph1 = paraItems.Owner.Owner as WParagraph;
            if (wparagraph1 != null && !(paraItems.OwnerBase is InlineContentControl))
            {
              this.ParseParagraphFormat(reader, wparagraph1.ParagraphFormat);
              if ((wparagraph1.StyleName == null || wparagraph1.StyleName == string.Empty) && this.m_doc.Styles.FindByName("Normal") != null)
              {
                wparagraph1.ApplyStyle("Normal", false);
                break;
              }
              break;
            }
            break;
          case "bdo":
            switch (reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
            {
              case "rtl":
                this.m_biDirectionalOverride = BiDirectionalOverride.RTL;
                break;
              case "ltr":
                this.m_biDirectionalOverride = BiDirectionalOverride.LTR;
                break;
            }
            break;
          case "p":
            this.ParseNestedParagraph(reader, paraItems, isFirstNestedParaOccured);
            isFirstNestedParaOccured = true;
            break;
          case "r":
            this.ParseRun(reader, paraItems, (IOfficeMathRunElement) null, false, reader.NodeType, isMappedPictureContentControl);
            this.m_currentRunFormat = (WCharacterFormat) null;
            break;
          case "br":
          case "cr":
            if (isFirstNestedParaOccured)
            {
              WParagraph wparagraph2 = paraItems.OwnerBase as WParagraph;
              if (paraItems.Owner is InlineContentControl)
                wparagraph2 = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
              else if (paraItems.Owner is XmlParagraphItem)
                wparagraph2 = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
              paraItems = (wparagraph2.OwnerTextBody.AddParagraph() as WParagraph).Items;
            }
            this.ParseBreak(reader, paraItems, mathRunElement);
            break;
          case "bookmarkStart":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 5);
            this.ParseBookmarkStart(reader, paraItems);
            break;
          case "bookmarkEnd":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 4);
            this.ParseBookmarkEnd(reader, paraItems);
            break;
          case "permStart":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 21);
            this.ParseEditableRangeStart(reader, paraItems);
            break;
          case "permEnd":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 22);
            this.ParseEditableRangeEnd(reader, paraItems);
            break;
          case "commentRangeStart":
            this.ParseCommentRangeStart(reader, paraItems);
            break;
          case "commentRangeEnd":
            this.ParseCommentRangeEnd(reader, paraItems, (IEntity) null);
            break;
          case "del":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 12);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            this.UpdateInsDelRevision(reader, paraItems, RevisionType.Deletions, mathRunElement, false);
            break;
          case "moveFromRangeStart":
            this.UpdateRevAuthorInformation(reader, (WCharacterFormat) null);
            this.CreateMoveRangeRevision(paraItems.Owner as WParagraph, RevisionType.MoveFrom);
            break;
          case "moveFrom":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 26);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            this.UpdateRevAuthorInformation(reader, (WCharacterFormat) null);
            this.m_trackChangeType = this.moveRevision == null ? RevisionType.Deletions : RevisionType.MoveFrom;
            this.m_trackchangeStack.Push(this.m_trackChangeType);
            this.ParseParagraphItems(reader, paraItems, (string) null, mathRunElement, isMappedPictureContentControl);
            this.m_trackChangeType = RevisionType.None;
            int num = (int) this.m_trackchangeStack.Pop();
            if (this.m_trackchangeStack.Count > 0)
            {
              this.m_trackChangeType = this.m_trackchangeStack.Peek();
              break;
            }
            break;
          case "moveToRangeStart":
            this.UpdateRevAuthorInformation(reader, (WCharacterFormat) null);
            this.CreateMoveRangeRevision(paraItems.Owner as WParagraph, RevisionType.MoveTo);
            break;
          case "moveTo":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 27);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            this.UpdateRevAuthorInformation(reader, (WCharacterFormat) null);
            this.m_trackChangeType = this.moveRevision == null ? RevisionType.Insertions : RevisionType.MoveTo;
            this.ParseParagraphItems(reader, paraItems, (string) null, mathRunElement, isMappedPictureContentControl);
            this.m_trackChangeType = RevisionType.None;
            break;
          case "moveFromRangeEnd":
          case "moveToRangeEnd":
            this.moveRevision = (Revision) null;
            break;
          case "ins":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 24);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            this.UpdateInsDelRevision(reader, paraItems, RevisionType.Insertions, mathRunElement, false);
            break;
          case "customXmlInsRangeStart":
            this.UpdateRevAuthorInformation(reader, (WCharacterFormat) null);
            this.ContentControlRevision(paraItems, RevisionType.Insertions);
            break;
          case "customXmlDelRangeStart":
            this.UpdateRevAuthorInformation(reader, (WCharacterFormat) null);
            this.ContentControlRevision(paraItems, RevisionType.Deletions);
            break;
          case "hyperlink":
            if (!this.IsWord2003ML)
            {
              this.ParseHyperlink(reader, paraItems);
              break;
            }
            break;
          case "fldSimple":
            flag = this.ParseFieldSimple(reader, paraItems);
            break;
          case "drawing":
            ParagraphItem drawing = this.ParseDrawing(reader, paraItems, ref drawingStream, isMappedPictureContentControl);
            paraItems.Add((IEntity) drawing);
            this.m_currentRunFormat = (WCharacterFormat) null;
            flag = true;
            break;
          case "sdt":
            IInlineContentControl sdTagInline = (IInlineContentControl) new InlineContentControl(this.m_doc);
            this.AddItem(sdTagInline as ParagraphItem, paraItems);
            if (paraItems.OwnerBase is WParagraph)
              (paraItems.OwnerBase as WParagraph).HasSDTInlineItem = true;
            this.ParseStructureDocumentTagInline(reader, sdTagInline as InlineContentControl);
            break;
          case "altChunk":
            AlternateChunk alternateChunk = this.AddAlternateChunk((IEntity) null);
            this.AddBookmark(alternateChunk);
            this.ParseAlternateChunk(reader, alternateChunk);
            alternateChunk.IsParagraphItem = true;
            break;
          case "oMath":
          case "oMathPara":
            this.ParseMathMlElement(reader, paraItems);
            flag = true;
            break;
          case "pict":
            MemoryStream shapeStream = this.ReadSingleNodeIntoStream(reader);
            ParagraphItem shape = this.ParseShape(reader, paraItems, drawingStream, shapeStream);
            if (shape is Shape && (shape as Shape).TextBody.Count > 0)
            {
              this.AddToParagraph(shape, paraItems);
              this.CheckTrackChange(shape);
            }
            if (reader.LocalName == "p" && reader.NodeType == XmlNodeType.EndElement)
            {
              flag = true;
              break;
            }
            break;
          default:
            string namespaceUri = reader.NamespaceURI;
            if (!string.IsNullOrEmpty(namespaceUri) && namespaceUri == (this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/math" : "http://schemas.openxmlformats.org/officeDocument/2006/math"))
              this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 19);
            if (this.IsWord2003ML)
            {
              if (reader.LocalName == "annotation")
              {
                switch (reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml"))
                {
                  case "Word.Bookmark.Start":
                    this.ParseBookmarkStart(reader, paraItems);
                    break;
                  case "Word.Bookmark.End":
                    this.ParseBookmarkEnd(reader, paraItems);
                    break;
                  case "Word.Comment.Start":
                    this.ParseCommentRangeStart(reader, paraItems);
                    break;
                  case "Word.Comment.End":
                    this.ParseCommentRangeEnd(reader, paraItems, (IEntity) null);
                    break;
                  case "Word.Insertion":
                    this.m_trackChangeType = RevisionType.Insertions;
                    this.ParseParagraphItems(reader, paraItems, (string) null, mathRunElement, isMappedPictureContentControl);
                    this.m_trackChangeType = RevisionType.None;
                    break;
                  case "Word.Deletion":
                    this.m_trackChangeType = RevisionType.Deletions;
                    this.ParseParagraphItems(reader, paraItems, (string) null, mathRunElement, isMappedPictureContentControl);
                    this.m_trackChangeType = RevisionType.None;
                    break;
                }
              }
              else
              {
                if (reader.LocalName == "hlink")
                {
                  this.ParseHyperlink(reader, paraItems);
                  break;
                }
                break;
              }
            }
            else
              break;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else if (reader.LocalName == "bdo" && reader.NodeType == XmlNodeType.EndElement)
      {
        this.m_biDirectionalOverride = BiDirectionalOverride.None;
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseNestedParagraph(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    bool isFirstNestedParaOccured)
  {
    WParagraph paragraph1 = paraItems.OwnerBase as WParagraph;
    if (paraItems.Owner is InlineContentControl)
      paragraph1 = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
    else if (paraItems.Owner is XmlParagraphItem)
      paragraph1 = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
    else if (paraItems.Owner is XmlParagraphItem)
      paragraph1 = paraItems.Owner.Owner as WParagraph;
    if (paragraph1 == null || paragraph1.OwnerTextBody == null)
      return;
    if (paraItems.Owner is InlineContentControl && paragraph1.Owner is WTableCell && !isFirstNestedParaOccured)
    {
      this.ParseParagraphItems(reader, (paraItems.Owner as InlineContentControl).ParagraphItems, (string) null, (IOfficeMathRunElement) null, false);
      this.m_doc.UpdateLastItemRevision((IWParagraph) paragraph1, paragraph1.Items);
    }
    else
    {
      IWParagraph paragraph2 = paragraph1.ChildEntities.Count != 1 || !(paragraph1.ChildEntities[0] is Break) || !isFirstNestedParaOccured ? paragraph1.OwnerTextBody.AddParagraph() : (IWParagraph) paragraph1;
      this.ParseParagraphItems(reader, paragraph2.Items, (string) null, (IOfficeMathRunElement) null, false);
      this.m_doc.UpdateLastItemRevision(paragraph2, paragraph2.Items);
      if (paragraph2.NextSibling == null)
        return;
      WParagraph nextSibling = paragraph2.NextSibling as WParagraph;
      for (int index = 0; index < paragraph2.ChildEntities.Count; ++index)
        nextSibling.ChildEntities.Insert(index, (IEntity) paragraph2.ChildEntities[index].Clone());
      paragraph2.ChildEntities.Clear();
      nextSibling.OwnerTextBody.ChildEntities.Add((IEntity) paragraph2);
      paragraph1.ParagraphFormat.NestedParaFormatting(paragraph2.ParagraphFormat);
      if (paragraph2.ListFormat.CurrentListLevel == null && paragraph1.ListFormat.CurrentListLevel != null)
        paragraph2.ListFormat.ImportListFormat(paragraph1.ListFormat);
      paragraph2.ParagraphFormat.NestedParaFormatting(nextSibling.ParagraphFormat);
      if (nextSibling.ListFormat.CurrentListLevel != null || paragraph2.ListFormat.CurrentListLevel == null)
        return;
      nextSibling.ListFormat.ImportListFormat(paragraph2.ListFormat);
    }
  }

  private void ApplyDirectionalOverride(WCharacterFormat charFormat)
  {
    if (this.m_biDirectionalOverride == BiDirectionalOverride.None)
      return;
    charFormat.BiDirectionalOverride = this.m_biDirectionalOverride;
  }

  private void ContentControlRevision(ParagraphItemCollection paraItems, RevisionType revisionType)
  {
    if (paraItems.Count == 0)
      return;
    if (this.m_doc.HasRenderableItemBefore(paraItems.LastItem as ParagraphItem) && this.contentRevision == null)
    {
      Entity previousSibling = paraItems.Owner.PreviousSibling as Entity;
      switch (previousSibling)
      {
        case WParagraph _ when (paraItems.Owner.PreviousSibling as WParagraph).BreakCharacterFormat.Revisions.Count > 0:
          using (List<Revision>.Enumerator enumerator = (paraItems.Owner.PreviousSibling as WParagraph).BreakCharacterFormat.Revisions.GetEnumerator())
          {
            while (enumerator.MoveNext())
            {
              Revision current = enumerator.Current;
              if (current.RevisionType == revisionType && current.Author == this.m_revAuthorName)
              {
                this.contentRevision = current;
                break;
              }
            }
            break;
          }
        case WTable _ when (previousSibling as WTable).LastRow.RowFormat.Revisions.Count > 0:
          using (List<Revision>.Enumerator enumerator = (previousSibling as WTable).LastRow.RowFormat.Revisions.GetEnumerator())
          {
            while (enumerator.MoveNext())
            {
              Revision current = enumerator.Current;
              if (current.RevisionType == revisionType && current.Author == this.m_revAuthorName)
              {
                this.contentRevision = current;
                break;
              }
            }
            break;
          }
        default:
          this.contentRevision = this.m_doc.CreateNewChildRevision(revisionType, this.m_revAuthorName, this.m_revDateTime, this.m_name);
          break;
      }
    }
    else
    {
      Entity entity = paraItems.LastItem;
label_19:
      entity = entity is InlineContentControl ? (entity as InlineContentControl).ParagraphItems.LastItem : entity;
      while (true)
      {
        switch (entity)
        {
          case BookmarkStart _:
          case BookmarkEnd _:
          case EditableRangeStart _:
          case EditableRangeEnd _:
            entity = entity.PreviousSibling as Entity;
            continue;
          case InlineContentControl _:
            goto label_19;
          case null:
            goto label_1;
          default:
            goto label_22;
        }
      }
label_1:
      return;
label_22:
      if (entity.RevisionsInternal.Count <= 0)
        return;
      foreach (Revision revision in entity.RevisionsInternal)
      {
        if (revision.RevisionType == revisionType && revision.Author == this.m_revAuthorName)
        {
          this.contentRevision = revision;
          break;
        }
      }
    }
  }

  private void ParseComment(XmlReader reader)
  {
    if (this.m_comments == null)
      this.m_comments = new Dictionary<string, WComment>();
    WComment wcomment = new WComment((IWordDocument) this.m_doc);
    string attribute1 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    wcomment.Format.TagBkmk = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    string attribute2 = reader.GetAttribute("author", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute2))
      wcomment.Format.User = attribute2;
    string attribute3 = reader.GetAttribute("initials", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute3))
      wcomment.Format.UserInitials = attribute3;
    string attribute4 = reader.GetAttribute("date", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute4))
    {
      DateTime result = new DateTime();
      DateTime.TryParse(attribute4, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result);
      wcomment.Format.DateTime = result;
    }
    this.m_comments.Add(attribute1, wcomment);
    if (reader.IsEmptyElement)
      return;
    this.ParseBody(reader, (IEntity) wcomment, false, false, false);
  }

  private WComment Parse2003Comment(XmlReader reader)
  {
    if (this.m_comments == null)
      this.m_comments = new Dictionary<string, WComment>();
    WComment wcomment = new WComment((IWordDocument) this.m_doc);
    string attribute1 = reader.GetAttribute("id", "http://schemas.microsoft.com/aml/2001/core");
    wcomment.Format.TagBkmk = reader.GetAttribute("id", "http://schemas.microsoft.com/aml/2001/core");
    string attribute2 = reader.GetAttribute("author", "http://schemas.microsoft.com/aml/2001/core");
    if (!string.IsNullOrEmpty(attribute2))
      wcomment.Format.User = attribute2;
    string attribute3 = reader.GetAttribute("createdate", "http://schemas.microsoft.com/aml/2001/core");
    if (!string.IsNullOrEmpty(attribute3))
    {
      DateTime result = new DateTime();
      DateTime.TryParse(attribute3, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result);
      wcomment.Format.DateTime = result;
    }
    string attribute4 = reader.GetAttribute("initials", "http://schemas.microsoft.com/office/word/2003/wordml");
    if (!string.IsNullOrEmpty(attribute4))
      wcomment.Format.UserInitials = attribute4;
    this.m_comments.Add(attribute1, wcomment);
    this.ParseBody(reader, (IEntity) wcomment, false, false, false);
    return wcomment;
  }

  private void ParseComments()
  {
    Part part = this.FindPart("word/", "comments.xml");
    if (part == null || part.DataStream == null || part.DataStream.Length == 0L)
      return;
    part.DataStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(part.DataStream);
    this.m_currentFile = "comments.xml";
    this.IsInComments = true;
    this.ParseBody(reader, (IEntity) null, false, false, false);
    this.m_currentFile = string.Empty;
    this.IsInComments = false;
  }

  private void ParseCommentRangeStart(XmlReader reader, ParagraphItemCollection paraItems)
  {
    string attribute = reader.GetAttribute("id", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
    WCommentMark wcommentMark = new WCommentMark(this.m_doc, attribute);
    if (paraItems != null && paraItems.OwnerBase != null)
      paraItems.Add((IEntity) wcommentMark);
    else
      this.m_postCommMark = wcommentMark;
    bool flag = this.m_comments == null;
    if (!this.IsWord2003ML && this.Comments != null && attribute != null && this.Comments.ContainsKey(attribute))
      this.CommentsStack.Push(this.Comments[attribute]);
    if (paraItems == null && flag)
      this.m_postCommMark = wcommentMark;
    if (this.Comments == null || !this.Comments.ContainsKey(attribute))
      return;
    wcommentMark.Comment = this.Comments[attribute];
    this.Comments[attribute].CommentRangeStart = wcommentMark;
  }

  private void ParseCommentRangeEnd(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    IEntity ent)
  {
    string attribute = reader.GetAttribute("id", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
    WCommentMark wcommentMark = new WCommentMark(this.m_doc, attribute, CommentMarkType.CommentEnd);
    if (paraItems != null && paraItems.OwnerBase != null)
      paraItems.Add((IEntity) wcommentMark);
    else if (ent == null)
    {
      this.m_postCommMark = wcommentMark;
    }
    else
    {
      WTable ownerTable = this.GetOwnerTable(ent);
      bool isAfterTable = ownerTable != null && ownerTable.LastRow != null;
      WParagraph wparagraph = this.GetOwnerParagraph(ent, isAfterTable);
      if (isAfterTable)
        wparagraph = this.GetEndParagraph(ownerTable.LastRow);
      if (wparagraph != null)
      {
        wparagraph.Items.Add((IEntity) wcommentMark);
        if (ent is WTableRow)
          wcommentMark.IsAfterCellMark = true;
      }
      else
        this.m_postCommMark = wcommentMark;
    }
    if (this.m_commStack != null && this.m_commStack.Count > 0)
      this.UpdateCommentsStack(attribute);
    if (this.Comments == null || !this.Comments.ContainsKey(attribute))
      return;
    wcommentMark.Comment = this.Comments[attribute];
    this.Comments[attribute].CommentRangeEnd = wcommentMark;
  }

  private void UpdateCommentsStack(string id)
  {
    WComment wcomment = (WComment) null;
    if (this.Comments != null && id != null && this.Comments.ContainsKey(id))
      wcomment = this.Comments[id];
    List<WComment> wcommentList = new List<WComment>();
    if (wcomment != null && wcomment != this.m_commStack.Peek())
    {
      while (this.m_commStack.Count > 0)
      {
        wcommentList.Add(this.m_commStack.Peek());
        this.m_commStack.Pop();
        if (this.m_commStack.Count > 0 && this.m_commStack.Peek() == wcomment)
        {
          this.m_commStack.Pop();
          break;
        }
      }
      for (int index = wcommentList.Count - 1; index >= 0; --index)
        this.m_commStack.Push(wcommentList[index]);
    }
    else
    {
      if (wcomment == null)
        return;
      this.m_commStack.Pop();
    }
  }

  private void UpdateCommentItems(ParagraphItem item)
  {
    if (this.CurrentComment == null)
      return;
    this.CurrentComment.CommentedItems.InnerList.Add((object) item);
  }

  private void ParseCommentsExtended(XmlReader reader)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.NodeType != XmlNodeType.Element && (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement))
      reader.Read();
    this.SkipWhitespaces(reader);
    while (reader.LocalName == "commentEx")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        this.ParseCommentExtended(reader);
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseCommentExtended(XmlReader reader)
  {
    if (this.m_commentsEx == null)
      this.m_commentsEx = new List<WCommentExtended>();
    WCommentExtended commentEx = new WCommentExtended();
    commentEx.ParaId = reader.GetAttribute("paraId", "http://schemas.microsoft.com/office/word/2012/wordml");
    commentEx.ParentParaId = reader.GetAttribute("paraIdParent", "http://schemas.microsoft.com/office/word/2012/wordml");
    string attribute = reader.GetAttribute("done", "http://schemas.microsoft.com/office/word/2012/wordml");
    bool flag = true;
    if (attribute == "0")
      flag = false;
    commentEx.IsResolved = flag;
    this.m_commentsEx.Add(commentEx);
    this.m_doc.CommentsEx.Add(commentEx);
  }

  private void ParseTable(XmlReader reader, WTable table, bool isAlreadyCheck, string m_localName)
  {
    if (m_localName != "tbl")
      throw new XmlException("table element");
    if (isAlreadyCheck)
    {
      this.ParseTableValue(reader, table);
    }
    else
    {
      if (reader.IsEmptyElement)
        return;
      string localName = reader.LocalName;
      reader.Read();
      if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return;
      this.ParseTableValue(reader, table);
    }
  }

  private void ParseTableValue(XmlReader reader, WTable table)
  {
    if (table == null)
      throw new ArgumentException(nameof (table));
    this.SkipWhitespaces(reader);
    Dictionary<string, short> cellGridSpan = new Dictionary<string, short>();
    bool isTableGridMissMatch = false;
    bool isTableCellWidthDefined = true;
    table.IsAllCellsHavePointWidth = true;
    table.HasOnlyParagraphs = true;
    while (reader.LocalName != "tbl")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "tblPr":
            bool isEmptyElement = true;
            this.ParseTableProperties(reader, (IEntity) table, ref isEmptyElement);
            if (!isEmptyElement)
            {
              flag = true;
              this.UpdateTableBorders(table.DocxTableFormat);
              break;
            }
            break;
          case "tblGrid":
            if (!reader.IsEmptyElement)
            {
              string localName = reader.LocalName;
              reader.Read();
              if ((!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement) && table.TableGrid.Count <= 0)
              {
                this.ParseTableGrid(reader, table, false, localName);
                break;
              }
              break;
            }
            break;
          case "tr":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 16 /*0x10*/);
            WTableRow wtableRow = table.AddRow(false, false);
            this.ApplyTableProperties(wtableRow, table);
            this.ParseTableRow(reader, wtableRow, ref isTableCellWidthDefined, cellGridSpan);
            this.m_doc.UpdateTableFormatRevision(wtableRow);
            if (wtableRow.Cells.Count > table.TableGrid.Count)
            {
              isTableGridMissMatch = true;
              break;
            }
            break;
          case "sdt":
            RowContentControl sdtRow = new RowContentControl(table.Document);
            this.ParseStructureDocumentTagRow(reader, sdtRow, table, ref isTableCellWidthDefined, cellGridSpan);
            break;
          case "bookmarkStart":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 5);
            this.ParseBookmarkStart(reader, (ParagraphItemCollection) null);
            break;
          case "bookmarkEnd":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 4);
            this.ParseBookmarkEnd(reader, (IEntity) table);
            break;
          case "permStart":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 21);
            this.ParseEditableRangeStart(reader, (ParagraphItemCollection) null);
            break;
          case "permEnd":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 22);
            this.ParseEditableRangeEnd(reader, (IEntity) table);
            break;
          case "moveFromRangeEnd":
          case "moveToRangeEnd":
            this.ParseMoveRangeEnd(reader, (IEntity) table);
            this.moveRevision = (Revision) null;
            break;
          case "commentRangeEnd":
            this.ParseCommentRangeEnd(reader, table.LastCell.LastParagraph.Items, (IEntity) null);
            break;
          default:
            if (this.IsWord2003ML && reader.LocalName == "annotation")
            {
              switch (reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml"))
              {
                case "Word.Bookmark.Start":
                  this.ParseBookmarkStart(reader, (ParagraphItemCollection) null);
                  break;
                case "Word.Bookmark.End":
                  this.ParseBookmarkEnd(reader, (IEntity) table);
                  break;
              }
            }
            else
              break;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
    if (!table.IsInCell)
      table.IsUpdateCellWidthByPartitioning = true;
    if (table.Rows.Count > 0 && table.Rows[0].Cells.Count > 0 && (isTableGridMissMatch || isTableCellWidthDefined && !table.TableFormat.IsAutoResized))
      table.UpdateTableGrid(isTableGridMissMatch, this.IsNeedtoConsiderGridafter(table));
    table.UpdateGridSpan();
    if (table.TableGrid.Count > 1)
      this.UpdateTableCellWidth(table, cellGridSpan);
    if (cellGridSpan.Count == 0)
      return;
    cellGridSpan.Clear();
  }

  private bool IsNeedtoConsiderGridafter(WTable table)
  {
    bool flag = true;
    if (table.Rows.Count > 0)
    {
      int count = table.Rows[0].Cells.Count;
      foreach (WTableRow row in (Syncfusion.DocIO.DLS.CollectionImpl) table.Rows)
      {
        if (count == row.Cells.Count)
        {
          flag = (int) this.m_gridCount > row.Cells.Count;
        }
        else
        {
          flag = true;
          break;
        }
      }
    }
    return flag;
  }

  private void UpdateTableCellWidth(WTable table, Dictionary<string, short> cellGridSpan)
  {
    WTableColumnCollection tableGrid = table.TableGrid;
    foreach (WTableRow row in (Syncfusion.DocIO.DLS.CollectionImpl) table.Rows)
    {
      if (this.IsRowsFirstCellWidthZero(row.Cells[0]))
      {
        int index1 = row.Index;
        if (this.IsCellsWidthTypesNoneOrAuto(row))
        {
          short num1 = 0;
          int num2 = 0;
          foreach (WTableCell cell in (Syncfusion.DocIO.DLS.CollectionImpl) row.Cells)
          {
            int index2 = cell.Index;
            ++num1;
            string key = $"{index1.ToString()},{index2.ToString()}";
            if (index2 + num2 - 1 < tableGrid.Count)
            {
              if (cellGridSpan.ContainsKey(key))
              {
                short num3 = (short) ((int) num1 - 1);
                short num4 = cellGridSpan[key];
                num1 = (short) ((int) num3 + (int) num4);
                if ((int) num1 - 1 < tableGrid.Count)
                  cell.CellFormat.CellWidth = (float) ((cell.Index == 0 ? (double) tableGrid[(int) num1 - 1].EndOffset : (double) tableGrid[(int) num1 - 1].EndOffset - (double) tableGrid[num2 + index2 - 1].EndOffset) / 20.0);
                num2 += (int) num4 - 1;
                cellGridSpan.Remove(key);
              }
              else if ((int) num1 - 1 < tableGrid.Count)
                cell.CellFormat.CellWidth = (float) ((cell.Index == 0 ? (double) tableGrid[(int) num1 - 1].EndOffset : (double) tableGrid[(int) num1 - 1].EndOffset - (double) tableGrid[index2 + num2 - 1].EndOffset) / 20.0);
            }
          }
        }
      }
    }
  }

  private void ParseTableRow(
    XmlReader reader,
    WTableRow tableRow,
    ref bool isTableCellWidthDefined,
    Dictionary<string, short> cellGridSpan)
  {
    if (reader.LocalName != "tr")
      throw new XmlException("table row element");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (tableRow == null)
      throw new ArgumentException("table row");
    this.m_gridCount = (short) 0;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "tr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "trPr":
            this.ParseTableRowProperties(reader, tableRow);
            break;
          case "tblPrEx":
            tableRow.HasTblPrEx = true;
            bool isEmptyElement = true;
            this.ParseTableProperties(reader, (IEntity) tableRow, ref isEmptyElement);
            flag = true;
            break;
          case "sdt":
            CellContentControl sdtCell = new CellContentControl(tableRow.Document);
            this.ParseStructureDocumentTagCell(reader, sdtCell, tableRow, ref isTableCellWidthDefined, cellGridSpan);
            break;
          case "altChunk":
            AlternateChunk alternateChunk = new AlternateChunk(this.m_doc);
            this.AddBookmark(alternateChunk);
            this.ParseAlternateChunk(reader, alternateChunk);
            this.AltChunkCollection.Add((Entity) alternateChunk);
            break;
          case "tc":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 10);
            WTableCell tableCell = tableRow.AddCell(false);
            if (this.m_altChunkCollection != null && this.m_altChunkCollection.Count != 0)
              this.AddAltChunk(tableCell);
            this.ParseTableCell(reader, tableCell, cellGridSpan);
            if (tableRow.OwnerTable != null && tableRow.OwnerTable.IsAllCellsHavePointWidth && tableCell.PreferredWidth.WidthType != FtsWidth.Point)
              tableRow.OwnerTable.IsAllCellsHavePointWidth = false;
            if (tableRow.OwnerTable != null && tableCell.OwnerRow.OwnerTable.HasOnlyParagraphs && (tableCell.Tables != null && tableCell.Tables.Count > 0 || tableCell.ContentControl != null))
              tableCell.OwnerRow.OwnerTable.HasOnlyParagraphs = false;
            if (isTableCellWidthDefined && (tableCell.PreferredWidth.WidthType != FtsWidth.Point && tableCell.PreferredWidth.WidthType != FtsWidth.Percentage || tableCell.GridSpan > (short) 1))
              isTableCellWidthDefined = false;
            if (tableRow.OwnerTable != null)
            {
              tableRow.OwnerTable.HasAutoPreferredCellWidth = tableRow.OwnerTable.HasAutoPreferredCellWidth ? tableRow.OwnerTable.HasAutoPreferredCellWidth : tableCell.PreferredWidth.WidthType == FtsWidth.Auto;
              tableRow.OwnerTable.HasPointPreferredCellWidth = tableRow.OwnerTable.HasPointPreferredCellWidth ? tableRow.OwnerTable.HasPointPreferredCellWidth : tableCell.PreferredWidth.WidthType == FtsWidth.Point;
              tableRow.OwnerTable.HasPercentPreferredCellWidth = tableRow.OwnerTable.HasPercentPreferredCellWidth ? tableRow.OwnerTable.HasPercentPreferredCellWidth : tableCell.PreferredWidth.WidthType == FtsWidth.Percentage;
              tableRow.OwnerTable.HasNonePreferredCellWidth = tableRow.OwnerTable.HasNonePreferredCellWidth ? tableRow.OwnerTable.HasNonePreferredCellWidth : tableCell.PreferredWidth.WidthType == FtsWidth.None;
              break;
            }
            break;
          case "bookmarkStart":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 5);
            this.ParseBookmarkStart(reader, (ParagraphItemCollection) null);
            break;
          case "bookmarkEnd":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 4);
            this.ParseBookmarkEnd(reader, (IEntity) tableRow);
            break;
          case "permStart":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 21);
            this.ParseEditableRangeStart(reader, (ParagraphItemCollection) null);
            break;
          case "permEnd":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 22);
            this.ParseEditableRangeEnd(reader, (IEntity) tableRow);
            break;
          case "moveFromRangeEnd":
          case "moveToRangeEnd":
            this.ParseMoveRangeEnd(reader, (IEntity) tableRow);
            this.moveRevision = (Revision) null;
            break;
          case "commentRangeStart":
            this.ParseCommentRangeStart(reader, (ParagraphItemCollection) null);
            break;
          case "commentRangeEnd":
            this.ParseCommentRangeEnd(reader, (ParagraphItemCollection) null, (IEntity) tableRow);
            break;
          default:
            if (this.IsWord2003ML && reader.LocalName == "annotation")
            {
              switch (reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml"))
              {
                case "Word.Bookmark.Start":
                  this.ParseBookmarkStart(reader, (ParagraphItemCollection) null);
                  break;
                case "Word.Bookmark.End":
                  this.ParseBookmarkEnd(reader, (IEntity) tableRow);
                  break;
              }
            }
            else
              break;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    if (!(reader.LocalName == "tr") || this.m_altChunkCollection == null || this.m_altChunkCollection.Count == 0)
      return;
    this.AddAltChunk(tableRow.AddCell(false));
  }

  private void AddAltChunk(WTableCell tableCell)
  {
    foreach (AlternateChunk altChunk in this.AltChunkCollection)
    {
      AlternateChunk alternateChunk = tableCell.AddAltChunk(altChunk);
      if (this.m_doc.LastSection != null)
        this.m_doc.LastSection.Body.AlternateChunkCollection.Add(alternateChunk);
    }
    this.AltChunkCollection.Clear();
  }

  private void ParseStructureDocumentTagCell(
    XmlReader reader,
    CellContentControl sdtCell,
    WTableRow tableRow,
    ref bool isTableCellWidthDefined,
    Dictionary<string, short> cellGridSpan)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 3);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName1)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "sdtPr":
            this.ParseSDTProperties(reader, sdtCell.ContentControlProperties);
            break;
          case "sdtContent":
            this.ParseSDTCellContent(reader, sdtCell, tableRow, ref isTableCellWidthDefined, cellGridSpan);
            break;
          case "sdtEndPr":
            this.ParseSDTEndCharacterFormat(reader, sdtCell.BreakCharacterFormat);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseSDTCellContent(
    XmlReader reader,
    CellContentControl sdtCell,
    WTableRow tableRow,
    ref bool isTableCellWidthDefined,
    Dictionary<string, short> cellGridSpan)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    string localName1 = reader.LocalName;
    if (reader.IsEmptyElement)
      return;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool flag = false;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName1)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "tc":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 10);
            WTableCell tableCell = tableRow.AddCell(false);
            if (this.m_altChunkCollection != null && this.m_altChunkCollection.Count != 0)
              this.AddAltChunk(tableCell);
            this.ParseTableCell(reader, tableCell, cellGridSpan);
            tableCell.ContentControl = sdtCell;
            if (isTableCellWidthDefined && (tableCell.PreferredWidth.WidthType != FtsWidth.Point && tableCell.PreferredWidth.WidthType != FtsWidth.Percentage || tableCell.GridSpan > (short) 1))
              isTableCellWidthDefined = false;
            if (sdtCell.ContentControlProperties.XmlMapping != null)
              this.CellContentControls.Add(tableCell);
            if (tableRow.OwnerTable != null)
            {
              tableRow.OwnerTable.HasAutoPreferredCellWidth = tableRow.OwnerTable.HasAutoPreferredCellWidth ? tableRow.OwnerTable.HasAutoPreferredCellWidth : tableCell.PreferredWidth.WidthType == FtsWidth.Auto;
              tableRow.OwnerTable.HasPointPreferredCellWidth = tableRow.OwnerTable.HasPointPreferredCellWidth ? tableRow.OwnerTable.HasPointPreferredCellWidth : tableCell.PreferredWidth.WidthType == FtsWidth.Point;
              tableRow.OwnerTable.HasPercentPreferredCellWidth = tableRow.OwnerTable.HasPercentPreferredCellWidth ? tableRow.OwnerTable.HasPercentPreferredCellWidth : tableCell.PreferredWidth.WidthType == FtsWidth.Percentage;
              tableRow.OwnerTable.HasNonePreferredCellWidth = tableRow.OwnerTable.HasNonePreferredCellWidth ? tableRow.OwnerTable.HasNonePreferredCellWidth : tableCell.PreferredWidth.WidthType == FtsWidth.None;
              break;
            }
            break;
          case "sdt":
            CellContentControl sdtCell1 = new CellContentControl(this.m_doc);
            this.ParseStructureDocumentTagCell(reader, sdtCell1, tableRow, ref isTableCellWidthDefined, cellGridSpan);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseStructureDocumentTagRow(
    XmlReader reader,
    RowContentControl sdtRow,
    WTable table,
    ref bool isTableCellWidthDefined,
    Dictionary<string, short> cellGridSpan)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 4);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    bool isSDTcontentFirst = true;
    while (reader.LocalName != localName2)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "sdtPr":
            this.ParseSDTProperties(reader, sdtRow.ContentControlProperties);
            break;
          case "sdtContent":
            MemoryStream stream = this.ReadSingleNodeIntoStream(reader);
            this.ParseSDTRowContent(stream, sdtRow, table, ref isSDTcontentFirst, ref isTableCellWidthDefined, cellGridSpan);
            flag = true;
            if (sdtRow.ContentControlProperties.XmlMapping != null && sdtRow.ContentControlProperties.XmlMapping.IsMapped && sdtRow.ContentControlProperties.Type == ContentControlType.RepeatingSection)
            {
              PartContainer partContainer = this.m_doc.DocxPackage.FindPartContainer("customXml/");
              if (partContainer.Name == "customXml/")
              {
                int itemsCount = 0;
                string empty1 = string.Empty;
                string empty2 = string.Empty;
                foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
                {
                  string key = xmlPart.Key;
                  if (key.Contains("Props") && partContainer.XmlParts[xmlPart.Key].DataStream.Length > 0L)
                  {
                    Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[xmlPart.Key].DataStream);
                    XmlDocument xmlDocument = new XmlDocument();
                    using (XmlTextReader reader1 = new XmlTextReader(input))
                    {
                      reader1.Namespaces = false;
                      xmlDocument.Load((XmlReader) reader1);
                    }
                    XmlElement documentElement = xmlDocument.DocumentElement;
                    if (documentElement != null)
                    {
                      foreach (XmlAttribute attribute in (XmlNamedNodeMap) documentElement.Attributes)
                      {
                        if (attribute.Name.Contains("itemID") && attribute.Value.Equals(sdtRow.ContentControlProperties.XmlMapping.StoreItemID))
                        {
                          this.GetXMLNodesForRepeatSection(ref empty1, ref empty2, ref itemsCount, partContainer, sdtRow, key);
                          if (itemsCount > 0)
                            break;
                        }
                      }
                      if (itemsCount > 0)
                        break;
                    }
                  }
                }
                if (itemsCount == 0)
                {
                  foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
                    this.GetXMLNodesForRepeatSection(ref empty1, ref empty2, ref itemsCount, partContainer, sdtRow, xmlPart.Key);
                }
                this.UpdateXPathForRepeatSection(itemsCount, table, stream, 2, empty1, empty2, ref isSDTcontentFirst, ref isTableCellWidthDefined, cellGridSpan, sdtRow);
                break;
              }
              break;
            }
            break;
          case "sdtEndPr":
            this.ParseSDTEndCharacterFormat(reader, sdtRow.BreakCharacterFormat);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void UpdateXPathForRepeatSection(
    int itemsCount,
    WTable table,
    MemoryStream stream,
    int sdtRowIndex,
    string tempPath,
    string parentOfTempPath,
    ref bool isSDTcontentFirst,
    ref bool isTableCellWidthDefined,
    Dictionary<string, short> cellGridSpan,
    RowContentControl sdtRow)
  {
    while (itemsCount > 1)
    {
      List<BlockContentControl> blockContentControlList = new List<BlockContentControl>();
      List<InlineContentControl> inlineContentControlList = new List<InlineContentControl>();
      List<WTableCell> wtableCellList = new List<WTableCell>();
      foreach (BlockContentControl blockContentControl in this.BlockContentControls)
        blockContentControlList.Add(blockContentControl);
      foreach (WTableCell cellContentControl in this.CellContentControls)
        wtableCellList.Add(cellContentControl);
      foreach (InlineContentControl inlineContentControl in this.InlineContentControls)
        inlineContentControlList.Add(inlineContentControl);
      this.BlockContentControls.Clear();
      this.InlineContentControls.Clear();
      this.CellContentControls.Clear();
      stream.Position = 0L;
      this.ParseSDTRowContent(stream, new RowContentControl(table.Document)
      {
        ContentControlProperties = sdtRow.ContentControlProperties.Clone()
      }, table, ref isSDTcontentFirst, ref isTableCellWidthDefined, cellGridSpan);
      --itemsCount;
      foreach (BlockContentControl blockContentControl in this.BlockContentControls)
      {
        if (blockContentControl.ContentControlProperties.XmlMapping != null)
          blockContentControl.ContentControlProperties.XmlMapping.XPath = this.GetNewpath(blockContentControl.ContentControlProperties.XmlMapping.XPath, tempPath, parentOfTempPath, sdtRowIndex);
      }
      foreach (WTableCell cellContentControl in this.CellContentControls)
      {
        if (cellContentControl.ContentControl != null && cellContentControl.ContentControl.ContentControlProperties.XmlMapping != null)
          cellContentControl.ContentControl.ContentControlProperties.XmlMapping.XPath = this.GetNewpath(cellContentControl.ContentControl.ContentControlProperties.XmlMapping.XPath, tempPath, parentOfTempPath, sdtRowIndex);
      }
      foreach (InlineContentControl inlineContentControl in this.InlineContentControls)
      {
        if (inlineContentControl.ContentControlProperties.XmlMapping != null)
          inlineContentControl.ContentControlProperties.XmlMapping.XPath = this.GetNewpath(inlineContentControl.ContentControlProperties.XmlMapping.XPath, tempPath, parentOfTempPath, sdtRowIndex);
      }
      ++sdtRowIndex;
      foreach (BlockContentControl blockContentControl in blockContentControlList)
        this.BlockContentControls.Add(blockContentControl);
      foreach (WTableCell wtableCell in wtableCellList)
        this.CellContentControls.Add(wtableCell);
      foreach (InlineContentControl inlineContentControl in inlineContentControlList)
        this.InlineContentControls.Add(inlineContentControl);
    }
  }

  private string GetNewpath(
    string newPath,
    string tempPath,
    string parentOfTempPath,
    int sdtRowIndex)
  {
    List<string> listPath = this.GetListPath(newPath);
    for (int index = 0; index < listPath.Count; ++index)
    {
      string oldValue1 = listPath[index];
      if (index == 0 && oldValue1.Contains(tempPath) || oldValue1.Contains(tempPath) && parentOfTempPath == listPath[index - 1])
      {
        if (oldValue1.Contains(":"))
          oldValue1 = oldValue1.Substring(oldValue1.IndexOf(":") + 1);
        string oldValue2 = oldValue1.Substring(tempPath.Length);
        string newValue = oldValue1.Replace(oldValue2, $"[{(object) sdtRowIndex}]");
        newPath = !(parentOfTempPath != string.Empty) ? newPath.Replace(oldValue1, newValue) : newPath.Substring(0, newPath.IndexOf(parentOfTempPath)) + newPath.Substring(newPath.IndexOf(parentOfTempPath)).Replace(oldValue1, newValue);
        return newPath;
      }
    }
    return newPath;
  }

  private void GetXMLNodesForRepeatSection(
    ref string tempPath,
    ref string parentOfTempPath,
    ref int itemsCount,
    PartContainer partContainer,
    RowContentControl sdtRow,
    string key)
  {
    XmlNodeList childNodes = this.GetXmlElement(key, partContainer).ChildNodes;
    bool isDocProperty = false;
    List<string> listPath = this.GetListPath(sdtRow.ContentControlProperties.XmlMapping.XPath, ref isDocProperty);
    XmlNode currentNode = (XmlNode) null;
    int index1 = 0;
    int result = 0;
    string attributeName = string.Empty;
    string attributeValue = string.Empty;
    for (int index2 = 0; index2 < listPath.Count; ++index2)
    {
      string path = listPath[index1];
      if (index1 > 0)
      {
        parentOfTempPath = index2 > 0 ? listPath[index2 - 1] : string.Empty;
        int startIndex = 0;
        int endIndex = 0;
        tempPath = this.GetPathIndex(path, ref startIndex, ref endIndex);
        if (startIndex != -1 && endIndex != -1 || startIndex == -1 && endIndex == -1)
        {
          if (startIndex != -1 && endIndex != -1)
          {
            int length = endIndex - (startIndex + 1);
            ++startIndex;
            if (startIndex + length <= endIndex && !int.TryParse(tempPath.Substring(startIndex, length), NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              string str = tempPath.Substring(startIndex, length);
              if (str.Contains("="))
              {
                attributeName = str.Contains("@") ? str.Substring(str.IndexOf("@") + 1, str.IndexOf("=") - 1) : str.Substring(0, str.IndexOf("="));
                attributeValue = str.Substring(str.IndexOf("=") + 1).Trim('\'');
              }
            }
            tempPath = tempPath.Substring(0, startIndex - 1);
            int toIterate = 0;
            if (childNodes != null)
            {
              currentNode = this.GetCurrentNode(childNodes, currentNode, ref toIterate, result, tempPath, parentOfTempPath, attributeName, attributeValue);
              if (currentNode != null)
                childNodes = currentNode.ChildNodes;
            }
          }
          else
          {
            result = 1;
            if (itemsCount != 0)
              itemsCount = 0;
            if (childNodes == null)
              break;
            IEnumerator enumerator = childNodes.GetEnumerator();
            try
            {
              while (enumerator.MoveNext())
              {
                if (((XmlNode) enumerator.Current).Name == tempPath)
                  ++itemsCount;
              }
              break;
            }
            finally
            {
              if (enumerator is IDisposable disposable)
                disposable.Dispose();
            }
          }
        }
      }
      ++index1;
    }
  }

  private void ParseSDTRowContent(
    MemoryStream stream,
    RowContentControl sdtRow,
    WTable table,
    ref bool isSDTcontentFirst,
    ref bool isTableCellWidthDefined,
    Dictionary<string, short> cellGridSpan)
  {
    stream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader((Stream) stream);
    if (reader == null)
      throw new ArgumentNullException("reader");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    string localName1 = reader.LocalName;
    if (reader.IsEmptyElement)
      return;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool flag = false;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName1)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "tr":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 16 /*0x10*/);
            WTableRow wtableRow = table.AddRow(false, false);
            this.ApplyTableProperties(wtableRow, table);
            this.ParseTableRow(reader, wtableRow, ref isTableCellWidthDefined, cellGridSpan);
            this.m_doc.UpdateTableFormatRevision(wtableRow);
            if (isSDTcontentFirst)
            {
              wtableRow.ContentControl = sdtRow;
              isSDTcontentFirst = false;
              break;
            }
            break;
          case "sdt":
            RowContentControl sdtRow1 = new RowContentControl(this.m_doc);
            this.ParseStructureDocumentTagRow(reader, sdtRow1, table, ref isTableCellWidthDefined, cellGridSpan);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseTableCell(
    XmlReader reader,
    WTableCell tableCell,
    Dictionary<string, short> cellGridSpan)
  {
    if (reader.LocalName != "tc")
      throw new XmlException("table cell element");
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (tableCell == null)
      throw new ArgumentException("table cell");
    this.SkipWhitespaces(reader);
    this.UpdateCellWidth(tableCell, (short) 1);
    while (reader.LocalName != "tc")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "tcPr":
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              reader.Read();
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                tableCell.CellFormat.Borders.IsDefault = false;
                this.m_gridSpan = (short) 1;
                this.ParseCellProperties(reader, tableCell, cellGridSpan, localName2);
                this.UpdateCellWidth(tableCell, this.m_gridSpan);
                if (this.m_gridSpan > (short) 1)
                {
                  this.m_gridCount += (short) ((int) this.m_gridSpan - 1);
                  this.m_gridSpan = (short) 1;
                  break;
                }
                break;
              }
              break;
            }
            break;
          case "p":
            IWParagraph paragraph = (IWParagraph) null;
            if (this.IsNeedToApplyParaFormat)
            {
              if (this.m_doc.LastParagraph != null)
              {
                paragraph = tableCell.AddPrevParagraph();
                this.m_doc.LastParagraph.RemoveSelf();
              }
              this.IsNeedToApplyParaFormat = false;
            }
            else
              paragraph = tableCell.AddParagraph();
            this.AddPostElements(paragraph);
            this.InsertPostBreakElements(paragraph);
            this.ParseParagraphItems(reader, paragraph.Items, (string) null, (IOfficeMathRunElement) null, false);
            this.m_doc.UpdateLastItemRevision(paragraph, paragraph.Items);
            if (!string.IsNullOrEmpty(paragraph.StyleName))
            {
              (paragraph as WParagraph).ApplyStyle(paragraph.StyleName, false);
              break;
            }
            break;
          case "tbl":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 11);
            WTable table = tableCell.AddTable() as WTable;
            table.TableFormat.IsAutoResized = true;
            short gridCount = this.m_gridCount;
            this.ParseTable(reader, table, false, reader.LocalName);
            this.m_gridCount = gridCount;
            if (table.Rows.Count == 0)
            {
              (table.Owner as WTextBody).ChildEntities.RemoveAt(table.Index);
              break;
            }
            break;
          case "bookmarkStart":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 5);
            this.ParseBookmarkStart(reader, (ParagraphItemCollection) null);
            break;
          case "bookmarkEnd":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 4);
            this.ParseBookmarkEnd(reader, (IEntity) tableCell);
            break;
          case "permStart":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 21);
            this.ParseEditableRangeStart(reader, (ParagraphItemCollection) null);
            break;
          case "permEnd":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 22);
            this.ParseEditableRangeEnd(reader, (IEntity) tableCell);
            break;
          case "moveFromRangeEnd":
          case "moveToRangeEnd":
            this.ParseMoveRangeEnd(reader, (IEntity) tableCell);
            this.moveRevision = (Revision) null;
            break;
          case "altChunk":
            AlternateChunk alternateChunk = this.AddAlternateChunk((IEntity) tableCell);
            this.AddBookmark(alternateChunk);
            this.ParseAlternateChunk(reader, alternateChunk);
            break;
          case "sdt":
            IBlockContentControl sdTagBlock = this.AddStructureDocumentTagBlock((IEntity) tableCell);
            this.ParseStructureDocumentTagBlock(reader, sdTagBlock as BlockContentControl);
            break;
          case "commentRangeStart":
            this.ParseCommentRangeStart(reader, (ParagraphItemCollection) null);
            break;
          case "commentRangeEnd":
            this.ParseCommentRangeEnd(reader, (ParagraphItemCollection) null, (IEntity) tableCell);
            break;
          default:
            if (this.IsWord2003ML && reader.LocalName == "annotation")
            {
              switch (reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml"))
              {
                case "Word.Bookmark.Start":
                  this.ParseBookmarkStart(reader, (ParagraphItemCollection) null);
                  break;
                case "Word.Bookmark.End":
                  this.ParseBookmarkEnd(reader, (IEntity) tableCell);
                  break;
              }
            }
            else
              break;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    ++this.m_gridCount;
  }

  private void ParseCellProperties(
    XmlReader reader,
    WTableCell tableCell,
    Dictionary<string, short> cellGridSpan,
    string localName)
  {
    if (localName != "tcPr")
      throw new XmlException("table cell properties element");
    this.SkipWhitespaces(reader);
    CellFormat cellFormat = tableCell.CellFormat;
    while (reader.LocalName != "tcPr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "noWrap":
            cellFormat.TextWrap = !this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "tcFitText":
            cellFormat.FitText = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "hideMark":
            cellFormat.HideMark = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "tcW":
            this.ParseCellWidth(reader, tableCell);
            goto case "cnfStyle";
          case "textDirection":
            this.ParseCellDirection(reader, cellFormat);
            goto case "cnfStyle";
          case "textFlow":
            if (this.IsWord2003ML)
            {
              this.Parse2003CellDirection(reader, cellFormat);
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          case "vAlign":
            cellFormat.VerticalAlignment = this.ParseCellVerticalAlignment(reader);
            goto case "cnfStyle";
          case "vMerge":
          case "vmerge":
            this.ParseCellVerticalMerge(reader, cellFormat);
            goto case "cnfStyle";
          case "hMerge":
          case "hmerge":
            this.ParseCellHorizontalMerge(reader, cellFormat);
            goto case "cnfStyle";
          case "tcMar":
            cellFormat.SamePaddingsAsTable = false;
            this.ParseTableMargins(reader, (IEntity) tableCell);
            goto case "cnfStyle";
          case "tcBorders":
            this.ParseBorders(reader, (IEntity) tableCell, (Borders) null);
            goto case "cnfStyle";
          case "shd":
            this.ParseCellShading(reader, tableCell);
            goto case "cnfStyle";
          case "gridSpan":
            if (!this.IsCellChangeFormat)
            {
              string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute))
              {
                float result = 0.0f;
                float.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                this.m_gridSpan = (short) result;
                if ((double) result > 1.0 && this.IsRowsFirstCellWidthZero(tableCell) && this.IsCellsWidthTypesNoneOrAuto(tableCell.OwnerRow))
                {
                  string key = $"{tableCell.OwnerRow.Index.ToString()},{tableCell.Index.ToString()}";
                  cellGridSpan.Add(key, (short) result);
                  goto case "cnfStyle";
                }
                goto case "cnfStyle";
              }
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          case "tcPrChange":
            this.IsCellChangeFormat = true;
            if (reader.AttributeCount > 0)
            {
              string attribute1 = reader.GetAttribute("author", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute1))
                tableCell.CellFormat.FormatChangeAuthorName = attribute1;
              string attribute2 = reader.GetAttribute("date", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute2))
              {
                DateTime result = new DateTime();
                DateTime.TryParse(attribute2, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result);
                tableCell.CellFormat.FormatChangeDateTime = result;
              }
            }
            this.ParseChangeCellFormat(reader, tableCell, cellGridSpan);
            this.IsCellChangeFormat = false;
            this.m_doc.UpdateCellFormatRevision(tableCell);
            goto case "cnfStyle";
          case "cnfStyle":
            if (!flag)
            {
              reader.Read();
              break;
            }
            break;
          default:
            if (!this.IsWord2003ML)
            {
              cellFormat.XmlProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
        }
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private bool IsRowsFirstCellWidthZero(WTableCell cell)
  {
    WTableCell cell1 = cell.OwnerRow.Cells[0];
    return cell1.PreferredWidth.WidthType < FtsWidth.Percentage && (double) cell1.PreferredWidth.Width == 0.0;
  }

  private bool IsCellsWidthTypesNoneOrAuto(WTableRow row)
  {
    foreach (WTableCell cell in (Syncfusion.DocIO.DLS.CollectionImpl) row.Cells)
    {
      if (cell.PreferredWidth.WidthType >= FtsWidth.Percentage || (double) cell.PreferredWidth.Width != 0.0)
        return false;
    }
    return true;
  }

  private void ParseChangeCellFormat(
    XmlReader reader,
    WTableCell tableCell,
    Dictionary<string, short> cellGridSpan)
  {
    if (!reader.IsEmptyElement)
    {
      string localName1 = reader.LocalName;
      reader.Read();
      if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return;
      tableCell.CellFormat.IsFormattingChange = true;
      this.SkipWhitespaces(reader);
      if (reader.LocalName == "tcPrChange" && reader.NodeType == XmlNodeType.EndElement)
        return;
      while (reader.LocalName != "tcPrChange")
      {
        bool flag = false;
        if (reader.NodeType == XmlNodeType.Element)
        {
          switch (reader.LocalName)
          {
            case "tcPr":
              if (!reader.IsEmptyElement)
              {
                string localName2 = reader.LocalName;
                reader.Read();
                if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
                {
                  this.ParseCellProperties(reader, tableCell, cellGridSpan, localName2);
                  break;
                }
                break;
              }
              break;
            default:
              reader.Read();
              flag = true;
              break;
          }
          if (!flag)
            reader.Read();
        }
        else
          reader.Read();
        this.SkipWhitespaces(reader);
      }
    }
    tableCell.CellFormat.IsFormattingChange = false;
  }

  private void ParseCellShading(XmlReader reader, WTableCell cell)
  {
    string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    cell.CellFormat.TextureStyle = !this.IsWord2003ML ? this.ParseTexture(attribute1) : this.Parse2003Texture(attribute1);
    string attribute2 = reader.GetAttribute("fill", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    Color color1 = Color.Empty;
    if (attribute2 != "auto")
      color1 = this.GetColorValue(attribute2);
    cell.CellFormat.BackColor = color1;
    string attribute3 = reader.GetAttribute("color", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    Color color2 = !(attribute3 == "auto") ? this.GetColorValue(attribute3) : Color.Empty;
    cell.CellFormat.ForeColor = color2;
  }

  private void ParseCellVerticalMerge(XmlReader reader, CellFormat cellFormat)
  {
    if (reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace) == "restart")
      cellFormat.VerticalMerge = CellMerge.Start;
    else
      cellFormat.VerticalMerge = CellMerge.Continue;
  }

  private void ParseCellHorizontalMerge(XmlReader reader, CellFormat cellFormat)
  {
    if (reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace) == "restart")
      cellFormat.HorizontalMerge = CellMerge.Start;
    else
      cellFormat.HorizontalMerge = CellMerge.Continue;
  }

  private VerticalAlignment ParseCellVerticalAlignment(XmlReader reader)
  {
    VerticalAlignment verticalAlignment = VerticalAlignment.Top;
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute))
    {
      switch (attribute)
      {
        case "top":
          verticalAlignment = VerticalAlignment.Top;
          break;
        case "bottom":
          verticalAlignment = VerticalAlignment.Bottom;
          break;
        case "center":
          verticalAlignment = VerticalAlignment.Middle;
          break;
      }
    }
    return verticalAlignment;
  }

  private void Parse2003CellDirection(XmlReader reader, CellFormat cellFormat)
  {
    switch (reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml"))
    {
      case "tb-rl":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.VerticalTopToBottom;
        break;
      case "bt-lr":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.VerticalBottomToTop;
        break;
      case "lr-tb-v":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast;
        break;
      case "tb-rl-v":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.VerticalFarEast;
        break;
      case "tb-lr-v":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.Vertical;
        break;
      default:
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.Horizontal;
        break;
    }
  }

  private void ParseCellDirection(XmlReader reader, CellFormat cellFormat)
  {
    switch (reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
    {
      case "tbRl":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.VerticalTopToBottom;
        break;
      case "btLr":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.VerticalBottomToTop;
        break;
      case "lrTbV":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast;
        break;
      case "tbRlV":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.VerticalFarEast;
        break;
      case "tbLrV":
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.Vertical;
        break;
      default:
        cellFormat.TextDirection = Syncfusion.DocIO.DLS.TextDirection.Horizontal;
        break;
    }
  }

  private void ParseCellWidth(XmlReader reader, WTableCell cell)
  {
    string attribute1 = reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute1 == null)
      return;
    CellFormat cellFormat = cell.CellFormat;
    if (attribute1 == "auto")
    {
      cellFormat.PreferredWidth.WidthType = FtsWidth.Auto;
      this.UpdateCellWidth(cell);
    }
    else
    {
      string attribute2 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
      switch (attribute1)
      {
        case "pct":
          cellFormat.PreferredWidth.WidthType = FtsWidth.Percentage;
          cellFormat.PreferredWidth.Width = (float) this.ParseIntegerValue(attribute2) / 50f;
          break;
        case "dxa":
          cellFormat.PreferredWidth.WidthType = FtsWidth.Point;
          if (this.IsStrict)
          {
            cellFormat.PreferredWidth.Width = this.ParseFloatValue(attribute2);
            break;
          }
          cellFormat.PreferredWidth.Width = (float) this.ParseIntegerValue(attribute2) / 20f;
          break;
      }
    }
  }

  private void UpdateCellWidth(WTableCell cell)
  {
    if (cell.OwnerRow == null || cell.OwnerRow.OwnerTable == null)
      return;
    WTableColumnCollection tableGrid = cell.OwnerRow.OwnerTable.TableGrid;
    float num = 0.0f;
    if (tableGrid == null || tableGrid.Count == 0)
    {
      float width = cell.OwnerRow.OwnerTable.Width;
      if ((double) width != 0.0)
        num = width / (float) cell.OwnerRow.Cells.Count;
    }
    else if ((int) this.m_gridCount < tableGrid.Count)
      num = this.m_gridCount == (short) 0 ? tableGrid[(int) this.m_gridCount].EndOffset : tableGrid[(int) this.m_gridCount].EndOffset - tableGrid[(int) this.m_gridCount - 1].EndOffset;
    cell.CellFormat.CellWidth = num / 20f;
  }

  private void UpdateCellWidth(WTableCell cell, short gridSpan)
  {
    cell.GridColumnStartIndex = this.m_gridCount;
    cell.GridSpan = gridSpan;
    if (cell.OwnerRow == null || cell.OwnerRow.OwnerTable == null || cell.OwnerRow.OwnerTable.TableGrid == null || cell.OwnerRow.OwnerTable.TableGrid.Count == 0)
      return;
    WTableColumnCollection tableGrid = cell.OwnerRow.OwnerTable.TableGrid;
    float num = 0.0f;
    if ((int) this.m_gridCount + (int) gridSpan - 1 < tableGrid.Count)
      num = this.m_gridCount == (short) 0 ? tableGrid[(int) this.m_gridCount + (int) gridSpan - 1].EndOffset : tableGrid[(int) this.m_gridCount + (int) gridSpan - 1].EndOffset - tableGrid[(int) this.m_gridCount - 1].EndOffset;
    cell.CellFormat.CellWidth = num / 20f;
  }

  private void ParseTableRowProperties(XmlReader reader, WTableRow tableRow)
  {
    if (reader.LocalName != "trPr")
      throw new XmlException("table row element");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    RowFormat rowFormat = this.GetRowFormat((IEntity) tableRow);
    while (reader.LocalName != "trPr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "trHeight":
            this.ParseRowHeight(reader, tableRow);
            goto case "cnfStyle";
          case "tblCellSpacing":
            float num = 0.0f;
            string attribute1 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
              num = this.GetFloatValue(attribute1, reader.LocalName);
            string attribute2 = reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if ((double) num != 3.4028234663852886E+38 && (string.IsNullOrEmpty(attribute2) || !(attribute2 == "nil")))
            {
              rowFormat.CellSpacing = num;
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          case "tblHeader":
            tableRow.IsHeader = true;
            goto case "cnfStyle";
          case "trPrChange":
            this.IsRowChangeFormat = true;
            this.UpdateRevAuthorInformation(tableRow.RowFormat, reader, RevisionType.Formatting);
            this.ParseChangeRowFormat(reader, tableRow);
            this.IsRowChangeFormat = false;
            this.m_doc.UpdateRowFormatRevision(tableRow.RowFormat);
            goto case "cnfStyle";
          case "del":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 12);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            this.UpdateRevAuthorInformation(tableRow.RowFormat, reader, RevisionType.Deletions);
            tableRow.IsDeleteRevision = true;
            this.m_doc.TableRowRevision(RevisionType.Deletions, tableRow, (WordReaderBase) null);
            goto case "cnfStyle";
          case "ins":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 24);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            this.UpdateRevAuthorInformation(tableRow.RowFormat, reader, RevisionType.Insertions);
            tableRow.IsInsertRevision = true;
            this.m_doc.TableRowRevision(RevisionType.Insertions, tableRow, (WordReaderBase) null);
            goto case "cnfStyle";
          case "cantSplit":
            rowFormat.IsBreakAcrossPages = !this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "cnfStyle":
label_38:
            if (!flag)
            {
              reader.Read();
              continue;
            }
            continue;
          case "jc":
            rowFormat.HorizontalAlignment = this.ParseTableJustification(reader);
            goto case "cnfStyle";
          case "gridBefore":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            float result1 = 0.0f;
            if (!string.IsNullOrEmpty(attribute3) && !float.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1))
              result1 = 0.0f;
            if ((double) result1 > 0.0 && !rowFormat.IsFormattingChange)
            {
              rowFormat.BeforeWidth = rowFormat.UpdateRowBeforeAfterWidth((short) result1, false);
              this.m_gridCount = (short) result1;
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          case "gridAfter":
            string attribute4 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            short result2 = 0;
            if (!string.IsNullOrEmpty(attribute4))
              short.TryParse(attribute4, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
            if (result2 > (short) 0 && !rowFormat.IsFormattingChange)
            {
              rowFormat.AfterWidth = rowFormat.UpdateRowBeforeAfterWidth(result2, true);
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          case "wBefore":
            string attribute5 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            switch (reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace))
            {
              case "pct":
                rowFormat.GridBeforeWidth.WidthType = FtsWidth.Percentage;
                rowFormat.GridBeforeWidth.Width = (float) this.ParseIntegerValue(attribute5) / 50f;
                goto label_38;
              case "dxa":
                rowFormat.GridBeforeWidth.WidthType = FtsWidth.Point;
                rowFormat.GridBeforeWidth.Width = (float) this.ParseIntegerValue(attribute5) / 20f;
                goto label_38;
              default:
                goto label_38;
            }
          case "wAfter":
            string attribute6 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            switch (reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace))
            {
              case "pct":
                rowFormat.GridAfterWidth.WidthType = FtsWidth.Percentage;
                rowFormat.GridAfterWidth.Width = (float) this.ParseIntegerValue(attribute6) / 50f;
                goto label_38;
              case "dxa":
                rowFormat.GridAfterWidth.WidthType = FtsWidth.Point;
                rowFormat.GridAfterWidth.Width = (float) this.ParseIntegerValue(attribute6) / 20f;
                goto label_38;
              default:
                goto label_38;
            }
          case "hidden":
            rowFormat.Hidden = true;
            goto case "cnfStyle";
          default:
            if (!this.IsWord2003ML)
            {
              rowFormat.XmlProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
        }
      }
      else
        reader.Read();
    }
  }

  private void ParseChangeRowFormat(XmlReader reader, WTableRow tableRow)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    tableRow.RowFormat.IsChangedFormat = true;
    tableRow.RowFormat.IsFormattingChange = true;
    this.SkipWhitespaces(reader);
    if (reader.LocalName == "trPrChange" && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != "trPrChange")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "trPr":
            this.ParseTableRowProperties(reader, tableRow);
            break;
          default:
            reader.Read();
            flag = true;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private string GetStringVal(XmlReader reader, string attrName, string attrNS)
  {
    if (reader.AttributeCount == 0)
      return (string) null;
    return attrNS == null ? reader.GetAttribute(attrName) : reader.GetAttribute(attrName, attrNS);
  }

  private void ParseRowHeight(XmlReader reader, WTableRow tableRow)
  {
    string name = this.IsWord2003ML ? "h-rule" : "hRule";
    if (tableRow.RowFormat.IsFormattingChange)
      return;
    string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
      tableRow.RowFormat.Height = this.GetFloatValue(attribute1, "rowHeight");
    string attribute2 = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute2) || !(attribute2 == "exact"))
      return;
    tableRow.HeightType = TableRowHeightType.Exactly;
  }

  private void ApplyTableProperties(WTableRow tblRow, WTable table)
  {
    tblRow.RowFormat.ImportContainer((FormatBase) table.DocxTableFormat.Format);
    tblRow.RowFormat.IsAutoResized = table.DocxTableFormat.Format.IsAutoResized;
    if (table.DocxTableFormat.StyleName != null && table.DocxTableFormat.StyleName.Length != 0)
      return;
    Borders borders1 = table.DocxTableFormat.Format.Borders;
    Borders borders2 = tblRow.RowFormat.Borders;
    if (borders1.Bottom.BorderType == BorderStyle.None)
      borders2.Bottom.HasNoneStyle = true;
    if (borders1.Left.BorderType == BorderStyle.None)
      borders2.Left.HasNoneStyle = true;
    if (borders1.Right.BorderType == BorderStyle.None)
      borders2.Right.HasNoneStyle = true;
    if (borders1.Top.BorderType == BorderStyle.None)
      borders2.Top.HasNoneStyle = true;
    if (borders1.Horizontal.BorderType == BorderStyle.None)
      borders2.Horizontal.HasNoneStyle = true;
    if (borders1.Vertical.BorderType != BorderStyle.None)
      return;
    borders2.Vertical.HasNoneStyle = true;
  }

  private void UpdateTableBorders(XmlTableFormat xmlFormat)
  {
    if (!string.IsNullOrEmpty(xmlFormat.StyleName) || !xmlFormat.Format.Borders.IsDefault)
      return;
    xmlFormat.Format.Borders.BorderType = BorderStyle.None;
  }

  private void ParseTableProperties(XmlReader reader, IEntity entity, ref bool isEmptyElement)
  {
    if (!reader.IsEmptyElement)
    {
      string localName1 = reader.LocalName;
      Stream stream = (Stream) this.ReadSingleNodeIntoStream(reader);
      if (!(localName1 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
      {
        isEmptyElement = false;
        bool flag1 = this.HasNode(stream, "tblStyle");
        XmlReader reader1 = UtilityMethods.CreateReader(stream);
        if (flag1)
        {
          while (reader1.Read())
          {
            if (reader1.LocalName == "tblStyle")
            {
              string attribute = reader1.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (string.IsNullOrEmpty(attribute) || !this.StyleNameId.ContainsKey(attribute) || this.m_doc.Styles.FindByName(this.StyleNameId[attribute], StyleType.TableStyle) == null)
              {
                flag1 = false;
                break;
              }
              break;
            }
          }
          stream.Position = 0L;
          reader1 = UtilityMethods.CreateReader(stream);
        }
        string localName2 = reader1.LocalName;
        if (localName2 == "tblPrEx")
          flag1 = false;
        RowFormat rowFormat = this.GetRowFormat(entity);
        reader1.Read();
        this.SkipWhitespaces(reader1);
        WTable table = entity as WTable;
        if (entity is WTableRow)
          table = (entity as WTableRow).OwnerTable;
        while (reader1.LocalName != localName2)
        {
          bool flag2 = false;
          if (reader1.NodeType == XmlNodeType.Element)
          {
            switch (reader1.LocalName)
            {
              case "tblStyle":
                if (flag1)
                  this.ParseTableStyle(reader1, table);
                flag1 = false;
                break;
              case "tblW":
                string attribute1 = reader1.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
                if (attribute1 == null)
                  return;
                if (!flag1)
                {
                  if (!(entity is WTableRow))
                  {
                    if (attribute1 == "auto")
                    {
                      table.PreferredTableWidth.WidthType = FtsWidth.Auto;
                      break;
                    }
                    string attribute2 = reader1.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
                    switch (attribute1)
                    {
                      case "pct":
                        table.PreferredTableWidth.WidthType = FtsWidth.Percentage;
                        table.PreferredTableWidth.Width = !attribute2.EndsWith("%") ? (float) this.ParseIntegerValue(attribute2) / 50f : (float) this.GetPercentage(attribute2);
                        break;
                      case "dxa":
                        table.PreferredTableWidth.WidthType = FtsWidth.Point;
                        table.PreferredTableWidth.Width = this.IsStrict ? this.ParseFloatValue(attribute2) : (float) this.ParseIntegerValue(attribute2) / 20f;
                        break;
                    }
                  }
                  else
                  {
                    if (attribute1 == "auto")
                    {
                      (entity as WTableRow).RowFormat.PreferredWidth.WidthType = FtsWidth.Auto;
                      break;
                    }
                    string attribute3 = reader1.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
                    switch (attribute1)
                    {
                      case "pct":
                        (entity as WTableRow).RowFormat.PreferredWidth.WidthType = FtsWidth.Percentage;
                        if (attribute3.EndsWith("%"))
                        {
                          (entity as WTableRow).RowFormat.PreferredWidth.Width = (float) this.GetPercentage(attribute3);
                          break;
                        }
                        (entity as WTableRow).RowFormat.PreferredWidth.Width = (float) this.ParseIntegerValue(attribute3) / 50f;
                        break;
                      case "dxa":
                        (entity as WTableRow).RowFormat.PreferredWidth.WidthType = FtsWidth.Point;
                        (entity as WTableRow).RowFormat.PreferredWidth.Width = this.IsStrict ? this.ParseFloatValue(attribute3) : (float) this.ParseIntegerValue(attribute3) / 20f;
                        break;
                    }
                  }
                }
                else
                  break;
                break;
              case "tblBorders":
                if (flag1)
                {
                  reader1.Skip();
                  break;
                }
                this.ParseBorders(reader1, entity, (Borders) null);
                break;
              case "tblCellSpacing":
                if (!flag1)
                {
                  float num = 0.0f;
                  string attribute4 = reader1.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
                  if (!string.IsNullOrEmpty(attribute4))
                    num = this.GetFloatValue(attribute4, reader1.LocalName);
                  string attribute5 = reader1.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
                  if ((double) num != 3.4028234663852886E+38 && (string.IsNullOrEmpty(attribute5) || !(attribute5 == "nil")))
                  {
                    rowFormat.CellSpacing = num;
                    break;
                  }
                  break;
                }
                break;
              case "jc":
                if (!flag1)
                {
                  rowFormat.HorizontalAlignment = this.ParseTableJustification(reader1);
                  break;
                }
                break;
              case "bidiVisual":
                rowFormat.Bidi = this.GetBooleanValue(reader1);
                break;
              case "tblCellMar":
                if (flag1)
                {
                  reader1.Skip();
                  break;
                }
                this.ParseTableMargins(reader1, entity);
                break;
              case "tblInd":
                if (!flag1)
                {
                  string attribute6 = reader1.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
                  if (!string.IsNullOrEmpty(attribute6))
                  {
                    float floatValue = this.GetFloatValue(attribute6, "tblInd");
                    rowFormat.LeftIndent = (double) floatValue < -1080.0 || (double) floatValue > 1080.0 || float.IsNaN(floatValue) ? 0.0f : floatValue;
                  }
                  if (localName2 == "tblPrEx" && entity is WTableRow && (entity as WTableRow).GetRowIndex() == 0)
                  {
                    rowFormat.OwnerRow.OwnerTable.TableFormat.LeftIndent = rowFormat.LeftIndent;
                    break;
                  }
                  break;
                }
                break;
              case "tblLayout":
                if (!flag1)
                {
                  this.ParseTableLayout(reader1, rowFormat);
                  break;
                }
                break;
              case "tblPrChange":
                if (flag1)
                {
                  reader1.Skip();
                  flag2 = true;
                  break;
                }
                this.IsTableChangeFormat = true;
                this.UpdateRevAuthorInformation(table.DocxTableFormat.Format, reader1, RevisionType.Formatting);
                this.ParseChangeTableProperties(reader1, (IEntity) table);
                this.IsTableChangeFormat = false;
                table.DocxTableFormat.Format.IsFormattingChange = false;
                this.m_doc.UpdateTableRevision(table);
                break;
              case "tblPrExChange":
                if (flag1)
                {
                  reader1.Skip();
                  flag2 = true;
                  break;
                }
                this.IsRowChangeFormat = true;
                this.UpdateRevAuthorInformation(rowFormat, reader1, RevisionType.Formatting);
                this.ParseChangeTableProperties(reader1, entity);
                this.IsRowChangeFormat = false;
                rowFormat.IsFormattingChange = false;
                Revision newRevision = this.m_doc.CreateNewRevision(RevisionType.Formatting, rowFormat.FormatChangeAuthorName, rowFormat.FormatChangeDateTime, (string) null);
                rowFormat.Revisions.Add(newRevision);
                newRevision.Range.Items.Add((object) rowFormat);
                break;
              case "tblpPr":
                if (!flag1)
                {
                  this.ParseTablePositioning(reader1, table);
                  break;
                }
                break;
              case "tblOverlap":
                if (table.TableFormat.WrapTextAround)
                {
                  string attribute7 = reader1.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
                  if (!string.IsNullOrEmpty(attribute7) && attribute7.ToLower() == "never")
                  {
                    table.TableFormat.Positioning.AllowOverlap = false;
                    break;
                  }
                  break;
                }
                break;
              case "shd":
                if (!flag1)
                {
                  this.ParseTableShading(reader1, rowFormat);
                  break;
                }
                break;
              case "tblLook":
                this.ParseTableLook(reader1, table);
                break;
              case "tblCaption":
                this.ParseTableTitle(reader1, table);
                break;
              case "tblDescription":
                this.ParseTableDescription(reader1, table);
                break;
              default:
                if (!this.IsWord2003ML && reader1.LocalName != string.Empty && !(entity is WTableRow))
                {
                  if (!this.IsTableChangeFormat)
                    table.DocxTableFormat.NodeArray.Add((Stream) this.ReadSingleNodeIntoStream(reader1));
                  flag2 = true;
                  break;
                }
                break;
            }
            if (!flag2)
              reader1.Read();
          }
          else
            reader1.Read();
        }
      }
      else
        isEmptyElement = true;
    }
    else
      isEmptyElement = true;
  }

  private void ParseChangeTableProperties(XmlReader reader, IEntity entity)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (entity is WTableRow)
      (entity as WTableRow).RowFormat.IsFormattingChange = true;
    else
      (entity as WTable).DocxTableFormat.Format.IsFormattingChange = true;
    this.SkipWhitespaces(reader);
    if (reader.LocalName == localName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "tblPr":
          case "tblPrEx":
            bool isEmptyElement = true;
            this.ParseTableProperties(reader, entity, ref isEmptyElement);
            if (isEmptyElement)
            {
              flag = true;
              break;
            }
            break;
          default:
            flag = true;
            break;
        }
        if (flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private int ParseIntegerValue(string value)
  {
    int result1 = 0;
    double result2 = 0.0;
    if (double.TryParse(value, NumberStyles.Any, (IFormatProvider) CultureInfo.InvariantCulture, out result2))
    {
      if (value.Contains("."))
      {
        int length = value.IndexOf('.');
        if (length > 0)
          value = value.Substring(0, length);
        else if (length == 0)
          value = "0";
      }
      int.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
    }
    return result1;
  }

  private float ParseFloatValue(string value)
  {
    float result1 = 0.0f;
    double result2 = 0.0;
    if (double.TryParse(value.Remove(value.IndexOf("pt")), NumberStyles.Any, (IFormatProvider) CultureInfo.InvariantCulture, out result2))
    {
      double num = result2 * 20.0;
      value = value.Remove(value.IndexOf("pt"));
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
    }
    return result1;
  }

  private void ParseTableTitle(XmlReader reader, WTable table)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute))
      return;
    table.Title = attribute;
  }

  private void ParseTableDescription(XmlReader reader, WTable table)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute))
      return;
    table.Description = attribute;
  }

  private void ParseTableLook(XmlReader reader, WTable table)
  {
    string tableLookValue1 = this.GetTableLookValue(reader, "firstRow");
    if (!string.IsNullOrEmpty(tableLookValue1))
      table.ApplyStyleForHeaderRow = this.GetBoolValue(tableLookValue1);
    string tableLookValue2 = this.GetTableLookValue(reader, "lastRow");
    if (!string.IsNullOrEmpty(tableLookValue2))
      table.ApplyStyleForLastRow = this.GetBoolValue(tableLookValue2);
    string tableLookValue3 = this.GetTableLookValue(reader, "firstColumn");
    if (!string.IsNullOrEmpty(tableLookValue3))
      table.ApplyStyleForFirstColumn = this.GetBoolValue(tableLookValue3);
    string tableLookValue4 = this.GetTableLookValue(reader, "lastColumn");
    if (!string.IsNullOrEmpty(tableLookValue4))
      table.ApplyStyleForLastColumn = this.GetBoolValue(tableLookValue4);
    string tableLookValue5 = this.GetTableLookValue(reader, "noHBand");
    if (!string.IsNullOrEmpty(tableLookValue5))
      table.ApplyStyleForBandedRows = !this.GetBoolValue(tableLookValue5);
    string tableLookValue6 = this.GetTableLookValue(reader, "noVBand");
    if (string.IsNullOrEmpty(tableLookValue6))
      return;
    table.ApplyStyleForBandedColumns = !this.GetBoolValue(tableLookValue6);
  }

  private bool GetBoolValue(string value)
  {
    return !string.IsNullOrEmpty(value) && !(value == "f") && !(value == "0") && !(value == "off") && !(value == "false");
  }

  private bool GetBoolValue(XmlReader reader, string nameSpace)
  {
    string attribute = reader.GetAttribute("val", nameSpace);
    return string.IsNullOrEmpty(attribute) || !(attribute == "0") && !(attribute == "off") && !(attribute == "false");
  }

  private string GetTableLookValue(XmlReader reader, string name)
  {
    string tableLookValue = reader.GetAttribute(name, this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (tableLookValue == null)
    {
      string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
      if (!string.IsNullOrEmpty(attribute))
      {
        string str = Convert.ToString(Convert.ToInt32(attribute, 16 /*0x10*/), 2).PadLeft(11, '0');
        switch (name)
        {
          case "firstRow":
            tableLookValue = str.Substring(5, 1);
            break;
          case "lastRow":
            tableLookValue = str.Substring(4, 1);
            break;
          case "firstColumn":
            tableLookValue = str.Substring(3, 1);
            break;
          case "lastColumn":
            tableLookValue = str.Substring(2, 1);
            break;
          case "noHBand":
            tableLookValue = str.Substring(1, 1);
            break;
          case "noVBand":
            tableLookValue = str.Substring(0, 1);
            break;
        }
      }
    }
    return tableLookValue;
  }

  private void ParseTableMargins(XmlReader reader, Paddings paddings)
  {
    string empty = string.Empty;
    string str = !(reader.LocalName != "tblCellMar") || !(reader.LocalName != "tcMar") ? reader.LocalName : throw new XmlException("Table margins");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "top":
            string attribute1 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
            {
              paddings.Top = this.GetFloatValue(attribute1, reader.LocalName);
              break;
            }
            break;
          case "left":
          case "start":
            string attribute2 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute2))
            {
              paddings.Left = this.GetFloatValue(attribute2, reader.LocalName);
              break;
            }
            break;
          case "bottom":
            string attribute3 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute3))
            {
              paddings.Bottom = this.GetFloatValue(attribute3, reader.LocalName);
              break;
            }
            break;
          case "right":
          case "end":
            string attribute4 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute4))
            {
              paddings.Right = this.GetFloatValue(attribute4, reader.LocalName);
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseTableMargins(XmlReader reader, IEntity entity)
  {
    string empty = string.Empty;
    Paddings paddings = this.GetPaddings(entity);
    string str = !(reader.LocalName != "tblCellMar") || !(reader.LocalName != "tcMar") ? reader.LocalName : throw new XmlException("Table margins");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "top":
            string attribute1 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
            {
              paddings.Top = this.GetFloatValue(attribute1, reader.LocalName);
              break;
            }
            break;
          case "left":
          case "start":
            string attribute2 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute2))
            {
              paddings.Left = this.GetFloatValue(attribute2, reader.LocalName);
              break;
            }
            break;
          case "bottom":
            string attribute3 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute3))
            {
              paddings.Bottom = this.GetFloatValue(attribute3, reader.LocalName);
              break;
            }
            break;
          case "right":
          case "end":
            string attribute4 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute4))
            {
              paddings.Right = this.GetFloatValue(attribute4, reader.LocalName);
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private Paddings GetPaddings(IEntity entity)
  {
    Paddings paddings = new Paddings();
    switch (entity)
    {
      case WTable _:
        if (this.IsTableChangeFormat)
        {
          (entity as WTable).DocxTableFormat.Format.SetPropertyValue(3, (object) paddings);
          paddings = (Paddings) (entity as WTable).DocxTableFormat.Format.OldPropertiesHash[3];
          break;
        }
        paddings = (entity as WTable).DocxTableFormat.Format.Paddings;
        break;
      case WTableRow _:
        if (this.IsRowChangeFormat)
        {
          (entity as WTableRow).RowFormat.SetPropertyValue(3, (object) paddings);
          paddings = (Paddings) (entity as WTableRow).RowFormat.OldPropertiesHash[3];
          break;
        }
        paddings = (entity as WTableRow).RowFormat.Paddings;
        break;
      case WTableCell _:
        if (this.IsCellChangeFormat)
        {
          (entity as WTableCell).CellFormat.SetPropertyValue(3, (object) paddings);
          paddings = (Paddings) (entity as WTableCell).CellFormat.OldPropertiesHash[3];
          break;
        }
        paddings = (entity as WTableCell).CellFormat.Paddings;
        break;
    }
    return paddings;
  }

  private RowAlignment ParseTableJustification(XmlReader reader)
  {
    RowAlignment tableJustification = RowAlignment.Left;
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute))
    {
      switch (attribute)
      {
        case "left":
          tableJustification = RowAlignment.Left;
          break;
        case "center":
          tableJustification = RowAlignment.Center;
          break;
        case "right":
          tableJustification = RowAlignment.Right;
          break;
      }
    }
    return tableJustification;
  }

  private void ParseTablePositioning(XmlReader reader, WTable table)
  {
    RowFormat.TablePositioning positioning = table.DocxTableFormat.Format.Positioning;
    string attribute1 = reader.GetAttribute("leftFromText", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
      positioning.DistanceFromLeft = this.GetFloatValue(attribute1, "leftFromText");
    string attribute2 = reader.GetAttribute("rightFromText", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      positioning.DistanceFromRight = this.GetFloatValue(attribute2, "rightFromText");
    string attribute3 = reader.GetAttribute("topFromText", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
      positioning.DistanceFromTop = this.GetFloatValue(attribute3, "topFromText");
    string attribute4 = reader.GetAttribute("bottomFromText", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute4))
      positioning.DistanceFromBottom = this.GetFloatValue(attribute4, "bottomFromText");
    string attribute5 = reader.GetAttribute("vertAnchor", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute5))
      this.ParseTableVerticalRelation(positioning, attribute5);
    string attribute6 = reader.GetAttribute("horzAnchor", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute6))
      this.ParseTableHorizontalRelation(positioning, attribute6);
    string attribute7 = reader.GetAttribute("tblpXSpec", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute7))
      this.ParseTableHorizontalPosition(positioning, attribute7);
    string attribute8 = reader.GetAttribute("tblpYSpec", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute8))
      this.ParseTableVerticalPosition(positioning, attribute8);
    string attribute9 = reader.GetAttribute("tblpX", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute9))
      positioning.HorizPosition = this.GetFloatValue(attribute9, "tblpX");
    string attribute10 = reader.GetAttribute("tblpY", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute10))
      return;
    positioning.VertPosition = this.GetFloatValue(attribute10, "tblpY");
  }

  private void ParseTableVerticalRelation(RowFormat.TablePositioning positioning, string position)
  {
    switch (position)
    {
      case "page":
        positioning.VertRelationTo = VerticalRelation.Page;
        break;
      case "text":
        positioning.VertRelationTo = VerticalRelation.Paragraph;
        break;
      default:
        positioning.VertRelationTo = VerticalRelation.Margin;
        break;
    }
  }

  private void ParseTableHorizontalRelation(RowFormat.TablePositioning positioning, string position)
  {
    switch (position)
    {
      case "page":
        positioning.HorizRelationTo = HorizontalRelation.Page;
        break;
      case "margin":
        positioning.HorizRelationTo = HorizontalRelation.Margin;
        break;
      default:
        positioning.HorizRelationTo = HorizontalRelation.Column;
        break;
    }
  }

  private void ParseTableHorizontalPosition(RowFormat.TablePositioning positioning, string position)
  {
    switch (position)
    {
      case "inside":
        positioning.HorizPositionAbs = HorizontalPosition.Inside;
        break;
      case "outside":
        positioning.HorizPositionAbs = HorizontalPosition.Outside;
        break;
      case "center":
        positioning.HorizPositionAbs = HorizontalPosition.Center;
        break;
      case "right":
        positioning.HorizPositionAbs = HorizontalPosition.Right;
        break;
      default:
        positioning.HorizPositionAbs = HorizontalPosition.Left;
        break;
    }
  }

  private void ParseTableVerticalPosition(RowFormat.TablePositioning positioning, string position)
  {
    switch (position)
    {
      case "inside":
        positioning.VertPositionAbs = VerticalPosition.Inside;
        break;
      case "outside":
        positioning.VertPositionAbs = VerticalPosition.Outside;
        break;
      case "center":
        positioning.VertPositionAbs = VerticalPosition.Center;
        break;
      case "bottom":
        positioning.VertPositionAbs = VerticalPosition.Bottom;
        break;
      case "top":
        positioning.VertPositionAbs = VerticalPosition.Top;
        break;
      default:
        positioning.VertPositionAbs = VerticalPosition.None;
        break;
    }
  }

  private void ParseTableShading(XmlReader reader, RowFormat format)
  {
    string attribute1 = reader.GetAttribute("fill", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      format.TextureStyle = this.ParseTexture(attribute2);
    if (string.IsNullOrEmpty(attribute1))
      return;
    if (attribute1 == "auto")
      format.BackColor = Color.Empty;
    else
      format.BackColor = this.GetColorValue(attribute1);
  }

  private void ParseTableLayout(XmlReader reader, RowFormat format)
  {
    string str = this.IsWord2003ML ? "Fixed" : "fixed";
    if (!(reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace) == str))
      return;
    format.IsAutoResized = false;
  }

  private void ParseTableStyle(XmlReader reader, WTable table)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute) && this.StyleNameId.ContainsKey(attribute) && this.m_doc.Styles.FindByName(this.StyleNameId[attribute], StyleType.TableStyle) != null)
      table.ApplyStyle(this.StyleNameId[attribute], false);
    if (this.IsTableChangeFormat)
      table.TrackTblFormat.StyleName = attribute;
    else
      table.DocxTableFormat.StyleName = attribute;
  }

  private RowFormat GetRowFormat(IEntity entity)
  {
    RowFormat rowFormat = (RowFormat) null;
    switch (entity)
    {
      case WTable _:
        WTable wtable = entity as WTable;
        rowFormat = wtable.DocxTableFormat.Format;
        if (wtable.DocxTableFormat.StyleName == null)
        {
          wtable.DocxTableFormat.StyleName = string.Empty;
          break;
        }
        break;
      case WTableRow _:
        rowFormat = (entity as WTableRow).RowFormat;
        break;
    }
    return rowFormat;
  }

  private void ParseTableGrid(
    XmlReader reader,
    WTable table,
    bool isTableGridChange,
    string localName)
  {
    string str = localName == "tblGrid" || localName == "tblGridChange" ? localName : throw new XmlException("table grid");
    WTableColumnCollection columnCollection = isTableGridChange ? table.TrackTableGrid : table.TableGrid;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "gridCol":
            string attribute = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (string.IsNullOrEmpty(attribute))
            {
              table.IsTableGridCorrupted = true;
              break;
            }
            float num = 0.0f;
            if (columnCollection.Count > 0)
              num = columnCollection[columnCollection.Count - 1].EndOffset;
            float result = 0.0f;
            float.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
            columnCollection.AddColumns(result + num);
            break;
          case "tblGridChange":
            if (!reader.IsEmptyElement)
            {
              localName = reader.LocalName;
              reader.Read();
              if ((!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement) && table.TrackTableGrid.Count <= 0)
              {
                this.ParseTableGrid(reader, table, true, localName);
                break;
              }
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private IWTable AddTable(IEntity entity)
  {
    IWTable wtable;
    switch (entity)
    {
      case HeaderFooter _:
        wtable = (entity as HeaderFooter).AddTable();
        break;
      case WFootnote _:
        wtable = (entity as WFootnote).TextBody.AddTable();
        break;
      case WComment _:
        wtable = (entity as WComment).TextBody.AddTable();
        break;
      case BlockContentControl _:
        wtable = (entity as BlockContentControl).TextBody.AddTable();
        break;
      case WTextBody _:
        wtable = (entity as WTextBody).AddTable();
        break;
      default:
        wtable = this.m_doc.LastSection.AddTable();
        break;
    }
    return wtable;
  }

  private bool ParseHyperlink(XmlReader reader, ParagraphItemCollection paraItems)
  {
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 23);
    string str1 = (string) null;
    string attribute1;
    if (this.IsWord2003ML)
    {
      attribute1 = reader.GetAttribute("bookmark", "http://schemas.microsoft.com/office/word/2003/wordml");
    }
    else
    {
      str1 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
      attribute1 = reader.GetAttribute("anchor", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
      if (str1 == null && attribute1 == null)
        return false;
    }
    WField hyperlink1 = new WField((IWordDocument) this.m_doc);
    hyperlink1.FieldType = FieldType.FieldHyperlink;
    Hyperlink hyperlink2 = new Hyperlink(hyperlink1);
    WTextRange wtextRange = new WTextRange((IWordDocument) this.m_doc);
    if (this.IsWord2003ML)
    {
      hyperlink2.Type = HyperlinkType.Bookmark;
      if (attribute1 != null)
        hyperlink2.BookmarkName = attribute1;
      string attribute2 = reader.GetAttribute("dest", "http://schemas.microsoft.com/office/word/2003/wordml");
      if (!string.IsNullOrEmpty(attribute2))
        hyperlink1.m_fieldValue = attribute2;
      this.AddToParagraph((ParagraphItem) hyperlink1, paraItems);
      this.AddToParagraph((ParagraphItem) wtextRange, paraItems);
    }
    else
    {
      string attribute3 = reader.GetAttribute("tooltip", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
      if (!string.IsNullOrEmpty(attribute3))
        hyperlink1.ScreenTip = attribute3;
      if (str1 == null)
      {
        hyperlink2.Type = HyperlinkType.Bookmark;
        hyperlink2.BookmarkName = attribute1;
        this.AddToParagraph((ParagraphItem) hyperlink1, paraItems);
        this.AddToParagraph((ParagraphItem) wtextRange, paraItems);
      }
      else
      {
        DictionaryEntry relation = this.GetRelation(str1);
        if (relation.Key == null || relation.Key.ToString() != "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink")
          return false;
        this.AddToParagraph((ParagraphItem) hyperlink1, paraItems);
        this.AddToParagraph((ParagraphItem) wtextRange, paraItems);
        string text = (string) relation.Value;
        if (this.StartsWithExt(text, "#"))
        {
          hyperlink2.Type = HyperlinkType.Bookmark;
          hyperlink2.BookmarkName = text.Replace("#", string.Empty);
        }
        else
          hyperlink1.m_fieldValue = $"\"{text.Replace("\\", "\\\\")}\"";
        if (this.m_isExternalHyperlink != null && this.m_docRelations.ContainsKey(str1))
        {
          if (this.IsExternalHyperlink.ContainsKey(str1) && this.IsExternalHyperlink[str1])
          {
            if (attribute1 != null)
            {
              hyperlink1.IsLocal = true;
              hyperlink1.LocalReference = attribute1;
            }
          }
          else
            hyperlink1.IsLocal = true;
        }
      }
    }
    this.FieldStack.Push(hyperlink1);
    WFieldMark wfieldMark1 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldSeparator);
    this.AddToParagraph((ParagraphItem) wfieldMark1, paraItems);
    hyperlink1.FieldSeparator = wfieldMark1;
    hyperlink2.SetHyperlinkFieldCode();
    string str2 = this.IsWord2003ML ? "hlink" : "hyperlink";
    if (!(reader.LocalName.ToLower() == str2))
      return true;
    this.ParseHyperlinkText(reader, paraItems);
    if (paraItems.Count > wfieldMark1.Index + 1 && paraItems[wfieldMark1.Index + 1] != null && paraItems[wfieldMark1.Index + 1].ParaItemCharFormat.Hidden)
    {
      for (int index = hyperlink1.Index; index <= wfieldMark1.Index; ++index)
        paraItems[index].ParaItemCharFormat.Hidden = true;
    }
    WFieldMark wfieldMark2 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldEnd);
    if (paraItems.Count > wfieldMark1.Index + 1 && paraItems[wfieldMark1.Index + 1] != null && paraItems[paraItems.Count - 1].ParaItemCharFormat.Hidden)
      wfieldMark2.CharacterFormat.Hidden = true;
    this.AddToParagraph((ParagraphItem) wfieldMark2, paraItems);
    hyperlink1.FieldEnd = wfieldMark2;
    this.FieldStack.Pop();
    return false;
  }

  private DictionaryEntry GetRelation(string id)
  {
    DictionaryEntry relation = new DictionaryEntry();
    if (this.m_currentFile.Contains("header") || this.m_currentFile.Contains("footer") || this.StartsWithExt(this.m_currentFile, "comments") || this.StartsWithExt(this.m_currentFile, "footnotes") || this.StartsWithExt(this.m_currentFile, "endnotes"))
    {
      string name = string.Empty;
      if (this.m_currentFile.Contains("header") || this.m_currentFile.Contains("footer"))
        name = this.m_currentFile;
      else if (this.StartsWithExt(this.m_currentFile, "comments"))
        name = "comments.xml.rels";
      else if (this.StartsWithExt(this.m_currentFile, "footnotes"))
        name = "footnotes.xml.rels";
      else if (this.StartsWithExt(this.m_currentFile, "endnotes"))
        name = "endnotes.xml.rels";
      Dictionary<string, DictionaryEntry> fileRelations = this.GetFileRelations(name);
      if (fileRelations != null && fileRelations.ContainsKey(id))
        relation = fileRelations[id];
    }
    else if (this.m_docRelations.ContainsKey(id))
      relation = this.m_docRelations[id];
    return relation;
  }

  private void ParseHyperlinkText(XmlReader reader, ParagraphItemCollection paraItems)
  {
    reader.MoveToElement();
    string message = this.IsWord2003ML ? "hlink" : "hyperlink";
    if (reader.LocalName != message)
      throw new XmlException(message);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    this.IsHyperLinkField = true;
    while (reader.LocalName != message)
    {
      if (reader.LocalName == "r")
        this.ParseRun(reader, paraItems, (IOfficeMathRunElement) null, false, reader.NodeType, false);
      reader.Read();
      this.SkipWhitespaces(reader);
    }
    this.m_currentRunFormat = (WCharacterFormat) null;
    this.IsHyperLinkField = false;
  }

  private bool ParseFieldSimple(XmlReader reader, ParagraphItemCollection paraItems)
  {
    string fieldCode = reader.GetAttribute("instr", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(fieldCode))
      fieldCode = this.ModifyText(reader.ReadInnerXml());
    WField fieldByType = new WField((IWordDocument) this.m_doc).CreateFieldByType(fieldCode, FieldType.FieldUnknown);
    fieldByType.UpdateFieldCode(fieldCode);
    WTextRange wtextRange = new WTextRange((IWordDocument) this.m_doc);
    wtextRange.Text = fieldCode;
    if (this.m_currentRunFormat != null)
    {
      fieldByType.ApplyCharacterFormat(this.m_currentRunFormat);
      this.ApplyDirectionalOverride(fieldByType.CharacterFormat);
      wtextRange.ApplyCharacterFormat(fieldByType.CharacterFormat);
    }
    bool flag1 = fieldByType.FieldType == FieldType.FieldTOC && !this.m_doc.TOC.ContainsKey(fieldByType);
    if (flag1)
    {
      this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 15);
      TableOfContent tableOfContent = new TableOfContent((IWordDocument) this.m_doc, fieldByType.FormattingString);
      this.m_doc.TOC.Add(fieldByType, tableOfContent);
      this.AddItem((ParagraphItem) tableOfContent, paraItems);
      paraItems.Add((IEntity) wtextRange);
    }
    else
    {
      this.AddItem((ParagraphItem) fieldByType, paraItems);
      paraItems.Add((IEntity) wtextRange);
    }
    if (!reader.IsEmptyElement)
    {
      string localName = reader.LocalName;
      reader.Read();
      bool flag2 = true;
      if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      {
        WFieldMark wfieldMark1 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldSeparator);
        this.AddItem((ParagraphItem) wfieldMark1, paraItems);
        fieldByType.FieldSeparator = wfieldMark1;
        WFieldMark wfieldMark2 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldEnd);
        this.AddItem((ParagraphItem) wfieldMark2, paraItems);
        fieldByType.FieldEnd = wfieldMark2;
        return false;
      }
      WFieldMark wfieldMark3 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldSeparator);
      this.AddItem((ParagraphItem) wfieldMark3, paraItems);
      if (flag1 && this.m_doc.TOC.ContainsKey(fieldByType))
        this.m_doc.TOC[fieldByType].TOCField.FieldSeparator = wfieldMark3;
      else
        fieldByType.FieldSeparator = wfieldMark3;
      fieldByType.FieldSeparator = wfieldMark3;
      if (flag2)
        this.ParseParagraphItems(reader, paraItems, localName, (IOfficeMathRunElement) null, false);
      else
        this.ParseParagraphItems(reader, paraItems, (string) null, (IOfficeMathRunElement) null, false);
      WFieldMark wfieldMark4 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldEnd);
      this.AddItem((ParagraphItem) wfieldMark4, paraItems);
      if (flag1 && this.m_doc.TOC.ContainsKey(fieldByType))
        this.m_doc.TOC[fieldByType].TOCField.FieldEnd = wfieldMark4;
      else
        fieldByType.FieldEnd = wfieldMark4;
      return true;
    }
    WFieldMark wfieldMark5 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldSeparator);
    this.AddItem((ParagraphItem) wfieldMark5, paraItems);
    fieldByType.FieldSeparator = wfieldMark5;
    WFieldMark wfieldMark6 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldEnd);
    this.AddItem((ParagraphItem) wfieldMark6, paraItems);
    fieldByType.FieldEnd = wfieldMark6;
    return false;
  }

  private string GetBookmarkName(string bookmarkId)
  {
    for (int index = 0; index < this.BookmarkNames.Count; ++index)
    {
      if (this.BookmarkNames[index].bookmarkId != null && this.BookmarkNames[index].bookmarkId.Equals(bookmarkId))
        return this.BookmarkNames[index].bookmarName;
    }
    return (string) null;
  }

  private bool RemoveBookmarkName(string bookmarkId)
  {
    for (int index = 0; index < this.BookmarkNames.Count; ++index)
    {
      if (this.BookmarkNames[index].bookmarkId != null && this.BookmarkNames[index].bookmarkId.Equals(bookmarkId))
      {
        this.BookmarkNames.RemoveAt(index);
        return true;
      }
    }
    return false;
  }

  private void ParseBookmarkEnd(XmlReader reader, ParagraphItemCollection paraItems)
  {
    string attribute1 = reader.GetAttribute("id", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    string bookmarkName = this.GetBookmarkName(attribute1);
    if (bookmarkName == null)
      return;
    BookmarkEnd bookmarkEnd = new BookmarkEnd((IWordDocument) this.m_doc, bookmarkName);
    string attribute2 = reader.GetAttribute("displacedByCustomXml", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute2))
      bookmarkEnd.DisplacedByCustomXml = attribute2;
    paraItems.Add((IEntity) bookmarkEnd);
    if (this.moveRevision != null)
      this.moveRevision.Range.Items.Add((object) bookmarkEnd);
    this.RemoveBookmarkName(attribute1);
  }

  private void ParseBookmarkEnd(XmlReader reader, IEntity ent)
  {
    string attribute1 = reader.GetAttribute("id", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    string bookmarkName = this.GetBookmarkName(attribute1);
    string attribute2 = reader.GetAttribute("displacedByCustomXml", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    BookmarkEnd bkmkEnd = (BookmarkEnd) null;
    WTable ownerTable = this.GetOwnerTable(ent);
    bool isAfterTable = ownerTable != null && ownerTable.LastRow != null;
    if (bookmarkName == null)
      return;
    WParagraph wparagraph = this.GetOwnerParagraph(ent, isAfterTable);
    if (isAfterTable)
      wparagraph = this.GetEndParagraph(ownerTable.LastRow);
    if (this.IsUpdateBkmkEnd(bkmkEnd, bookmarkName, ent, attribute2, isAfterTable))
      return;
    Bookmark byName = this.m_doc.Bookmarks.FindByName(bookmarkName);
    if (wparagraph != null && byName != null)
    {
      BookmarkEnd bookmarkEnd = wparagraph.AppendBookmarkEnd(bookmarkName);
      if (!string.IsNullOrEmpty(attribute2))
        bookmarkEnd.DisplacedByCustomXml = attribute2;
      this.RemoveBookmarkName(attribute1);
      if ((ent == null || ent is WTableCell || ent is BlockContentControl) && !isAfterTable)
        bookmarkEnd.IsAfterParagraphMark = true;
      else if (ent is WTableRow)
        bookmarkEnd.IsAfterCellMark = true;
      else if (ent is WTable)
      {
        bookmarkEnd.IsAfterRowMark = true;
      }
      else
      {
        if (!isAfterTable)
          return;
        bookmarkEnd.IsAfterTableMark = true;
      }
    }
    else
    {
      BookmarkEnd bookmarkEnd = new BookmarkEnd((IWordDocument) this.m_doc, bookmarkName);
      if (!string.IsNullOrEmpty(attribute2))
        bookmarkEnd.DisplacedByCustomXml = attribute2;
      this.BookMarkCollection.Add((Entity) bookmarkEnd);
    }
  }

  private bool IsUpdateBkmkEnd(
    BookmarkEnd bkmkEnd,
    string bkmkName,
    IEntity entity,
    string displacedByCustomXml,
    bool isAfterTable)
  {
    bool flag = false;
    if (entity != null)
    {
      switch (entity.EntityType)
      {
        case Syncfusion.DocIO.DLS.EntityType.HeaderFooter:
          Entity lastItem1 = (entity as HeaderFooter).ChildEntities.LastItem;
          if (lastItem1 != null && lastItem1 is AlternateChunk)
          {
            flag = true;
            break;
          }
          break;
        case Syncfusion.DocIO.DLS.EntityType.BlockContentControl:
          WTextBody textBody1 = (entity as BlockContentControl).TextBody;
          if (textBody1.ChildEntities.LastItem != null && textBody1.ChildEntities.LastItem is AlternateChunk)
          {
            flag = true;
            break;
          }
          break;
        case Syncfusion.DocIO.DLS.EntityType.Table:
          Entity lastCell1 = (Entity) (entity as WTable).LastCell;
          if (lastCell1 != null && lastCell1 is WTableCell)
          {
            Entity lastItem2 = (lastCell1 as WTableCell).ChildEntities.LastItem;
            if (lastItem2 != null && lastItem2 is AlternateChunk)
            {
              flag = true;
              break;
            }
            break;
          }
          break;
        case Syncfusion.DocIO.DLS.EntityType.TableRow:
          Entity lastItem3 = (entity as WTableRow).ChildEntities.LastItem;
          if (lastItem3 != null && lastItem3 is WTableCell)
          {
            Entity lastItem4 = (lastItem3 as WTableCell).ChildEntities.LastItem;
            if (lastItem4 != null && lastItem4 is AlternateChunk)
            {
              flag = true;
              break;
            }
            break;
          }
          break;
        case Syncfusion.DocIO.DLS.EntityType.TableCell:
          Entity lastItem5 = (entity as WTableCell).ChildEntities.LastItem;
          if (lastItem5 != null && lastItem5 is AlternateChunk)
          {
            flag = true;
            break;
          }
          break;
        case Syncfusion.DocIO.DLS.EntityType.Comment:
          WTextBody textBody2 = (entity as WComment).TextBody;
          if (textBody2.ChildEntities.LastItem != null && textBody2.ChildEntities.LastItem is AlternateChunk)
          {
            flag = true;
            break;
          }
          break;
        case Syncfusion.DocIO.DLS.EntityType.Footnote:
          WTextBody textBody3 = (entity as WFootnote).TextBody;
          if (textBody3.ChildEntities.LastItem != null && textBody3.ChildEntities.LastItem is AlternateChunk)
          {
            flag = true;
            break;
          }
          break;
      }
    }
    else
    {
      Entity lastItem6 = this.m_doc.LastSection.Body.ChildEntities.LastItem;
      if (lastItem6 != null && lastItem6 is AlternateChunk)
        flag = true;
      else if (lastItem6 != null && lastItem6 is WTable)
      {
        Entity lastCell2 = (Entity) (lastItem6 as WTable).LastCell;
        if (lastCell2 != null && lastCell2 is WTableCell)
        {
          Entity lastItem7 = (lastCell2 as WTableCell).ChildEntities.LastItem;
          if (lastItem7 != null && lastItem7 is AlternateChunk)
            flag = true;
        }
      }
    }
    if (this.m_doc.LastSection == null || !flag)
      return false;
    int count = this.m_doc.LastSection.Body.AlternateChunkCollection.Count;
    if (count <= 0)
      return false;
    AlternateChunk alternateChunk = this.m_doc.LastSection.Body.AlternateChunkCollection[count - 1];
    bkmkEnd = new BookmarkEnd((IWordDocument) this.m_doc, bkmkName);
    if (!string.IsNullOrEmpty(displacedByCustomXml))
      bkmkEnd.DisplacedByCustomXml = displacedByCustomXml;
    alternateChunk.AltChunkBookmarks.Add((Entity) bkmkEnd);
    bkmkEnd.IsAfterParagraphMark = true;
    if (entity is WTableRow)
      bkmkEnd.IsAfterCellMark = true;
    else if (entity is WTable)
      bkmkEnd.IsAfterRowMark = true;
    else if (isAfterTable)
      bkmkEnd.IsAfterTableMark = true;
    return true;
  }

  private WParagraph GetEndParagraph(WTableCell cell)
  {
    WParagraph endParagraph = (WParagraph) null;
    if (cell.Items != null && cell.Items.Count > 0)
      endParagraph = cell.Items[cell.Items.Count - 1] as WParagraph;
    return endParagraph;
  }

  private WParagraph GetEndParagraph(WTableRow row)
  {
    WParagraph endParagraph = (WParagraph) null;
    if (row.Cells.Count > 0)
      endParagraph = this.GetEndParagraph(row.Cells[row.Cells.Count - 1]);
    return endParagraph;
  }

  private void ParseBookmarkStart(XmlReader reader, ParagraphItemCollection paraItems)
  {
    string attribute1 = reader.GetAttribute("name", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    string attribute2 = reader.GetAttribute("id", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
    BookmarkStart bookmarkStart = new BookmarkStart((IWordDocument) this.m_doc, attribute1);
    string attribute3 = reader.GetAttribute("colFirst", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
    if (!string.IsNullOrEmpty(attribute3))
      bookmarkStart.ColumnFirst = (short) this.ParseIntegerValue(attribute3);
    string attribute4 = reader.GetAttribute("colLast", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : (this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
    if (!string.IsNullOrEmpty(attribute4))
      bookmarkStart.ColumnLast = (short) this.ParseIntegerValue(attribute4);
    string attribute5 = reader.GetAttribute("displacedByCustomXml", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute5))
      bookmarkStart.DisplacedByCustomXml = attribute5;
    this.BookmarkNames.Add(new DocxParser.BookmarkInfo()
    {
      bookmarName = attribute1,
      bookmarkId = attribute2
    });
    if (paraItems == null)
    {
      this.BookMarkCollection.Add((Entity) bookmarkStart);
    }
    else
    {
      paraItems.Add((IEntity) bookmarkStart);
      if (this.moveRevision == null)
        return;
      this.moveRevision.Range.Items.Add((object) bookmarkStart);
    }
  }

  private void ParseMoveRangeEnd(XmlReader reader, IEntity ent)
  {
    WTable ownerTable = this.GetOwnerTable(ent);
    bool isAfterTable = ownerTable != null && ownerTable.LastRow != null;
    WParagraph wparagraph = this.GetOwnerParagraph(ent, isAfterTable);
    if (isAfterTable)
      wparagraph = this.GetEndParagraph(ownerTable.LastRow);
    if (wparagraph == null || this.moveRevision == null)
      return;
    if ((ent == null || ent is WTableCell || ent is BlockContentControl) && !isAfterTable)
      this.moveRevision.IsAfterParagraphMark = true;
    else if (ent is WTableRow)
      this.moveRevision.IsAfterCellMark = true;
    else if (ent is WTable)
    {
      this.moveRevision.IsAfterRowMark = true;
    }
    else
    {
      if (!isAfterTable)
        return;
      this.moveRevision.IsAfterTableMark = true;
    }
  }

  private void ParseEditableRangeEnd(XmlReader reader, ParagraphItemCollection paraItems)
  {
    string attribute = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute == null)
      return;
    EditableRangeEnd editableRangeEnd = new EditableRangeEnd((IWordDocument) this.m_doc, attribute);
    paraItems.Add((IEntity) editableRangeEnd);
  }

  private void ParseEditableRangeEnd(XmlReader reader, IEntity ent)
  {
    string attribute = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    WTable ownerTable = this.GetOwnerTable(ent);
    bool isAfterTable = ownerTable != null && ownerTable.LastRow != null;
    if (attribute == null)
      return;
    WParagraph wparagraph = this.GetOwnerParagraph(ent, isAfterTable);
    if (isAfterTable)
      wparagraph = this.GetEndParagraph(ownerTable.LastRow);
    if (wparagraph != null)
    {
      EditableRangeEnd editableRangeEnd = wparagraph.AppendEditableRangeEnd(attribute);
      switch (ent)
      {
        case WTableCell _ when !isAfterTable:
          editableRangeEnd.IsAfterParagraphMark = true;
          break;
        case WTableRow _:
          editableRangeEnd.IsAfterCellMark = true;
          break;
        case WTable _:
          editableRangeEnd.IsAfterRowMark = true;
          break;
        default:
          if (!isAfterTable)
            break;
          editableRangeEnd.IsAfterTableMark = true;
          break;
      }
    }
    else
      this.EditableRangeCollection.Add((Entity) new EditableRangeEnd((IWordDocument) this.m_doc, attribute));
  }

  private WTable GetOwnerTable(IEntity entity)
  {
    WTable ownerTable = (WTable) null;
    switch (entity)
    {
      case null:
        if (this.m_doc.LastSection.Body.ChildEntities.Count > 0 && this.m_doc.LastSection.Body.ChildEntities[this.m_doc.LastSection.Body.ChildEntities.Count - 1] is WTable)
        {
          ownerTable = this.m_doc.LastSection.Body.ChildEntities[this.m_doc.LastSection.Body.ChildEntities.Count - 1] as WTable;
          break;
        }
        break;
      case WTableCell _:
        WTableCell wtableCell = entity as WTableCell;
        if (wtableCell.ChildEntities.Count > 0 && wtableCell.ChildEntities[wtableCell.ChildEntities.Count - 1] is WTable)
        {
          ownerTable = wtableCell.ChildEntities[wtableCell.ChildEntities.Count - 1] as WTable;
          break;
        }
        break;
      case BlockContentControl _:
        BlockContentControl blockContentControl = (BlockContentControl) entity;
        if (blockContentControl.ChildEntities.Count > 0 && blockContentControl.ChildEntities[blockContentControl.ChildEntities.Count - 1] is WTable)
        {
          ownerTable = blockContentControl.ChildEntities[blockContentControl.ChildEntities.Count - 1] as WTable;
          break;
        }
        break;
    }
    return ownerTable;
  }

  private WParagraph GetOwnerParagraph(IEntity entity, bool isAfterTable)
  {
    WParagraph ownerParagraph = (WParagraph) null;
    if (entity is WParagraph)
      ownerParagraph = entity as WParagraph;
    else if (entity == null && !isAfterTable)
    {
      ownerParagraph = this.m_doc.LastSection.Body.ChildEntities.LastItem != null ? this.GetOwnerParagraph((IEntity) this.m_doc.LastSection.Body.ChildEntities.LastItem, false) : (WParagraph) null;
    }
    else
    {
      switch (entity)
      {
        case WTable _ when (entity as WTable).OwnerTextBody != null:
          WTableRow lastRow = (entity as WTable).LastRow;
          ownerParagraph = lastRow == null ? (entity as WTable).OwnerTextBody.AddParagraph() as WParagraph : this.GetEndParagraph(lastRow);
          break;
        case WTableCell _ when !isAfterTable:
          ownerParagraph = this.GetEndParagraph(entity as WTableCell);
          break;
        case WTableRow _:
          ownerParagraph = this.GetEndParagraph(entity as WTableRow);
          break;
        case BlockContentControl _ when !isAfterTable:
          ownerParagraph = ((BlockContentControl) entity).GetLastParagraphOfSDTContent();
          break;
      }
    }
    return ownerParagraph;
  }

  internal WParagraph GetMathOwnerParagraph(IOfficeMathFunctionBase mathFunctionBase)
  {
    IOfficeMathEntity ownerMathEntity = mathFunctionBase.OwnerMathEntity;
    while (!(ownerMathEntity is OfficeMathParagraph))
      ownerMathEntity = ownerMathEntity.OwnerMathEntity;
    if (ownerMathEntity is OfficeMathParagraph && (ownerMathEntity as OfficeMathParagraph).Owner is WMath)
    {
      WMath owner = (ownerMathEntity as OfficeMathParagraph).Owner as WMath;
      if (owner.Owner is WParagraph)
        return owner.Owner as WParagraph;
      if (owner.Owner is InlineContentControl)
        return (owner.Owner as InlineContentControl).GetOwnerParagraphValue();
      if (owner.Owner is XmlParagraphItem)
        return (owner.Owner as XmlParagraphItem).GetOwnerParagraphValue();
    }
    return (WParagraph) null;
  }

  private void ParseEditableRangeStart(XmlReader reader, ParagraphItemCollection paraItems)
  {
    EditableRangeStart editableRangeStart = new EditableRangeStart((IWordDocument) this.m_doc, reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
    string attribute1 = reader.GetAttribute("colFirst", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute1))
      editableRangeStart.ColumnFirst = (short) this.ParseIntegerValue(attribute1);
    string attribute2 = reader.GetAttribute("colLast", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute2))
      editableRangeStart.ColumnLast = (short) this.ParseIntegerValue(attribute2);
    string attribute3 = reader.GetAttribute("ed", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute3))
      editableRangeStart.Ed = attribute3;
    string attribute4 = reader.GetAttribute("edGrp", this.IsWord2003ML ? "http://schemas.microsoft.com/aml/2001/core" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute4))
      editableRangeStart.EdGrp = attribute4;
    if (paraItems == null)
      this.EditableRangeCollection.Add((Entity) editableRangeStart);
    else
      paraItems.Add((IEntity) editableRangeStart);
  }

  private void CreateRunFormat(ParagraphItemCollection paraItems)
  {
    WParagraph wparagraph = paraItems.OwnerBase as WParagraph;
    if (paraItems.Owner is InlineContentControl)
      wparagraph = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
    else if (paraItems.Owner is XmlParagraphItem)
      wparagraph = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
    else if (paraItems.Owner is XmlParagraphItem)
      wparagraph = paraItems.Owner.Owner as WParagraph;
    this.m_currentRunFormat = new WCharacterFormat((IWordDocument) this.m_doc);
    this.ApplyDirectionalOverride(this.m_currentRunFormat);
    if (wparagraph == null || wparagraph.ParaStyle == null)
      return;
    this.m_currentRunFormat.ApplyBase((FormatBase) wparagraph.ParaStyle.CharacterFormat);
  }

  private void ParseRunValues(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    IOfficeMathRunElement mathParaItem,
    bool isMappedPictureContentControl)
  {
    bool flag1 = false;
    bool flag2 = false;
    bool flag3 = false;
    ParagraphItem paragraphItem1 = (ParagraphItem) null;
    MemoryStream drawingStream = (MemoryStream) null;
    bool isFirstNestedParaOccured = false;
    string str = (string) null;
    this.SkipWhitespaces(reader);
    while ((!(reader.LocalName == "r") || reader.NodeType != XmlNodeType.EndElement) && (!(reader.LocalName == "ins") || reader.NodeType != XmlNodeType.EndElement))
    {
      ParagraphItem paragraphItem2 = (ParagraphItem) null;
      bool flag4 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "r":
            this.ApplyDirectionalOverride(this.m_currentRunFormat);
            WCharacterFormat currentRunFormat = this.m_currentRunFormat;
            this.ParseRun(reader, paraItems, mathParaItem, false, reader.NodeType, isMappedPictureContentControl);
            this.m_currentRunFormat = currentRunFormat;
            break;
          case "rPr":
            if (reader.Name == "m:rPr")
            {
              new MathMLParser().ParseMathRunFormat(reader, mathParaItem.MathFormat as OfficeMathFormat);
              break;
            }
            WParagraph wparagraph1;
            if (mathParaItem != null)
            {
              wparagraph1 = this.GetMathOwnerParagraph((IOfficeMathFunctionBase) mathParaItem);
            }
            else
            {
              wparagraph1 = paraItems.OwnerBase as WParagraph;
              if (paraItems.Owner is InlineContentControl)
                wparagraph1 = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
              else if (paraItems.Owner is XmlParagraphItem)
                wparagraph1 = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
            }
            this.m_currentRunFormat = new WCharacterFormat((IWordDocument) this.m_doc);
            this.ApplyDirectionalOverride(this.m_currentRunFormat);
            if (wparagraph1 != null && wparagraph1.ParaStyle != null)
              this.m_currentRunFormat.ApplyBase((FormatBase) wparagraph1.ParaStyle.CharacterFormat);
            this.ParseCharacterFormat(reader, this.m_currentRunFormat, paraItems);
            break;
          case "delInstrText":
          case "instrText":
          case "delText":
          case "t":
            paragraphItem2 = (ParagraphItem) this.ParseText(reader, paraItems, false, mathParaItem != null);
            break;
          case "drawing":
            if (flag1 && flag2 && !flag3)
            {
              paragraphItem1 = this.ParseDrawing(reader, paraItems, ref drawingStream, isMappedPictureContentControl);
              paragraphItem2 = paragraphItem1;
              switch (paragraphItem2)
              {
                case Shape _:
                case GroupShape _:
                case XmlParagraphItem _:
                case WPicture _:
                  if (paragraphItem1 is Shape && (paragraphItem1 as Shape).AutoShapeType == Syncfusion.DocIO.DLS.AutoShapeType.Rectangle && (paragraphItem1 as Shape).TextBody.Count > 0)
                  {
                    paragraphItem2 = (ParagraphItem) null;
                    break;
                  }
                  break;
                default:
                  paragraphItem2 = (ParagraphItem) null;
                  if (!(paragraphItem1 is XmlParagraphItem))
                  {
                    paragraphItem1 = (ParagraphItem) null;
                    break;
                  }
                  break;
              }
            }
            else
            {
              paragraphItem2 = this.ParseDrawing(reader, paraItems, ref drawingStream, isMappedPictureContentControl);
              if (flag1 && flag2 && flag3 && paragraphItem1 != null && paragraphItem2 != null && paragraphItem1.EntityType != paragraphItem2.EntityType)
                paragraphItem2 = paragraphItem1;
            }
            flag4 = true;
            break;
          case "rStyle":
            if (this.m_currentRunFormat == null)
              this.CreateRunFormat(paraItems);
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1) && this.StyleNameId.ContainsKey(attribute1))
              this.m_currentRunFormat.CharStyleName = this.StyleNameId[attribute1];
            List<string> list = new List<string>();
            list.AddRange((IEnumerable<string>) this.StyleNameId.Values);
            Dictionary<string, int> dictionary = this.CountOccurrencesOfValue(list);
            if (this.m_currentRunFormat.CharStyleName != null && dictionary[this.m_currentRunFormat.CharStyleName] > 1)
            {
              this.m_currentRunFormat.CharStyleId = attribute1;
              break;
            }
            break;
          case "object":
            paragraphItem2 = this.ParseObject(reader);
            if (this.m_doc.Settings.PreserveOleImageAsImage && paragraphItem2 is WOleObject && (paragraphItem2 as WOleObject).LinkType == OleLinkType.Embed && (paragraphItem2 as WOleObject).ObjectType == "PBrush")
              paragraphItem2 = (ParagraphItem) ((paragraphItem2 as WOleObject).OlePicture.Clone() as WPicture);
            flag4 = true;
            break;
          case "pict":
            MemoryStream memoryStream = this.ReadSingleNodeIntoStream(reader);
            if (paragraphItem1 != null && paragraphItem1 is XmlParagraphItem)
            {
              this.ParseXmlParaItem((Stream) memoryStream);
              break;
            }
            if (!this.IsWord2003ML || !this.HasOleObject((Stream) memoryStream))
              paragraphItem2 = this.ParseShape(reader, paraItems, drawingStream, memoryStream);
            if (paragraphItem2 is Shape && paragraphItem1 is Shape && (paragraphItem1 as Shape).EffectList.Count == (paragraphItem2 as Shape).EffectList.Count)
            {
              for (int index = 0; index < (paragraphItem2 as Shape).EffectList.Count; ++index)
              {
                if ((paragraphItem2 as Shape).EffectList[index].IsShadowEffect && (paragraphItem1 as Shape).EffectList[index].IsShadowEffect)
                {
                  (paragraphItem1 as Shape).EffectList[index].ShadowFormat.NonChoiceShadowOffsetX = (paragraphItem2 as Shape).EffectList[index].ShadowFormat.ShadowOffsetX;
                  (paragraphItem1 as Shape).EffectList[index].ShadowFormat.NonChoiceShadowOffsetY = (paragraphItem2 as Shape).EffectList[index].ShadowFormat.ShadowOffsetY;
                }
              }
            }
            if (flag1 && flag2 && paragraphItem2 is WTextBox)
            {
              if (paragraphItem1 is XmlParagraphItem)
                this.ParseTextBoxGraphics(paragraphItem2 as WTextBox, paragraphItem1 as XmlParagraphItem);
              else if (paragraphItem1 != null && paragraphItem1 is Shape)
                (paragraphItem2 as WTextBox).TextBoxFormat.TextThemeColor = (paragraphItem1 as Shape).FontRefColor;
              if (this.m_doc.Settings.CompatibilityMode != CompatibilityMode.Word2007 && paragraphItem1 != null && paragraphItem1 is Shape && paragraphItem2 is WTextBox)
              {
                Shape shape = paragraphItem1 as Shape;
                WTextBox wtextBox = paragraphItem2 as WTextBox;
                InternalMargin internalMargin1 = shape.TextFrame.InternalMargin;
                InternalMargin internalMargin2 = wtextBox.TextBoxFormat.InternalMargin;
                if (internalMargin1.PropertiesHash.ContainsKey(0))
                  internalMargin2.Left = internalMargin1.Left;
                if (internalMargin1.PropertiesHash.ContainsKey(1))
                  internalMargin2.Right = internalMargin1.Right;
                if (internalMargin1.PropertiesHash.ContainsKey(2))
                  internalMargin2.Top = internalMargin1.Top;
                if (internalMargin1.PropertiesHash.ContainsKey(3))
                  internalMargin2.Bottom = internalMargin1.Bottom;
                if (shape.LineFormat.PropertiesHash.ContainsKey(13))
                  wtextBox.TextBoxFormat.NoLine = !shape.LineFormat.Line;
                if (shape.TextFrame.PropertiesHash.ContainsKey(0))
                  wtextBox.TextBoxFormat.AutoFit = true;
                if (shape.TextFrame.PropertiesHash.ContainsKey(1))
                  wtextBox.TextBoxFormat.AutoFit = false;
                if (shape.TextFrame.PropertiesHash.ContainsKey(2))
                  wtextBox.TextBoxFormat.AutoFit = false;
              }
            }
            if (drawingStream != null && paragraphItem2 is WTextBox && paragraphItem1 is Shape && (paragraphItem1 as Shape).AutoShapeType == Syncfusion.DocIO.DLS.AutoShapeType.Rectangle && (paragraphItem1 as Shape).TextBody.Count > 0)
            {
              Shape shape = paragraphItem1 as Shape;
              WTextBox wtextBox = paragraphItem2 as WTextBox;
              if (!shape.IsRelativeHorizontalPosition)
              {
                wtextBox.TextBoxFormat.HorizontalAlignment = shape.HorizontalAlignment;
                wtextBox.TextBoxFormat.HorizontalOrigin = shape.HorizontalOrigin;
              }
              if (!shape.IsRelativeVerticalPosition)
              {
                wtextBox.TextBoxFormat.VerticalAlignment = shape.VerticalAlignment;
                wtextBox.TextBoxFormat.VerticalOrigin = shape.VerticalOrigin;
              }
              if (shape.LineFormat.PropertiesHash.ContainsKey(11))
                wtextBox.TextBoxFormat.LineWidth = shape.LineFormat.Weight;
              else
                wtextBox.TextBoxFormat.m_txbxLineWidth = 0.75f;
              if (!shape.LineFormat.PropertiesHash.ContainsKey(0))
                shape.LineFormat.LineJoin = LineJoin.Round;
              wtextBox.TextBoxFormat.WrapDistanceTop = shape.WrapFormat.DistanceTop;
              wtextBox.TextBoxFormat.WrapDistanceBottom = shape.WrapFormat.DistanceBottom;
              wtextBox.TextBoxFormat.WrapDistanceLeft = shape.WrapFormat.DistanceLeft;
              wtextBox.TextBoxFormat.WrapDistanceRight = shape.WrapFormat.DistanceRight;
              wtextBox.IsShape = true;
              wtextBox.Shape = paragraphItem1.Clone() as Shape;
              if (shape.TextBody.ChildEntities.Count > 0)
              {
                wtextBox.m_textBody = shape.TextBody.Clone() as WTextBody;
                wtextBox.m_textBody.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) (paragraphItem2 as WTextBox));
              }
              this.m_doc.RemoveRevisionFromCollection(shape.TextBody);
              paragraphItem1 = (ParagraphItem) null;
            }
            else if (flag3 && paragraphItem1 != null)
            {
              if (paragraphItem1 is Shape && paragraphItem2 is Shape)
                this.ImportDocxPropsAndXMLRelation(paragraphItem1 as Shape, paragraphItem2, (Stream) memoryStream);
              if (paragraphItem1 is GroupShape && paragraphItem2 is GroupShape)
              {
                this.ImportDocxPropsAndXMLRelation(paragraphItem1 as GroupShape, paragraphItem2, (Stream) memoryStream);
                this.UpdateTextBoxFormat((paragraphItem1 as GroupShape).ChildShapes, (paragraphItem2 as GroupShape).ChildShapes);
              }
              if (paragraphItem2 is Shape)
                this.m_doc.RemoveRevisionFromCollection((paragraphItem2 as Shape).TextBody);
              paragraphItem2 = (ParagraphItem) null;
            }
            flag4 = true;
            drawingStream = (MemoryStream) null;
            break;
          case "br":
          case "cr":
            if (isFirstNestedParaOccured)
            {
              WParagraph wparagraph2 = paraItems.OwnerBase as WParagraph;
              if (paraItems.Owner is InlineContentControl)
                wparagraph2 = (paraItems.Owner as InlineContentControl).GetOwnerParagraphValue();
              else if (paraItems.Owner is XmlParagraphItem)
                wparagraph2 = (paraItems.Owner as XmlParagraphItem).GetOwnerParagraphValue();
              paraItems = (wparagraph2.OwnerTextBody.AddParagraph() as WParagraph).Items;
            }
            this.ParseBreak(reader, paraItems, mathParaItem);
            break;
          case "fldChar":
            this.ParseFieldMark(reader, paraItems);
            flag4 = true;
            break;
          case "footnoteReference":
          case "endnoteReference":
            WCharacterFormat format = (WCharacterFormat) null;
            if (this.m_currentRunFormat != null)
            {
              this.ApplyDirectionalOverride(this.m_currentRunFormat);
              format = this.m_currentRunFormat;
            }
            paragraphItem2 = (ParagraphItem) this.ParseFootnote(reader);
            if ((paragraphItem2 as WFootnote).TextBody.AlternateChunkCollection.Count > 0)
            {
              foreach (AlternateChunk alternateChunk in (paragraphItem2 as WFootnote).TextBody.AlternateChunkCollection)
                this.m_doc.LastSection.Body.AlternateChunkCollection.Add(alternateChunk);
            }
            (paragraphItem2 as WFootnote).TextBody.AlternateChunkCollection.Clear();
            if (format != null)
            {
              (paragraphItem2 as WFootnote).MarkerCharacterFormat.ImportContainer((FormatBase) format);
              break;
            }
            break;
          case "footnoteRef":
          case "endnoteRef":
            paragraphItem2 = (ParagraphItem) this.ParseFootnoteMarker();
            break;
          case "tab":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 9);
            paragraphItem2 = (ParagraphItem) new WTextRange((IWordDocument) this.m_doc);
            string text = '\t'.ToString();
            this.UpdateTextRange(paragraphItem2 as WTextRange, text, this.m_currentRunFormat);
            break;
          case "sym":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 8);
            paragraphItem2 = this.ParseSymbol(reader, paraItems);
            break;
          case "noBreakHyphen":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 28);
            paragraphItem2 = (ParagraphItem) new WTextRange((IWordDocument) this.m_doc);
            this.UpdateTextRange(paragraphItem2 as WTextRange, '\u001E'.ToString(), this.m_currentRunFormat);
            break;
          case "softHyphen":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 7);
            paragraphItem2 = (ParagraphItem) new WTextRange((IWordDocument) this.m_doc);
            this.UpdateTextRange(paragraphItem2 as WTextRange, '\u001F'.ToString(), this.m_currentRunFormat);
            break;
          case "commentReference":
            string attribute2 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (this.Comments.ContainsKey(attribute2))
            {
              paragraphItem2 = (ParagraphItem) this.Comments[attribute2];
              break;
            }
            break;
          case "AlternateContent":
            flag1 = true;
            break;
          case "Choice":
            if (flag1)
            {
              flag2 = true;
              break;
            }
            break;
          case "symEx":
            if (flag2)
            {
              str = reader.GetAttribute("font", "http://schemas.microsoft.com/office/word/2015/wordml/symex");
              break;
            }
            break;
          case "Fallback":
            if (flag1 && !reader.IsEmptyElement)
            {
              string localName = reader.LocalName;
              reader.Read();
              if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                flag3 = true;
                flag4 = true;
                break;
              }
              break;
            }
            break;
          case "ptab":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 1);
            paragraphItem2 = this.ParseAbsoluteTab(reader);
            break;
          case "separator":
            paragraphItem2 = (ParagraphItem) new WTextRange((IWordDocument) this.m_doc);
            this.UpdateTextRange(paragraphItem2 as WTextRange, '\u0003'.ToString(), this.m_currentRunFormat);
            (paragraphItem2 as WTextRange).CharacterFormat.Special = true;
            break;
          case "continuationSeparator":
            paragraphItem2 = (ParagraphItem) new WTextRange((IWordDocument) this.m_doc);
            this.UpdateTextRange(paragraphItem2 as WTextRange, '\u0004'.ToString(), this.m_currentRunFormat);
            (paragraphItem2 as WTextRange).CharacterFormat.Special = true;
            break;
          case "fldSimple":
            flag4 = this.ParseFieldSimple(reader, paraItems);
            break;
          case "annotationRef":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 4);
            break;
          case "dayLong":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 13);
            break;
          case "dayShort":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 14);
            break;
          case "monthLong":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 22);
            break;
          case "monthShort":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 23);
            break;
          case "pgNum":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 18);
            this.AppendPageFieldForPgNum(paraItems);
            break;
          case "yearLong":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 0);
            break;
          case "yearShort":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 1);
            break;
          case "oMath":
          case "oMathPara":
            this.ParseMathMlElement(reader, paraItems);
            flag4 = true;
            break;
          case "p":
            this.ParseNestedParagraph(reader, paraItems, isFirstNestedParaOccured);
            isFirstNestedParaOccured = true;
            break;
          case "del":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 12);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            this.UpdateInsDelRevision(reader, paraItems, RevisionType.Deletions, mathParaItem, false);
            break;
          case "ins":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 24);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            this.UpdateInsDelRevision(reader, paraItems, RevisionType.Insertions, mathParaItem, false);
            break;
          case "altChunk":
            AlternateChunk alternateChunk1 = this.AddAlternateChunk((IEntity) null);
            this.AddBookmark(alternateChunk1);
            this.ParseAlternateChunk(reader, alternateChunk1);
            alternateChunk1.IsParagraphItem = true;
            break;
          default:
            if (this.IsWord2003ML)
            {
              switch (reader.LocalName)
              {
                case "annotation":
                  string attribute3 = reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml");
                  reader.GetAttribute("id", "http://schemas.microsoft.com/aml/2001/core");
                  if (attribute3 == "Word.Comment")
                  {
                    paragraphItem2 = (ParagraphItem) this.Parse2003Comment(reader);
                    break;
                  }
                  break;
                case "footnote":
                  paragraphItem2 = (ParagraphItem) this.Parse2003FootnotePart(reader, true);
                  break;
                case "endnote":
                  paragraphItem2 = (ParagraphItem) this.Parse2003FootnotePart(reader, false);
                  break;
              }
            }
            else
              break;
            break;
        }
        if (!flag4)
          reader.Read();
      }
      else if (reader.LocalName == "AlternateContent" && reader.NodeType == XmlNodeType.EndElement)
      {
        flag1 = false;
        if (flag2 && !flag3 && paragraphItem1 != null && this.IsChoiceItemNotAdded(paragraphItem1))
        {
          this.AddToParagraph(paragraphItem1, paraItems);
          this.CheckTrackChange(paragraphItem1);
        }
        flag2 = false;
        paragraphItem1 = (ParagraphItem) null;
        flag3 = false;
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
      if (paragraphItem2 != null)
      {
        if (!string.IsNullOrEmpty(str) && paragraphItem2 is WTextRange)
        {
          (paragraphItem2 as WTextRange).CharacterFormat.SymExFontName = str;
          str = (string) null;
        }
        if (mathParaItem != null)
          mathParaItem.Item = (IOfficeRun) paragraphItem2;
        else
          this.AddToParagraph(paragraphItem2, paraItems);
        this.CheckTrackChange(paragraphItem2);
        if (paragraphItem2 is WOleObject && paragraphItem2.m_revisions != null)
        {
          for (int index = paragraphItem2.Index + 1; index < paraItems.Count; ++index)
            this.CheckTrackChange(paraItems[index]);
        }
      }
    }
  }

  private void ParseRun(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    IOfficeMathRunElement mathParaItem,
    bool isAlreadyChecked,
    XmlNodeType nodeType,
    bool isMappedPictureContentControl)
  {
    while (nodeType != XmlNodeType.Element)
      reader.Read();
    if (isAlreadyChecked)
    {
      this.ParseRunValues(reader, paraItems, mathParaItem, isMappedPictureContentControl);
    }
    else
    {
      if (reader.IsEmptyElement)
        return;
      string localName = reader.LocalName;
      reader.Read();
      if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return;
      this.ParseRunValues(reader, paraItems, mathParaItem, isMappedPictureContentControl);
    }
  }

  private void UpdateTextBoxFormat(
    ChildShapeCollection choiceCollection,
    ChildShapeCollection fallbackCollection)
  {
    for (int index1 = 0; index1 < fallbackCollection.Count; ++index1)
    {
      ChildShape fallback = fallbackCollection[index1];
      if (fallback.ElementType == Syncfusion.DocIO.DLS.EntityType.TextBox)
      {
        for (int index2 = 0; index2 < choiceCollection.Count; ++index2)
        {
          ChildShape choice = choiceCollection[index2];
          if (choice.ElementType == Syncfusion.DocIO.DLS.EntityType.TextBox && choice.Name == fallback.Name && choice.TextBody.Count > 0)
          {
            choice.FillFormat.Fill = fallback.FillFormat.Fill;
            if (choice.FillFormat.IsDefaultFill)
              choice.FillFormat.IsDefaultFill = fallback.FillFormat.IsDefaultFill;
            choice.LineFormat.Line = fallback.LineFormat.Line;
            choice.FontRefColor = fallback.FontRefColor;
            if (this.m_doc.Settings.CompatibilityMode != CompatibilityMode.Word2007)
            {
              InternalMargin internalMargin1 = choice.TextFrame.InternalMargin;
              InternalMargin internalMargin2 = fallback.TextFrame.InternalMargin;
              if (internalMargin2.PropertiesHash.ContainsKey(0))
                internalMargin1.Left = internalMargin2.Left;
              if (internalMargin2.PropertiesHash.ContainsKey(1))
                internalMargin1.Right = internalMargin2.Right;
              if (internalMargin2.PropertiesHash.ContainsKey(2))
                internalMargin1.Top = internalMargin2.Top;
              if (internalMargin2.PropertiesHash.ContainsKey(3))
                internalMargin1.Bottom = internalMargin2.Bottom;
            }
          }
        }
      }
      else if (fallback.ElementType == Syncfusion.DocIO.DLS.EntityType.ChildGroupShape)
      {
        for (int index3 = 0; index3 < choiceCollection.Count; ++index3)
        {
          ChildShape choice = choiceCollection[index3];
          if (choice.ElementType == Syncfusion.DocIO.DLS.EntityType.ChildGroupShape && choice.Name == fallback.Name)
            this.UpdateTextBoxFormat((choice as ChildGroupShape).ChildShapes, (fallback as ChildGroupShape).ChildShapes);
        }
      }
    }
  }

  private bool IsChoiceItemNotAdded(ParagraphItem item)
  {
    if (!(item is Shape))
      return true;
    return (item as Shape).AutoShapeType == Syncfusion.DocIO.DLS.AutoShapeType.Rectangle && (item as Shape).TextBody.Count > 0;
  }

  private bool GetShapeLineFillType(Shape shape)
  {
    switch (shape.LineFormat.LineFormatType)
    {
      case LineFormatType.Solid:
      case LineFormatType.Patterned:
      case LineFormatType.Gradient:
        return true;
      default:
        return false;
    }
  }

  private void ImportDocxPropsAndXMLRelation(Shape shape, ParagraphItem item, Stream shapeStream)
  {
    shape.DocxProps.Add("pict", shapeStream);
    if (!(item is Shape))
      return;
    Shape shape1 = item as Shape;
    shape.Docx2007Props = shape1.Docx2007Props;
    if (shape.LineFormat.Color.IsEmpty && !shape1.LineFormat.Color.IsEmpty)
      shape.LineFormat.Color = shape1.LineFormat.Color;
    if (shape.FillFormat.Color.IsEmpty && !shape1.FillFormat.Color.IsEmpty)
      shape.FillFormat.Color = shape1.FillFormat.Color;
    if (shape.FillFormat.ForeColor.IsEmpty && !shape1.FillFormat.ForeColor.IsEmpty)
      shape.FillFormat.ForeColor = shape1.FillFormat.ForeColor;
    string[] array1 = new string[shape1.ImageRelations.Count];
    (item as Shape).ImageRelations.Keys.CopyTo(array1, 0);
    for (int index = 0; index < array1.Length; ++index)
    {
      if (!shape.ImageRelations.ContainsKey(array1[index]))
        shape.ImageRelations.Add(array1[index], shape1.ImageRelations[array1[index]]);
    }
    string[] array2 = new string[shape1.Relations.Count];
    shape1.Relations.Keys.CopyTo(array2, 0);
    for (int index = 0; index < array2.Length; ++index)
    {
      if (!shape.Relations.ContainsKey(array2[index]))
        shape.Relations.Add(array2[index], shape1.Relations[array2[index]]);
    }
  }

  private void ImportDocxPropsAndXMLRelation(
    GroupShape shape,
    ParagraphItem item,
    Stream shapeStream)
  {
    shape.DocxProps.Add("pict", shapeStream);
    if (!(item is GroupShape))
      return;
    GroupShape groupShape = item as GroupShape;
    if (shape.LineFormat.Color.IsEmpty && !groupShape.LineFormat.Color.IsEmpty)
      shape.LineFormat.Color = groupShape.LineFormat.Color;
    if (shape.FillFormat.Color.IsEmpty && !groupShape.FillFormat.Color.IsEmpty)
      shape.FillFormat.Color = groupShape.FillFormat.Color;
    if (shape.FillFormat.ForeColor.IsEmpty && !groupShape.FillFormat.ForeColor.IsEmpty)
      shape.FillFormat.ForeColor = groupShape.FillFormat.ForeColor;
    string[] array1 = new string[groupShape.ImageRelations.Count];
    (item as GroupShape).ImageRelations.Keys.CopyTo(array1, 0);
    for (int index = 0; index < array1.Length; ++index)
    {
      if (!shape.ImageRelations.ContainsKey(array1[index]))
        shape.ImageRelations.Add(array1[index], groupShape.ImageRelations[array1[index]]);
    }
    string[] array2 = new string[groupShape.Relations.Count];
    groupShape.Relations.Keys.CopyTo(array2, 0);
    for (int index = 0; index < array2.Length; ++index)
    {
      if (!shape.Relations.ContainsKey(array2[index]))
        shape.Relations.Add(array2[index], groupShape.Relations[array2[index]]);
    }
  }

  private ParagraphItem ParseAbsoluteTab(XmlReader reader)
  {
    string attribute1 = reader.GetAttribute("relativeTo", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    string attribute2 = reader.GetAttribute("alignment", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    string attribute3 = reader.GetAttribute("leader", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    WAbsoluteTab absoluteTab = new WAbsoluteTab((IWordDocument) this.m_doc);
    if (!string.IsNullOrEmpty(attribute1))
    {
      switch (attribute1.ToLower())
      {
        case "margin":
          absoluteTab.Relation = AbsoluteTabRelation.Margin;
          break;
        case "indent":
          absoluteTab.Relation = AbsoluteTabRelation.Indent;
          break;
      }
    }
    if (!string.IsNullOrEmpty(attribute2))
    {
      switch (attribute2.ToLower())
      {
        case "left":
          absoluteTab.Alignment = AbsoluteTabAlignment.Left;
          break;
        case "right":
          absoluteTab.Alignment = AbsoluteTabAlignment.Right;
          break;
        case "center":
          absoluteTab.Alignment = AbsoluteTabAlignment.Center;
          break;
      }
    }
    absoluteTab.TabLeader = this.GetTabLeader(attribute3);
    absoluteTab.CharacterFormat = this.m_currentRunFormat;
    this.ApplyDirectionalOverride(absoluteTab.CharacterFormat);
    return (ParagraphItem) absoluteTab;
  }

  private void ParseFieldMark(XmlReader reader, ParagraphItemCollection paraItems)
  {
    string attribute = reader.GetAttribute("fldCharType", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute == null)
      return;
    Stream stream = (Stream) this.ReadSingleNodeIntoStream(reader);
    if (this.HasFFData(stream))
    {
      this.ParseFieldData(UtilityMethods.CreateReader(stream), paraItems);
    }
    else
    {
      switch (attribute)
      {
        case "begin":
          this.InitFieldMarkBegin(paraItems);
          break;
        case "separate":
          this.ProcessFieldMarkSeperator(paraItems);
          break;
        case "end":
          this.ProcessFieldMarkEnd(paraItems);
          break;
      }
    }
  }

  private bool HasFFData(Stream fieldNode)
  {
    if (this.IsWord2003ML)
      return false;
    XmlReader reader = UtilityMethods.CreateReader(fieldNode);
    while (reader.Read())
    {
      if (reader.LocalName == "ffData")
        return true;
    }
    return false;
  }

  private bool HasOleObject(Stream fieldNode)
  {
    XmlReader reader = UtilityMethods.CreateReader(fieldNode);
    while (reader.Read())
    {
      if (reader.LocalName == "OLEObject")
        return true;
    }
    return false;
  }

  private void ProcessFieldMarkSeperator(ParagraphItemCollection paraItems)
  {
    if (this.CurrentField == null)
      return;
    WFieldMark wfieldMark = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldSeparator);
    if (this.m_currentRunFormat != null)
    {
      wfieldMark.CharacterFormat.ImportContainer((FormatBase) this.m_currentRunFormat);
      this.ApplyDirectionalOverride(wfieldMark.CharacterFormat);
    }
    this.AddItem((ParagraphItem) wfieldMark, paraItems);
    this.CheckTrackChange((ParagraphItem) wfieldMark);
    WField currentField = this.CurrentField;
    if (currentField == null)
      return;
    currentField.FieldSeparator = wfieldMark;
  }

  private void ProcessFieldMarkEnd(ParagraphItemCollection paraItems)
  {
    if (this.CurrentField == null)
      return;
    WFieldMark fieldMark = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldEnd);
    if (this.m_currentRunFormat != null)
    {
      fieldMark.CharacterFormat.ImportContainer((FormatBase) this.m_currentRunFormat);
      this.ApplyDirectionalOverride(fieldMark.CharacterFormat);
    }
    this.AddItem((ParagraphItem) fieldMark, paraItems);
    this.CheckTrackChange((ParagraphItem) fieldMark);
    if (this.CurrentField != null)
    {
      WField currentField = this.CurrentField;
      currentField.FieldEnd = fieldMark;
      this.m_doc.UpdateFieldRevision(currentField);
      if (currentField.IsFieldWithoutSeparator && currentField.FieldSeparator != null)
      {
        currentField.RemoveFieldSeparator(fieldMark);
        currentField.FieldSeparator = (WFieldMark) null;
      }
      if (currentField.FieldType == FieldType.FieldUnknown)
        this.UpdateFieldType(currentField, fieldMark);
      if (this.m_fieldStack != null && this.m_fieldStack.Count > 0)
      {
        WField wfield = this.m_fieldStack.Pop();
        if (wfield.FieldType != FieldType.FieldTOC)
          wfield.UpdateFieldCode(wfield.GetFieldCodeForUnknownFieldType());
        if (wfield.FieldType == FieldType.FieldDate || wfield.FieldType == FieldType.FieldTime)
          wfield.Update();
      }
    }
    this.m_currentRunFormat = (WCharacterFormat) null;
  }

  private void InitFieldMarkBegin(ParagraphItemCollection paraItems)
  {
    WField wfield = new WField((IWordDocument) this.m_doc);
    wfield.FieldType = FieldType.FieldUnknown;
    if (this.m_currentRunFormat != null)
    {
      wfield.ApplyCharacterFormat(this.m_currentRunFormat);
      this.ApplyDirectionalOverride(wfield.CharacterFormat);
    }
    this.AddToParagraph((ParagraphItem) wfield, paraItems);
    this.CheckTrackChange((ParagraphItem) wfield);
    this.FieldStack.Push(wfield);
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 18);
  }

  private void UpdateFieldType(WField parentField, WFieldMark fieldMark)
  {
    parentField.SetUnknownFieldType();
    if (parentField.FieldType == FieldType.FieldUnknown)
      return;
    if (parentField.FieldType == FieldType.FieldTOC)
    {
      parentField.ReplaceAsTOCField();
    }
    else
    {
      if (parentField.FieldType != FieldType.FieldIf && parentField.FieldType != FieldType.FieldMergeField && !parentField.IsFormField() && parentField.FieldType != FieldType.FieldSequence)
        return;
      parentField = parentField.ReplaceValidField();
      this.FieldStack.Pop();
      this.FieldStack.Push(parentField);
    }
  }

  private void AppendPageFieldForPgNum(ParagraphItemCollection paraItems)
  {
    WField wfield = new WField((IWordDocument) this.m_doc);
    wfield.SetFieldTypeValue(FieldType.FieldPage);
    wfield.m_fieldValue = "";
    paraItems.Add((IEntity) wfield);
    WTextRange wtextRange1 = new WTextRange((IWordDocument) this.m_doc);
    wtextRange1.Text = FieldTypeDefiner.GetFieldCode(FieldType.FieldPage) + " ";
    paraItems.Add((IEntity) wtextRange1);
    wtextRange1.ApplyCharacterFormat(this.m_currentRunFormat);
    WFieldMark wfieldMark1 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldSeparator);
    paraItems.Add((IEntity) wfieldMark1);
    wfield.FieldSeparator = wfieldMark1;
    WTextRange wtextRange2 = new WTextRange((IWordDocument) this.m_doc);
    paraItems.Add((IEntity) wtextRange2);
    WFieldMark wfieldMark2 = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldEnd);
    paraItems.Add((IEntity) wfieldMark2);
    wfield.FieldEnd = wfieldMark2;
    wfield.IsPgNum = true;
    wfield.ApplyCharacterFormat(this.m_currentRunFormat);
  }

  private void ParseFieldData(XmlReader reader, ParagraphItemCollection paraItems)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    int content = (int) reader.MoveToContent();
    string str = localName1;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "ffData":
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              Stream stream = (Stream) this.ReadSingleNodeIntoStream(reader);
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                WFormField formField = this.GetFormField(stream);
                if (formField != null)
                {
                  this.FieldStack.Push((WField) formField);
                  stream.Position = 0L;
                  this.ParseFormField(UtilityMethods.CreateReader(stream), formField);
                  if (this.m_currentRunFormat != null)
                  {
                    formField.ApplyCharacterFormat(this.m_currentRunFormat);
                    this.ApplyDirectionalOverride(formField.CharacterFormat);
                  }
                  this.m_currentRunFormat = (WCharacterFormat) null;
                  if (paraItems.OwnerBase is WParagraph)
                  {
                    this.AddToParagraph((ParagraphItem) formField, paraItems);
                    this.CheckTrackChange((ParagraphItem) formField);
                    continue;
                  }
                  continue;
                }
                continue;
              }
              continue;
            }
            continue;
          default:
            reader.Read();
            continue;
        }
      }
      else
        reader.Read();
    }
  }

  private void ParseFormField(XmlReader reader, WFormField formField)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    int content = (int) reader.MoveToContent();
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "checkBox":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 9);
            this.ParseCheckBox(reader, formField as WCheckBox);
            break;
          case "textInput":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 14);
            this.ParseTextInput(reader, formField as WTextFormField);
            break;
          case "ddList":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 15);
            this.ParseDropDown(reader, formField as WDropDownFormField);
            break;
          case "name":
            formField.Name = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
          case "enabled":
            formField.Enabled = this.GetBooleanValue(reader);
            break;
          case "calcOnExit":
            formField.CalculateOnExit = this.GetBooleanValue(reader);
            break;
          case "helpText":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute1))
            {
              formField.Help = attribute1;
              break;
            }
            break;
          case "statusText":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute2))
            {
              formField.StatusBarHelp = attribute2;
              break;
            }
            break;
          case "entryMacro":
            formField.MacroOnStart = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
          case "exitMacro":
            formField.MacroOnEnd = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseDropDown(XmlReader reader, WDropDownFormField dropDownFormField)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    int content = (int) reader.MoveToContent();
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "listEntry":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            dropDownFormField.DropDownItems.Add(attribute1);
            break;
          case "result":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute2))
            {
              dropDownFormField.DropDownSelectedIndex = (int) this.GetNumericValue(attribute2);
              break;
            }
            break;
          case "default":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute3))
            {
              dropDownFormField.DefaultDropDownValue = (int) this.GetNumericValue(attribute3);
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseTextInput(XmlReader reader, WTextFormField textFormField)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    int content = (int) reader.MoveToContent();
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "type":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            textFormField.SetTextFormFieldType(this.GetTextFieldType(attribute1));
            break;
          case "default":
            textFormField.DefaultText = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
          case "maxLength":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute2))
            {
              float result = 0.0f;
              if (float.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
              {
                textFormField.MaximumLength = (int) result;
                break;
              }
              textFormField.MaximumLength = attribute2.Trim(ControlChar.SpaceChar) == string.Empty ? 1 : "     ".Length;
              break;
            }
            break;
          case "format":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (textFormField.Type == TextFormFieldType.RegularText)
            {
              textFormField.TextFormat = this.GetTextFormat(attribute3);
              break;
            }
            textFormField.StringFormat = attribute3;
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private Syncfusion.DocIO.DLS.TextFormat GetTextFormat(string format)
  {
    if (string.IsNullOrEmpty(format))
      return Syncfusion.DocIO.DLS.TextFormat.None;
    switch (format.ToUpper())
    {
      case "UPPERCASE":
      case "UPPER CASE":
        return Syncfusion.DocIO.DLS.TextFormat.Uppercase;
      case "LOWERCASE":
      case "LOWER CASE":
        return Syncfusion.DocIO.DLS.TextFormat.Lowercase;
      case "FIRSTCAPITAL":
      case "FIRST CAPITAL":
        return Syncfusion.DocIO.DLS.TextFormat.FirstCapital;
      case "TITLECASE":
      case "TITLE CASE":
        return Syncfusion.DocIO.DLS.TextFormat.Titlecase;
      default:
        return Syncfusion.DocIO.DLS.TextFormat.None;
    }
  }

  private TextFormFieldType GetTextFieldType(string type)
  {
    switch (type)
    {
      case "number":
        return TextFormFieldType.NumberText;
      case "currentDate":
        return TextFormFieldType.CurrentDateText;
      case "currentTime":
        return TextFormFieldType.CurrentTimeText;
      case "date":
        return TextFormFieldType.DateText;
      case "calculated":
        return TextFormFieldType.Calculation;
      default:
        return TextFormFieldType.RegularText;
    }
  }

  private void ParseCheckBox(XmlReader reader, WCheckBox checkBox)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    int content = (int) reader.MoveToContent();
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "sizeAuto":
            bool booleanValue = this.GetBooleanValue(reader);
            checkBox.SizeType = booleanValue ? CheckBoxSizeType.Auto : CheckBoxSizeType.Exactly;
            break;
          case "default":
            checkBox.DefaultCheckBoxValue = this.GetBooleanValue(reader);
            break;
          case "checked":
            checkBox.Checked = this.GetBooleanValue(reader);
            break;
          case "size":
            float result = 0.0f;
            string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute))
            {
              if (float.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
              {
                checkBox.SetCheckBoxSizeValue((int) result / 2);
                checkBox.SizeType = CheckBoxSizeType.Exactly;
                break;
              }
              checkBox.SizeType = CheckBoxSizeType.Auto;
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private WFormField GetFormField(Stream ffDataStream)
  {
    ffDataStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(ffDataStream);
    while (reader.Read())
    {
      switch (reader.LocalName)
      {
        case "checkBox":
          return (WFormField) new WCheckBox((IWordDocument) this.m_doc);
        case "ddList":
          return (WFormField) new WDropDownFormField((IWordDocument) this.m_doc);
        case "textInput":
          return (WFormField) new WTextFormField((IWordDocument) this.m_doc);
        default:
          continue;
      }
    }
    return (WFormField) new WTextFormField((IWordDocument) this.m_doc);
  }

  private WFootnote Parse2003FootnotePart(XmlReader reader, bool isFootnote)
  {
    if (isFootnote)
    {
      WFootnote wfootnote = new WFootnote((IWordDocument) this.m_doc);
      this.ParseBody(reader, (IEntity) wfootnote, false, false, false);
      return wfootnote;
    }
    WFootnote wfootnote1 = new WFootnote((IWordDocument) this.m_doc);
    wfootnote1.FootnoteType = FootnoteType.Endnote;
    this.ParseBody(reader, (IEntity) wfootnote1, false, false, false);
    return wfootnote1;
  }

  private void ParseFootnotePart(bool isFootnote)
  {
    string empty1 = string.Empty;
    string partName = isFootnote ? "footnotes.xml" : "endnotes.xml";
    this.m_currentFile = partName + ".rels";
    Part part = this.FindPart("word/", partName);
    if (part == null)
      return;
    this.IsInFootnote = isFootnote;
    this.IsInEndnote = !isFootnote;
    XmlReader reader = UtilityMethods.CreateReader(part.DataStream);
    int content = (int) reader.MoveToContent();
    string empty2 = string.Empty;
    string empty3 = string.Empty;
    bool flag = false;
    do
    {
      if (!flag)
        reader.Read();
      string attribute1 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
      string attribute2 = reader.GetAttribute("type", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
      if (!string.IsNullOrEmpty(attribute1))
      {
        if (attribute2 != null && attribute2 != string.Empty && attribute2 != "normal")
        {
          flag = false;
          if (isFootnote)
          {
            switch (attribute2)
            {
              case "separator":
                this.m_doc.Footnotes.Separator = new WTextBody(this.m_doc, (Entity) null);
                this.ParseBody(reader, (IEntity) this.m_doc.Footnotes.Separator, false, false, false);
                break;
              case "continuationSeparator":
                this.m_doc.Footnotes.ContinuationSeparator = new WTextBody(this.m_doc, (Entity) null);
                this.ParseBody(reader, (IEntity) this.m_doc.Footnotes.ContinuationSeparator, false, false, false);
                break;
              case "continuationNotice":
                this.m_doc.Footnotes.ContinuationNotice = new WTextBody(this.m_doc, (Entity) null);
                this.ParseBody(reader, (IEntity) this.m_doc.Footnotes.ContinuationNotice, false, false, false);
                break;
            }
          }
          else
          {
            switch (attribute2)
            {
              case "separator":
                this.m_doc.Endnotes.Separator = new WTextBody(this.m_doc, (Entity) null);
                this.ParseBody(reader, (IEntity) this.m_doc.Endnotes.Separator, false, false, false);
                break;
              case "continuationSeparator":
                this.m_doc.Endnotes.ContinuationSeparator = new WTextBody(this.m_doc, (Entity) null);
                this.ParseBody(reader, (IEntity) this.m_doc.Endnotes.ContinuationSeparator, false, false, false);
                break;
              case "continuationNotice":
                this.m_doc.Endnotes.ContinuationNotice = new WTextBody(this.m_doc, (Entity) null);
                this.ParseBody(reader, (IEntity) this.m_doc.Endnotes.ContinuationNotice, false, false, false);
                break;
            }
          }
        }
        else
        {
          WFootnote wfootnote = new WFootnote((IWordDocument) this.m_doc);
          this.ParseBody(reader, (IEntity) wfootnote, false, false, false);
          DictionaryEntry dictionaryEntry = new DictionaryEntry((object) attribute1, (object) wfootnote);
          if (isFootnote)
          {
            this.Footnote.Add(dictionaryEntry);
          }
          else
          {
            wfootnote.FootnoteType = FootnoteType.Endnote;
            this.Endnote.Add(dictionaryEntry);
          }
          flag = false;
        }
      }
    }
    while (!reader.EOF);
    this.m_currentFile = "";
    this.IsInFootnote = false;
    this.IsInEndnote = false;
  }

  private WFootnote ParseFootnote(XmlReader reader)
  {
    string attribute1 = reader.GetAttribute("id", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    string attribute2 = reader.GetAttribute("customMarkFollows", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    bool flag = true;
    bool isFootnote = this.StartsWithExt(reader.LocalName, "footnote");
    if (attribute1 == null)
      return (WFootnote) null;
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, isFootnote ? 21 : 17);
    int num;
    switch (attribute2)
    {
      case null:
label_6:
        WFootnote footnote = this.GetFootnote(isFootnote, attribute1);
        if (!flag)
          this.ParseFootnoteSymbol(reader, footnote);
        return footnote;
      case "0":
        num = 1;
        break;
      default:
        num = 0;
        break;
    }
    flag = num != 0;
    goto label_6;
  }

  private WFootnote GetFootnote(bool isFootnote, string id)
  {
    WFootnote footnote = (WFootnote) null;
    if (isFootnote)
    {
      int index = 0;
      for (int count = this.Footnote.Count; index < count; ++index)
      {
        if (this.Footnote[index].Key.ToString() == id)
        {
          footnote = (WFootnote) this.Footnote[index].Value;
          break;
        }
      }
    }
    else
    {
      int index = 0;
      for (int count = this.Endnote.Count; index < count; ++index)
      {
        if (this.Endnote[index].Key.ToString() == id)
        {
          footnote = (WFootnote) this.Endnote[index].Value;
          break;
        }
      }
    }
    return footnote;
  }

  private void ParseFootnoteSymbol(XmlReader reader, WFootnote footnote)
  {
    footnote.IsAutoNumbered = false;
    this.SkipWhitespaces(reader);
    this.MoveToNextLine(reader);
    string attribute1 = reader.GetAttribute("font", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    string attribute2 = reader.GetAttribute("char", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    string str = reader.ReadString();
    if (attribute1 != null && attribute2 != null)
    {
      footnote.SymbolFontName = attribute1;
      byte num = byte.Parse(attribute2.Replace("F0", string.Empty), NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture);
      footnote.SymbolCode = num;
    }
    else
    {
      if (str == null)
        return;
      footnote.CustomMarker = str;
    }
  }

  private void MoveToNextLine(XmlReader reader)
  {
    do
    {
      reader.Read();
    }
    while (reader.LocalName == string.Empty || reader.NodeType == XmlNodeType.Whitespace);
  }

  private WTextRange ParseFootnoteMarker()
  {
    WTextRange footnoteMarker = new WTextRange((IWordDocument) this.m_doc);
    footnoteMarker.Text = '\u0002'.ToString();
    if (this.m_currentRunFormat != null)
      footnoteMarker.ApplyCharacterFormat(this.m_currentRunFormat);
    return footnoteMarker;
  }

  private ParagraphItem ParseObject(XmlReader reader)
  {
    Stream stream = (Stream) this.ReadSingleNodeIntoStream(reader);
    bool flag = this.HasNode(stream, "control");
    if (this.HasNode(stream, "OLEObject"))
    {
      this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 29);
      return this.ParseOleObject(stream);
    }
    if (!flag && !this.isResultFromLinkField())
      return (ParagraphItem) null;
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 16 /*0x10*/);
    stream.Position = 0L;
    return (ParagraphItem) this.ParseXmlParaItem(stream);
  }

  private bool isResultFromLinkField()
  {
    WParagraph wparagraph = this.m_doc.LastParagraph;
    if (this.m_doc.LastParagraph.ChildEntities.Count == 0 & this.m_doc.LastParagraph.PreviousSibling is WParagraph)
      wparagraph = this.m_doc.LastParagraph.PreviousSibling as WParagraph;
    return wparagraph.ChildEntities.Count != 0 && wparagraph.LastItem is WFieldMark && FieldMarkType.FieldSeparator == (wparagraph.LastItem as WFieldMark).Type;
  }

  private ParagraphItem ParseOleObject(Stream objectStream)
  {
    WOleObject oleObject = new WOleObject(this.m_doc);
    XmlReader reader = UtilityMethods.CreateReader(objectStream);
    if (reader.IsEmptyElement)
      return (ParagraphItem) null;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return (ParagraphItem) null;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName2)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "shape":
          case "rect":
            WPicture wpicture = new WPicture((IWordDocument) this.m_doc);
            wpicture.PictureShape.ShapeContainer = new MsofbtSpContainer(this.m_doc);
            wpicture.PictureShape.ShapeContainer.Children.Add((object) new MsofbtOPT(this.m_doc));
            wpicture.PictureShape.ShapeContainer.Children.Add((object) new MsofbtTertiaryFOPT(this.m_doc));
            this.ParsePictureShapeProperties(reader, (IEntity) wpicture);
            wpicture.IsShape = true;
            wpicture.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) oleObject);
            oleObject.SetOlePicture(wpicture);
            if (this.m_currentRunFormat != null)
            {
              wpicture.CharacterFormat.ImportContainer((FormatBase) this.m_currentRunFormat);
              this.ApplyDirectionalOverride(wpicture.CharacterFormat);
            }
            this.ParsePictureShapeImage(reader, (IEntity) wpicture, reader.LocalName, false, false);
            break;
          case "OLEObject":
            this.ParseOleData(reader, oleObject);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
    return (ParagraphItem) oleObject;
  }

  private void ParseOlePictureWrapStyle(XmlReader reader, WPicture picture)
  {
    switch (reader.GetAttribute("type").ToLower())
    {
      case "square":
        picture.SetTextWrappingStyleValue(TextWrappingStyle.Square);
        break;
      case "through":
        picture.SetTextWrappingStyleValue(TextWrappingStyle.Through);
        break;
      case "tight":
        picture.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
        break;
      case "topandbottom":
        picture.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
        break;
    }
  }

  private void ParseOleData(XmlReader reader, WOleObject oleObject)
  {
    string str = !(reader.LocalName != "OLEObject") ? reader.GetAttribute("Type") : throw new XmlException("OLE Object data");
    if (!string.IsNullOrEmpty(str))
    {
      if (str == "Link")
        oleObject.SetLinkType(OleLinkType.Link);
      else
        oleObject.SetLinkType(OleLinkType.Embed);
    }
    string attribute1 = reader.GetAttribute("ProgID");
    if (!string.IsNullOrEmpty(attribute1))
      oleObject.ObjectType = attribute1;
    string attribute2 = reader.GetAttribute("ObjectID");
    if (!string.IsNullOrEmpty(attribute2))
      oleObject.OleStorageName = attribute2.Replace("_", string.Empty);
    string attribute3 = reader.GetAttribute("DrawAspect");
    if (!string.IsNullOrEmpty(attribute3) && attribute3 == "Content")
      oleObject.DisplayAsIcon = false;
    string attribute4 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    string attribute5 = reader.GetAttribute("UpdateMode");
    if (!string.IsNullOrEmpty(attribute5))
      oleObject.UpdateMode = !(attribute5.ToLower() == "oncall") ? UpdateMode.Always : UpdateMode.OnCall;
    if (oleObject.LinkType == OleLinkType.Embed)
    {
      Part olePart = this.GetOlePart(attribute4);
      if (olePart == null)
        return;
      olePart.DataStream.Position = 0L;
      if (!this.m_doc.Settings.PreserveOleImageAsImage || !(oleObject.ObjectType == "PBrush") || oleObject.LinkType != OleLinkType.Embed || oleObject.DisplayAsIcon)
        oleObject.ParseOlePartStream(olePart.DataStream);
      this.ClearParsedImage(olePart.Name, "word/embeddings/");
    }
    else
      oleObject.SetLinkPathValue(this.GetOleLinkPath(attribute4));
  }

  private Part GetOlePart(string oleId)
  {
    Dictionary<string, DictionaryEntry> dictionary = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer") ? this.GetFileRelations(this.m_currentFile) : this.m_docRelations;
    DictionaryEntry dictionaryEntry = new DictionaryEntry();
    if (dictionary != null && dictionary.ContainsKey(oleId))
      dictionaryEntry = dictionary[oleId];
    string fileName = dictionaryEntry.Value != null ? dictionaryEntry.Value.ToString() : (string) null;
    return fileName == null ? (Part) null : this.FindPart(this.GetPartName(ref fileName), fileName);
  }

  private string GetOleLinkPath(string id)
  {
    bool flag = false;
    string str = (string) null;
    if (!flag && this.m_docRelations.ContainsKey(id))
      str = this.m_docRelations[id].Value.ToString();
    return str?.Replace("file:///", string.Empty);
  }

  private bool IsNativeDataInside(OleObjectType type)
  {
    bool flag = false;
    if (type == OleObjectType.Excel_97_2003_Worksheet || type == OleObjectType.ExcelBinaryWorksheet || type == OleObjectType.ExcelChart || type == OleObjectType.ExcelMacroWorksheet || type == OleObjectType.ExcelWorksheet || type == OleObjectType.PowerPoint_97_2003_Presentation || type == OleObjectType.PowerPoint_97_2003_Slide || type == OleObjectType.PowerPointMacroPresentation || type == OleObjectType.PowerPointMacroSlide || type == OleObjectType.PowerPointPresentation || type == OleObjectType.PowerPointSlide || type == OleObjectType.VisioDrawing || type == OleObjectType.Word_97_2003_Document || type == OleObjectType.WordDocument || type == OleObjectType.WordMacroDocument)
      flag = true;
    return flag;
  }

  private bool HasNode(Stream objectStream, string elementName)
  {
    objectStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(objectStream);
    while (reader.Read())
    {
      if (reader.LocalName == elementName)
      {
        objectStream.Position = 0L;
        return true;
      }
    }
    objectStream.Position = 0L;
    return false;
  }

  private ParagraphItem ParseShape(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    MemoryStream drawingStream,
    MemoryStream shapeStream)
  {
    shapeStream.Position = 0L;
    Syncfusion.DocIO.DLS.AutoShapeType autoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Unknown;
    Dictionary<string, Stream> docxProps = new Dictionary<string, Stream>();
    string shapeTypeId = (string) null;
    ShapeType shapeType = this.DetectShapeType(shapeStream, ref autoShapeType, ref docxProps, ref shapeTypeId);
    Entity owner = paraItems.Owner;
    if (shapeType == ShapeType.WatermarkShape && owner != null && !(owner.GetBaseEntity(owner) is HeaderFooter))
      shapeType = ShapeType.PictureShape;
    shapeStream.Position = 0L;
    XmlReader reader1 = UtilityMethods.CreateReader((Stream) shapeStream);
    if ((autoShapeType != Syncfusion.DocIO.DLS.AutoShapeType.Unknown || shapeType == ShapeType.XmlParagraphItem && this.IsVMLCustomShape(autoShapeType, shapeStream)) && (autoShapeType != Syncfusion.DocIO.DLS.AutoShapeType.Rectangle || shapeType != ShapeType.TextboxShape))
    {
      this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 6);
      Shape shape = this.ParseShape(shapeStream, drawingStream);
      shape.Docx2007Props = docxProps;
      for (int index = 1; index <= docxProps.Count; ++index)
      {
        if (shape.Docx2007Props.ContainsKey("shadow" + (object) index))
          this.ParseDocx2007ShadowEffect(shape, shape.Docx2007Props["shadow" + (object) index]);
        if (shape.Docx2007Props.ContainsKey("extrusion"))
          this.ParseDocx2007Extrusion(shape, shape.Docx2007Props["extrusion"]);
      }
      shape.ShapeTypeID = shapeTypeId;
      this.ParseXMLRelations(shape, shapeStream);
      shape.DocxProps.Add("pict", (Stream) shapeStream);
      if (drawingStream == null)
        shape.Is2007Shape = true;
      shape.AutoShapeType = autoShapeType;
      if (shape.Is2007Shape)
        shape.VMLPathPoints = shape.Parse2007CustomShapePoints(shape.Path);
      if (shape.VMLPathPoints == null)
        this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 10);
      return (ParagraphItem) shape;
    }
    switch (shapeType)
    {
      case ShapeType.TextboxShape:
        return (ParagraphItem) this.ParseTextboxShape(shapeStream, drawingStream);
      case ShapeType.GroupedShape:
        GroupShape shape1 = new GroupShape((IWordDocument) this.m_doc);
        shape1.InitializeVMLDefaultValues();
        shape1.ApplyCharacterFormat(this.m_currentRunFormat);
        this.ApplyDirectionalOverride(shape1.GetCharFormat());
        if (drawingStream == null)
          shape1.Is2007Shape = true;
        this.Parse2007GroupShape(reader1, shape1);
        return (ParagraphItem) shape1;
      case ShapeType.PictureShape:
        this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 31 /*0x1F*/);
        return (ParagraphItem) this.ParsePictureShape(shapeStream);
      case ShapeType.WatermarkShape:
        this.ParseWatermark(shapeStream, paraItems);
        return (ParagraphItem) null;
      case ShapeType.OleObject:
        return this.ParseOleObject((Stream) shapeStream);
      default:
        if (this.IsWord2003ML)
          return (ParagraphItem) null;
        if (shapeType == ShapeType.XmlParagraphItem)
          this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 10);
        shapeStream.Position = 0L;
        return (ParagraphItem) this.ParseXmlParaItem((Stream) shapeStream);
    }
  }

  private bool IsVMLCustomShape(Syncfusion.DocIO.DLS.AutoShapeType shapeType, MemoryStream shapeStream)
  {
    XmlReader reader = UtilityMethods.CreateReader((Stream) shapeStream);
    reader.ReadToFollowing("shape", "urn:schemas-microsoft-com:vml");
    return shapeType == Syncfusion.DocIO.DLS.AutoShapeType.Unknown && reader.GetAttribute("path") != null;
  }

  private void ParseDocx2007Extrusion(Shape shape, Stream extrusionStream)
  {
    EffectFormat effectFormat = new EffectFormat(shape);
    effectFormat.IsShapeProperties = true;
    extrusionStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(extrusionStream);
    if (reader.HasAttributes)
    {
      string attribute1 = reader.GetAttribute("v:ext");
      if (!string.IsNullOrEmpty(attribute1))
        effectFormat.ThreeDFormat.Extension = attribute1;
      string attribute2 = reader.GetAttribute("color");
      if (!string.IsNullOrEmpty(attribute2))
        effectFormat.ThreeDFormat.ExtrusionColor = this.GetColorValue(attribute2);
      string attribute3 = reader.GetAttribute("colormode");
      if (!string.IsNullOrEmpty(attribute3))
        effectFormat.ThreeDFormat.ColorMode = attribute3;
      string attribute4 = reader.GetAttribute("on");
      if (!string.IsNullOrEmpty(attribute4))
        effectFormat.ThreeDFormat.Visible = this.GetBoolValue(attribute4);
      string attribute5 = reader.GetAttribute("metal");
      if (!string.IsNullOrEmpty(attribute5))
        effectFormat.ThreeDFormat.Metal = this.GetBoolValue(attribute5);
      string attribute6 = reader.GetAttribute("lightharsh");
      if (!string.IsNullOrEmpty(attribute6))
        effectFormat.ThreeDFormat.LightHarsh = this.GetBoolValue(attribute6);
      string attribute7 = reader.GetAttribute("lightharsh2");
      if (!string.IsNullOrEmpty(attribute7))
        effectFormat.ThreeDFormat.LightHarsh2 = this.GetBoolValue(attribute7);
      string attribute8 = reader.GetAttribute("lightface");
      if (!string.IsNullOrEmpty(attribute8))
        effectFormat.ThreeDFormat.LightFace = this.GetBoolValue(attribute8);
      string attribute9 = reader.GetAttribute("lockrotationcenter");
      if (!string.IsNullOrEmpty(attribute9))
        effectFormat.ThreeDFormat.LockRotationCenter = this.GetBoolValue(attribute9);
      string attribute10 = reader.GetAttribute("autorotationcenter");
      if (!string.IsNullOrEmpty(attribute10))
        effectFormat.ThreeDFormat.AutoRotationCenter = this.GetBoolValue(attribute10);
      string attribute11 = reader.GetAttribute("rotationangle");
      if (!string.IsNullOrEmpty(attribute11))
        this.ParseExtrusionAxis(effectFormat, attribute11, "rotationangle");
      string attribute12 = reader.GetAttribute("orientationangle");
      if (!string.IsNullOrEmpty(attribute12))
        effectFormat.ThreeDFormat.OrientationAngle = !attribute12.EndsWith("%") ? this.GetEffectsPointValue(attribute12) : (float) (this.GetPercentage(attribute12) * 65536.0 / 100.0);
      string attribute13 = reader.GetAttribute("orientation");
      if (!string.IsNullOrEmpty(attribute13))
        this.ParseExtrusionAxis(effectFormat, attribute13, "orientation");
      string attribute14 = reader.GetAttribute("viewpoint");
      if (!string.IsNullOrEmpty(attribute14))
        this.ParseExtrusionAxis(effectFormat, attribute14, "viewpoint");
      string attribute15 = reader.GetAttribute("viewpointorigin");
      if (!string.IsNullOrEmpty(attribute15))
        this.ParseExtrusionAxis(effectFormat, attribute15, "viewpointorigin");
      string attribute16 = reader.GetAttribute("skewangle");
      if (!string.IsNullOrEmpty(attribute16))
        effectFormat.ThreeDFormat.SkewAngle = !attribute16.EndsWith("%") ? this.GetEffectsPointValue(attribute16) : (float) (this.GetPercentage(attribute16) * 65536.0 / 100.0);
      string attribute17 = reader.GetAttribute("skewamt");
      if (!string.IsNullOrEmpty(attribute17))
        effectFormat.ThreeDFormat.SkewAmount = !attribute17.EndsWith("%") ? this.GetEffectsPointValue(attribute17) : (float) (this.GetPercentage(attribute17) * 65536.0 / 100.0);
      string attribute18 = reader.GetAttribute("shininess");
      if (!string.IsNullOrEmpty(attribute18))
        effectFormat.ThreeDFormat.Shininess = !attribute18.EndsWith("%") ? this.GetEffectsPointValue(attribute18) : (float) (this.GetPercentage(attribute18) * 65536.0 / 100.0);
      string attribute19 = reader.GetAttribute("lightposition");
      if (!string.IsNullOrEmpty(attribute19))
      {
        if (attribute19.Contains(","))
        {
          if (this.StartsWithExt(attribute19, ",") && attribute19.IndexOf(',') == attribute19.LastIndexOf(','))
          {
            string str = attribute19.Substring(1);
            effectFormat.ThreeDFormat.LightRigRotationY = !str.EndsWith("%") ? this.GetEffectsPointValue(str) : (float) (this.GetPercentage(str) * 65536.0 / 100.0);
          }
          else if (attribute19.EndsWith(",") && attribute19.IndexOf(',') == attribute19.LastIndexOf(','))
          {
            string str = attribute19.Substring(0, attribute19.Length - 1);
            effectFormat.ThreeDFormat.LightRigRotationX = !str.EndsWith("%") ? this.GetEffectsPointValue(str) : (float) (this.GetPercentage(str) * 65536.0 / 100.0);
          }
          else
            this.ParseExtrusionAxis(effectFormat, attribute19, "lightposition");
        }
        else
          effectFormat.ThreeDFormat.LightRigRotationX = !attribute19.EndsWith("%") ? this.GetEffectsPointValue(attribute19) : (float) (this.GetPercentage(attribute19) * 65536.0 / 100.0);
      }
      string attribute20 = reader.GetAttribute("lightposition2");
      if (!string.IsNullOrEmpty(attribute20))
      {
        if (attribute20.Contains(","))
        {
          if (this.StartsWithExt(attribute20, ",") && attribute20.IndexOf(',') == attribute20.LastIndexOf(','))
          {
            string str = attribute20.Substring(1);
            effectFormat.ThreeDFormat.LightRigRotation2Y = !str.EndsWith("%") ? this.GetEffectsPointValue(str) : (float) (this.GetPercentage(str) * 65536.0 / 100.0);
          }
          else if (attribute20.EndsWith(",") && attribute20.IndexOf(',') == attribute20.LastIndexOf(','))
          {
            string str = attribute20.Substring(0, attribute20.Length - 1);
            effectFormat.ThreeDFormat.LightRigRotation2X = !str.EndsWith("%") ? this.GetEffectsPointValue(str) : (float) (this.GetPercentage(str) * 65536.0 / 100.0);
          }
          else
            this.ParseExtrusionAxis(effectFormat, attribute20, "lightposition2");
        }
        else
          effectFormat.ThreeDFormat.LightRigRotation2X = !attribute20.EndsWith("%") ? this.GetEffectsPointValue(attribute20) : (float) (this.GetPercentage(attribute20) * 65536.0 / 100.0);
      }
      string attribute21 = reader.GetAttribute("rotationcenter");
      if (!string.IsNullOrEmpty(attribute21))
        this.ParseExtrusionAxis(effectFormat, attribute21, "rotationcenter");
      string attribute22 = reader.GetAttribute("type");
      if (!string.IsNullOrEmpty(attribute22) && attribute22.Length > 2 && System.Enum.IsDefined(typeof (ExtrusionType), (object) (char.ToUpper(attribute22[0]).ToString() + attribute22.Substring(1))))
        effectFormat.ThreeDFormat.ExtrusionType = (ExtrusionType) System.Enum.Parse(typeof (ExtrusionType), attribute22, true);
      string attribute23 = reader.GetAttribute("render");
      if (!string.IsNullOrEmpty(attribute23) && attribute23.Length > 2 && System.Enum.IsDefined(typeof (ExtrusionRenderMode), (object) (char.ToUpper(attribute23[0]).ToString() + attribute23.Substring(1))))
        effectFormat.ThreeDFormat.ExtrusionRenderMode = (ExtrusionRenderMode) System.Enum.Parse(typeof (ExtrusionRenderMode), attribute23, true);
      string attribute24 = reader.GetAttribute("plane");
      if (!string.IsNullOrEmpty(attribute24) && attribute24.Length > 2 && System.Enum.IsDefined(typeof (ExtrusionPlane), (object) (char.ToUpper(attribute24[0]).ToString() + attribute24.Substring(1))))
        effectFormat.ThreeDFormat.ExtrusionPlane = (ExtrusionPlane) System.Enum.Parse(typeof (ExtrusionPlane), attribute24, true);
      string attribute25 = reader.GetAttribute("specularity");
      if (!string.IsNullOrEmpty(attribute25))
        effectFormat.ThreeDFormat.Specularity = this.GetPropertyValue(attribute25);
      string attribute26 = reader.GetAttribute("brightness");
      if (!string.IsNullOrEmpty(attribute26))
        effectFormat.ThreeDFormat.Brightness = this.GetPropertyValue(attribute26);
      string attribute27 = reader.GetAttribute("lightlevel");
      if (!string.IsNullOrEmpty(attribute27))
        effectFormat.ThreeDFormat.LightLevel = this.GetPropertyValue(attribute27);
      string attribute28 = reader.GetAttribute("lightlevel2");
      if (!string.IsNullOrEmpty(attribute28))
        effectFormat.ThreeDFormat.LightLevel2 = this.GetPropertyValue(attribute28);
      string attribute29 = reader.GetAttribute("facet");
      if (!string.IsNullOrEmpty(attribute29))
        effectFormat.ThreeDFormat.Facet = this.GetPropertyValue(attribute29);
      string attribute30 = reader.GetAttribute("diffusity");
      if (!string.IsNullOrEmpty(attribute30))
        effectFormat.ThreeDFormat.Diffusity = this.GetPropertyValue(attribute30);
      string attribute31 = reader.GetAttribute("foredepth");
      if (!string.IsNullOrEmpty(attribute31))
        effectFormat.ThreeDFormat.ForeDepth = !attribute31.EndsWith("%") ? this.GetEffectsPointValue(attribute31) : (float) (this.GetPercentage(attribute31) * 65536.0 / 100.0);
      string attribute32 = reader.GetAttribute("backdepth");
      if (!string.IsNullOrEmpty(attribute32))
        effectFormat.ThreeDFormat.BackDepth = !attribute32.EndsWith("%") ? this.GetEffectsPointValue(attribute32) : (float) (this.GetPercentage(attribute32) * 65536.0 / 100.0);
      string attribute33 = reader.GetAttribute("edge");
      if (!string.IsNullOrEmpty(attribute33))
        effectFormat.ThreeDFormat.Edge = !attribute33.EndsWith("%") ? this.GetEffectsPointValue(attribute33) : (float) (this.GetPercentage(attribute33) * 65536.0 / 100.0);
    }
    shape.EffectList.Add(effectFormat);
  }

  private float GetPropertyValue(string value)
  {
    float result = 0.0f;
    if (value.Trim(ControlChar.SpaceChar, '%', 'f') == string.Empty)
      return result;
    if (value.EndsWith("f"))
    {
      float.TryParse(value.Replace("f", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result = (float) Math.Round((double) result / 65536.0, 5);
    }
    else if (value.EndsWith("%"))
      result = (float) (this.GetPercentage(value) * 65536.0 / 100.0);
    else
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    return result;
  }

  private void ParseExtrusionAxis(EffectFormat effectFormat, string value, string attribute)
  {
    List<string> stringList = new List<string>();
    string[] strArray = new string[3];
    value = value.Replace(" ", "");
    if (value.Contains(","))
    {
      if (value.IndexOf(',') == value.LastIndexOf(","))
      {
        if (this.StartsWithExt(value, ","))
          value = value.Insert(0, " ");
        if (value.EndsWith(","))
          value = value.Insert(value.IndexOf(',') + 1, " ");
        strArray = value.Split(new char[1]{ ',' }, StringSplitOptions.RemoveEmptyEntries);
      }
      else if (value.IndexOf(',') + 1 == value.LastIndexOf(","))
      {
        if (this.StartsWithExt(value, ","))
        {
          value = value.Insert(0, " ");
          value = value.Insert(value.IndexOf(',') + 1, " ");
        }
        else if (value.EndsWith(","))
        {
          value = value.Insert(value.IndexOf(',') + 1, " ");
          value = value.Insert(value.LastIndexOf(',') + 1, " ");
        }
        else
          value = value.Insert(value.IndexOf(',') + 1, " ");
        strArray = value.Split(new char[1]{ ',' }, StringSplitOptions.RemoveEmptyEntries);
      }
      else
      {
        if (this.StartsWithExt(value, ",") && value.EndsWith(","))
        {
          value = value.Insert(0, " ");
          value = value.Insert(value.LastIndexOf(',') + 1, " ");
        }
        else if (this.StartsWithExt(value, ","))
          value = value.Insert(0, " ");
        else if (value.EndsWith(","))
          value = value.Insert(value.LastIndexOf(',') + 1, " ");
        strArray = value.Split(new char[1]{ ',' }, StringSplitOptions.RemoveEmptyEntries);
      }
    }
    else
      strArray[0] = value;
    foreach (string str in strArray)
    {
      if (str != null)
        stringList.Add(str);
    }
    switch (attribute)
    {
      case "rotationangle":
        if (stringList.Count > 0 && stringList[0] != " ")
          effectFormat.ThreeDFormat.RotationAngleX = !stringList[0].EndsWith("%") ? this.GetEffectsPointValue(stringList[0]) : (float) (this.GetPercentage(stringList[0]) * 65536.0 / 100.0);
        if (stringList.Count <= 1 || !(stringList[1] != " "))
          break;
        if (stringList[1].EndsWith("%"))
        {
          effectFormat.ThreeDFormat.RotationAngleY = (float) (this.GetPercentage(stringList[1]) * 65536.0 / 100.0);
          break;
        }
        effectFormat.ThreeDFormat.RotationAngleY = this.GetEffectsPointValue(stringList[1]);
        break;
      case "orientation":
        if (stringList.Count > 0 && stringList[0] != " ")
          effectFormat.ThreeDFormat.RotationX = !stringList[0].EndsWith("%") ? this.GetEffectsPointValue(stringList[0]) : (float) (this.GetPercentage(stringList[0]) * 65536.0 / 100.0);
        if (stringList.Count > 1 && stringList[1] != " ")
          effectFormat.ThreeDFormat.RotationY = !stringList[1].EndsWith("%") ? this.GetEffectsPointValue(stringList[1]) : (float) (this.GetPercentage(stringList[1]) * 65536.0 / 100.0);
        if (stringList.Count <= 2 || !(stringList[2] != " "))
          break;
        if (stringList[2].EndsWith("%"))
        {
          effectFormat.ThreeDFormat.RotationZ = (float) (this.GetPercentage(stringList[2]) * 65536.0 / 100.0);
          break;
        }
        effectFormat.ThreeDFormat.RotationZ = this.GetEffectsPointValue(stringList[2]);
        break;
      case "rotationcenter":
        if (stringList.Count > 0 && stringList[0] != " ")
          effectFormat.ThreeDFormat.RotationCenterX = !stringList[0].EndsWith("%") ? this.GetEffectsPointValue(stringList[0]) : (float) (this.GetPercentage(stringList[0]) * 65536.0 / 100.0);
        if (stringList.Count > 1 && stringList[1] != " ")
          effectFormat.ThreeDFormat.RotationCenterY = !stringList[1].EndsWith("%") ? this.GetEffectsPointValue(stringList[1]) : (float) (this.GetPercentage(stringList[1]) * 65536.0 / 100.0);
        if (stringList.Count <= 2 || !(stringList[2] != " "))
          break;
        if (stringList[2].EndsWith("%"))
        {
          effectFormat.ThreeDFormat.RotationCenterZ = (float) (this.GetPercentage(stringList[2]) * 65536.0 / 100.0);
          break;
        }
        effectFormat.ThreeDFormat.RotationCenterZ = this.GetEffectsPointValue(stringList[2]);
        break;
      case "viewpoint":
        if (stringList.Count > 0 && stringList[0] != " ")
          effectFormat.ThreeDFormat.ViewPointX = !stringList[0].EndsWith("%") ? this.GetEffectsPointValue(stringList[0]) : (float) (this.GetPercentage(stringList[0]) * 65536.0 / 100.0);
        if (stringList.Count > 1 && stringList[1] != " ")
          effectFormat.ThreeDFormat.ViewPointY = !stringList[1].EndsWith("%") ? this.GetEffectsPointValue(stringList[1]) : (float) (this.GetPercentage(stringList[1]) * 65536.0 / 100.0);
        if (stringList.Count <= 2 || !(stringList[2] != " "))
          break;
        if (stringList[2].EndsWith("%"))
        {
          effectFormat.ThreeDFormat.ViewPointZ = (float) (this.GetPercentage(stringList[2]) * 65536.0 / 100.0);
          break;
        }
        effectFormat.ThreeDFormat.ViewPointZ = this.GetEffectsPointValue(stringList[2]);
        break;
      case "viewpointorigin":
        if (stringList.Count > 0 && stringList[0] != " ")
          effectFormat.ThreeDFormat.ViewPointOriginX = !stringList[0].EndsWith("%") ? this.GetEffectsPointValue(stringList[0]) : (float) (this.GetPercentage(stringList[0]) * 65536.0 / 100.0);
        if (stringList.Count <= 1 || !(stringList[1] != " "))
          break;
        if (stringList[1].EndsWith("%"))
        {
          effectFormat.ThreeDFormat.ViewPointOriginY = (float) (this.GetPercentage(stringList[1]) * 65536.0 / 100.0);
          break;
        }
        effectFormat.ThreeDFormat.ViewPointOriginY = this.GetEffectsPointValue(stringList[1]);
        break;
      case "lightposition":
        if (stringList.Count > 0 && stringList[0] != " ")
          effectFormat.ThreeDFormat.LightRigRotationX = !stringList[0].EndsWith("%") || !(stringList[0] != " ") ? this.GetEffectsPointValue(stringList[0]) : (float) (this.GetPercentage(stringList[0]) * 65536.0 / 100.0);
        if (stringList.Count > 1 && stringList[1] != " ")
          effectFormat.ThreeDFormat.LightRigRotationY = !stringList[1].EndsWith("%") || !(stringList[1] != " ") ? this.GetEffectsPointValue(stringList[1]) : (float) (this.GetPercentage(stringList[1]) * 65536.0 / 100.0);
        if (stringList.Count <= 2 || !(stringList[2] != " "))
          break;
        if (stringList[2].EndsWith("%") && stringList[2] != " ")
        {
          effectFormat.ThreeDFormat.LightRigRotationZ = (float) (this.GetPercentage(stringList[2]) * 65536.0 / 100.0);
          break;
        }
        effectFormat.ThreeDFormat.LightRigRotationZ = this.GetEffectsPointValue(stringList[2]);
        break;
      case "lightposition2":
        if (stringList.Count > 0 && stringList[0] != " ")
          effectFormat.ThreeDFormat.LightRigRotation2X = !stringList[0].EndsWith("%") ? this.GetEffectsPointValue(stringList[0]) : (float) (this.GetPercentage(stringList[0]) * 65536.0 / 100.0);
        if (stringList.Count > 1 && stringList[1] != " ")
          effectFormat.ThreeDFormat.LightRigRotation2Y = !stringList[1].EndsWith("%") ? this.GetEffectsPointValue(stringList[1]) : (float) (this.GetPercentage(stringList[1]) * 65536.0 / 100.0);
        if (stringList.Count <= 2 || !(stringList[2] != " "))
          break;
        if (stringList[2].EndsWith("%"))
        {
          effectFormat.ThreeDFormat.LightRigRotation2Z = (float) (this.GetPercentage(stringList[2]) * 65536.0 / 100.0);
          break;
        }
        effectFormat.ThreeDFormat.LightRigRotation2Z = this.GetEffectsPointValue(stringList[2]);
        break;
    }
  }

  private void ParseDocx2007ShadowEffect(Shape shape, Stream shadowStream)
  {
    EffectFormat effectFormat = new EffectFormat(shape);
    effectFormat.IsShadowEffect = true;
    shadowStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(shadowStream);
    if (reader.HasAttributes)
    {
      string attribute1 = reader.GetAttribute("on");
      if (!string.IsNullOrEmpty(attribute1))
        effectFormat.ShadowFormat.Visible = this.GetBoolValue(attribute1);
      string attribute2 = reader.GetAttribute("color");
      if (!string.IsNullOrEmpty(attribute2))
        effectFormat.ShadowFormat.Color = this.GetColorValue(attribute2);
      string attribute3 = reader.GetAttribute("color2");
      if (!string.IsNullOrEmpty(attribute3))
        effectFormat.ShadowFormat.Color2 = !(attribute3 == "shadow add(102)") ? this.GetColorValue(attribute3) : Color.LightGray;
      string attribute4 = reader.GetAttribute("id");
      if (!string.IsNullOrEmpty(attribute4))
        effectFormat.ShadowFormat.Name = attribute4;
      string attribute5 = reader.GetAttribute("obscured");
      if (!string.IsNullOrEmpty(attribute5))
        effectFormat.ShadowFormat.Obscured = this.GetBoolValue(attribute5);
      string attribute6 = reader.GetAttribute("offset");
      if (!string.IsNullOrEmpty(attribute6))
      {
        string text = attribute6.Trim(ControlChar.SpaceChar);
        if (text.Contains(","))
        {
          if (this.StartsWithExt(text, ","))
          {
            string str1 = text.Substring(1);
            if (str1.EndsWith("%"))
              effectFormat.ShadowFormat.ShadowOffsetY = (float) (this.GetPercentage(str1) * 65536.0 / 100.0);
            else if (str1.EndsWith("f"))
            {
              string str2 = str1.Replace("f", "");
              effectFormat.ShadowFormat.ShadowOffsetY = this.GetEffectsPointValue(str2);
            }
            else
              effectFormat.ShadowFormat.ShadowOffsetY = this.GetEffectsPointValue(str1);
          }
          else if (text.EndsWith(","))
          {
            string str3 = text.Substring(0, text.Length - 1);
            if (str3.EndsWith("%"))
              effectFormat.ShadowFormat.ShadowOffsetX = (float) (this.GetPercentage(str3) * 65536.0 / 100.0);
            else if (str3.EndsWith("f"))
            {
              string str4 = str3.Replace("f", "");
              effectFormat.ShadowFormat.ShadowOffsetX = this.GetEffectsPointValue(str4);
            }
            else
              effectFormat.ShadowFormat.ShadowOffsetX = this.GetEffectsPointValue(str3);
          }
          else
            this.ParseShadowOffsets(effectFormat, text, "offset");
        }
        else if (text.EndsWith("%"))
          effectFormat.ShadowFormat.ShadowOffsetX = (float) (this.GetPercentage(text) * 65536.0 / 100.0);
        else if (text.EndsWith("f"))
        {
          string str = text.Replace("f", "");
          effectFormat.ShadowFormat.ShadowOffsetX = this.GetEffectsPointValue(str);
        }
        else
          effectFormat.ShadowFormat.ShadowOffsetX = this.GetEffectsPointValue(text);
      }
      string attribute7 = reader.GetAttribute("offset2");
      if (!string.IsNullOrEmpty(attribute7))
      {
        string text = attribute7.Trim(ControlChar.SpaceChar);
        if (text.Contains(","))
        {
          if (this.StartsWithExt(text, ","))
          {
            string str5 = text.Substring(1);
            if (str5.EndsWith("%"))
              effectFormat.ShadowFormat.ShadowOffset2Y = (float) (this.GetPercentage(str5) * 65536.0 / 100.0);
            else if (str5.EndsWith("f"))
            {
              string str6 = str5.Replace("f", "");
              effectFormat.ShadowFormat.ShadowOffset2Y = this.GetEffectsPointValue(str6);
            }
            else
              effectFormat.ShadowFormat.ShadowOffset2Y = this.GetEffectsPointValue(str5);
          }
          else if (text.EndsWith(","))
          {
            string str7 = text.Substring(0, text.Length - 1);
            if (str7.EndsWith("%"))
              effectFormat.ShadowFormat.ShadowOffset2X = (float) (this.GetPercentage(str7) * 65536.0 / 100.0);
            else if (str7.EndsWith("f"))
            {
              string str8 = str7.Replace("f", "");
              effectFormat.ShadowFormat.ShadowOffset2X = this.GetEffectsPointValue(str8);
            }
            else
              effectFormat.ShadowFormat.ShadowOffset2X = this.GetEffectsPointValue(str7);
          }
          else
            this.ParseShadowOffsets(effectFormat, text, "offset2");
        }
        else if (text.EndsWith("%"))
          effectFormat.ShadowFormat.ShadowOffset2X = (float) (this.GetPercentage(text) * 65536.0 / 100.0);
        else if (text.EndsWith("f"))
        {
          string str = text.Replace("f", "");
          effectFormat.ShadowFormat.ShadowOffset2X = this.GetEffectsPointValue(str);
        }
        else
          effectFormat.ShadowFormat.ShadowOffset2X = this.GetEffectsPointValue(text);
      }
      string attribute8 = reader.GetAttribute("origin");
      if (!string.IsNullOrEmpty(attribute8))
      {
        string text = attribute8.Trim(ControlChar.SpaceChar);
        if (text.Contains(","))
        {
          if (this.StartsWithExt(text, ","))
          {
            string str9 = text.Substring(1);
            if (str9.EndsWith("%"))
              effectFormat.ShadowFormat.OriginY = (float) (this.GetPercentage(str9) * 65536.0 / 100.0);
            else if (str9.EndsWith("f"))
            {
              string str10 = str9.Replace("f", "");
              effectFormat.ShadowFormat.OriginY = this.GetEffectsPointValue(str10);
            }
            else
              effectFormat.ShadowFormat.OriginY = this.GetEffectsPointValue(str9);
          }
          else if (text.EndsWith(","))
          {
            string str11 = text.Substring(0, text.Length - 1);
            if (str11.EndsWith("%"))
              effectFormat.ShadowFormat.OriginX = (float) (this.GetPercentage(str11) * 65536.0 / 100.0);
            else if (str11.EndsWith("f"))
            {
              string str12 = str11.Replace("f", "");
              effectFormat.ShadowFormat.OriginX = this.GetEffectsPointValue(str12);
            }
            else
              effectFormat.ShadowFormat.OriginX = this.GetEffectsPointValue(str11);
          }
          else
            this.ParseShadowOffsets(effectFormat, text, "origin");
        }
        else if (text.EndsWith("%"))
          effectFormat.ShadowFormat.OriginX = (float) (this.GetPercentage(text) * 65536.0 / 100.0);
        else if (text.EndsWith("f"))
        {
          string str = text.Replace("f", "");
          effectFormat.ShadowFormat.OriginX = this.GetEffectsPointValue(str);
        }
        else
          effectFormat.ShadowFormat.OriginX = this.GetEffectsPointValue(text);
      }
      string attribute9 = reader.GetAttribute("type");
      if (!string.IsNullOrEmpty(attribute9))
        effectFormat.ShadowFormat.ShadowType = this.GetShadowType(attribute9);
      string attribute10 = reader.GetAttribute("opacity");
      if (!string.IsNullOrEmpty(attribute10))
        effectFormat.ShadowFormat.Transparency = this.GetPropertyValue(attribute10);
      string attribute11 = reader.GetAttribute("matrix");
      if (!string.IsNullOrEmpty(attribute11))
        effectFormat.ShadowFormat.ShadowPerspectiveMatrix = attribute11;
    }
    shape.EffectList.Add(effectFormat);
  }

  private void ParseShadowOffsets(EffectFormat effectFormat, string value, string attribute)
  {
    string[] strArray = value.Split(new char[1]{ ',' }, StringSplitOptions.RemoveEmptyEntries);
    float num1 = !strArray[0].EndsWith("%") ? this.GetEffectsPointValue(strArray[0]) : (float) (this.GetPercentage(strArray[0]) * 65536.0 / 100.0);
    float num2 = !strArray[1].EndsWith("%") ? this.GetEffectsPointValue(strArray[1]) : (float) (this.GetPercentage(strArray[1]) * 65536.0 / 100.0);
    switch (attribute)
    {
      case "offset":
        effectFormat.ShadowFormat.ShadowOffsetX = num1;
        effectFormat.ShadowFormat.ShadowOffsetY = num2;
        break;
      case "offset2":
        effectFormat.ShadowFormat.ShadowOffset2X = num1;
        effectFormat.ShadowFormat.ShadowOffset2Y = num2;
        break;
      default:
        effectFormat.ShadowFormat.OriginX = num1;
        effectFormat.ShadowFormat.OriginY = num2;
        break;
    }
  }

  private void ParseFillOffsets(FillFormat fillFormat, string value, string attribute)
  {
    string[] strArray = value.Split(new char[1]{ ',' }, StringSplitOptions.RemoveEmptyEntries);
    float num1 = !strArray[0].EndsWith("%") ? this.GetEffectsPointValue(strArray[0]) : (float) (this.GetPercentage(strArray[0]) * 65536.0 / 100.0);
    float num2 = !strArray[1].EndsWith("%") ? this.GetEffectsPointValue(strArray[1]) : (float) (this.GetPercentage(strArray[1]) * 65536.0 / 100.0);
    switch (attribute)
    {
      case "focusposition":
        fillFormat.FocusPositionX = num1;
        fillFormat.FocusPositionY = num2;
        break;
      case "focussize":
        fillFormat.FocusSizeX = num1;
        fillFormat.FocusSizeY = num2;
        break;
      default:
        fillFormat.PositionX = num1;
        fillFormat.PositionY = num2;
        break;
    }
  }

  private float GetEffectsPointValue(string value)
  {
    if (this.StartsWithExt(value, "."))
      value = "0" + value;
    float result = 0.0f;
    if (value.EndsWith("pt"))
    {
      value = value.Replace("pt", string.Empty);
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result = (float) (Math.Ceiling((double) result * 10.0) / 10.0);
    }
    else if (value.EndsWith("mm"))
    {
      value = value.Replace("mm", string.Empty);
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result = (float) (Math.Ceiling((double) result / 25.399999618530273 * 72.0 * 10.0) / 10.0);
    }
    else if (value.EndsWith("px"))
    {
      value = value.Replace("px", string.Empty);
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result = (float) (Math.Ceiling((double) result / 4.0 * 3.0 * 10.0) / 10.0);
    }
    else if (value.EndsWith("in"))
    {
      value = value.Replace("in", string.Empty);
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result = (float) Math.Ceiling((double) result * 72.0 * 10.0 / 10.0);
    }
    else if (value.EndsWith("cm"))
    {
      value = value.Replace("cm", string.Empty);
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result = (float) Math.Ceiling((double) result / 2.5399999618530273 * 72.0 * 10.0 / 10.0);
    }
    else if (value.EndsWith("emu"))
    {
      value = value.Replace("emu", string.Empty);
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result /= 12700f;
      result = (float) (Math.Ceiling((double) result * 10.0) / 10.0);
    }
    else
    {
      if (value.EndsWith("fd"))
      {
        value = value.Replace("fd", string.Empty);
        float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
        result = (float) ((double) result / 32768.0 / 2.0);
        return (double) result >= 0.0 ? Math.Abs(result) : 360f - Math.Abs(result);
      }
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result = (float) (Math.Ceiling((double) result * 10.0) / 10.0);
    }
    return result;
  }

  private ShadowType GetShadowType(string value)
  {
    switch (value.ToLower())
    {
      case "double":
        return ShadowType.Double;
      case "shaperelative":
        return ShadowType.ShapeRelative;
      case "drawingrelative":
        return ShadowType.DrawingRelative;
      case "emboss":
        return ShadowType.Emboss;
      case "perspective":
        return ShadowType.Perspective;
      case "single":
        return ShadowType.Single;
      default:
        return ShadowType.Single;
    }
  }

  private void ParseXMLRelations(Shape shape, MemoryStream shapeStream)
  {
    List<string> relationshipIds = this.FindRelationshipIds((Stream) shapeStream);
    if (relationshipIds.Count <= 0 || this.m_docRelations == null)
      return;
    int index = 0;
    for (int count = relationshipIds.Count; index < count; ++index)
    {
      string str = relationshipIds[index];
      if (!this.ParseImageRelation((ParagraphItem) shape, str))
      {
        DictionaryEntry dictionaryEntry = new DictionaryEntry();
        if (!string.IsNullOrEmpty(this.m_currentFile))
        {
          Dictionary<string, DictionaryEntry> fileRelations = this.GetFileRelations(this.m_currentFile);
          if (fileRelations != null && fileRelations.ContainsKey(str))
            dictionaryEntry = fileRelations[str];
        }
        else if (this.m_docRelations.ContainsKey(str))
          dictionaryEntry = this.m_docRelations[str];
        if (!shape.Relations.ContainsKey(str))
          shape.Relations.Add(str, dictionaryEntry);
      }
    }
  }

  private void ParseXMLRelations(GroupShape shape, MemoryStream shapeStream)
  {
    List<string> relationshipIds = this.FindRelationshipIds((Stream) shapeStream);
    if (relationshipIds.Count <= 0 || this.m_docRelations == null)
      return;
    int index = 0;
    for (int count = relationshipIds.Count; index < count; ++index)
    {
      string str = relationshipIds[index];
      if (!this.ParseImageRelation(shape, str))
      {
        DictionaryEntry dictionaryEntry = new DictionaryEntry();
        if (!string.IsNullOrEmpty(this.m_currentFile))
        {
          Dictionary<string, DictionaryEntry> fileRelations = this.GetFileRelations(this.m_currentFile);
          if (fileRelations != null)
            dictionaryEntry = fileRelations[str];
        }
        else if (this.m_docRelations.ContainsKey(str))
          dictionaryEntry = this.m_docRelations[str];
        if (!shape.Relations.ContainsKey(str))
          shape.Relations.Add(str, dictionaryEntry);
      }
    }
  }

  private GroupShape ParseGroupShape(Stream groupShape)
  {
    groupShape.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(groupShape);
    GroupShape shape = new GroupShape((IWordDocument) this.m_doc);
    shape.ApplyCharacterFormat(this.m_currentRunFormat);
    this.ApplyDirectionalOverride(shape.GetCharFormat());
    shape.FillFormat.Color = Color.White;
    shape.LineFormat.ForeColor = Color.Black;
    shape.LineFormat.Color = Color.Empty;
    reader.Read();
    this.ParseShapeBaseProperties(reader, (Syncfusion.DocIO.DLS.ShapeBase) shape, groupShape as MemoryStream);
    this.Parse2007GroupShape(reader, shape);
    return shape;
  }

  private Shape ParseShape(MemoryStream shapeStream, MemoryStream drawingStream)
  {
    shapeStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader((Stream) shapeStream);
    Shape shape = new Shape((IWordDocument) this.m_doc);
    shape.InitializeVMLDefaultValues();
    shape.ApplyCharacterFormat(this.m_currentRunFormat);
    this.ApplyDirectionalOverride(shape.GetCharFormat());
    if (drawingStream != null)
    {
      drawingStream.Position = 0L;
      this.ParseDrawingProperties(UtilityMethods.CreateReader((Stream) drawingStream), shape);
    }
    this.Parse2007Shape(reader, shape);
    return shape;
  }

  private void Parse2007Shape(XmlReader reader, Shape shape)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (!reader.EOF && reader.LocalName != localName2)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case nameof (shape):
          case "rect":
          case "oval":
          case "line":
          case "roundrect":
            this.ParseShape2007Properties(reader, shape);
            this.ParseTextbox(reader, shape);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void Parse2007GroupShape(XmlReader reader, GroupShape shape)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (!reader.EOF && reader.LocalName != localName2)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "group":
            string attribute1 = reader.GetAttribute("id");
            if (!string.IsNullOrEmpty(attribute1))
              shape.Name = attribute1;
            string attribute2 = reader.GetAttribute("coordsize");
            if (!string.IsNullOrEmpty(attribute2))
              shape.CoordinateSize = attribute2;
            string str = reader.GetAttribute("coordorigin");
            if (!string.IsNullOrEmpty(str))
            {
              if (str.EndsWith(","))
                str = str.Insert(str.LastIndexOf(',') + 1, " ");
              else if (str.StartsWith(","))
                str = str.Insert(0, " ");
              else if (!str.Contains(","))
                str = str.Insert(str.Length, ",0");
              string[] strArray = str.Split(new char[1]
              {
                ','
              }, StringSplitOptions.RemoveEmptyEntries);
              shape.CoordinateXOrigin = this.GetChildShapePointValue(strArray[0]);
              shape.CoordinateYOrigin = this.GetChildShapePointValue(strArray[1]);
            }
            this.ParseShape2007Properties(reader, shape);
            this.Parse2007GroupShapeItems(reader, shape);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void Parse2007GroupShapeItems(XmlReader reader, GroupShape shape)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (!reader.EOF && reader.LocalName != localName2 || reader.LocalName == localName2 && reader.NodeType == XmlNodeType.Element)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "group":
            ChildGroupShape childGroupShape = new ChildGroupShape((IWordDocument) this.m_doc);
            childGroupShape.ElementType = Syncfusion.DocIO.DLS.EntityType.ChildGroupShape;
            childGroupShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
            if (shape.Is2007Shape)
              childGroupShape.Is2007Shape = true;
            this.ParseCoordinatesOfNestedGroupShape(reader, childGroupShape);
            this.ParseShape2007Properties(reader, (ChildShape) childGroupShape);
            shape.Add((ParagraphItem) childGroupShape);
            this.Parse2007GroupShapeItems(reader, childGroupShape);
            break;
          case nameof (shape):
          case "rect":
          case "oval":
          case "line":
          case "roundrect":
            string attribute1 = reader.GetAttribute("type");
            string attribute2 = reader.GetAttribute("id");
            string attribute3 = reader.GetAttribute("alt");
            string localName3 = reader.LocalName;
            string attribute4 = reader.GetAttribute("coordsize");
            string attribute5 = reader.GetAttribute("coordorigin");
            MemoryStream memoryStream = this.ReadSingleNodeIntoStream(reader);
            ShapeType shapeType = ShapeType.XmlParagraphItem;
            if (!string.IsNullOrEmpty(attribute1) && this.AutoShapeHelper.GetAutoShapeType(attribute1.Replace("#", "").Replace("_x0000_t", "")) == Syncfusion.DocIO.DLS.AutoShapeType.Unknown && (attribute1 == "#_x0000_t75" || attribute1 == "#_x0000_t202"))
              shapeType = this.DetectShapeType(memoryStream);
            if (localName3 == nameof (shape) && shapeType == ShapeType.PictureShape)
            {
              memoryStream.Position = 0L;
              WPicture pictureShape = this.ParsePictureShape(memoryStream);
              if (!string.IsNullOrEmpty(attribute2))
                pictureShape.AlternativeText = attribute2;
              if (!string.IsNullOrEmpty(attribute3))
                pictureShape.AlternativeText = attribute3;
              pictureShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
              shape.Add((ParagraphItem) pictureShape);
              memoryStream.Position = 0L;
              ChildShape childShape = shape.ChildShapes[shape.ChildShapes.Count - 1];
              childShape.Type = attribute1;
              if (shape.Is2007Shape)
                childShape.Is2007Shape = true;
              if (!string.IsNullOrEmpty(attribute4))
                childShape.CoordinateSize = attribute4;
              if (!string.IsNullOrEmpty(attribute5))
                this.GetCoordinateOrigin(attribute5, (Entity) childShape);
              this.ParseShape2007Properties(UtilityMethods.CreateReader((Stream) memoryStream), childShape);
              if (childShape.Is2007Shape)
                childShape.VMLPathPoints = childShape.Parse2007CustomShapePoints(childShape.Path);
            }
            else
            {
              memoryStream.Position = 0L;
              XmlReader reader1 = UtilityMethods.CreateReader((Stream) memoryStream);
              ChildShape childShape = new ChildShape((IWordDocument) this.m_doc);
              childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.AutoShape;
              childShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
              if (shape.Is2007Shape)
                childShape.Is2007Shape = true;
              if (!string.IsNullOrEmpty(attribute2))
                childShape.Name = attribute2;
              if (!string.IsNullOrEmpty(attribute3))
                childShape.AlternativeText = attribute3;
              this.UpdateAutoShapeType(reader1, childShape, attribute1, localName3, shapeType);
              if (!string.IsNullOrEmpty(attribute4))
                childShape.CoordinateSize = attribute4;
              if (!string.IsNullOrEmpty(attribute5))
                this.GetCoordinateOrigin(attribute5, (Entity) childShape);
              this.ParseShape2007Properties(reader1, childShape);
              this.ParseTextbox(reader1, childShape);
              shape.Add((ParagraphItem) childShape);
              if (childShape.Is2007Shape)
                childShape.VMLPathPoints = childShape.Parse2007CustomShapePoints(childShape.Path);
            }
            flag = true;
            break;
          case "shapetype":
            reader.GetAttribute("id");
            this.ReadSingleNodeIntoStream(reader);
            flag = true;
            break;
          case "wrap":
            string attribute6 = reader.GetAttribute("type");
            switch (attribute6)
            {
              case null:
                goto label_41;
              case "none":
                if (shape.WrapFormat.TextWrappingStyle != TextWrappingStyle.Inline)
                  goto label_41;
                break;
            }
            shape.WrapFormat.SetTextWrappingStyleValue(this.GetWrapStyle(attribute6));
            break;
        }
label_41:
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private ShapeType DetectShapeType(MemoryStream shapeStream)
  {
    XmlReader reader = UtilityMethods.CreateReader((Stream) shapeStream);
    string str1 = (string) null;
    string id = (string) null;
    string str2 = (string) null;
    bool flag1 = false;
    bool flag2 = false;
    bool flag3 = false;
    reader.Read();
    while (reader.LocalName != "shape" && !reader.EOF)
    {
      bool flag4 = false;
      this.SkipWhitespaces(reader);
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "shape":
            str1 = reader.GetAttribute("type");
            reader.GetAttribute("id");
            break;
          case "imagedata":
            flag1 = true;
            id = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            str2 = reader.GetAttribute("href", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            break;
          case "textbox":
            flag2 = true;
            break;
          case "txbxContent":
            flag3 = true;
            reader.Skip();
            break;
        }
      }
      if (!flag4)
        reader.Read();
    }
    if (flag2 && str1 == "#_x0000_t202" || flag2 && flag3 && (str1 == null || id != null))
      return ShapeType.TextboxShape;
    switch (str1)
    {
      case "#_x0000_t75":
        if (flag1)
          return ShapeType.PictureShape;
        break;
    }
    return str2 != null && str2 != string.Empty || id != null && this.GetRelation(id).Key != null ? ShapeType.PictureShape : ShapeType.XmlParagraphItem;
  }

  private void UpdateAutoShapeType(
    XmlReader shapeReader,
    ChildShape childShape,
    string shapetype,
    string node,
    ShapeType shapeType)
  {
    if (shapeReader.LocalName == "rect")
      childShape.AutoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Rectangle;
    else if (shapeReader.LocalName == "oval")
      childShape.AutoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Oval;
    else if (shapeReader.LocalName == "line")
      childShape.AutoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Line;
    else if (shapeReader.LocalName == "roundrect")
    {
      childShape.AutoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.RoundedRectangle;
    }
    else
    {
      if (string.IsNullOrEmpty(shapetype))
        return;
      childShape.AutoShapeType = this.AutoShapeHelper.GetAutoShapeType(shapetype.Replace("#", "").Replace("_x0000_t", ""));
      childShape.Type = shapetype;
      if (!(node == "shape") || shapeType != ShapeType.TextboxShape)
        return;
      childShape.AutoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Rectangle;
    }
  }

  private void Parse2007GroupShapeItems(XmlReader reader, ChildGroupShape shape)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (!reader.EOF && reader.LocalName != localName2 || reader.LocalName == localName2 && reader.NodeType == XmlNodeType.Element)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "group":
            ChildGroupShape childGroupShape = new ChildGroupShape((IWordDocument) this.m_doc);
            childGroupShape.ElementType = Syncfusion.DocIO.DLS.EntityType.ChildGroupShape;
            childGroupShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
            if (shape.Is2007Shape)
              childGroupShape.Is2007Shape = true;
            this.ParseCoordinatesOfNestedGroupShape(reader, childGroupShape);
            this.ParseShape2007Properties(reader, (ChildShape) childGroupShape);
            this.Parse2007GroupShapeItems(reader, childGroupShape);
            shape.Add((ParagraphItem) childGroupShape);
            break;
          case nameof (shape):
          case "rect":
          case "oval":
          case "line":
          case "roundrect":
            string attribute1 = reader.GetAttribute("type");
            string attribute2 = reader.GetAttribute("id");
            string attribute3 = reader.GetAttribute("alt");
            string localName3 = reader.LocalName;
            string attribute4 = reader.GetAttribute("coordsize");
            string attribute5 = reader.GetAttribute("coordorigin");
            MemoryStream memoryStream = this.ReadSingleNodeIntoStream(reader);
            ShapeType shapeType = ShapeType.XmlParagraphItem;
            if (!string.IsNullOrEmpty(attribute1) && this.AutoShapeHelper.GetAutoShapeType(attribute1.Replace("#", "").Replace("_x0000_t", "")) == Syncfusion.DocIO.DLS.AutoShapeType.Unknown && (attribute1 == "#_x0000_t75" || attribute1 == "#_x0000_t202"))
              shapeType = this.DetectShapeType(memoryStream);
            if (localName3 == nameof (shape) && shapeType == ShapeType.PictureShape)
            {
              memoryStream.Position = 0L;
              WPicture pictureShape = this.ParsePictureShape(memoryStream);
              if (!string.IsNullOrEmpty(attribute2))
                pictureShape.AlternativeText = attribute2;
              if (!string.IsNullOrEmpty(attribute3))
                pictureShape.AlternativeText = attribute3;
              pictureShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
              shape.Add((ParagraphItem) pictureShape);
              memoryStream.Position = 0L;
              ChildShape childShape = shape.ChildShapes[shape.ChildShapes.Count - 1];
              childShape.Type = attribute1;
              if (shape.Is2007Shape)
                childShape.Is2007Shape = true;
              if (!string.IsNullOrEmpty(attribute4))
                childShape.CoordinateSize = attribute4;
              if (!string.IsNullOrEmpty(attribute5))
                this.GetCoordinateOrigin(attribute5, (Entity) childShape);
              this.ParseShape2007Properties(UtilityMethods.CreateReader((Stream) memoryStream), childShape);
            }
            else
            {
              memoryStream.Position = 0L;
              XmlReader reader1 = UtilityMethods.CreateReader((Stream) memoryStream);
              ChildShape childShape = new ChildShape((IWordDocument) this.m_doc);
              childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.AutoShape;
              childShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
              if (shape.Is2007Shape)
                childShape.Is2007Shape = true;
              if (!string.IsNullOrEmpty(attribute2))
                childShape.Name = attribute2;
              if (!string.IsNullOrEmpty(attribute3))
                childShape.AlternativeText = attribute3;
              this.UpdateAutoShapeType(reader1, childShape, attribute1, localName3, shapeType);
              if (!string.IsNullOrEmpty(attribute4))
                childShape.CoordinateSize = attribute4;
              if (!string.IsNullOrEmpty(attribute5))
                this.GetCoordinateOrigin(attribute5, (Entity) childShape);
              this.ParseShape2007Properties(reader1, childShape);
              this.ParseTextbox(reader1, childShape);
              shape.Add((ParagraphItem) childShape);
            }
            flag = true;
            break;
          case "shapetype":
            reader.GetAttribute("id");
            this.ReadSingleNodeIntoStream(reader);
            flag = true;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseCoordinatesOfNestedGroupShape(XmlReader reader, ChildGroupShape nestedGroup)
  {
    string attribute1 = reader.GetAttribute("id");
    if (!string.IsNullOrEmpty(attribute1))
      nestedGroup.Name = attribute1;
    string attribute2 = reader.GetAttribute("coordsize");
    if (!string.IsNullOrEmpty(attribute2))
      nestedGroup.CoordinateSize = attribute2;
    string attribute3 = reader.GetAttribute("coordorigin");
    if (string.IsNullOrEmpty(attribute3))
      return;
    this.GetCoordinateOrigin(attribute3, (Entity) nestedGroup);
  }

  private void GetCoordinateOrigin(string coordOrigin, Entity shapeEntity)
  {
    if (coordOrigin.EndsWith(","))
      coordOrigin = coordOrigin.Insert(coordOrigin.LastIndexOf(',') + 1, " ");
    else if (coordOrigin.StartsWith(","))
      coordOrigin = coordOrigin.Insert(0, " ");
    else if (!coordOrigin.Contains(","))
      coordOrigin = coordOrigin.Insert(coordOrigin.Length, ",0");
    string[] strArray = coordOrigin.Split(new char[1]{ ',' }, StringSplitOptions.RemoveEmptyEntries);
    switch (shapeEntity)
    {
      case ShapeCommon _:
        (shapeEntity as ShapeCommon).CoordinateXOrigin = this.GetChildShapePointValue(strArray[0]);
        (shapeEntity as ShapeCommon).CoordinateYOrigin = this.GetChildShapePointValue(strArray[1]);
        break;
      case WTextBox _:
        (shapeEntity as WTextBox).TextBoxFormat.CoordinateXOrigin = this.GetChildShapePointValue(strArray[0]);
        (shapeEntity as WTextBox).TextBoxFormat.CoordinateYOrigin = this.GetChildShapePointValue(strArray[1]);
        break;
    }
  }

  private void ParseTextBoxWrapStyle(XmlReader reader, Shape shape)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (!reader.EOF && reader.LocalName != localName2)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "wrap":
            string attribute = reader.GetAttribute("type");
            if (attribute != null)
            {
              shape.WrapFormat.SetTextWrappingStyleValue(this.GetWrapStyle(attribute));
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseTextbox(XmlReader reader, ChildShape shape)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (!reader.EOF && !(reader.LocalName == localName2))
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "stroke":
            this.ParseStroke(reader, shape);
            break;
          case "textbox":
            if (shape.AutoShapeType == Syncfusion.DocIO.DLS.AutoShapeType.Unknown)
              shape.IsTextBoxShape = true;
            shape.ElementType = shape.AutoShapeType != Syncfusion.DocIO.DLS.AutoShapeType.Rectangle ? Syncfusion.DocIO.DLS.EntityType.AutoShape : Syncfusion.DocIO.DLS.EntityType.TextBox;
            this.ParseTextBoxStyle(reader, shape.TextFrame);
            if (!string.IsNullOrEmpty(reader.GetAttribute("inset")))
            {
              shape.TextFrame.HasInternalMargin = true;
              this.ParseTextFrameInternalMargins(reader, shape.TextFrame);
            }
            this.m_currentRunFormat = (WCharacterFormat) null;
            RevisionType trackChangeType = this.m_trackChangeType;
            this.m_trackChangeType = RevisionType.None;
            Stack<Revision> collection1 = new Stack<Revision>((IEnumerable<Revision>) this.m_trackchangeRevisionDetails);
            this.m_trackchangeRevisionDetails.Clear();
            Stack<RevisionType> collection2 = new Stack<RevisionType>((IEnumerable<RevisionType>) this.m_trackchangeStack);
            this.m_trackchangeStack.Clear();
            this.Parse2007TextboxContent(reader, shape.TextBody);
            this.m_trackChangeType = trackChangeType;
            this.m_trackchangeRevisionDetails = new Stack<Revision>((IEnumerable<Revision>) collection1);
            collection1.Clear();
            this.m_trackchangeStack = new Stack<RevisionType>((IEnumerable<RevisionType>) collection2);
            collection2.Clear();
            break;
          case "fill":
            shape.IsFillStyleInline = true;
            flag = this.ParseFillEffects(reader, shape);
            break;
          case "textpath":
            if (!shape.Docx2007Props.ContainsKey("textpath"))
            {
              shape.Docx2007Props.Add("textpath", (Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              break;
            }
            break;
          case "shadow":
            if (!shape.Docx2007Props.ContainsKey("shadow"))
            {
              shape.Docx2007Props.Add("shadow", (Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              break;
            }
            break;
          case "path":
            if (!shape.Docx2007Props.ContainsKey("path"))
            {
              shape.Docx2007Props.Add("path", (Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              break;
            }
            break;
          case "imagedata":
            string attribute1 = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            if (!string.IsNullOrEmpty(attribute1))
            {
              ImageRecord imageRecord1 = this.GetImageRecord(attribute1);
              if (attribute1 != null && imageRecord1 != null && !shape.ImageRelations.ContainsKey(attribute1))
              {
                bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
                bool isImageRelation = true;
                string imageName = this.GetImageName(attribute1, isHeaderFooter, false, ref isImageRelation);
                shape.FillFormat.ImageRecord = imageRecord1;
                shape.ImageRelations.Add(attribute1, imageRecord1);
                if (!this.ImageIds.ContainsKey(imageName))
                {
                  ImageRecord imageRecord2 = this.m_doc.Images.LoadXmlItemImage(shape.FillFormat.ImageRecord.ImageBytes);
                  this.ImageIds.Add(imageName, imageRecord2.ImageId);
                }
              }
            }
            string attribute2 = reader.GetAttribute("gain");
            if (!string.IsNullOrEmpty(attribute2))
              shape.FillFormat.Contrast = this.GetOpacityValue(attribute2);
            string attribute3 = reader.GetAttribute("recolortarget");
            if (!string.IsNullOrEmpty(attribute3))
            {
              shape.FillFormat.ReColorTarget = this.GetColorValue(attribute3);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseTextbox(XmlReader reader, Shape shape)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (!reader.EOF && !(reader.LocalName == localName2))
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "stroke":
            this.ParseStroke(reader, shape);
            break;
          case "textbox":
            this.ParseTextboxIntMargins(reader, shape);
            this.ParseTextBoxStyle(reader, shape.TextFrame);
            this.m_currentRunFormat = (WCharacterFormat) null;
            RevisionType trackChangeType = this.m_trackChangeType;
            this.m_trackChangeType = RevisionType.None;
            Stack<Revision> collection1 = new Stack<Revision>((IEnumerable<Revision>) this.m_trackchangeRevisionDetails);
            this.m_trackchangeRevisionDetails.Clear();
            Stack<RevisionType> collection2 = new Stack<RevisionType>((IEnumerable<RevisionType>) this.m_trackchangeStack);
            this.m_trackchangeStack.Clear();
            this.Parse2007TextboxContent(reader, shape.TextBody);
            this.m_trackChangeType = trackChangeType;
            this.m_trackchangeRevisionDetails = new Stack<Revision>((IEnumerable<Revision>) collection1);
            collection1.Clear();
            this.m_trackchangeStack = new Stack<RevisionType>((IEnumerable<RevisionType>) collection2);
            collection2.Clear();
            break;
          case "fill":
            flag = this.ParseFillEffects(reader, shape);
            break;
          case "wrap":
            string attribute1 = reader.GetAttribute("type");
            if (!string.IsNullOrEmpty(attribute1))
              shape.WrapFormat.SetTextWrappingStyleValue(this.GetWrapStyle(attribute1));
            string attribute2 = reader.GetAttribute("side");
            if (!string.IsNullOrEmpty(attribute2))
            {
              shape.WrapFormat.TextWrappingType = this.GetTextWrapType(attribute2);
              break;
            }
            break;
          case "textpath":
            shape.Docx2007Props.Add("textpath", (Stream) this.ReadSingleNodeIntoStream(reader));
            flag = true;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private bool ParseFillEffects(XmlReader reader, GroupShape shape)
  {
    bool fillEffects = false;
    string attribute1 = reader.GetAttribute("opacity");
    if (!string.IsNullOrEmpty(attribute1))
      shape.FillFormat.Transparency = this.GetOpacityValue(attribute1);
    string attribute2 = reader.GetAttribute("opacity2");
    if (!string.IsNullOrEmpty(attribute2))
      shape.FillFormat.SecondaryOpacity = this.GetOpacityValue(attribute2);
    string attribute3 = reader.GetAttribute("color2");
    if (!string.IsNullOrEmpty(attribute3) && !shape.FillFormat.Color.IsEmpty)
    {
      shape.FillFormat.ForeColor = shape.FillFormat.Color;
      shape.FillFormat.Color = this.GetColorValue(attribute3);
    }
    string attribute4 = reader.GetAttribute("rotate");
    if (!string.IsNullOrEmpty(attribute4))
      shape.FillFormat.RotateWithObject = this.GetBoolValue(attribute4);
    string attribute5 = reader.GetAttribute("on");
    if (!string.IsNullOrEmpty(attribute5))
      shape.FillFormat.Visible = this.GetBoolValue(attribute5);
    string attribute6 = reader.GetAttribute("alignshape");
    if (!string.IsNullOrEmpty(attribute4))
      shape.FillFormat.AlignWithShape = this.GetBoolValue(attribute6);
    string attribute7 = reader.GetAttribute("althref");
    if (!string.IsNullOrEmpty(attribute7))
      shape.FillFormat.AlternateHRef = attribute7.ToString();
    string attribute8 = reader.GetAttribute("aspect");
    if (!string.IsNullOrEmpty(attribute8) && attribute8.Length > 2 && System.Enum.IsDefined(typeof (FillAspect), (object) (char.ToUpper(attribute8[0]).ToString() + attribute8.Substring(1))))
      shape.FillFormat.Aspect = (FillAspect) System.Enum.Parse(typeof (FillAspect), attribute8, true);
    string attribute9 = reader.GetAttribute("detectmouseclick");
    if (!string.IsNullOrEmpty(attribute9))
      shape.FillFormat.DetectMouseClick = this.GetBoolValue(attribute9);
    string attribute10 = reader.GetAttribute("recolor");
    if (!string.IsNullOrEmpty(attribute10))
      shape.FillFormat.ReColor = this.GetBoolValue(attribute10);
    string attribute11 = reader.GetAttribute("focus");
    if (!string.IsNullOrEmpty(attribute11))
    {
      if (attribute11.EndsWith("%"))
        shape.FillFormat.Focus = (float) (this.GetPercentage(attribute11) * 65536.0 / 100.0);
      else if (attribute11.EndsWith("f"))
      {
        string str = attribute11.Replace("f", "");
        shape.FillFormat.Focus = this.GetEffectsPointValue(str);
      }
      else
        shape.FillFormat.Focus = this.GetEffectsPointValue(attribute11);
    }
    string attribute12 = reader.GetAttribute("position");
    if (!string.IsNullOrEmpty(attribute12))
    {
      string str1 = attribute12.Trim(ControlChar.SpaceChar);
      if (str1.Contains(","))
      {
        if (str1.StartsWith(","))
        {
          string str2 = str1.Substring(1);
          if (str2.EndsWith("%"))
            shape.FillFormat.PositionY = (float) (this.GetPercentage(str2) * 65536.0 / 100.0);
          else if (str2.EndsWith("f"))
          {
            string str3 = str2.Replace("f", "");
            shape.FillFormat.PositionY = this.GetEffectsPointValue(str3);
          }
          else
            shape.FillFormat.PositionY = this.GetEffectsPointValue(str2);
        }
        else if (str1.EndsWith(","))
        {
          string str4 = str1.Substring(0, str1.Length - 1);
          if (str4.EndsWith("%"))
            shape.FillFormat.PositionX = (float) (this.GetPercentage(str4) * 65536.0 / 100.0);
          else if (str4.EndsWith("f"))
          {
            string str5 = str4.Replace("f", "");
            shape.FillFormat.PositionX = this.GetEffectsPointValue(str5);
          }
          else
            shape.FillFormat.PositionX = this.GetEffectsPointValue(str4);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, str1, "position");
      }
      else if (str1.EndsWith("%"))
        shape.FillFormat.PositionX = (float) (this.GetPercentage(str1) * 65536.0 / 100.0);
      else if (str1.EndsWith("f"))
      {
        string str6 = str1.Replace("f", "");
        shape.FillFormat.PositionX = this.GetEffectsPointValue(str6);
      }
      else
        shape.FillFormat.PositionX = this.GetEffectsPointValue(str1);
    }
    string attribute13 = reader.GetAttribute("focusposition");
    if (!string.IsNullOrEmpty(attribute13))
    {
      string str7 = attribute13.Trim(ControlChar.SpaceChar);
      if (str7.Contains(","))
      {
        if (str7.StartsWith(","))
        {
          string str8 = str7.Substring(1);
          if (str8.EndsWith("%"))
            shape.FillFormat.FocusPositionY = (float) (this.GetPercentage(str8) * 65536.0 / 100.0);
          else if (str8.EndsWith("f"))
          {
            string str9 = str8.Replace("f", "");
            shape.FillFormat.FocusPositionY = this.GetEffectsPointValue(str9);
          }
          else
            shape.FillFormat.FocusPositionY = this.GetEffectsPointValue(str8);
        }
        else if (str7.EndsWith(","))
        {
          string str10 = str7.Substring(0, str7.Length - 1);
          if (str10.EndsWith("%"))
            shape.FillFormat.FocusPositionX = (float) (this.GetPercentage(str10) * 65536.0 / 100.0);
          else if (str10.EndsWith("f"))
          {
            string str11 = str10.Replace("f", "");
            shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str11);
          }
          else
            shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str10);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, str7, "focusposition");
      }
      else if (str7.EndsWith("%"))
        shape.FillFormat.FocusPositionX = (float) (this.GetPercentage(str7) * 65536.0 / 100.0);
      else if (str7.EndsWith("f"))
      {
        string str12 = str7.Replace("f", "");
        shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str12);
      }
      else
        shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str7);
    }
    string attribute14 = reader.GetAttribute("focussize");
    if (!string.IsNullOrEmpty(attribute14))
    {
      string str13 = attribute14.Trim(ControlChar.SpaceChar);
      if (str13.Contains(","))
      {
        if (str13.StartsWith(","))
        {
          string str14 = str13.Substring(1);
          if (str14.EndsWith("%"))
            shape.FillFormat.FocusSizeY = (float) (this.GetPercentage(str14) * 65536.0 / 100.0);
          else if (str14.EndsWith("f"))
          {
            string str15 = str14.Replace("f", "");
            shape.FillFormat.FocusSizeY = this.GetEffectsPointValue(str15);
          }
          else
            shape.FillFormat.FocusSizeY = this.GetEffectsPointValue(str14);
        }
        else if (str13.EndsWith(","))
        {
          string str16 = str13.Substring(0, str13.Length - 1);
          if (str16.EndsWith("%"))
            shape.FillFormat.FocusSizeX = (float) (this.GetPercentage(str16) * 65536.0 / 100.0);
          else if (str16.EndsWith("f"))
          {
            string str17 = str16.Replace("f", "");
            shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str17);
          }
          else
            shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str16);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, str13, "focussize");
      }
      else if (str13.EndsWith("%"))
        shape.FillFormat.FocusSizeX = (float) (this.GetPercentage(str13) * 65536.0 / 100.0);
      else if (str13.EndsWith("f"))
      {
        string str18 = str13.Replace("f", "");
        shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str18);
      }
      else
        shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str13);
    }
    string attribute15 = reader.GetAttribute("type");
    if (!string.IsNullOrEmpty(attribute15))
    {
      switch (attribute15)
      {
        case "solid":
        case "tile":
        case "frame":
        case "pattern":
          switch (attribute15)
          {
            case "pattern":
              shape.FillFormat.FillType = FillType.FillPatterned;
              break;
            case "frame":
              shape.FillFormat.FillType = FillType.FillPicture;
              break;
            case "tile":
              shape.FillFormat.FillType = FillType.FillTextured;
              break;
            case "solid":
              shape.FillFormat.FillType = FillType.FillSolid;
              break;
          }
          string attribute16 = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute16))
          {
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            bool isImageRelation = true;
            string imageName = this.GetImageName(attribute16, isHeaderFooter, false, ref isImageRelation);
            shape.FillFormat.ImageRecord = this.GetImageRecord(attribute16);
            if (!this.ImageIds.ContainsKey(imageName))
            {
              ImageRecord imageRecord = this.m_doc.Images.LoadXmlItemImage(shape.FillFormat.ImageRecord.ImageBytes);
              this.ImageIds.Add(imageName, imageRecord.ImageId);
              break;
            }
            break;
          }
          break;
        case "gradient":
        case "gradientRadial":
          reader.GetAttribute("color2");
          shape.FillFormat.FillType = FillType.FillGradient;
          if (attribute15 == "gradient")
          {
            shape.FillFormat.GradientFill.LinearGradient = new LinearGradient();
            string attribute17 = reader.GetAttribute("angle");
            if (!string.IsNullOrEmpty(attribute17))
            {
              int angle = this.GetAngle(attribute17);
              if (attribute17.StartsWith("-"))
                shape.FillFormat.GradientFill.LinearGradient.AnglePositive = false;
              if (angle != int.MaxValue)
                shape.FillFormat.GradientFill.LinearGradient.Angle = Convert.ToInt16((object) angle, (IFormatProvider) CultureInfo.InvariantCulture);
            }
          }
          else
          {
            shape.FillFormat.GradientFill.PathGradient = new PathGradient();
            shape.FillFormat.GradientFill.PathGradient.PathShade = GradientShadeType.Shape;
          }
          this.Parse2007GradientFill(reader, shape.FillFormat.GradientFill);
          break;
      }
    }
    return fillEffects;
  }

  private bool ParseFillEffects(XmlReader reader, ChildShape shape)
  {
    bool fillEffects = false;
    string attribute1 = reader.GetAttribute("opacity");
    if (!string.IsNullOrEmpty(attribute1))
      shape.FillFormat.Transparency = this.GetOpacityValue(attribute1);
    string attribute2 = reader.GetAttribute("opacity2");
    if (!string.IsNullOrEmpty(attribute2))
      shape.FillFormat.SecondaryOpacity = this.GetOpacityValue(attribute2);
    string attribute3 = reader.GetAttribute("color2");
    if (!string.IsNullOrEmpty(attribute3) && !shape.FillFormat.Color.IsEmpty)
    {
      shape.FillFormat.ForeColor = shape.FillFormat.Color;
      shape.FillFormat.Color = this.GetColorValue(attribute3);
    }
    string attribute4 = reader.GetAttribute("rotate");
    if (!string.IsNullOrEmpty(attribute4))
      shape.FillFormat.RotateWithObject = this.GetBoolValue(attribute4);
    string attribute5 = reader.GetAttribute("on");
    if (!string.IsNullOrEmpty(attribute5))
      shape.FillFormat.Visible = this.GetBoolValue(attribute5);
    string attribute6 = reader.GetAttribute("alignshape");
    if (!string.IsNullOrEmpty(attribute4))
      shape.FillFormat.AlignWithShape = this.GetBoolValue(attribute6);
    string attribute7 = reader.GetAttribute("althref");
    if (!string.IsNullOrEmpty(attribute7))
      shape.FillFormat.AlternateHRef = attribute7.ToString();
    string attribute8 = reader.GetAttribute("aspect");
    if (!string.IsNullOrEmpty(attribute8) && attribute8.Length > 2 && System.Enum.IsDefined(typeof (FillAspect), (object) (char.ToUpper(attribute8[0]).ToString() + attribute8.Substring(1))))
      shape.FillFormat.Aspect = (FillAspect) System.Enum.Parse(typeof (FillAspect), attribute8, true);
    string attribute9 = reader.GetAttribute("detectmouseclick");
    if (!string.IsNullOrEmpty(attribute9))
      shape.FillFormat.DetectMouseClick = this.GetBoolValue(attribute9);
    string attribute10 = reader.GetAttribute("recolor");
    if (!string.IsNullOrEmpty(attribute10))
      shape.FillFormat.ReColor = this.GetBoolValue(attribute10);
    string attribute11 = reader.GetAttribute("focus");
    if (!string.IsNullOrEmpty(attribute11))
    {
      if (attribute11.EndsWith("%"))
        shape.FillFormat.Focus = (float) (this.GetPercentage(attribute11) * 65536.0 / 100.0);
      else if (attribute11.EndsWith("f"))
      {
        string str = attribute11.Replace("f", "");
        shape.FillFormat.Focus = this.GetEffectsPointValue(str);
      }
      else
        shape.FillFormat.Focus = this.GetEffectsPointValue(attribute11);
    }
    string attribute12 = reader.GetAttribute("position");
    if (!string.IsNullOrEmpty(attribute12))
    {
      string str1 = attribute12.Trim(ControlChar.SpaceChar);
      if (str1.Contains(","))
      {
        if (str1.StartsWith(","))
        {
          string str2 = str1.Substring(1);
          if (str2.EndsWith("%"))
            shape.FillFormat.PositionY = (float) (this.GetPercentage(str2) * 65536.0 / 100.0);
          else if (str2.EndsWith("f"))
          {
            string str3 = str2.Replace("f", "");
            shape.FillFormat.PositionY = this.GetEffectsPointValue(str3);
          }
          else
            shape.FillFormat.PositionY = this.GetEffectsPointValue(str2);
        }
        else if (str1.EndsWith(","))
        {
          string str4 = str1.Substring(0, str1.Length - 1);
          if (str4.EndsWith("%"))
            shape.FillFormat.PositionX = (float) (this.GetPercentage(str4) * 65536.0 / 100.0);
          else if (str4.EndsWith("f"))
          {
            string str5 = str4.Replace("f", "");
            shape.FillFormat.PositionX = this.GetEffectsPointValue(str5);
          }
          else
            shape.FillFormat.PositionX = this.GetEffectsPointValue(str4);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, str1, "position");
      }
      else if (str1.EndsWith("%"))
        shape.FillFormat.PositionX = (float) (this.GetPercentage(str1) * 65536.0 / 100.0);
      else if (str1.EndsWith("f"))
      {
        string str6 = str1.Replace("f", "");
        shape.FillFormat.PositionX = this.GetEffectsPointValue(str6);
      }
      else
        shape.FillFormat.PositionX = this.GetEffectsPointValue(str1);
    }
    string attribute13 = reader.GetAttribute("focusposition");
    if (!string.IsNullOrEmpty(attribute13))
    {
      string str7 = attribute13.Trim(ControlChar.SpaceChar);
      if (str7.Contains(","))
      {
        if (str7.StartsWith(","))
        {
          string str8 = str7.Substring(1);
          if (str8.EndsWith("%"))
            shape.FillFormat.FocusPositionY = (float) (this.GetPercentage(str8) * 65536.0 / 100.0);
          else if (str8.EndsWith("f"))
          {
            string str9 = str8.Replace("f", "");
            shape.FillFormat.FocusPositionY = this.GetEffectsPointValue(str9);
          }
          else
            shape.FillFormat.FocusPositionY = this.GetEffectsPointValue(str8);
        }
        else if (str7.EndsWith(","))
        {
          string str10 = str7.Substring(0, str7.Length - 1);
          if (str10.EndsWith("%"))
            shape.FillFormat.FocusPositionX = (float) (this.GetPercentage(str10) * 65536.0 / 100.0);
          else if (str10.EndsWith("f"))
          {
            string str11 = str10.Replace("f", "");
            shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str11);
          }
          else
            shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str10);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, str7, "focusposition");
      }
      else if (str7.EndsWith("%"))
        shape.FillFormat.FocusPositionX = (float) (this.GetPercentage(str7) * 65536.0 / 100.0);
      else if (str7.EndsWith("f"))
      {
        string str12 = str7.Replace("f", "");
        shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str12);
      }
      else
        shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str7);
    }
    string attribute14 = reader.GetAttribute("focussize");
    if (!string.IsNullOrEmpty(attribute14))
    {
      string str13 = attribute14.Trim(ControlChar.SpaceChar);
      if (str13.Contains(","))
      {
        if (str13.StartsWith(","))
        {
          string str14 = str13.Substring(1);
          if (str14.EndsWith("%"))
            shape.FillFormat.FocusSizeY = (float) (this.GetPercentage(str14) * 65536.0 / 100.0);
          else if (str14.EndsWith("f"))
          {
            string str15 = str14.Replace("f", "");
            shape.FillFormat.FocusSizeY = this.GetEffectsPointValue(str15);
          }
          else
            shape.FillFormat.FocusSizeY = this.GetEffectsPointValue(str14);
        }
        else if (str13.EndsWith(","))
        {
          string str16 = str13.Substring(0, str13.Length - 1);
          if (str16.EndsWith("%"))
            shape.FillFormat.FocusSizeX = (float) (this.GetPercentage(str16) * 65536.0 / 100.0);
          else if (str16.EndsWith("f"))
          {
            string str17 = str16.Replace("f", "");
            shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str17);
          }
          else
            shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str16);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, str13, "focussize");
      }
      else if (str13.EndsWith("%"))
        shape.FillFormat.FocusSizeX = (float) (this.GetPercentage(str13) * 65536.0 / 100.0);
      else if (str13.EndsWith("f"))
      {
        string str18 = str13.Replace("f", "");
        shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str18);
      }
      else
        shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str13);
    }
    string attribute15 = reader.GetAttribute("type");
    if (!string.IsNullOrEmpty(attribute15))
    {
      switch (attribute15)
      {
        case "solid":
        case "tile":
        case "frame":
        case "pattern":
          switch (attribute15)
          {
            case "pattern":
              shape.FillFormat.FillType = FillType.FillPatterned;
              break;
            case "frame":
              shape.FillFormat.FillType = FillType.FillPicture;
              break;
            case "tile":
              shape.FillFormat.FillType = FillType.FillTextured;
              break;
            case "solid":
              shape.FillFormat.FillType = FillType.FillSolid;
              break;
          }
          string attribute16 = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute16))
          {
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            bool isImageRelation = true;
            string imageName = this.GetImageName(attribute16, isHeaderFooter, false, ref isImageRelation);
            shape.FillFormat.ImageRecord = this.GetImageRecord(attribute16);
            if (!this.ImageIds.ContainsKey(imageName))
            {
              ImageRecord imageRecord = this.m_doc.Images.LoadXmlItemImage(shape.FillFormat.ImageRecord.ImageBytes);
              this.ImageIds.Add(imageName, imageRecord.ImageId);
              break;
            }
            break;
          }
          break;
        case "gradient":
        case "gradientRadial":
          reader.GetAttribute("color2");
          shape.FillFormat.FillType = FillType.FillGradient;
          if (attribute15 == "gradient")
          {
            shape.FillFormat.GradientFill.LinearGradient = new LinearGradient();
            string attribute17 = reader.GetAttribute("angle");
            if (!string.IsNullOrEmpty(attribute17))
            {
              int angle = this.GetAngle(attribute17);
              if (attribute17.StartsWith("-"))
                shape.FillFormat.GradientFill.LinearGradient.AnglePositive = false;
              if (angle != int.MaxValue)
                shape.FillFormat.GradientFill.LinearGradient.Angle = Convert.ToInt16((object) angle, (IFormatProvider) CultureInfo.InvariantCulture);
            }
            shape.FillFormat.GradientFill.LinearGradient.IsAngleDefined = attribute17 != null;
          }
          else
          {
            shape.FillFormat.GradientFill.PathGradient = new PathGradient();
            shape.FillFormat.GradientFill.PathGradient.PathShade = GradientShadeType.Shape;
          }
          this.Parse2007GradientFill(reader, shape.FillFormat.GradientFill);
          break;
      }
    }
    return fillEffects;
  }

  private bool ParseFillEffects(XmlReader reader, Shape shape)
  {
    bool fillEffects = false;
    string attribute1 = reader.GetAttribute("opacity");
    if (!string.IsNullOrEmpty(attribute1))
      shape.FillFormat.Transparency = this.GetOpacityValue(attribute1);
    string attribute2 = reader.GetAttribute("opacity2");
    if (!string.IsNullOrEmpty(attribute2))
      shape.FillFormat.SecondaryOpacity = this.GetOpacityValue(attribute2);
    string attribute3 = reader.GetAttribute("color2");
    if (!string.IsNullOrEmpty(attribute3) && !shape.FillFormat.Color.IsEmpty)
    {
      shape.FillFormat.ForeColor = shape.FillFormat.Color;
      shape.FillFormat.Color = this.GetColorValue(attribute3);
    }
    string attribute4 = reader.GetAttribute("rotate");
    if (!string.IsNullOrEmpty(attribute4))
      shape.FillFormat.RotateWithObject = this.GetBoolValue(attribute4);
    string attribute5 = reader.GetAttribute("on");
    if (!string.IsNullOrEmpty(attribute5))
      shape.FillFormat.Visible = this.GetBoolValue(attribute5);
    string attribute6 = reader.GetAttribute("alignshape");
    if (!string.IsNullOrEmpty(attribute6))
      shape.FillFormat.AlignWithShape = this.GetBoolValue(attribute6);
    string attribute7 = reader.GetAttribute("althref");
    if (!string.IsNullOrEmpty(attribute7))
      shape.FillFormat.AlternateHRef = attribute7.ToString();
    string attribute8 = reader.GetAttribute("aspect");
    if (!string.IsNullOrEmpty(attribute8) && attribute8.Length > 2 && System.Enum.IsDefined(typeof (FillAspect), (object) (char.ToUpper(attribute8[0]).ToString() + attribute8.Substring(1))))
      shape.FillFormat.Aspect = (FillAspect) System.Enum.Parse(typeof (FillAspect), attribute8, true);
    string attribute9 = reader.GetAttribute("detectmouseclick");
    if (!string.IsNullOrEmpty(attribute9))
      shape.FillFormat.DetectMouseClick = this.GetBoolValue(attribute9);
    string attribute10 = reader.GetAttribute("recolor");
    if (!string.IsNullOrEmpty(attribute10))
      shape.FillFormat.ReColor = this.GetBoolValue(attribute10);
    string attribute11 = reader.GetAttribute("focus");
    if (!string.IsNullOrEmpty(attribute11))
    {
      if (attribute11.EndsWith("%"))
        shape.FillFormat.Focus = (float) (this.GetPercentage(attribute11) * 65536.0 / 100.0);
      else if (attribute11.EndsWith("f"))
      {
        string str = attribute11.Replace("f", "");
        shape.FillFormat.Focus = this.GetEffectsPointValue(str);
      }
      else
        shape.FillFormat.Focus = this.GetEffectsPointValue(attribute11);
    }
    string attribute12 = reader.GetAttribute("position");
    if (!string.IsNullOrEmpty(attribute12))
    {
      string text = attribute12.Trim(ControlChar.SpaceChar);
      if (text.Contains(","))
      {
        if (this.StartsWithExt(text, ","))
        {
          string str1 = text.Substring(1);
          if (str1.EndsWith("%"))
            shape.FillFormat.PositionY = (float) (this.GetPercentage(str1) * 65536.0 / 100.0);
          else if (str1.EndsWith("f"))
          {
            string str2 = str1.Replace("f", "");
            shape.FillFormat.PositionY = this.GetEffectsPointValue(str2);
          }
          else
            shape.FillFormat.PositionY = this.GetEffectsPointValue(str1);
        }
        else if (text.EndsWith(","))
        {
          string str3 = text.Substring(0, text.Length - 1);
          if (str3.EndsWith("%"))
            shape.FillFormat.PositionX = (float) (this.GetPercentage(str3) * 65536.0 / 100.0);
          else if (str3.EndsWith("f"))
          {
            string str4 = str3.Replace("f", "");
            shape.FillFormat.PositionX = this.GetEffectsPointValue(str4);
          }
          else
            shape.FillFormat.PositionX = this.GetEffectsPointValue(str3);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, text, "position");
      }
      else if (text.EndsWith("%"))
        shape.FillFormat.PositionX = (float) (this.GetPercentage(text) * 65536.0 / 100.0);
      else if (text.EndsWith("f"))
      {
        string str = text.Replace("f", "");
        shape.FillFormat.PositionX = this.GetEffectsPointValue(str);
      }
      else
        shape.FillFormat.PositionX = this.GetEffectsPointValue(text);
    }
    string attribute13 = reader.GetAttribute("focusposition");
    if (!string.IsNullOrEmpty(attribute13))
    {
      string text = attribute13.Trim(ControlChar.SpaceChar);
      if (text.Contains(","))
      {
        if (this.StartsWithExt(text, ","))
        {
          string str5 = text.Substring(1);
          if (str5.EndsWith("%"))
            shape.FillFormat.FocusPositionY = (float) (this.GetPercentage(str5) * 65536.0 / 100.0);
          else if (str5.EndsWith("f"))
          {
            string str6 = str5.Replace("f", "");
            shape.FillFormat.FocusPositionY = this.GetEffectsPointValue(str6);
          }
          else
            shape.FillFormat.FocusPositionY = this.GetEffectsPointValue(str5);
        }
        else if (text.EndsWith(","))
        {
          string str7 = text.Substring(0, text.Length - 1);
          if (str7.EndsWith("%"))
            shape.FillFormat.FocusPositionX = (float) (this.GetPercentage(str7) * 65536.0 / 100.0);
          else if (str7.EndsWith("f"))
          {
            string str8 = str7.Replace("f", "");
            shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str8);
          }
          else
            shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str7);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, text, "focusposition");
      }
      else if (text.EndsWith("%"))
        shape.FillFormat.FocusPositionX = (float) (this.GetPercentage(text) * 65536.0 / 100.0);
      else if (text.EndsWith("f"))
      {
        string str = text.Replace("f", "");
        shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(str);
      }
      else
        shape.FillFormat.FocusPositionX = this.GetEffectsPointValue(text);
    }
    string attribute14 = reader.GetAttribute("focussize");
    if (!string.IsNullOrEmpty(attribute14))
    {
      string text = attribute14.Trim(ControlChar.SpaceChar);
      if (text.Contains(","))
      {
        if (this.StartsWithExt(text, ","))
        {
          string str9 = text.Substring(1);
          if (str9.EndsWith("%"))
            shape.FillFormat.FocusSizeY = (float) (this.GetPercentage(str9) * 65536.0 / 100.0);
          else if (str9.EndsWith("f"))
          {
            string str10 = str9.Replace("f", "");
            shape.FillFormat.FocusSizeY = this.GetEffectsPointValue(str10);
          }
          else
            shape.FillFormat.FocusSizeY = this.GetEffectsPointValue(str9);
        }
        else if (text.EndsWith(","))
        {
          string str11 = text.Substring(0, text.Length - 1);
          if (str11.EndsWith("%"))
            shape.FillFormat.FocusSizeX = (float) (this.GetPercentage(str11) * 65536.0 / 100.0);
          else if (str11.EndsWith("f"))
          {
            string str12 = str11.Replace("f", "");
            shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str12);
          }
          else
            shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str11);
        }
        else
          this.ParseFillOffsets(shape.FillFormat, text, "focussize");
      }
      else if (text.EndsWith("%"))
        shape.FillFormat.FocusSizeX = (float) (this.GetPercentage(text) * 65536.0 / 100.0);
      else if (text.EndsWith("f"))
      {
        string str = text.Replace("f", "");
        shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(str);
      }
      else
        shape.FillFormat.FocusSizeX = this.GetEffectsPointValue(text);
    }
    string attribute15 = reader.GetAttribute("type");
    if (!string.IsNullOrEmpty(attribute15))
    {
      switch (attribute15.ToLower())
      {
        case "solid":
        case "tile":
        case "frame":
        case "pattern":
          switch (attribute15)
          {
            case "pattern":
              shape.FillFormat.FillType = FillType.FillPatterned;
              break;
            case "frame":
              shape.FillFormat.FillType = FillType.FillPicture;
              break;
            case "tile":
              shape.FillFormat.FillType = FillType.FillTextured;
              break;
            case "solid":
              shape.FillFormat.FillType = FillType.FillSolid;
              break;
          }
          string attribute16 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute16))
          {
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            bool isImageRelation = true;
            string imageName = this.GetImageName(attribute16, isHeaderFooter, false, ref isImageRelation);
            shape.FillFormat.ImageRecord = this.GetImageRecord(attribute16);
            if (!this.ImageIds.ContainsKey(imageName))
            {
              ImageRecord imageRecord = this.m_doc.Images.LoadXmlItemImage(shape.FillFormat.ImageRecord.ImageBytes);
              this.ImageIds.Add(imageName, imageRecord.ImageId);
              break;
            }
            break;
          }
          break;
        case "gradient":
        case "gradientradial":
          reader.GetAttribute("color2");
          shape.FillFormat.FillType = FillType.FillGradient;
          if (attribute15 == "gradient")
          {
            shape.FillFormat.GradientFill.LinearGradient = new LinearGradient();
            string attribute17 = reader.GetAttribute("angle");
            if (!string.IsNullOrEmpty(attribute17))
            {
              int angle = this.GetAngle(attribute17);
              if (this.StartsWithExt(attribute17, "-"))
                shape.FillFormat.GradientFill.LinearGradient.AnglePositive = false;
              if (angle != int.MaxValue)
                shape.FillFormat.GradientFill.LinearGradient.Angle = Convert.ToInt16((object) angle, (IFormatProvider) CultureInfo.InvariantCulture);
            }
          }
          else
          {
            shape.FillFormat.GradientFill.PathGradient = new PathGradient();
            shape.FillFormat.GradientFill.PathGradient.PathShade = GradientShadeType.Shape;
          }
          this.Parse2007GradientFill(reader, shape.FillFormat.GradientFill);
          break;
      }
    }
    return fillEffects;
  }

  private float GetOpacityValue(string value)
  {
    float result = 0.0f;
    if (value.Trim(ControlChar.SpaceChar, '%', 'f') == string.Empty)
      return result;
    if (value.EndsWith("%"))
      result = float.TryParse(value.Replace("%", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? 100f - result : 0.0f;
    else if (value.EndsWith("f"))
    {
      result = float.TryParse(value.Replace("f", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (float) (Math.Round(1.0 - (double) result / 65536.0, 2) * 100.0) : 0.0f;
    }
    else
    {
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      if ((double) result >= 0.0 && (double) result < 1.0)
        result = (float) (100.0 - (double) result * 100.0);
      result = (double) result < 0.0 || (double) result > 100.0 ? 0.0f : result;
    }
    return result;
  }

  private int GetAngle(string angle)
  {
    int result = 0;
    int.TryParse(angle, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    int num1 = int.MaxValue;
    int angle1;
    if (result < 0)
    {
      int num2 = -result;
      if (num2 >= 0 && num2 <= 90)
        num1 = 270 + num2;
      else if (num2 > 90 && num2 <= 180)
        num1 = num2 - 90;
      else if (num2 > 180 && num2 <= 270)
        num1 = 90 + (num2 - 180);
      else if (num2 > 270 && num2 <= 360)
        num1 = 180 + (num2 - 270);
      angle1 = num1 == 360 ? 0 : num1;
    }
    else
    {
      if (result >= 0 && result <= 90)
        num1 = 90 - result;
      else if (result > 90 && result <= 180)
        num1 = 270 + (180 - result);
      else if (result > 180 && result <= 270)
        num1 = 180 + (270 - result);
      else if (result > 270 && result <= 360)
        num1 = 90 + (360 - result);
      angle1 = num1 == 360 ? 0 : num1;
    }
    return angle1;
  }

  private void Parse2007GradientFill(XmlReader reader, GradientFill gradientFill)
  {
    string attribute = reader.GetAttribute("rotate");
    if (!string.IsNullOrEmpty(attribute))
      gradientFill.RotateWithShape = attribute == "t";
    this.ParseFocus(reader, gradientFill);
    this.ParseGradientStops(reader, gradientFill);
    if (gradientFill.PathGradient == null)
      return;
    this.ParseFocusPosition(reader, gradientFill);
  }

  private void ParseFocusPosition(XmlReader reader, GradientFill gradientFill)
  {
    switch (reader.GetAttribute("focusposition"))
    {
      case null:
        gradientFill.TileRectangle.TopOffset = -100f;
        gradientFill.TileRectangle.LeftOffset = -100f;
        gradientFill.PathGradient.RightOffset = (short) 100;
        gradientFill.PathGradient.BottomOffset = (short) 100;
        break;
      case "1":
        gradientFill.TileRectangle.TopOffset = -100f;
        gradientFill.TileRectangle.LeftOffset = 100f;
        gradientFill.PathGradient.RightOffset = (short) -100;
        gradientFill.PathGradient.BottomOffset = (short) 100;
        break;
      case "1,1":
        gradientFill.TileRectangle.TopOffset = 100f;
        gradientFill.TileRectangle.LeftOffset = 100f;
        gradientFill.PathGradient.RightOffset = (short) -100;
        gradientFill.PathGradient.BottomOffset = (short) -100;
        break;
      case ",1":
        gradientFill.TileRectangle.TopOffset = 100f;
        gradientFill.TileRectangle.LeftOffset = -100f;
        gradientFill.PathGradient.RightOffset = (short) 100;
        gradientFill.PathGradient.BottomOffset = (short) -100;
        break;
      case ".5,.5":
        gradientFill.TileRectangle.TopOffset = gradientFill.TileRectangle.LeftOffset = (float) (gradientFill.PathGradient.RightOffset = gradientFill.PathGradient.BottomOffset = (short) 50);
        break;
    }
  }

  private void ParseGradientStops(XmlReader reader, GradientFill gradientFill)
  {
    string attribute = reader.GetAttribute("colors");
    if (string.IsNullOrEmpty(attribute))
      return;
    string str1 = attribute;
    char[] chArray1 = new char[1]{ ';' };
    foreach (string str2 in str1.Split(chArray1))
    {
      char[] chArray2 = new char[1]{ ' ' };
      string[] strArray = str2.Split(chArray2);
      GradientStop gradientStop = new GradientStop();
      double result = 0.0;
      double num;
      if (strArray[0].Contains("f"))
      {
        double.TryParse(strArray[0].Replace("f", string.Empty), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
        num = result * 100.0 / 65536.0;
      }
      else
      {
        double.TryParse(strArray[0], NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
        num = result * 100.0;
      }
      gradientStop.Position = Convert.ToByte(num);
      gradientStop.Color = this.GetColorValue(strArray[1]);
      gradientFill.GradientStops.Add(gradientStop);
    }
  }

  private void ParseFocus(XmlReader reader, GradientFill gradientFill)
  {
    gradientFill.Focus = reader.GetAttribute("focus");
  }

  private ImageRecord GetImageRecord(string imageId)
  {
    bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
    bool isImageRelation = true;
    string imageName = this.GetImageName(imageId, isHeaderFooter, false, ref isImageRelation);
    if (isImageRelation)
    {
      if (this.ImageIds.ContainsKey(imageName))
        return this.m_doc.Images[this.ImageIds[imageName]];
      byte[] imageBytes = this.GetImageBytes(imageName);
      if (imageBytes != null)
        return new ImageRecord(this.m_doc, imageBytes);
    }
    return (ImageRecord) null;
  }

  private void Parse2007TextboxContent(XmlReader reader, WTextBody textBody)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    this.SkipWhitespaces(reader);
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement || reader.NodeType != XmlNodeType.Element || reader.IsEmptyElement)
      return;
    string localName3 = reader.LocalName;
    reader.Read();
    this.SkipWhitespaces(reader);
    if (localName3 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement || reader.NodeType != XmlNodeType.Element)
      return;
    while (reader.LocalName != localName2)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "p":
            IWParagraph paragraph = textBody.AddParagraph();
            this.ParseParagraphItems(reader, paragraph.Items, (string) null, (IOfficeMathRunElement) null, false);
            this.m_doc.UpdateLastItemRevision(paragraph, paragraph.Items);
            break;
          case "tbl":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 11);
            IWTable table = textBody.AddTable();
            table.TableFormat.IsAutoResized = true;
            short gridCount = this.m_gridCount;
            this.ParseTable(reader, table as WTable, false, reader.LocalName);
            this.m_gridCount = gridCount;
            if (table.Rows.Count == 0)
            {
              (table.Owner as WTextBody).ChildEntities.RemoveAt((table as WTable).Index);
              break;
            }
            break;
          case "sdt":
            IBlockContentControl sdTagBlock = textBody.AddStructureDocumentTag();
            this.ParseStructureDocumentTagBlock(reader, sdTagBlock as BlockContentControl);
            break;
          case "altChunk":
            AlternateChunk altChunk = this.AddAlternateChunk((IEntity) textBody.Owner);
            this.ParseAlternateChunk(reader, altChunk);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseTextBoxStyle(XmlReader reader, TextFrame textFrame)
  {
    string attribute = reader.GetAttribute("style");
    if (attribute == null)
      return;
    string[] strArray1 = attribute.Split(';');
    string empty = string.Empty;
    if (strArray1.Length <= 0)
      return;
    for (int index = 0; index < strArray1.Length; ++index)
    {
      string[] strArray2 = strArray1[index].Split(':');
      if (strArray2.Length > 1)
      {
        switch (strArray2[0])
        {
          case "mso-fit-shape-to-text":
            textFrame.ShapeAutoFit = strArray2[1] == "t";
            continue;
          case "layout-flow":
          case "mso-layout-flow-alt":
            empty = strArray2[1];
            continue;
          default:
            continue;
        }
      }
    }
    if (string.IsNullOrEmpty(empty))
      return;
    textFrame.TextDirection = this.GetTextDirection(empty);
  }

  private Syncfusion.DocIO.DLS.TextDirection GetTextDirection(string textDirection)
  {
    switch (textDirection)
    {
      case "vertical":
        return Syncfusion.DocIO.DLS.TextDirection.VerticalTopToBottom;
      case "horizontal-ideographic":
        return Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast;
      case "vertical-ideographic":
        return Syncfusion.DocIO.DLS.TextDirection.VerticalFarEast;
      case "bottom-to-top":
        return Syncfusion.DocIO.DLS.TextDirection.VerticalBottomToTop;
      case "top-to-bottom":
        return Syncfusion.DocIO.DLS.TextDirection.Vertical;
      default:
        return Syncfusion.DocIO.DLS.TextDirection.Horizontal;
    }
  }

  private void ParseTextboxIntMargins(XmlReader reader, Shape shape)
  {
    string attribute = reader.GetAttribute("inset");
    if (attribute == null || string.IsNullOrEmpty(attribute))
      return;
    shape.TextFrame.HasInternalMargin = true;
    this.ParseTextFrameInternalMargins(reader, shape.TextFrame);
  }

  private void ParseStroke(XmlReader reader, GroupShape shape)
  {
    string attribute1 = reader.GetAttribute("opacity");
    if (!string.IsNullOrEmpty(attribute1))
      shape.LineFormat.Transparency = this.GetOpacityValue(attribute1);
    string attribute2 = reader.GetAttribute("color2");
    if (!string.IsNullOrEmpty(attribute2) && !shape.LineFormat.Color.IsEmpty)
    {
      shape.LineFormat.ForeColor = shape.LineFormat.Color;
      shape.LineFormat.Color = this.GetColorValue(attribute2);
    }
    string attribute3 = reader.GetAttribute("filltype");
    if (!string.IsNullOrEmpty(attribute3))
    {
      switch (attribute3)
      {
        case "tile":
        case "frame":
        case "pattern":
          shape.LineFormat.LineFormatType = LineFormatType.Patterned;
          string attribute4 = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute4))
          {
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            bool isImageRelation = true;
            string imageName = this.GetImageName(attribute4, isHeaderFooter, false, ref isImageRelation);
            shape.LineFormat.ImageRecord = this.GetImageRecord(attribute4);
            if (!this.ImageIds.ContainsKey(imageName))
            {
              ImageRecord imageRecord = this.m_doc.Images.LoadXmlItemImage(shape.LineFormat.ImageRecord.ImageBytes);
              this.ImageIds.Add(imageName, imageRecord.ImageId);
              break;
            }
            break;
          }
          break;
      }
    }
    string attribute5 = reader.GetAttribute("dashstyle");
    if (!string.IsNullOrEmpty(attribute5))
      shape.LineFormat.DashStyle = this.GetDashStyle(attribute5);
    string attribute6 = reader.GetAttribute("linestyle");
    if (!string.IsNullOrEmpty(attribute6))
      shape.LineFormat.Style = this.GetShapeLineStyle(attribute6);
    string attribute7 = reader.GetAttribute("joinstyle");
    if (!string.IsNullOrEmpty(attribute7))
      shape.LineFormat.LineJoin = this.GetLineJoinStyle(attribute7);
    string attribute8 = reader.GetAttribute("endcap");
    if (!string.IsNullOrEmpty(attribute8))
      shape.LineFormat.LineCap = this.GetLineCapStyle(attribute8);
    string attribute9 = reader.GetAttribute("startarrow");
    if (!string.IsNullOrEmpty(attribute9))
      shape.LineFormat.BeginArrowheadStyle = this.GetLineEnd(attribute9);
    string attribute10 = reader.GetAttribute("startarrowwidth");
    if (!string.IsNullOrEmpty(attribute10))
      shape.LineFormat.BeginArrowheadWidth = this.GetLineEndWidth(attribute10);
    string attribute11 = reader.GetAttribute("startarrowlength");
    if (!string.IsNullOrEmpty(attribute11))
      shape.LineFormat.BeginArrowheadLength = this.GetLineEndLength(attribute11);
    string attribute12 = reader.GetAttribute("endarrow");
    if (!string.IsNullOrEmpty(attribute12))
      shape.LineFormat.EndArrowheadStyle = this.GetLineEnd(attribute12);
    string attribute13 = reader.GetAttribute("endarrowwidth");
    if (!string.IsNullOrEmpty(attribute13))
      shape.LineFormat.EndArrowheadWidth = this.GetLineEndWidth(attribute13);
    string attribute14 = reader.GetAttribute("endarrowlength");
    if (string.IsNullOrEmpty(attribute14))
      return;
    shape.LineFormat.EndArrowheadLength = this.GetLineEndLength(attribute14);
  }

  private void ParseStroke(XmlReader reader, ChildShape shape)
  {
    string attribute1 = reader.GetAttribute("opacity");
    if (!string.IsNullOrEmpty(attribute1))
      shape.LineFormat.Transparency = this.GetOpacityValue(attribute1);
    string attribute2 = reader.GetAttribute("color2");
    if (!string.IsNullOrEmpty(attribute2) && !shape.LineFormat.Color.IsEmpty)
      shape.LineFormat.ForeColor = this.GetColorValue(attribute2);
    string attribute3 = reader.GetAttribute("filltype");
    if (!string.IsNullOrEmpty(attribute3))
    {
      switch (attribute3)
      {
        case "tile":
        case "frame":
        case "pattern":
          shape.LineFormat.LineFormatType = LineFormatType.Patterned;
          string attribute4 = reader.GetAttribute("id", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute4))
          {
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            bool isImageRelation = true;
            string imageName = this.GetImageName(attribute4, isHeaderFooter, false, ref isImageRelation);
            shape.LineFormat.ImageRecord = this.GetImageRecord(attribute4);
            if (!this.ImageIds.ContainsKey(imageName))
            {
              ImageRecord imageRecord = this.m_doc.Images.LoadXmlItemImage(shape.LineFormat.ImageRecord.ImageBytes);
              this.ImageIds.Add(imageName, imageRecord.ImageId);
              break;
            }
            break;
          }
          break;
      }
    }
    string attribute5 = reader.GetAttribute("dashstyle");
    if (!string.IsNullOrEmpty(attribute5))
      shape.LineFormat.DashStyle = this.GetDashStyle(attribute5);
    string attribute6 = reader.GetAttribute("linestyle");
    if (!string.IsNullOrEmpty(attribute6))
      shape.LineFormat.Style = this.GetShapeLineStyle(attribute6);
    string attribute7 = reader.GetAttribute("joinstyle");
    if (!string.IsNullOrEmpty(attribute7))
      shape.LineFormat.LineJoin = this.GetLineJoinStyle(attribute7);
    string attribute8 = reader.GetAttribute("endcap");
    if (!string.IsNullOrEmpty(attribute8))
      shape.LineFormat.LineCap = this.GetLineCapStyle(attribute8);
    string attribute9 = reader.GetAttribute("startarrow");
    if (!string.IsNullOrEmpty(attribute9))
      shape.LineFormat.BeginArrowheadStyle = this.GetLineEnd(attribute9);
    string attribute10 = reader.GetAttribute("startarrowwidth");
    if (!string.IsNullOrEmpty(attribute10))
      shape.LineFormat.BeginArrowheadWidth = this.GetLineEndWidth(attribute10);
    string attribute11 = reader.GetAttribute("startarrowlength");
    if (!string.IsNullOrEmpty(attribute11))
      shape.LineFormat.BeginArrowheadLength = this.GetLineEndLength(attribute11);
    string attribute12 = reader.GetAttribute("endarrow");
    if (!string.IsNullOrEmpty(attribute12))
      shape.LineFormat.EndArrowheadStyle = this.GetLineEnd(attribute12);
    string attribute13 = reader.GetAttribute("endarrowwidth");
    if (!string.IsNullOrEmpty(attribute13))
      shape.LineFormat.EndArrowheadWidth = this.GetLineEndWidth(attribute13);
    string attribute14 = reader.GetAttribute("endarrowlength");
    if (string.IsNullOrEmpty(attribute14))
      return;
    shape.LineFormat.EndArrowheadLength = this.GetLineEndLength(attribute14);
  }

  private void ParseStroke(XmlReader reader, Shape shape)
  {
    string attribute1 = reader.GetAttribute("opacity");
    if (!string.IsNullOrEmpty(attribute1))
      shape.LineFormat.Transparency = this.GetOpacityValue(attribute1);
    string attribute2 = reader.GetAttribute("color2");
    if (!string.IsNullOrEmpty(attribute2) && !shape.LineFormat.Color.IsEmpty)
    {
      shape.LineFormat.ForeColor = shape.LineFormat.Color;
      shape.LineFormat.Color = this.GetColorValue(attribute2);
    }
    string attribute3 = reader.GetAttribute("filltype");
    if (!string.IsNullOrEmpty(attribute3))
    {
      switch (attribute3)
      {
        case "tile":
        case "frame":
        case "pattern":
          shape.LineFormat.LineFormatType = LineFormatType.Patterned;
          string attribute4 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute4))
          {
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            bool isImageRelation = true;
            string imageName = this.GetImageName(attribute4, isHeaderFooter, false, ref isImageRelation);
            shape.LineFormat.ImageRecord = this.GetImageRecord(attribute4);
            if (!this.ImageIds.ContainsKey(imageName))
            {
              ImageRecord imageRecord = this.m_doc.Images.LoadXmlItemImage(shape.LineFormat.ImageRecord.ImageBytes);
              this.ImageIds.Add(imageName, imageRecord.ImageId);
              break;
            }
            break;
          }
          break;
      }
    }
    string attribute5 = reader.GetAttribute("dashstyle");
    if (!string.IsNullOrEmpty(attribute5))
      shape.LineFormat.DashStyle = this.GetDashStyle(attribute5);
    string attribute6 = reader.GetAttribute("linestyle");
    if (!string.IsNullOrEmpty(attribute6))
      shape.LineFormat.Style = this.GetShapeLineStyle(attribute6);
    string attribute7 = reader.GetAttribute("joinstyle");
    if (!string.IsNullOrEmpty(attribute7))
      shape.LineFormat.LineJoin = this.GetLineJoinStyle(attribute7);
    string attribute8 = reader.GetAttribute("endcap");
    if (!string.IsNullOrEmpty(attribute8))
      shape.LineFormat.LineCap = this.GetLineCapStyle(attribute8);
    string attribute9 = reader.GetAttribute("startarrow");
    if (!string.IsNullOrEmpty(attribute9))
      shape.LineFormat.BeginArrowheadStyle = this.GetLineEnd(attribute9);
    string attribute10 = reader.GetAttribute("startarrowwidth");
    if (!string.IsNullOrEmpty(attribute10))
      shape.LineFormat.BeginArrowheadWidth = this.GetLineEndWidth(attribute10);
    string attribute11 = reader.GetAttribute("startarrowlength");
    if (!string.IsNullOrEmpty(attribute11))
      shape.LineFormat.BeginArrowheadLength = this.GetLineEndLength(attribute11);
    string attribute12 = reader.GetAttribute("endarrow");
    if (!string.IsNullOrEmpty(attribute12))
      shape.LineFormat.EndArrowheadStyle = this.GetLineEnd(attribute12);
    string attribute13 = reader.GetAttribute("endarrowwidth");
    if (!string.IsNullOrEmpty(attribute13))
      shape.LineFormat.EndArrowheadWidth = this.GetLineEndWidth(attribute13);
    string attribute14 = reader.GetAttribute("endarrowlength");
    if (string.IsNullOrEmpty(attribute14))
      return;
    shape.LineFormat.EndArrowheadLength = this.GetLineEndLength(attribute14);
  }

  private LineStyle GetShapeLineStyle(string lineStyle)
  {
    switch (lineStyle)
    {
      case "dbl":
      case "thinThin":
        return LineStyle.ThinThin;
      case "thinThick":
        return LineStyle.ThinThick;
      case "thickThin":
        return LineStyle.ThickThin;
      case "thickBetweenThin":
      case "tri":
        return LineStyle.ThickBetweenThin;
      default:
        return LineStyle.Single;
    }
  }

  private void ParseShape2007Properties(XmlReader reader, GroupShape shape)
  {
    string attribute1 = reader.GetAttribute("style");
    if (attribute1 == null)
      return;
    string[] strArray1 = attribute1.Trim().Split(';');
    string[] strArray2 = new string[2];
    bool flag = false;
    int index = 0;
    for (int length = strArray1.Length; index < length; ++index)
    {
      string[] propertyValues = this.GetPropertyValues(strArray1[index]);
      if (propertyValues != null)
      {
        this.Apply2007ShapeProperties(shape, propertyValues[0], propertyValues[1]);
        if (propertyValues != null && propertyValues[0].Equals("position"))
          flag = true;
      }
    }
    if (!flag)
      shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.Inline;
    this.ParseHorizontalRule(reader, shape);
    string attribute2 = reader.GetAttribute("arcsize");
    if (!string.IsNullOrEmpty(attribute2))
    {
      double result = 0.0;
      double.TryParse(attribute2.Replace("f", string.Empty), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    }
    this.ParseLineShapeProperties(reader, shape);
    this.Parse2007ShapeEffects(reader, shape);
  }

  private void ParseShape2007Properties(XmlReader reader, ChildShape shape)
  {
    string attribute1 = reader.GetAttribute("style");
    if (attribute1 == null)
      return;
    string[] strArray1 = attribute1.Trim().Split(';');
    string[] strArray2 = new string[2];
    int index = 0;
    for (int length = strArray1.Length; index < length; ++index)
    {
      string[] propertyValues = this.GetPropertyValues(strArray1[index]);
      if (propertyValues != null)
        this.Apply2007ShapeProperties(shape, propertyValues[0], propertyValues[1]);
    }
    string attribute2 = reader.GetAttribute("arcsize");
    if (!string.IsNullOrEmpty(attribute2))
    {
      double result = 0.0;
      double.TryParse(attribute2.Replace("f", string.Empty), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      shape.ArcSize = result;
      double num = result / 65536.0;
      if (num > 0.5)
        num = 0.5;
      shape.ShapeGuide.Add("adj", "val " + (object) Math.Round(num * 100000.0));
    }
    string attribute3 = reader.GetAttribute("adj");
    if (!string.IsNullOrEmpty(attribute3))
      shape.Adjustments = attribute3;
    string attribute4 = reader.GetAttribute("path");
    if (!string.IsNullOrEmpty(attribute4))
      shape.Path = attribute4;
    this.ParseLineShapeProperties(reader, shape);
    this.Parse2007ShapeEffects(reader, shape);
  }

  private void ParseShape2007Properties(XmlReader reader, Shape shape)
  {
    string attribute1 = reader.GetAttribute("style");
    if (attribute1 == null)
      return;
    string[] strArray1 = attribute1.Trim().Split(';');
    string[] strArray2 = new string[2];
    int index = 0;
    for (int length = strArray1.Length; index < length; ++index)
    {
      string[] propertyValues = this.GetPropertyValues(strArray1[index]);
      if (propertyValues != null)
        this.Apply2007ShapeProperties(shape, propertyValues[0], propertyValues[1]);
    }
    shape.Adjustments = reader.GetAttribute("adj");
    string attribute2 = reader.GetAttribute("coordorigin");
    if (!string.IsNullOrEmpty(attribute2))
      this.GetCoordinateOrigin(attribute2, (Entity) shape);
    shape.CoordinateSize = reader.GetAttribute("coordsize");
    shape.Path = reader.GetAttribute("path");
    this.ParseHorizontalRule(reader, shape);
    string attribute3 = reader.GetAttribute("arcsize");
    if (!string.IsNullOrEmpty(attribute3))
    {
      double result = 0.0;
      double.TryParse(attribute3.Replace("f", string.Empty), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      shape.ArcSize = result;
      double num = result / 65536.0;
      if (num > 0.5)
        num = 0.5;
      shape.ShapeGuide.Add("adj", "val " + (object) Math.Round(num * 100000.0));
    }
    this.ParseLineShapeProperties(reader, shape);
    this.Parse2007ShapeEffects(reader, shape);
  }

  private void ParseLineShapeProperties(XmlReader reader, GroupShape shape)
  {
    if (!(reader.LocalName == "line"))
      return;
    string attribute1 = reader.GetAttribute("from");
    string attribute2 = reader.GetAttribute("to");
    if (!string.IsNullOrEmpty(attribute1) && !string.IsNullOrEmpty(attribute2))
    {
      string[] strArray1 = attribute1.Split(',');
      float childShapePointValue1 = this.GetChildShapePointValue(strArray1[0]);
      float childShapePointValue2 = this.GetChildShapePointValue(strArray1[1]);
      shape.HorizontalPosition = childShapePointValue1;
      shape.VerticalPosition = childShapePointValue2;
      string[] strArray2 = attribute2.Split(',');
      float pointValue1 = this.GetPointValue(strArray2[0]);
      float pointValue2 = this.GetPointValue(strArray2[1]);
      float num1;
      shape.Height = (double) (num1 = pointValue2 - childShapePointValue2) > 0.0 ? num1 : -num1;
      float num2;
      shape.Width = (double) (num2 = pointValue1 - childShapePointValue1) > 0.0 ? num2 : -num2;
    }
    string attribute3 = reader.GetAttribute("style");
    if (string.IsNullOrEmpty(attribute3))
      return;
    string[] strArray3 = attribute3.Split(';');
    if (strArray3.Length <= 0)
      return;
    for (int index = 0; index < strArray3.Length; ++index)
    {
      string[] strArray4 = strArray3[index].Split(':');
      if (strArray4.Length > 1)
      {
        switch (strArray4[0])
        {
          case "flip":
            shape.FillFormat.FlipOrientation = this.GetFlipOrientation(strArray4[1]);
            continue;
          default:
            continue;
        }
      }
    }
  }

  private void ParseLineShapeProperties(XmlReader reader, ChildShape shape)
  {
    if (!(reader.LocalName == "line"))
      return;
    string attribute1 = reader.GetAttribute("from");
    string attribute2 = reader.GetAttribute("to");
    if (!string.IsNullOrEmpty(attribute1) && !string.IsNullOrEmpty(attribute2))
    {
      string[] strArray1 = attribute1.Split(',');
      shape.LineFromXPosition = this.GetChildShapePointValue(strArray1[0]);
      shape.LineFromYPosition = this.GetChildShapePointValue(strArray1[1]);
      shape.LeftMargin = shape.LineFromXPosition;
      shape.TopMargin = shape.LineFromYPosition;
      string[] strArray2 = attribute2.Split(',');
      shape.LineToXPosition = this.GetChildShapePointValue(strArray2[0]);
      shape.LineToYPosition = this.GetChildShapePointValue(strArray2[1]);
      float num1;
      shape.Height = (double) (num1 = shape.LineToYPosition - shape.LineFromYPosition) > 0.0 ? num1 : -num1;
      float num2;
      shape.Width = (double) (num2 = shape.LineToXPosition - shape.LineFromXPosition) > 0.0 ? num2 : -num2;
    }
    string attribute3 = reader.GetAttribute("style");
    if (string.IsNullOrEmpty(attribute3))
      return;
    string[] strArray3 = attribute3.Split(';');
    if (strArray3.Length <= 0)
      return;
    for (int index = 0; index < strArray3.Length; ++index)
    {
      string[] strArray4 = strArray3[index].Split(':');
      if (strArray4.Length > 1)
      {
        switch (strArray4[0])
        {
          case "flip":
            switch (strArray4[1])
            {
              case "x":
                shape.FlipHorizantal = true;
                continue;
              case "y":
                shape.FlipVertical = true;
                continue;
              case "x y":
              case "xy":
                shape.FlipHorizantal = true;
                shape.FlipVertical = true;
                continue;
              default:
                continue;
            }
          default:
            continue;
        }
      }
    }
  }

  private void ParseLineShapeProperties(XmlReader reader, Shape shape)
  {
    if (!(reader.LocalName == "line"))
      return;
    string attribute1 = reader.GetAttribute("from");
    string attribute2 = reader.GetAttribute("to");
    if (string.IsNullOrEmpty(attribute1) || string.IsNullOrEmpty(attribute2))
      return;
    string[] strArray1 = attribute1.Split(',');
    float pointValue1 = this.GetPointValue(strArray1[0]);
    float pointValue2 = this.GetPointValue(strArray1[1]);
    shape.HorizontalPosition = pointValue1;
    shape.VerticalPosition = pointValue2;
    string[] strArray2 = attribute2.Split(',');
    float pointValue3 = this.GetPointValue(strArray2[0]);
    float pointValue4 = this.GetPointValue(strArray2[1]);
    float num1;
    shape.Height = (double) (num1 = pointValue4 - pointValue2) > 0.0 ? num1 : -num1;
    float num2;
    shape.Width = (double) (num2 = pointValue3 - pointValue1) > 0.0 ? num2 : -num2;
  }

  private void ParseHorizontalRule(XmlReader reader, GroupShape shape)
  {
    string attribute = reader.GetAttribute("hr", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute))
      attribute = reader.GetAttribute("hrstd", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute))
      attribute = reader.GetAttribute("hrnoshade", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute))
      attribute = reader.GetAttribute("hralign", "urn:schemas-microsoft-com:office:office");
    if (string.IsNullOrEmpty(attribute))
      return;
    shape.HorizontalAlignment = this.GetHorizAlign(attribute);
  }

  private void ParseHorizontalRule(XmlReader reader, Shape shape)
  {
    string attribute1 = reader.GetAttribute("hr", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute1))
      shape.IsHorizontalRule = this.GetBoolValue(attribute1);
    string attribute2 = reader.GetAttribute("hrpct", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute2))
      shape.WidthScale = (float) Math.Round((double) this.GetNumericValue(attribute2) / 10.0);
    string attribute3 = reader.GetAttribute("hrstd", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute3))
      shape.UseStandardColorHR = this.GetBoolValue(attribute3);
    string attribute4 = reader.GetAttribute("hrnoshade", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute4))
      shape.UseNoShadeHR = this.GetBoolValue(attribute4);
    string attribute5 = reader.GetAttribute("hralign", "urn:schemas-microsoft-com:office:office");
    if (string.IsNullOrEmpty(attribute5))
      return;
    shape.HorizontalAlignment = this.GetHorizAlign(attribute5);
  }

  private void Parse2007ShapeEffects(XmlReader reader, GroupShape shape)
  {
    string attribute1 = reader.GetAttribute("strokecolor");
    if (!string.IsNullOrEmpty(attribute1))
      shape.LineFormat.Color = this.GetColorValue(attribute1);
    string attribute2 = reader.GetAttribute("strokeweight");
    shape.LineFormat.Weight = string.IsNullOrEmpty(attribute2) ? 0.75f : this.GetPointValue(attribute2);
    string attribute3 = reader.GetAttribute("filled");
    if (!string.IsNullOrEmpty(attribute3) && attribute3 == "f")
    {
      shape.FillFormat.Fill = false;
      shape.FillFormat.IsDefaultFill = false;
    }
    string attribute4 = reader.GetAttribute("fillcolor");
    if (!string.IsNullOrEmpty(attribute4))
    {
      shape.FillFormat.Color = this.GetColorValue(attribute4);
      shape.FillFormat.FillType = FillType.FillSolid;
      shape.FillFormat.IsDefaultFill = false;
    }
    string attribute5 = reader.GetAttribute("stroked");
    if (!string.IsNullOrEmpty(attribute5))
    {
      shape.LineFormat.Line = !(attribute5 == "f");
      shape.LineFormat.Is2007StrokeDefined = attribute5 == "t";
    }
    string attribute6 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute6))
      shape.LayoutInCell = !(attribute6 == "f");
    string attribute7 = reader.GetAttribute("allowoverlap", "urn:schemas-microsoft-com:office:office");
    if (string.IsNullOrEmpty(attribute7))
      return;
    shape.WrapFormat.AllowOverlap = !(attribute7 == "f") && !(attribute7 == "false");
  }

  private void Parse2007ShapeEffects(XmlReader reader, ChildShape shape)
  {
    string attribute1 = reader.GetAttribute("strokecolor");
    if (!string.IsNullOrEmpty(attribute1))
      shape.LineFormat.Color = this.GetColorValue(attribute1);
    string attribute2 = reader.GetAttribute("strokeweight");
    shape.LineFormat.Weight = string.IsNullOrEmpty(attribute2) ? 0.75f : this.GetPointValue(attribute2);
    string attribute3 = reader.GetAttribute("filled");
    if (!string.IsNullOrEmpty(attribute3) && attribute3 == "f")
    {
      shape.FillFormat.Fill = false;
      shape.FillFormat.IsDefaultFill = false;
    }
    string attribute4 = reader.GetAttribute("fillcolor");
    if (!string.IsNullOrEmpty(attribute4))
    {
      shape.FillFormat.Color = this.GetColorValue(attribute4);
      shape.FillFormat.FillType = FillType.FillSolid;
      shape.FillFormat.IsDefaultFill = false;
    }
    string attribute5 = reader.GetAttribute("stroked");
    if (!string.IsNullOrEmpty(attribute5))
    {
      shape.LineFormat.Line = !(attribute5 == "f");
      shape.LineFormat.Is2007StrokeDefined = attribute5 == "t";
    }
    string attribute6 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
    if (string.IsNullOrEmpty(attribute6))
      return;
    shape.LayoutInCell = !(attribute6 == "f");
  }

  private void Parse2007ShapeEffects(XmlReader reader, Shape shape)
  {
    string attribute1 = reader.GetAttribute("strokecolor");
    if (!string.IsNullOrEmpty(attribute1))
      shape.LineFormat.Color = this.GetColorValue(attribute1);
    string attribute2 = reader.GetAttribute("strokeweight");
    shape.LineFormat.Weight = string.IsNullOrEmpty(attribute2) ? 0.75f : this.GetPointValue(attribute2);
    string attribute3 = reader.GetAttribute("filled");
    if (!string.IsNullOrEmpty(attribute3) && attribute3 == "f")
    {
      shape.FillFormat.Fill = false;
      shape.FillFormat.IsDefaultFill = false;
    }
    else
    {
      string attribute4 = reader.GetAttribute("fillcolor");
      if (!string.IsNullOrEmpty(attribute4))
      {
        shape.FillFormat.Color = this.GetColorValue(attribute4);
        shape.FillFormat.FillType = FillType.FillSolid;
        shape.FillFormat.IsDefaultFill = false;
      }
    }
    string attribute5 = reader.GetAttribute("stroked");
    if (!string.IsNullOrEmpty(attribute5))
      shape.LineFormat.Line = !(attribute5 == "f");
    string attribute6 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute6))
      shape.LayoutInCell = !(attribute6 == "f");
    string attribute7 = reader.GetAttribute("allowoverlap", "urn:schemas-microsoft-com:office:office");
    if (string.IsNullOrEmpty(attribute7))
      return;
    shape.WrapFormat.AllowOverlap = !(attribute7 == "f") && !(attribute7 == "false");
  }

  private void Apply2007ShapeProperties(
    GroupShape shape,
    string propertyName,
    string propertyValue)
  {
    switch (propertyName)
    {
      case "left":
        shape.LeftMargin = this.GetPointValue(propertyValue);
        break;
      case "margin-left":
        shape.HorizontalPosition = this.GetPointValue(propertyValue);
        break;
      case "top":
        shape.TopMargin = this.GetPointValue(propertyValue);
        break;
      case "margin-top":
        shape.VerticalPosition = this.GetPointValue(propertyValue);
        break;
      case "width":
        shape.Width = this.GetPointValue(propertyValue);
        break;
      case "height":
        shape.Height = this.GetPointValue(propertyValue);
        break;
      case "z-index":
        int result1 = 0;
        int.TryParse(propertyValue, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
        if (shape.ZOrderPosition == int.MaxValue)
          shape.ZOrderPosition = result1;
        shape.IsBelowText = result1 <= 0;
        if (shape.IsBelowText)
        {
          shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.Behind;
          break;
        }
        shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.InFrontOfText;
        break;
      case "mso-position-horizontal":
        shape.HorizontalAlignment = this.GetHorizAlign(propertyValue);
        break;
      case "mso-position-vertical":
        shape.VerticalAlignment = this.GetVertAlign(propertyValue);
        break;
      case "mso-position-vertical-relative":
        shape.VerticalOrigin = this.GetVertOrigin(propertyValue);
        break;
      case "mso-position-horizontal-relative":
        shape.HorizontalOrigin = this.GetHorizOrigin(propertyValue);
        break;
      case "mso-wrap-distance-left":
        shape.WrapFormat.DistanceLeft = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-top":
        shape.WrapFormat.DistanceTop = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-right":
        shape.WrapFormat.DistanceRight = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-bottom":
        shape.WrapFormat.DistanceBottom = this.GetPointValue(propertyValue);
        break;
      case "flip":
        switch (propertyValue)
        {
          case "x":
            shape.FlipHorizontal = true;
            return;
          case "y":
            shape.FlipVertical = true;
            return;
          case "x y":
            shape.FlipHorizontal = true;
            shape.FlipVertical = true;
            return;
          default:
            shape.DocxStyleProps.Add($"{propertyName}:{propertyValue}");
            return;
        }
      case "rotation":
        if (string.IsNullOrEmpty(propertyValue))
          break;
        float result2 = 0.0f;
        if (propertyValue.EndsWith("fd"))
        {
          float.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
          result2 = (float) ((double) result2 / 32768.0 / 2.0);
          if ((double) result2 < 0.0)
          {
            shape.Rotation = 360f - Math.Abs(result2);
            break;
          }
          shape.Rotation = Math.Abs(result2);
          break;
        }
        float.TryParse(propertyValue, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
        shape.Rotation = result2;
        break;
      default:
        if (!(propertyName == "position") || !(propertyValue == "absolute") && !(propertyValue == "relative") || shape.WrapFormat.TextWrappingStyle != TextWrappingStyle.Inline)
          break;
        shape.WrapFormat.TextWrappingStyle = TextWrappingStyle.InFrontOfText;
        break;
    }
  }

  private void Apply2007ShapeProperties(
    ChildShape shape,
    string propertyName,
    string propertyValue)
  {
    switch (propertyName)
    {
      case "left":
        shape.LeftMargin = this.GetChildShapePointValue(propertyValue);
        break;
      case "top":
        shape.TopMargin = this.GetChildShapePointValue(propertyValue);
        break;
      case "width":
        shape.Width = this.GetChildShapePointValue(propertyValue);
        break;
      case "height":
        shape.Height = this.GetChildShapePointValue(propertyValue);
        break;
      case "v-text-anchor":
        shape.TextFrame.TextVerticalAlignment = this.GetTextVertAlign(propertyValue);
        break;
      case "flip":
        switch (propertyValue)
        {
          case "x":
            shape.FlipHorizantal = true;
            return;
          case "y":
            shape.FlipVertical = true;
            return;
          case "x y":
            shape.FlipHorizantal = true;
            shape.FlipVertical = true;
            return;
          default:
            shape.DocxStyleProps.Add($"{propertyName}:{propertyValue}");
            return;
        }
      case "rotation":
        if (string.IsNullOrEmpty(propertyValue))
          break;
        float result = 0.0f;
        if (propertyValue.EndsWith("fd"))
        {
          float.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
          result = (float) ((double) result / 32768.0 / 2.0);
          if ((double) result < 0.0)
          {
            shape.Rotation = 360f - Math.Abs(result);
            break;
          }
          shape.Rotation = Math.Abs(result);
          break;
        }
        float.TryParse(propertyValue, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
        shape.Rotation = result;
        break;
    }
  }

  private void Apply2007ShapeProperties(Shape shape, string propertyName, string propertyValue)
  {
    switch (propertyName)
    {
      case "margin-left":
        shape.HorizontalPosition = this.GetPointValue(propertyValue);
        break;
      case "margin-top":
        shape.VerticalPosition = this.GetPointValue(propertyValue);
        break;
      case "width":
        shape.Width = this.GetPointValue(propertyValue);
        break;
      case "height":
        shape.Height = this.GetPointValue(propertyValue);
        break;
      case "z-index":
        int result1 = 0;
        int.TryParse(propertyValue, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
        if (shape.ZOrderPosition == int.MaxValue)
          shape.ZOrderPosition = result1;
        shape.IsBelowText = result1 <= 0;
        if (shape.IsBelowText)
        {
          shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
          break;
        }
        shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
        break;
      case "mso-position-horizontal":
        shape.HorizontalAlignment = this.GetHorizAlign(propertyValue);
        break;
      case "mso-position-vertical":
        shape.VerticalAlignment = this.GetVertAlign(propertyValue);
        break;
      case "v-text-anchor":
        shape.TextFrame.TextVerticalAlignment = this.GetTextVertAlign(propertyValue);
        break;
      case "mso-position-vertical-relative":
        shape.VerticalOrigin = this.GetVertOrigin(propertyValue);
        break;
      case "mso-position-horizontal-relative":
        shape.HorizontalOrigin = this.GetHorizOrigin(propertyValue);
        break;
      case "mso-left-percent":
        shape.TextFrame.HorizontalRelativePercent = this.ParseFloatVal(propertyValue) / 10f;
        break;
      case "mso-top-percent":
        shape.TextFrame.VerticalRelativePercent = this.ParseFloatVal(propertyValue) / 10f;
        break;
      case "mso-width-percent":
        shape.TextFrame.WidthRelativePercent = this.ParseFloatVal(propertyValue) / 10f;
        break;
      case "mso-height-percent":
        shape.TextFrame.HeightRelativePercent = this.ParseFloatVal(propertyValue) / 10f;
        break;
      case "mso-height-relative":
        shape.TextFrame.HeightOrigin = this.GetHeightOrigin(propertyValue);
        break;
      case "mso-width-relative":
        shape.TextFrame.WidthOrigin = this.GetWidthOrigin(propertyValue);
        break;
      case "mso-wrap-distance-left":
        shape.WrapFormat.DistanceLeft = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-top":
        shape.WrapFormat.DistanceTop = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-right":
        shape.WrapFormat.DistanceRight = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-bottom":
        shape.WrapFormat.DistanceBottom = this.GetPointValue(propertyValue);
        break;
      case "rotation":
        if (string.IsNullOrEmpty(propertyValue))
          break;
        int result2 = 0;
        if (propertyValue.EndsWith("fd"))
        {
          int.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
          result2 = result2 / 32768 /*0x8000*/ / 2;
          if (result2 < 0)
          {
            shape.Rotation = (float) (360 - Math.Abs(result2));
            break;
          }
          shape.Rotation = (float) Math.Abs(result2);
          break;
        }
        int.TryParse(propertyValue, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
        shape.Rotation = (float) result2;
        break;
      case "flip":
        switch (propertyValue)
        {
          case "x":
            shape.FlipHorizontal = true;
            return;
          case "y":
            shape.FlipVertical = true;
            return;
          case "x y":
            shape.FlipHorizontal = true;
            shape.FlipVertical = true;
            return;
          default:
            shape.DocxStyleProps.Add($"{propertyName}:{propertyValue}");
            return;
        }
      case "position":
        switch (propertyValue)
        {
          case "absolute":
            shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
            return;
          default:
            shape.DocxStyleProps.Add($"{propertyName}:{propertyValue}");
            return;
        }
      default:
        shape.DocxStyleProps.Add($"{propertyName}:{propertyValue}");
        break;
    }
  }

  private void ParseDrawingProperties(XmlReader reader, Shape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "drawing")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "drawing")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "wrapSquare":
            shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Square);
            break;
          case "wrapTight":
            shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
            this.ParseWrapPolygon(reader, (IEntity) shape);
            break;
          case "wrapThrough":
            shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Through);
            this.ParseWrapPolygon(reader, (IEntity) shape);
            break;
          case "wrapTopAndBottom":
            shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
            break;
          case "wrapNone":
            if (shape.IsBelowText)
            {
              shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
              break;
            }
            shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
            break;
          case "anchor":
            if (reader.AttributeCount != 0)
            {
              string attribute1 = reader.GetAttribute("behindDoc");
              shape.IsBelowText = attribute1 == "1" || attribute1 == "true";
              string attribute2 = reader.GetAttribute("allowOverlap");
              if (!string.IsNullOrEmpty(attribute2))
                shape.WrapFormat.AllowOverlap = attribute2 == "1" || attribute2 == "true";
              string attribute3 = reader.GetAttribute("relativeHeight");
              if (!string.IsNullOrEmpty(attribute3))
              {
                int result = 0;
                int.TryParse(attribute3, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                shape.ZOrderPosition = result;
                break;
              }
              break;
            }
            break;
          case "inline":
            shape.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Inline);
            break;
          case "bodypr":
            if (reader.AttributeCount != 0)
            {
              string attribute4 = reader.GetAttribute("vert");
              shape.TextFrame.TextDirection = this.GetTextDirection(attribute4);
              string attribute5 = reader.GetAttribute("anchor");
              shape.TextFrame.TextVerticalAlignment = this.GetTextVertAlign(attribute5);
              if (reader.GetAttribute("wrap") == "none")
              {
                shape.TextFrame.NoWrap = true;
                break;
              }
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseWatermark(MemoryStream shapeStream, ParagraphItemCollection paraItems)
  {
    Entity baseEntity = this.GetBaseEntity(paraItems.OwnerBase as Entity);
    if (baseEntity != null && (baseEntity is HeaderFooter ? ((baseEntity as HeaderFooter).Watermark == null ? 0 : ((baseEntity as HeaderFooter).Watermark.Type == WatermarkType.NoWatermark ? 1 : 0)) : 0) != 0)
    {
      string attributeValue = this.FindAttributeValue((Stream) shapeStream, "shape", "id", (string) null, false);
      if (this.StartsWithExt(attributeValue, "PowerPlusWaterMarkObject"))
      {
        this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 17);
        this.ParseTextWatermark((Stream) shapeStream, baseEntity as HeaderFooter);
      }
      else if (this.StartsWithExt(attributeValue, "WordPictureWatermark"))
      {
        this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 0);
        this.ParsePictureWatermark(shapeStream, baseEntity as HeaderFooter);
      }
    }
    if (!(baseEntity is HeaderFooter) || !(baseEntity is HeaderFooter headerFooter))
      return;
    headerFooter.WriteWatermark = true;
  }

  private Entity GetBaseEntity(Entity entity)
  {
    Entity baseEntity = entity;
    while (baseEntity.Owner != null)
    {
      baseEntity = baseEntity.Owner;
      if (baseEntity is WSection || baseEntity is HeaderFooter)
        return baseEntity;
    }
    return baseEntity;
  }

  private void ParsePictureWatermark(MemoryStream shapeStream, HeaderFooter header)
  {
    PictureWatermark watermark = header.InsertWatermark(WatermarkType.PictureWatermark) as PictureWatermark;
    watermark.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) header);
    WPicture picture;
    if (this.IsWord2003ML)
    {
      string elementValue = this.FindElementValue((Stream) shapeStream, "binData", "http://schemas.microsoft.com/office/word/2003/wordml");
      string attributeValue = this.FindAttributeValue((Stream) shapeStream, "binData", "name", "http://schemas.microsoft.com/office/word/2003/wordml", false);
      if (!string.IsNullOrEmpty(attributeValue) && !attributeValue.ToLower().Contains(".wmz"))
      {
        if (!attributeValue.ToLower().Contains(".emz"))
        {
          try
          {
            byte[] imageBytes = Convert.FromBase64String(elementValue);
            picture = new WPicture((IWordDocument) this.m_doc);
            picture.LoadImage(imageBytes);
            goto label_7;
          }
          catch
          {
            picture = new WPicture((IWordDocument) this.m_doc);
            goto label_7;
          }
        }
      }
      picture = new WPicture((IWordDocument) this.m_doc);
    }
    else
    {
      string attributeValue = this.FindAttributeValue((Stream) shapeStream, "imagedata", "id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships", false);
      picture = new WPicture((IWordDocument) this.m_doc);
      this.LoadImage(picture, attributeValue, true, false);
    }
label_7:
    watermark.WordPicture = picture;
    string attributeValue1 = this.FindAttributeValue((Stream) shapeStream, "imagedata", "title", "urn:schemas-microsoft-com:office:office", true);
    if (attributeValue1 != null)
      watermark.WordPicture.Title = attributeValue1;
    string attributeValue2 = this.FindAttributeValue((Stream) shapeStream, "imagedata", "gain", (string) null, false);
    string attributeValue3 = this.FindAttributeValue((Stream) shapeStream, "imagedata", "blacklevel", (string) null, false);
    if (attributeValue2 == null && attributeValue3 == null)
      watermark.Washout = false;
    shapeStream.Position = 0L;
    this.ParsePictureWatermarkProperties(UtilityMethods.CreateReader((Stream) shapeStream), watermark);
    watermark.OrderIndex = watermark.WordPicture.OrderIndex;
    if (this.m_doc.Watermark == null || this.m_doc.Watermark.Type != WatermarkType.NoWatermark)
      return;
    this.m_doc.Watermark = (Watermark) watermark;
  }

  private void ParsePictureWatermarkProperties(XmlReader reader, PictureWatermark watermark)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName2)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "shape":
            this.ParsePictureShapeProperties(reader, (IEntity) watermark.WordPicture);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseTextWatermark(Stream stream, HeaderFooter header)
  {
    TextWatermark watermark = header.InsertWatermark(WatermarkType.TextWatermark) as TextWatermark;
    watermark.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) header);
    if (this.FindAttributeValue(stream, "fill", "opacity", (string) null, false) == null)
      watermark.Semitransparent = false;
    this.ParseTextWatermarkProperties(UtilityMethods.CreateReader(stream), watermark);
    if (this.m_doc.Watermark == null || this.m_doc.Watermark.Type != WatermarkType.NoWatermark)
      return;
    this.m_doc.Watermark = (Watermark) watermark;
  }

  private void ParseTextWatermarkProperties(XmlReader reader, TextWatermark watermark)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName2)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "textpath":
            if (!string.IsNullOrEmpty(reader.GetAttribute("string")))
              watermark.Text = reader.GetAttribute("string");
            if (!string.IsNullOrEmpty(reader.GetAttribute("style")))
            {
              int height = (int) watermark.Height;
              int width = (int) watermark.Width;
              this.ParseTextWatermarkStyleAndSize(reader, watermark, height, width);
              break;
            }
            break;
          case "shape":
            string attribute = reader.GetAttribute("fillcolor");
            switch (attribute)
            {
              case null:
                return;
              case "auto":
                watermark.Color = Color.Empty;
                break;
              default:
                watermark.Color = this.GetColorValue(attribute);
                break;
            }
            this.ParseTextWatermarkPosition(reader, watermark);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseTextWatermarkPosition(XmlReader reader, TextWatermark watermark)
  {
    string attribute = reader.GetAttribute("style");
    if (attribute.Length == 0)
      return;
    watermark.Layout = WatermarkLayout.Horizontal;
    string[] strArray1 = attribute.Trim().Split(';');
    string[] strArray2 = new string[2];
    int index = 0;
    for (int length = strArray1.Length; index < length; ++index)
    {
      string[] propertyValues = this.GetPropertyValues(strArray1[index]);
      if (propertyValues != null)
        this.ParseTextWatermarkProperties(watermark, propertyValues[0], propertyValues[1]);
    }
  }

  private void ParseTextWatermarkProperties(
    TextWatermark waterMark,
    string propertyName,
    string propertyValue)
  {
    switch (propertyName)
    {
      case "margin-left":
        waterMark.HorizontalPosition = this.GetPointValue(propertyValue);
        break;
      case "margin-top":
        waterMark.VerticalPosition = this.GetPointValue(propertyValue);
        break;
      case "width":
        waterMark.Width = this.GetPointValue(propertyValue);
        break;
      case "height":
        waterMark.Height = this.GetPointValue(propertyValue);
        break;
      case "z-index":
        int result1 = 0;
        int.TryParse(propertyValue, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
        if (waterMark.OrderIndex != int.MaxValue)
          break;
        waterMark.OrderIndex = result1;
        break;
      case "mso-position-horizontal":
        waterMark.HorizontalAlignment = this.GetHorizAlign(propertyValue);
        break;
      case "mso-position-vertical":
        waterMark.VerticalAlignment = this.GetVertAlign(propertyValue);
        break;
      case "mso-position-vertical-relative":
        waterMark.VerticalOrigin = this.GetVertOrigin(propertyValue);
        break;
      case "mso-position-horizontal-relative":
        waterMark.HorizontalOrigin = this.GetHorizOrigin(propertyValue);
        break;
      case "position":
        switch (propertyValue)
        {
          case null:
            return;
          case "absolute":
            waterMark.Position = ShapePosition.Absolute;
            return;
          case "relative":
            waterMark.Position = ShapePosition.Relative;
            return;
          default:
            return;
        }
      case "rotation":
        int result2 = 0;
        int.TryParse(propertyValue, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
        waterMark.Rotation = result2;
        if (result2 == 0)
          break;
        waterMark.Layout = WatermarkLayout.Diagonal;
        break;
    }
  }

  private void ParseTextWatermarkStyleAndSize(
    XmlReader reader,
    TextWatermark watermark,
    int shapeH,
    int shapeW)
  {
    string attribute = reader.GetAttribute("style");
    if (attribute.Length == 0)
      return;
    string[] strArray = attribute.Split(';');
    string str1 = strArray[0].Replace("\"", string.Empty);
    watermark.FontName = str1.Replace("font-family:", string.Empty);
    string str2 = strArray.Length == 2 ? strArray[1] : string.Empty;
    if (!(str2 != string.Empty))
      return;
    if (str2 == "font-size:2in")
    {
      watermark.Size = 144f;
    }
    else
    {
      string partString = str2.Replace("font-size:", string.Empty);
      watermark.Size = this.ParseSize(partString);
    }
    watermark.Height = (float) shapeH;
    watermark.Width = (float) shapeW;
  }

  private string FindAttributeValue(
    Stream stream,
    string elementName,
    string attributeName,
    string namspace,
    bool readEmpty)
  {
    stream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(stream);
    while (reader.Read())
    {
      if (reader.LocalName == elementName)
      {
        string attribute = reader.GetAttribute(attributeName, namspace);
        if (!string.IsNullOrEmpty(attribute) || readEmpty && attribute != null)
        {
          stream.Position = 0L;
          return attribute;
        }
      }
    }
    stream.Position = 0L;
    return (string) null;
  }

  private string FindElementValue(Stream stream, string elementName, string namspace)
  {
    stream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(stream);
    while (reader.Read())
    {
      if (reader.LocalName == elementName)
      {
        string elementValue = this.Read2003ImageBase64String(reader, (string) null);
        if (!string.IsNullOrEmpty(elementValue))
        {
          stream.Position = 0L;
          return elementValue;
        }
      }
    }
    stream.Position = 0L;
    return (string) null;
  }

  private WPicture ParsePictureShape(MemoryStream shapeStream)
  {
    XmlReader reader = UtilityMethods.CreateReader((Stream) shapeStream);
    WPicture pictureShape = new WPicture((IWordDocument) this.m_doc);
    if (this.m_currentRunFormat != null)
    {
      pictureShape.CharacterFormat.ImportContainer((FormatBase) this.m_currentRunFormat);
      this.ApplyDirectionalOverride(pictureShape.CharacterFormat);
    }
    this.m_currentRunFormat = (WCharacterFormat) null;
    pictureShape.PictureShape.ShapeContainer = new MsofbtSpContainer(this.m_doc);
    pictureShape.PictureShape.ShapeContainer.Children.Add((object) new MsofbtOPT(this.m_doc));
    pictureShape.PictureShape.ShapeContainer.Children.Add((object) new MsofbtTertiaryFOPT(this.m_doc));
    this.ParsePictureShape(reader, (IEntity) pictureShape);
    return pictureShape;
  }

  private void ParsePictureShape(XmlReader reader, IEntity entity)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    bool flag = false;
    if (reader.LocalName != "shape")
    {
      reader.Read();
      flag = true;
      localName1 = reader.LocalName;
    }
    bool isAlreadyRead = false;
    bool isAlreadyChecked = false;
    if (!flag)
    {
      this.ParsePictureShapeProperties(reader, entity);
      reader.Read();
      isAlreadyChecked = true;
      isAlreadyRead = true;
    }
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (!reader.EOF && (!(reader.LocalName == localName2) || reader.NodeType != XmlNodeType.EndElement))
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        string localName3;
        switch (localName1)
        {
          case "shape":
            if (!isAlreadyRead)
              this.ParsePictureShapeProperties(reader, entity);
            (entity as WPicture).IsShape = true;
            this.ParsePictureShapeImage(reader, entity, localName1, isAlreadyRead, isAlreadyChecked);
            localName3 = reader.LocalName;
            break;
          default:
            if (this.IsWord2003ML && reader.LocalName == "binData")
            {
              string attribute = reader.GetAttribute("name", "http://schemas.microsoft.com/office/word/2003/wordml");
              if (!string.IsNullOrEmpty(attribute) && !attribute.ToLower().Contains(".wmz") && !attribute.ToLower().Contains(".emz"))
              {
                WPicture wpicture = entity as WPicture;
                try
                {
                  byte[] imageBytes = Convert.FromBase64String(this.Read2003ImageBase64String(reader, (string) null));
                  wpicture.LoadImage(imageBytes);
                }
                catch
                {
                  return;
                }
              }
            }
            localName3 = reader.LocalName;
            break;
        }
        reader.Read();
        localName1 = reader.LocalName;
        isAlreadyRead = false;
        isAlreadyChecked = true;
      }
      else
      {
        reader.Read();
        localName1 = reader.LocalName;
        isAlreadyRead = false;
        isAlreadyChecked = true;
      }
    }
  }

  private string Read2003ImageBase64String(XmlReader reader, string endNode)
  {
    if (reader.IsEmptyElement)
      return string.Empty;
    string localName = reader.LocalName;
    if (endNode == null)
    {
      endNode = reader.LocalName;
      reader.Read();
    }
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return string.Empty;
    string str = (string) null;
    while (reader.LocalName != endNode)
    {
      if (reader.NodeType == XmlNodeType.Text)
        str = reader.Value.Replace(ControlChar.CarriegeReturn, "").Replace(ControlChar.LineFeed, "").Replace(" ", "");
      reader.Read();
    }
    return str;
  }

  private void ParsePictureShapeImageValues(
    XmlReader reader,
    IEntity ent,
    string localName,
    bool isAlreadyRead)
  {
    string str = localName;
    if (!isAlreadyRead)
      reader.Read();
    WPicture picture = ent as WPicture;
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName.ToLower())
        {
          case "imagedata":
            string attribute1 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            string attribute2 = reader.GetAttribute("href", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            if (!string.IsNullOrEmpty(attribute1))
            {
              bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
              float width = picture.Width;
              float height = picture.Height;
              if (!string.IsNullOrEmpty(attribute2))
              {
                bool isImageRelation = true;
                string imageName = this.GetImageName(attribute2, isHeaderFooter, false, ref isImageRelation);
                if (isImageRelation && !string.IsNullOrEmpty(imageName) && this.m_isExternalHyperlink != null && this.m_docRelations.ContainsKey(attribute1) && this.IsExternalHyperlink.ContainsKey(attribute1) && this.IsExternalHyperlink[attribute1])
                  picture.ExternalLink = imageName;
              }
              this.LoadImage(picture, attribute1, isHeaderFooter, false);
              picture.Width = width;
              picture.Height = height;
            }
            string attribute3 = reader.GetAttribute("title", "urn:schemas-microsoft-com:office:office");
            if (attribute3 != null)
              picture.Title = attribute3;
            string attribute4 = reader.GetAttribute("croptop");
            if (!string.IsNullOrEmpty(attribute4))
              picture.FillRectangle.TopOffset = this.GetCroppingValues(attribute4);
            string attribute5 = reader.GetAttribute("cropleft");
            if (!string.IsNullOrEmpty(attribute5))
              picture.FillRectangle.LeftOffset = this.GetCroppingValues(attribute5);
            string attribute6 = reader.GetAttribute("cropbottom");
            if (!string.IsNullOrEmpty(attribute6))
              picture.FillRectangle.BottomOffset = this.GetCroppingValues(attribute6);
            string attribute7 = reader.GetAttribute("cropright");
            if (!string.IsNullOrEmpty(attribute7))
              picture.FillRectangle.RightOffset = this.GetCroppingValues(attribute7);
            string attribute8 = reader.GetAttribute("chromakey");
            if (!string.IsNullOrEmpty(attribute8))
            {
              picture.ChromaKeyColor = this.GetColorValue(attribute8);
              break;
            }
            break;
          case "wrap":
            string attribute9 = reader.GetAttribute("type");
            if (!string.IsNullOrEmpty(attribute9) && picture.Owner is WOleObject)
              this.ParseOlePictureWrapStyle(reader, picture);
            else if (!string.IsNullOrEmpty(attribute9) && picture.Position != ShapePosition.Static && attribute9 != "none")
              picture.SetTextWrappingStyleValue(this.GetWrapStyle(attribute9));
            string attribute10 = reader.GetAttribute("side");
            if (!string.IsNullOrEmpty(attribute10))
            {
              picture.TextWrappingType = this.GetWrapType(attribute10);
              break;
            }
            break;
          case "bordertop":
            this.ParseShapeBorder(reader, picture.PictureShape.PictureDescriptor.BorderTop);
            break;
          case "borderleft":
            this.ParseShapeBorder(reader, picture.PictureShape.PictureDescriptor.BorderLeft);
            break;
          case "borderbottom":
            this.ParseShapeBorder(reader, picture.PictureShape.PictureDescriptor.BorderBottom);
            break;
          case "borderright":
            this.ParseShapeBorder(reader, picture.PictureShape.PictureDescriptor.BorderRight);
            break;
          case "stroke":
            this.ParseStrokeProps(reader, picture.PictureShape);
            break;
          case "lock":
            picture.SignatureLineElements.Add((Stream) this.ReadSingleNodeIntoStream(reader));
            continue;
          case "signatureline":
            picture.SignatureLineElements.Add((Stream) this.ReadSingleNodeIntoStream(reader));
            continue;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParsePictureShapeImage(
    XmlReader reader,
    IEntity ent,
    string localName,
    bool isAlreadyRead,
    bool isAlreadyChecked)
  {
    if (isAlreadyChecked)
    {
      this.ParsePictureShapeImageValues(reader, ent, localName, isAlreadyRead);
    }
    else
    {
      if (reader.IsEmptyElement)
        return;
      localName = reader.LocalName;
      string localName1 = reader.LocalName;
      reader.Read();
      isAlreadyRead = true;
      if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return;
      this.ParsePictureShapeImageValues(reader, ent, localName, isAlreadyRead);
    }
  }

  private float GetCroppingValues(string value)
  {
    float result = 0.0f;
    if (value.EndsWith("f"))
    {
      if (float.TryParse(value.Replace("f", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
        result = (float) Math.Round((double) (result * 1.5259f) / 1000.0, 3);
    }
    else if (value.EndsWith("%"))
    {
      if (float.TryParse(value.Replace("%", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
      {
        result = (float) ((double) result * 65536.0 / 100.0);
        result = (float) Math.Round((double) (result * 1.5259f) / 1000.0, 3);
      }
    }
    else if (this.StartsWithExt(value, "."))
    {
      if (float.TryParse(value.Replace(".", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
      {
        result = (float) ((double) result * 65536.0 / 100.0);
        result = (float) Math.Round((double) (result * 1.5259f) / 1000.0, 3);
      }
    }
    else if (this.StartsWithExt(value, "0.") && float.TryParse(value.Replace("0.", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
    {
      result = (float) ((double) result * 65536.0 / 100.0);
      result = (float) Math.Round((double) (result * 1.5259f) / 1000.0, 3);
    }
    return result;
  }

  private void ParseStrokeProps(XmlReader reader, InlineShapeObject shape)
  {
    if (!shape.ShapeContainer.ShapeOptions.LineProperties.HasDefined)
    {
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(511 /*0x01FF*/, 46U);
      shape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
      shape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
    }
    string attribute1 = reader.GetAttribute("on");
    if (!string.IsNullOrEmpty(attribute1))
    {
      bool boolValue = this.GetBoolValue(attribute1);
      shape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = boolValue;
      shape.ShapeContainer.ShapeOptions.LineProperties.Line = boolValue;
    }
    string attribute2 = reader.GetAttribute("color");
    if (!string.IsNullOrEmpty(attribute2))
    {
      Color hexColor = this.GetHexColor(attribute2);
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(448, WordColor.ConvertColorToRGB(hexColor));
    }
    string attribute3 = reader.GetAttribute("dashstyle");
    if (!string.IsNullOrEmpty(attribute3))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(462, (uint) this.GetDashStyle(attribute3));
    string attribute4 = reader.GetAttribute("endarrow");
    if (!string.IsNullOrEmpty(attribute4))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(465, (uint) this.GetLineEnd(attribute4));
    string attribute5 = reader.GetAttribute("endarrowlength");
    if (!string.IsNullOrEmpty(attribute5))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(469, (uint) this.GetLineEndLength(attribute5));
    string attribute6 = reader.GetAttribute("endarrowwidth");
    if (!string.IsNullOrEmpty(attribute6))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(468, (uint) this.GetLineEndWidth(attribute6));
    string attribute7 = reader.GetAttribute("endcap");
    if (!string.IsNullOrEmpty(attribute7))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(471, (uint) this.GetLineCapStyle(attribute7));
    string attribute8 = reader.GetAttribute("forcedash");
    if (!string.IsNullOrEmpty(attribute8))
    {
      bool boolValue = this.GetBoolValue(attribute8);
      shape.ShapeContainer.ShapeOptions.LineProperties.UsefNoLineDrawDash = boolValue;
      shape.ShapeContainer.ShapeOptions.LineProperties.NoLineDrawDash = boolValue;
    }
    string attribute9 = reader.GetAttribute("insetpen");
    if (!string.IsNullOrEmpty(attribute9))
      shape.ShapeContainer.ShapeOptions.LineProperties.PenAlignInset = this.GetBoolValue(attribute9);
    string attribute10 = reader.GetAttribute("joinstyle");
    if (!string.IsNullOrEmpty(attribute10))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(470, (uint) this.GetLineJoinStyle(attribute10));
    string attribute11 = reader.GetAttribute("linestyle");
    if (!string.IsNullOrEmpty(attribute11))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(461, (uint) this.GetLineStyle(attribute11));
    string attribute12 = reader.GetAttribute("miterlimit");
    if (!string.IsNullOrEmpty(attribute12))
    {
      if (attribute12.EndsWith("f"))
      {
        uint result;
        uint.TryParse(attribute12.Replace("f", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
        shape.ShapeContainer.ShapeOptions.SetPropertyValue(460, result);
      }
      else if (attribute12.EndsWith("%"))
      {
        uint num = (uint) (this.GetPercentage(attribute12) * 65536.0 / 100.0);
        shape.ShapeContainer.ShapeOptions.SetPropertyValue(460, num);
      }
    }
    string attribute13 = reader.GetAttribute("opacity");
    if (!string.IsNullOrEmpty(attribute13))
    {
      if (attribute13.EndsWith("f"))
      {
        uint result;
        uint.TryParse(attribute13.Replace("f", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
        shape.ShapeContainer.ShapeOptions.SetPropertyValue(449, result);
      }
      else if (attribute13.EndsWith("%"))
      {
        uint num = (uint) (this.GetPercentage(attribute13) * 65536.0 / 100.0);
        shape.ShapeContainer.ShapeOptions.SetPropertyValue(449, num);
      }
    }
    string attribute14 = reader.GetAttribute("startarrow");
    if (!string.IsNullOrEmpty(attribute14))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(464, (uint) this.GetLineEnd(attribute14));
    string attribute15 = reader.GetAttribute("startarrowlength");
    if (!string.IsNullOrEmpty(attribute15))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(467, (uint) this.GetLineEndLength(attribute15));
    string attribute16 = reader.GetAttribute("startarrowwidth");
    if (!string.IsNullOrEmpty(attribute16))
      shape.ShapeContainer.ShapeOptions.SetPropertyValue(466, (uint) this.GetLineEndWidth(attribute16));
    string attribute17 = reader.GetAttribute("weight");
    if (string.IsNullOrEmpty(attribute17))
      return;
    uint num1 = (uint) ((double) this.GetPointValue(attribute17) * 12700.0);
    shape.ShapeContainer.ShapeOptions.SetPropertyValue(459, num1);
  }

  private LineJoin GetLineJoinStyle(string lineJoinStyle)
  {
    switch (lineJoinStyle)
    {
      case "bevel":
        return LineJoin.Bevel;
      case "round":
        return LineJoin.Round;
      default:
        return LineJoin.Miter;
    }
  }

  private void ParseShapeBorder(XmlReader reader, BorderCode brc)
  {
    string attribute1 = reader.GetAttribute("type");
    if (!string.IsNullOrEmpty(attribute1))
    {
      BorderStyle shapeBorderStyle = this.GetShapeBorderStyle(attribute1);
      brc.BorderType = (byte) shapeBorderStyle;
    }
    string attribute2 = reader.GetAttribute("width");
    if (!string.IsNullOrEmpty(attribute2))
    {
      int result = 0;
      int.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      brc.LineWidth = (byte) result;
    }
    string attribute3 = reader.GetAttribute("shadow");
    if (string.IsNullOrEmpty(attribute3) || !(attribute3 == "on") && !(attribute3 == "1") && !(attribute3 == "true"))
      return;
    brc.Shadow = true;
  }

  private BorderStyle GetShapeBorderStyle(string boderStyle)
  {
    BorderStyle shapeBorderStyle = BorderStyle.None;
    switch (boderStyle)
    {
      case "single":
        shapeBorderStyle = BorderStyle.Single;
        break;
      case "thick":
        shapeBorderStyle = BorderStyle.Thick;
        break;
      case "double":
        shapeBorderStyle = BorderStyle.Double;
        break;
      case "hairline":
        shapeBorderStyle = BorderStyle.Hairline;
        break;
      case "dot":
        shapeBorderStyle = BorderStyle.Dot;
        break;
      case "dash":
        shapeBorderStyle = BorderStyle.DashLargeGap;
        break;
      case "dotDash":
        shapeBorderStyle = BorderStyle.DotDash;
        break;
      case "dashDotDot":
        shapeBorderStyle = BorderStyle.DotDotDash;
        break;
      case "triple":
        shapeBorderStyle = BorderStyle.Triple;
        break;
      case "thinThickSmall":
        shapeBorderStyle = BorderStyle.ThinThickSmallGap;
        break;
      case "thickThinSmall":
        shapeBorderStyle = BorderStyle.ThinThinSmallGap;
        break;
      case "thickBetweenThinSmall":
        shapeBorderStyle = BorderStyle.ThinThickThinSmallGap;
        break;
      case "thinThick":
        shapeBorderStyle = BorderStyle.ThinThickMediumGap;
        break;
      case "thickThin":
        shapeBorderStyle = BorderStyle.ThickThinMediumGap;
        break;
      case "thickBetweenThin":
        shapeBorderStyle = BorderStyle.ThickThickThinMediumGap;
        break;
      case "thinThickLarge":
        shapeBorderStyle = BorderStyle.ThinThickLargeGap;
        break;
      case "thickThinLarge":
        shapeBorderStyle = BorderStyle.ThickThinLargeGap;
        break;
      case "thickBetweenThinLarge":
        shapeBorderStyle = BorderStyle.ThinThickThinLargeGap;
        break;
      case "wave":
        shapeBorderStyle = BorderStyle.Wave;
        break;
      case "doubleWave":
        shapeBorderStyle = BorderStyle.DoubleWave;
        break;
      case "dashedSmall":
        shapeBorderStyle = BorderStyle.DashSmallGap;
        break;
      case "dashDotStroked":
        shapeBorderStyle = BorderStyle.DashDotStroker;
        break;
      case "threeDEmboss":
        shapeBorderStyle = BorderStyle.Emboss3D;
        break;
      case "threeDEngrave":
        shapeBorderStyle = BorderStyle.Engrave3D;
        break;
      case "HTMLOutset":
        shapeBorderStyle = BorderStyle.Outset;
        break;
      case "HTMLInset":
        shapeBorderStyle = BorderStyle.Inset;
        break;
    }
    return shapeBorderStyle;
  }

  private void ParsePictureShapeProperties(XmlReader reader, IEntity ent)
  {
    WPicture pic = ent as WPicture;
    pic.PictureShape.ShapeContainer = new MsofbtSpContainer(this.m_doc);
    pic.PictureShape.ShapeContainer.Children.Add((object) new MsofbtOPT(this.m_doc));
    pic.PictureShape.ShapeContainer.Children.Add((object) new MsofbtTertiaryFOPT(this.m_doc));
    string attribute1 = reader.GetAttribute("style");
    if (attribute1 != null && attribute1 != string.Empty)
      this.ParsePictureShapeStyle(attribute1, pic);
    string attribute2 = reader.GetAttribute("bordertopcolor", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute2))
    {
      Color hexColor = this.GetHexColor(attribute2);
      int id = WordColor.ConvertColorToId(hexColor);
      pic.PictureShape.PictureDescriptor.BorderTop.LineColor = (byte) id;
      pic.PictureShape.ShapeContainer.ShapePosition.SetPropertyValue(923, WordColor.ConvertColorToRGB(hexColor));
    }
    string attribute3 = reader.GetAttribute("hr", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute3))
      pic.PictureShape.IsHorizontalRule = this.GetBoolValue(attribute3);
    string attribute4 = reader.GetAttribute("borderleftcolor", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute4))
    {
      Color hexColor = this.GetHexColor(attribute4);
      int id = WordColor.ConvertColorToId(hexColor);
      pic.PictureShape.PictureDescriptor.BorderLeft.LineColor = (byte) id;
      pic.PictureShape.ShapeContainer.ShapePosition.SetPropertyValue(924, WordColor.ConvertColorToRGB(hexColor));
    }
    string attribute5 = reader.GetAttribute("borderbottomcolor", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute5))
    {
      Color hexColor = this.GetHexColor(attribute5);
      int id = WordColor.ConvertColorToId(hexColor);
      pic.PictureShape.PictureDescriptor.BorderBottom.LineColor = (byte) id;
      pic.PictureShape.ShapeContainer.ShapePosition.SetPropertyValue(925, WordColor.ConvertColorToRGB(hexColor));
    }
    string attribute6 = reader.GetAttribute("borderrightcolor", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute6))
    {
      Color hexColor = this.GetHexColor(attribute6);
      int id = WordColor.ConvertColorToId(hexColor);
      pic.PictureShape.PictureDescriptor.BorderRight.LineColor = (byte) id;
      pic.PictureShape.ShapeContainer.ShapePosition.SetPropertyValue(926, WordColor.ConvertColorToRGB(hexColor));
    }
    string attribute7 = reader.GetAttribute("stroked");
    if (!string.IsNullOrEmpty(attribute7))
    {
      pic.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511 /*0x01FF*/, 46U);
      if (this.GetBoolValue(attribute7))
      {
        pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
        pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
      }
    }
    string attribute8 = reader.GetAttribute("strokecolor");
    if (!string.IsNullOrEmpty(attribute8))
    {
      if (!pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.HasDefined)
      {
        pic.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511 /*0x01FF*/, 46U);
        pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
        pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
      }
      Color hexColor = this.GetHexColor(attribute8);
      pic.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(448, WordColor.ConvertColorToRGB(hexColor));
    }
    string attribute9 = reader.GetAttribute("strokeweight");
    if (!string.IsNullOrEmpty(attribute9))
    {
      if (!pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.HasDefined)
      {
        pic.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511 /*0x01FF*/, 46U);
        pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
        pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
      }
      uint num = (uint) ((double) this.GetPointValue(attribute9) * 12700.0);
      pic.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(459, num);
    }
    string attribute10 = reader.GetAttribute("insetpen");
    if (!string.IsNullOrEmpty(attribute10))
    {
      if (!pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.HasDefined)
      {
        pic.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511 /*0x01FF*/, 46U);
        pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
        pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
      }
      pic.PictureShape.ShapeContainer.ShapeOptions.LineProperties.PenAlignInset = this.GetBoolValue(attribute10);
    }
    pic.Href = reader.GetAttribute("href");
    pic.AlternativeText = reader.GetAttribute("alt");
    pic.Name = reader.GetAttribute("name");
    string attribute11 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
    if (string.IsNullOrEmpty(attribute11))
      return;
    pic.LayoutInCell = this.GetBoolValue(attribute11);
  }

  public void ParsePictureShapeStyle(string style, WPicture pic)
  {
    style = style.Trim();
    string[] strArray1 = this.SortShapeStyle(style);
    string[] strArray2 = new string[2];
    int index = 0;
    for (int length = strArray1.Length; index < length; ++index)
    {
      string[] propertyValues = this.GetPropertyValues(strArray1[index]);
      if (propertyValues != null)
        this.ParsePictureShapeProperties(pic, propertyValues[0], propertyValues[1]);
    }
  }

  private string[] SortShapeStyle(string style)
  {
    char ch1 = ';';
    char ch2 = ':';
    List<string> stringList = new List<string>();
    string[] strArray1 = style.Split(ch1);
    string[] strArray2 = new string[11]
    {
      "position",
      "margin-left",
      "margin-top",
      "width",
      "height",
      "z-index",
      "mso-position-horizontal",
      "mso-position-vertical",
      "mso-position-horizontal-relative",
      "mso-position-vertical-relative",
      "visibility"
    };
    foreach (string str in strArray2)
    {
      for (int index = 0; index < strArray1.Length; ++index)
      {
        string[] strArray3 = strArray1[index].Split(ch2);
        if (str == strArray3[0])
          stringList.Add(strArray1[index]);
      }
    }
    string[] strArray4 = new string[stringList.Count];
    for (int index = 0; index < stringList.Count; ++index)
      strArray4[index] = stringList[index];
    return strArray4;
  }

  private void ParsePictureShapeProperties(WPicture pic, string propertyName, string propertyValue)
  {
    switch (propertyName)
    {
      case "margin-left":
        pic.HorizontalPosition = this.GetPointValue(propertyValue);
        break;
      case "margin-top":
        pic.VerticalPosition = this.GetPointValue(propertyValue);
        break;
      case "width":
        pic.Width = this.GetPointValue(propertyValue);
        break;
      case "height":
        pic.Height = this.GetPointValue(propertyValue);
        break;
      case "z-index":
        int result = 0;
        int.TryParse(propertyValue, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
        if (pic.OrderIndex == int.MaxValue)
          pic.OrderIndex = result;
        pic.IsBelowText = result <= 0;
        if (pic.Position == ShapePosition.Static)
          break;
        if (pic.IsBelowText)
        {
          pic.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
          break;
        }
        pic.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
        break;
      case "mso-position-horizontal":
        pic.HorizontalAlignment = this.GetHorizAlign(propertyValue);
        break;
      case "mso-position-vertical":
        pic.VerticalAlignment = this.GetVertAlign(propertyValue);
        break;
      case "mso-position-vertical-relative":
        pic.VerticalOrigin = this.GetVertOrigin(propertyValue);
        break;
      case "mso-position-horizontal-relative":
        pic.HorizontalOrigin = this.GetHorizOrigin(propertyValue);
        break;
      case "position":
        if (!string.IsNullOrEmpty(propertyValue) && propertyValue == "absolute")
        {
          pic.HorizontalOrigin = HorizontalOrigin.Column;
          pic.VerticalOrigin = VerticalOrigin.Paragraph;
        }
        switch (propertyValue)
        {
          case "absolute":
            pic.Position = ShapePosition.Absolute;
            break;
          case "relative":
            pic.Position = ShapePosition.Relative;
            break;
        }
        if (pic.Position == ShapePosition.Static)
          break;
        pic.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
        break;
      case "visibility":
        if (propertyValue == null || !(propertyValue.ToLower() == "hidden"))
          break;
        pic.Visible = false;
        break;
    }
  }

  private WTextBox ParseTextboxShape(MemoryStream shapeStream, MemoryStream drawingStream)
  {
    shapeStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader((Stream) shapeStream);
    WTextBox textboxShape = new WTextBox((IWordDocument) this.m_doc);
    textboxShape.InitializeVMLDefaultValues();
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 13);
    if (drawingStream != null)
    {
      drawingStream.Position = 0L;
      this.ParseTextboxProperties(UtilityMethods.CreateReader((Stream) drawingStream), textboxShape);
    }
    this.ParseTextboxShape(reader, textboxShape);
    return textboxShape;
  }

  private void ParseTextboxProperties(XmlReader reader, WTextBox textbox)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "drawing")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool isToApplyFarEast = false;
    bool flag1 = false;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "drawing")
    {
      bool flag2 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "wsp":
            string attribute1 = reader.GetAttribute("normalEastAsianFlow");
            if (!string.IsNullOrEmpty(attribute1) && !isToApplyFarEast)
            {
              textbox.TextBoxFormat.TextDirection = this.GetBoolValue(attribute1) ? Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast : Syncfusion.DocIO.DLS.TextDirection.Horizontal;
              isToApplyFarEast = textbox.TextBoxFormat.TextDirection == Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast;
              break;
            }
            break;
          case "wrapSquare":
            textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Square);
            break;
          case "wrapTight":
            textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
            this.ParseWrapPolygon(reader, (IEntity) textbox);
            break;
          case "wrapThrough":
            textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Through);
            this.ParseWrapPolygon(reader, (IEntity) textbox);
            break;
          case "wrapTopAndBottom":
            textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
            break;
          case "wrapNone":
            if (!flag1)
            {
              if (textbox.TextBoxFormat.IsBelowText)
              {
                textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
                break;
              }
              textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
              break;
            }
            break;
          case "anchor":
            if (reader.AttributeCount != 0)
            {
              string attribute2 = reader.GetAttribute("behindDoc");
              textbox.TextBoxFormat.IsBelowText = attribute2 == "1" || attribute2 == "true";
              string attribute3 = reader.GetAttribute("allowOverlap");
              if (!string.IsNullOrEmpty(attribute3))
                textbox.TextBoxFormat.AllowOverlap = attribute3 == "1" || attribute3 == "true";
              string attribute4 = reader.GetAttribute("relativeHeight");
              if (!string.IsNullOrEmpty(attribute4))
              {
                int result = 0;
                int.TryParse(attribute4, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                textbox.TextBoxFormat.OrderIndex = result;
                break;
              }
              break;
            }
            break;
          case "inline":
            flag1 = true;
            textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Inline);
            break;
          case "bodypr":
            if (reader.AttributeCount != 0)
            {
              string attribute5 = reader.GetAttribute("vert");
              textbox.TextBoxFormat.TextDirection = this.GetTextDirection(attribute5, isToApplyFarEast);
              string attribute6 = reader.GetAttribute("anchor");
              textbox.TextBoxFormat.TextVerticalAlignment = this.GetTextVertAlign(attribute6);
              break;
            }
            break;
          case "docPr":
            string attribute7 = reader.GetAttribute("name");
            if (!string.IsNullOrEmpty(attribute7))
              textbox.Name = attribute7;
            string attribute8 = reader.GetAttribute("hidden");
            if (!string.IsNullOrEmpty(attribute8))
            {
              textbox.Visible = !this.GetBoolValue(attribute8);
              break;
            }
            break;
        }
        if (!flag2)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseTextboxShape(XmlReader reader, WTextBox textBox)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (!reader.EOF && reader.LocalName != localName2)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "shape":
          case "rect":
          case "roundrect":
            if (!string.IsNullOrEmpty(reader.GetAttribute("id")))
              textBox.Name = reader.GetAttribute("id");
            this.ParseShapeProperties(reader, textBox);
            this.ParseTextbox(reader, textBox);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseTextBoxWrappingStyle(XmlReader reader, IEntity entity)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (!(reader.LocalName == localName2))
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "wrap":
            string attribute1 = reader.GetAttribute("type");
            if (!string.IsNullOrEmpty(attribute1))
              (entity as WTextBox).TextBoxFormat.SetTextWrappingStyleValue(this.GetWrapStyle(attribute1));
            string attribute2 = reader.GetAttribute("side");
            if (!string.IsNullOrEmpty(attribute2))
            {
              (entity as WTextBox).TextBoxFormat.TextWrappingType = this.GetTextWrapType(attribute2);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseTextbox(XmlReader reader, WTextBox textbox)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (!(reader.LocalName == localName2))
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "stroke":
            this.ParseStroke(reader, textbox);
            break;
          case "shadow":
            if (!this.IsWord2003ML)
            {
              textbox.TextBoxFormat.DocxProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              break;
            }
            break;
          case nameof (textbox):
            this.ParseTextboxIntMargins(reader, textbox);
            this.ParseTextBoxStyle(reader, textbox);
            this.m_currentRunFormat = (WCharacterFormat) null;
            RevisionType trackChangeType = this.m_trackChangeType;
            this.m_trackChangeType = RevisionType.None;
            Stack<Revision> collection1 = new Stack<Revision>((IEnumerable<Revision>) this.m_trackchangeRevisionDetails);
            this.m_trackchangeRevisionDetails.Clear();
            Stack<RevisionType> collection2 = new Stack<RevisionType>((IEnumerable<RevisionType>) this.m_trackchangeStack);
            this.m_trackchangeStack.Clear();
            this.ParseTextboxContent(reader, textbox);
            this.m_trackChangeType = trackChangeType;
            this.m_trackchangeRevisionDetails = new Stack<Revision>((IEnumerable<Revision>) collection1);
            collection1.Clear();
            this.m_trackchangeStack = new Stack<RevisionType>((IEnumerable<RevisionType>) collection2);
            collection2.Clear();
            break;
          case "fill":
            flag = this.ParseFillEffects(reader, textbox);
            break;
          case "wrap":
            string attribute1 = reader.GetAttribute("type");
            if (!string.IsNullOrEmpty(attribute1) && (!(attribute1 == "none") || !textbox.TextBoxFormat.DocxStyleProps.Contains("position:absolute")))
              textbox.TextBoxFormat.SetTextWrappingStyleValue(this.GetWrapStyle(attribute1));
            string attribute2 = reader.GetAttribute("side");
            if (!string.IsNullOrEmpty(attribute2))
            {
              textbox.TextBoxFormat.TextWrappingType = this.GetTextWrapType(attribute2);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private bool ParseFillEffects(XmlReader reader, WTextBox textbox)
  {
    bool fillEffects = false;
    string attribute = reader.GetAttribute("type");
    if (!string.IsNullOrEmpty(attribute))
    {
      switch (attribute)
      {
        case "tile":
        case "frame":
          this.ParsePictureFill(reader, textbox, attribute);
          break;
        case "gradient":
        case "gradientRadial":
          this.ParseGradientFill(reader, textbox.TextBoxFormat.FillEfects);
          if (reader.LocalName != "fill")
          {
            fillEffects = true;
            break;
          }
          break;
        case "pattern":
          if (!this.IsWord2003ML)
          {
            this.ParsePatternFill(reader, textbox.TextBoxFormat.FillEfects);
            fillEffects = true;
            break;
          }
          break;
      }
    }
    if (reader.GetAttribute("opacity") == "0")
      textbox.TextBoxFormat.FillColor = Color.Empty;
    return fillEffects;
  }

  private void ParseGradientFill(XmlReader reader, Background background)
  {
    string attribute = reader.GetAttribute("type");
    background.Type = BackgroundType.Gradient;
    this.ParseGradientColor(reader, background);
    if (attribute == "gradientRadial")
      this.ParseRadialGradient(reader, background.Gradient);
    else
      this.ParseGradient(reader, background.Gradient);
  }

  private void ParseGradientColor(XmlReader reader, Background background)
  {
    BackgroundGradient gradient = background.Gradient;
    gradient.Color1 = !(background.Color == Color.Empty) ? background.Color : Color.White;
    string attribute = reader.GetAttribute("color2");
    if (attribute == null)
      gradient.Color2 = Color.Black;
    else
      gradient.Color2 = this.GetColorValue(attribute);
  }

  private void ParseGradient(XmlReader reader, BackgroundGradient gradient)
  {
    string attribute = reader.GetAttribute("focus");
    switch (reader.GetAttribute("angle"))
    {
      case null:
        gradient.ShadingStyle = GradientShadingStyle.Horizontal;
        break;
      case "-90":
        gradient.ShadingStyle = GradientShadingStyle.Vertical;
        break;
      case "-135":
        gradient.ShadingStyle = GradientShadingStyle.DiagonalUp;
        break;
      case "-45":
        gradient.ShadingStyle = GradientShadingStyle.DiagonalDown;
        break;
    }
    gradient.ShadingVariant = this.ParseShadingVariant(attribute);
  }

  private void ParseRadialGradient(XmlReader reader, BackgroundGradient gradient)
  {
    string attribute1 = reader.GetAttribute("focusposition");
    string attribute2 = reader.GetAttribute("focus");
    if (reader.ReadInnerXml() != string.Empty)
    {
      gradient.ShadingStyle = GradientShadingStyle.FromCorner;
      switch (attribute1)
      {
        case null:
          gradient.ShadingVariant = GradientShadingVariant.ShadingUp;
          break;
        case "1":
          gradient.ShadingVariant = GradientShadingVariant.ShadingDown;
          break;
        case "1,1":
          gradient.ShadingVariant = GradientShadingVariant.ShadingMiddle;
          break;
        case ",1":
          gradient.ShadingVariant = GradientShadingVariant.ShadingOut;
          break;
      }
    }
    else
    {
      gradient.ShadingStyle = GradientShadingStyle.FromCenter;
      gradient.ShadingVariant = this.ParseShadingVariant(attribute2);
    }
  }

  private GradientShadingVariant ParseShadingVariant(string focus)
  {
    switch (focus)
    {
      case null:
        return GradientShadingVariant.ShadingDown;
      case "100%":
        return GradientShadingVariant.ShadingUp;
      case "50%":
        return GradientShadingVariant.ShadingMiddle;
      default:
        return GradientShadingVariant.ShadingOut;
    }
  }

  private void ParsePatternFill(XmlReader reader, Background background)
  {
    string attribute = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    background.SetPatternFillValue((Stream) this.ReadSingleNodeIntoStream(reader));
    if (string.IsNullOrEmpty(attribute))
      return;
    bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
    bool isImageRelation = true;
    string imageName = this.GetImageName(attribute, isHeaderFooter, false, ref isImageRelation);
    if (!isImageRelation)
      return;
    background.PatternImageBytes = this.GetImageBytes(imageName);
  }

  private void ParsePatternFill(XmlReader reader, FillFormat fillFormat)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    uint maxValue = uint.MaxValue;
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == localName2))
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "fgClr":
            fillFormat.ForeColor = this.ParseColor(reader, "fgClr", ref maxValue, reader.LocalName, false);
            maxValue = uint.MaxValue;
            break;
          case "bgClr":
            fillFormat.Color = this.ParseColor(reader, "bgClr", ref maxValue, reader.LocalName, false);
            if (maxValue != uint.MaxValue)
            {
              fillFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParsePictureFill(XmlReader reader, WTextBox textbox, string fillType)
  {
    string attribute = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    if (attribute == null)
      return;
    textbox.TextBoxFormat.FillEfects.Type = fillType == "frame" ? BackgroundType.Picture : BackgroundType.Texture;
    bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
    bool isImageRelation = true;
    string imageName = this.GetImageName(attribute, isHeaderFooter, false, ref isImageRelation);
    if (!isImageRelation)
      return;
    if (this.ImageIds.ContainsKey(imageName))
    {
      textbox.TextBoxFormat.FillEfects.ImageRecord = this.m_doc.Images[this.ImageIds[imageName]];
    }
    else
    {
      textbox.TextBoxFormat.FillEfects.ImageBytes = this.GetImageBytes(imageName);
      this.ImageIds.Add(imageName, textbox.TextBoxFormat.FillEfects.ImageRecord.ImageId);
    }
  }

  private TextWrappingType GetTextWrapType(string wrapType)
  {
    switch (wrapType.ToLower())
    {
      case "left":
        return TextWrappingType.Left;
      case "right":
        return TextWrappingType.Right;
      case "largest":
        return TextWrappingType.Largest;
      default:
        return TextWrappingType.Both;
    }
  }

  private TextWrappingStyle GetWrapStyle(string wrapStyle)
  {
    switch (wrapStyle.ToLower())
    {
      case "square":
        return TextWrappingStyle.Square;
      case "tight":
        return TextWrappingStyle.Tight;
      case "through":
        return TextWrappingStyle.Through;
      case "topandbottom":
        return TextWrappingStyle.TopAndBottom;
      case "none":
        return TextWrappingStyle.Inline;
      default:
        return TextWrappingStyle.InFrontOfText;
    }
  }

  private TextWrappingType GetWrapType(string wrapType)
  {
    switch (wrapType)
    {
      case "left":
        return TextWrappingType.Left;
      case "right":
        return TextWrappingType.Right;
      default:
        return TextWrappingType.Both;
    }
  }

  private void ParseTextboxContent(XmlReader reader, WTextBox textbox)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (!(reader.LocalName == localName2))
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "p":
            IWParagraph paragraph = textbox.TextBoxBody.AddParagraph();
            this.ParseParagraphItems(reader, paragraph.Items, (string) null, (IOfficeMathRunElement) null, false);
            this.m_doc.UpdateLastItemRevision(paragraph, paragraph.Items);
            if (paragraph.NextSibling != null && !(paragraph.NextSibling is AlternateChunk))
              this.UpdateNestedParaItems(paragraph as WParagraph);
            if (!string.IsNullOrEmpty(paragraph.StyleName))
            {
              (paragraph as WParagraph).ApplyStyle(paragraph.StyleName, false);
              break;
            }
            break;
          case "tbl":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 11);
            IWTable table = textbox.TextBoxBody.AddTable();
            table.TableFormat.IsAutoResized = true;
            short gridCount = this.m_gridCount;
            this.ParseTable(reader, table as WTable, false, reader.LocalName);
            this.m_gridCount = gridCount;
            if (table.Rows.Count == 0)
            {
              (table.Owner as WTextBody).ChildEntities.RemoveAt((table as WTable).Index);
              break;
            }
            break;
          case "sdt":
            IBlockContentControl sdTagBlock = textbox.TextBoxBody.AddStructureDocumentTag();
            this.ParseStructureDocumentTagBlock(reader, sdTagBlock as BlockContentControl);
            break;
          case "altChunk":
            AlternateChunk altChunk = this.AddAlternateChunk((IEntity) textbox);
            this.ParseAlternateChunk(reader, altChunk);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseTextBoxStyle(XmlReader reader, WTextBox textbox)
  {
    string attribute = reader.GetAttribute("style");
    if (attribute == null)
      return;
    string[] strArray1 = attribute.Split(';');
    string empty = string.Empty;
    if (strArray1.Length <= 0)
      return;
    for (int index = 0; index < strArray1.Length; ++index)
    {
      string[] strArray2 = strArray1[index].Split(':');
      if (strArray2.Length > 1)
      {
        switch (strArray2[0])
        {
          case "mso-fit-shape-to-text":
            textbox.TextBoxFormat.AutoFit = this.GetBoolValue(strArray2[1]);
            continue;
          case "layout-flow":
          case "mso-layout-flow-alt":
            empty = strArray2[1];
            continue;
          default:
            continue;
        }
      }
    }
    if (string.IsNullOrEmpty(empty))
      return;
    textbox.TextBoxFormat.TextDirection = this.GetTextDirection(empty);
  }

  private void ParseTextboxIntMargins(XmlReader reader, WTextBox textbox)
  {
    string attribute = reader.GetAttribute("inset");
    if (attribute == null)
      return;
    string[] strArray = attribute.Replace("mm", string.Empty).Split(',');
    int index = 0;
    for (int length = strArray.Length; index < length; ++index)
    {
      if (!(strArray[index] == string.Empty))
      {
        float textboxMargin = this.GetTextboxMargin(strArray[index]);
        switch (index)
        {
          case 0:
            textbox.TextBoxFormat.InternalMargin.Left = textboxMargin;
            continue;
          case 1:
            textbox.TextBoxFormat.InternalMargin.Top = textboxMargin;
            continue;
          case 2:
            textbox.TextBoxFormat.InternalMargin.Right = textboxMargin;
            continue;
          case 3:
            textbox.TextBoxFormat.InternalMargin.Bottom = textboxMargin;
            continue;
          default:
            continue;
        }
      }
    }
  }

  private void ParseTextFrameInternalMargins(XmlReader reader, TextFrame textFrame)
  {
    string attribute = reader.GetAttribute("inset");
    if (attribute == null)
      return;
    string[] strArray = attribute.Replace("mm", string.Empty).Split(',');
    int index = 0;
    for (int length = strArray.Length; index < length; ++index)
    {
      if (!(strArray[index] == string.Empty))
      {
        float textboxMargin = this.GetTextboxMargin(strArray[index]);
        switch (index)
        {
          case 0:
            textFrame.InternalMargin.Left = textboxMargin;
            continue;
          case 1:
            textFrame.InternalMargin.Top = textboxMargin;
            continue;
          case 2:
            textFrame.InternalMargin.Right = textboxMargin;
            continue;
          case 3:
            textFrame.InternalMargin.Bottom = textboxMargin;
            continue;
          default:
            continue;
        }
      }
    }
  }

  private float GetTextboxMargin(string margin)
  {
    if (margin == string.Empty)
      return 0.0f;
    float result1 = float.MaxValue;
    float result2 = float.MaxValue;
    if (margin.EndsWith("pt"))
    {
      margin = margin.Replace("pt", string.Empty);
      float.TryParse(margin, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
    }
    else if (margin.EndsWith("in"))
    {
      margin = margin.Replace("in", string.Empty);
      result1 = (float) UnitsConvertor.Instance.ConvertUnits(Convert.ToDouble(margin, (IFormatProvider) CultureInfo.InvariantCulture), PrintUnits.Inch, PrintUnits.Point);
    }
    else if (margin.EndsWith("emu"))
    {
      float.TryParse(margin.Replace("emu", string.Empty), NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
      result1 = (float) UnitsConvertor.Instance.ConvertUnits(Convert.ToDouble((object) result2, (IFormatProvider) CultureInfo.InvariantCulture), PrintUnits.EMU, PrintUnits.Point);
    }
    else
    {
      float.TryParse(margin, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
      result1 = (float) UnitsConvertor.Instance.ConvertUnits((double) result2, PrintUnits.Millimeter, PrintUnits.Point);
    }
    return result1;
  }

  private float GetShapeInternalMargin(string margin)
  {
    if (margin == string.Empty)
      return 0.0f;
    float result1 = float.MaxValue;
    float result2 = float.MaxValue;
    if (margin.EndsWith("pt"))
    {
      margin = margin.Replace("pt", string.Empty);
      float.TryParse(margin, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
    }
    else if (margin.EndsWith("in"))
    {
      margin = margin.Replace("in", string.Empty);
      result1 = (float) UnitsConvertor.Instance.ConvertUnits(Convert.ToDouble(margin, (IFormatProvider) CultureInfo.InvariantCulture), PrintUnits.Inch, PrintUnits.Point);
    }
    else if (margin.EndsWith("mm"))
    {
      float.TryParse(margin, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
      result1 = (float) UnitsConvertor.Instance.ConvertUnits((double) result2, PrintUnits.Millimeter, PrintUnits.Point);
    }
    else
    {
      float.TryParse(margin.Replace("emu", string.Empty), NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
      result1 = (float) UnitsConvertor.Instance.ConvertUnits(Convert.ToDouble((object) result2, (IFormatProvider) CultureInfo.InvariantCulture), PrintUnits.EMU, PrintUnits.Point);
    }
    return result1;
  }

  private void ParseStroke(XmlReader reader, WTextBox textBox)
  {
    string attribute1 = reader.GetAttribute("dashstyle");
    if (!string.IsNullOrEmpty(attribute1))
      textBox.TextBoxFormat.LineDashing = this.GetDashStyle(attribute1);
    string attribute2 = reader.GetAttribute("linestyle");
    if (string.IsNullOrEmpty(attribute2))
      return;
    textBox.TextBoxFormat.LineStyle = this.GetLineStyle(attribute2);
  }

  private LineDashing GetDashStyle(string dashstyle)
  {
    switch (dashstyle)
    {
      case "sysDash":
        return LineDashing.Dash;
      case "sysDashDot":
        return LineDashing.DashDot;
      case "sysDashDotDot":
        return LineDashing.DashDotDot;
      case "sysDot":
        return LineDashing.Dot;
      case "dash":
        return LineDashing.DashGEL;
      case "dashDot":
        return LineDashing.DashDotGEL;
      case "1 1":
      case "dot":
        return LineDashing.DotGEL;
      case "lgDash":
      case "longDash":
        return LineDashing.LongDashGEL;
      case "lgDashDot":
      case "longDashDot":
        return LineDashing.LongDashDotGEL;
      case "lgDashDotDot":
      case "longDashDotDot":
        return LineDashing.LongDashDotDotGEL;
      default:
        return LineDashing.Solid;
    }
  }

  private TextBoxLineStyle GetLineStyle(string lineStyle)
  {
    switch (lineStyle)
    {
      case "dbl":
      case "thinThin":
        return TextBoxLineStyle.Double;
      case "thinThick":
        return TextBoxLineStyle.ThinThick;
      case "thickThin":
        return TextBoxLineStyle.ThickThin;
      case "thickBetweenThin":
      case "tri":
        return TextBoxLineStyle.Triple;
      default:
        return TextBoxLineStyle.Simple;
    }
  }

  private void ParseShapeProperties(XmlReader reader, WTextBox textbox)
  {
    string attribute = reader.GetAttribute("style");
    if (attribute == null)
      return;
    string[] strArray1 = attribute.Trim().Split(';');
    string[] strArray2 = new string[2];
    int index = 0;
    for (int length = strArray1.Length; index < length; ++index)
    {
      string[] propertyValues = this.GetPropertyValues(strArray1[index]);
      if (propertyValues != null)
        this.ApplyShapeProperties(textbox, propertyValues[0], propertyValues[1]);
    }
    this.ParseTextboxEffects(reader, textbox);
  }

  private void ParseTextboxEffects(XmlReader reader, WTextBox textbox)
  {
    string attribute1 = reader.GetAttribute("coordorigin");
    if (!string.IsNullOrEmpty(attribute1))
      this.GetCoordinateOrigin(attribute1, (Entity) textbox);
    textbox.TextBoxFormat.Path = reader.GetAttribute("path");
    textbox.TextBoxFormat.VMLPathPoints = textbox.Parse2007CustomShapePoints(textbox.TextBoxFormat.Path);
    textbox.TextBoxFormat.CoordinateSize = reader.GetAttribute("coordsize");
    string attribute2 = reader.GetAttribute("wrapcoords");
    if (!string.IsNullOrEmpty(attribute2))
    {
      textbox.TextBoxFormat.WrapPolygon = new WrapPolygon();
      char[] chArray = new char[1]{ ' ' };
      string[] strArray = attribute2.Split(chArray);
      for (int index = 0; index < strArray.Length - 1; index += 2)
      {
        float result1 = 0.0f;
        float result2 = 0.0f;
        float.TryParse(strArray[index], NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
        float.TryParse(strArray[index + 1], NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
        textbox.TextBoxFormat.WrapPolygon.Vertices.Add(new PointF(result1, result2));
      }
    }
    string attribute3 = reader.GetAttribute("strokecolor");
    if (!string.IsNullOrEmpty(attribute3))
      textbox.TextBoxFormat.LineColor = this.GetColorValue(attribute3);
    string attribute4 = reader.GetAttribute("strokeweight");
    if (!string.IsNullOrEmpty(attribute4))
      textbox.TextBoxFormat.LineWidth = this.GetPointValue(attribute4);
    string attribute5 = reader.GetAttribute("filled");
    if (!string.IsNullOrEmpty(attribute5) && attribute5 == "f")
    {
      textbox.TextBoxFormat.FillColor = Color.Empty;
    }
    else
    {
      string attribute6 = reader.GetAttribute("fillcolor");
      if (!string.IsNullOrEmpty(attribute6))
      {
        textbox.TextBoxFormat.FillEfects.SetBackgroundColor(this.GetColorValue(attribute6));
        textbox.TextBoxFormat.FillEfects.Type = BackgroundType.Color;
      }
    }
    string attribute7 = reader.GetAttribute("stroked");
    if (!string.IsNullOrEmpty(attribute7))
      textbox.TextBoxFormat.NoLine = attribute7 == "f" || attribute7 == "false";
    string attribute8 = reader.GetAttribute("allowincell", "urn:schemas-microsoft-com:office:office");
    if (!string.IsNullOrEmpty(attribute8))
      textbox.TextBoxFormat.AllowInCell = !(attribute8 == "f");
    string attribute9 = reader.GetAttribute("allowoverlap", "urn:schemas-microsoft-com:office:office");
    if (string.IsNullOrEmpty(attribute9))
      return;
    textbox.TextBoxFormat.AllowOverlap = !(attribute9 == "f") && !(attribute9 == "false");
  }

  private float GetPointValue(string value)
  {
    if (this.StartsWithExt(value, "."))
      value = "0" + value;
    double result1;
    if (value.EndsWith("pt"))
    {
      value = value.Replace("pt", string.Empty);
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
      result1 = Math.Round(result1, 2);
    }
    else if (value.EndsWith("mm"))
    {
      value = value.Replace("mm", string.Empty);
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
      result1 = Math.Round(result1 / 25.399999618530273 * 72.0, 2);
    }
    else if (value.EndsWith("px"))
    {
      value = value.Replace("px", string.Empty);
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
      result1 = Math.Round(result1 / 4.0 * 3.0, 2);
    }
    else if (value.EndsWith("in"))
    {
      value = value.Replace("in", string.Empty);
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
      result1 = Math.Round(result1 * 72.0, 2);
    }
    else if (value.EndsWith("cm"))
    {
      value = value.Replace("cm", string.Empty);
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
      result1 = Math.Round(result1 / 2.5399999618530273 * 72.0, 2);
    }
    else
    {
      if (value.EndsWith("emu"))
        value = value.Replace("emu", string.Empty);
      double result2;
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
      result1 = Math.Round(result2 / 12700.0, 2);
    }
    return (float) result1;
  }

  private float GetChildShapePointValue(string value)
  {
    if (value.StartsWith("."))
      value = "0" + value;
    double result1;
    if (value.EndsWith("pt"))
    {
      value = value.Replace("pt", string.Empty);
      double result2;
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
      result1 = Math.Round(result2, 2);
    }
    else if (value.EndsWith("mm"))
    {
      value = value.Replace("mm", string.Empty);
      double result3;
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result3);
      result1 = Math.Round(result3 / 25.399999618530273 * 72.0, 2);
    }
    else if (value.EndsWith("px"))
    {
      value = value.Replace("px", string.Empty);
      double result4;
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result4);
      result1 = Math.Round(result4 / 4.0 * 3.0, 2);
    }
    else if (value.EndsWith("in"))
    {
      value = value.Replace("in", string.Empty);
      double result5;
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result5);
      result1 = Math.Round(result5 * 72.0, 2);
    }
    else if (value.EndsWith("cm"))
    {
      value = value.Replace("cm", string.Empty);
      double result6;
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result6);
      result1 = Math.Round(result6 / 2.5399999618530273 * 72.0, 2);
    }
    else if (value.EndsWith("emu"))
    {
      value = value.Replace("emu", string.Empty);
      double result7;
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result7);
      result1 = result7 / 20.0;
    }
    else
    {
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
      result1 = Math.Round(result1, 2);
    }
    return (float) result1;
  }

  private void ApplyShapeProperties(WTextBox textbox, string propertyName, string propertyValue)
  {
    switch (propertyName)
    {
      case "margin-left":
        textbox.TextBoxFormat.HorizontalPosition = this.GetPointValue(propertyValue);
        break;
      case "margin-top":
        textbox.TextBoxFormat.VerticalPosition = this.GetPointValue(propertyValue);
        break;
      case "width":
        textbox.TextBoxFormat.Width = this.GetPointValue(propertyValue);
        break;
      case "height":
        textbox.TextBoxFormat.Height = this.GetPointValue(propertyValue);
        break;
      case "rotation":
        if (string.IsNullOrEmpty(propertyValue))
          break;
        int result1 = 0;
        if (propertyValue.EndsWith("fd"))
        {
          int.TryParse(propertyValue.Replace("fd", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
          result1 = result1 / 32768 /*0x8000*/ / 2;
          if (result1 < 0)
          {
            textbox.TextBoxFormat.Rotation = (float) (360 - Math.Abs(result1));
            break;
          }
          textbox.TextBoxFormat.Rotation = (float) Math.Abs(result1);
          break;
        }
        int.TryParse(propertyValue, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
        textbox.TextBoxFormat.Rotation = (float) result1;
        break;
      case "flip":
        switch (propertyValue)
        {
          case "x":
            textbox.TextBoxFormat.FlipHorizontal = true;
            return;
          case "y":
            textbox.TextBoxFormat.FlipVertical = true;
            return;
          case "x y":
            textbox.TextBoxFormat.FlipHorizontal = true;
            textbox.TextBoxFormat.FlipVertical = true;
            return;
          default:
            textbox.TextBoxFormat.DocxStyleProps.Add($"{propertyName}:{propertyValue}");
            return;
        }
      case "z-index":
        int result2 = 0;
        int.TryParse(propertyValue, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
        if (textbox.TextBoxFormat.OrderIndex == int.MaxValue)
          textbox.TextBoxFormat.OrderIndex = result2;
        textbox.TextBoxFormat.IsBelowText = result2 <= 0;
        if (textbox.TextBoxFormat.IsBelowText)
        {
          textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
          break;
        }
        textbox.TextBoxFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
        break;
      case "visibility":
        if (string.IsNullOrEmpty(propertyValue) || !(propertyValue.ToLower() == "hidden"))
          break;
        textbox.Visible = false;
        break;
      case "mso-position-horizontal":
        textbox.TextBoxFormat.HorizontalAlignment = this.GetHorizAlign(propertyValue);
        break;
      case "mso-width-percent":
        textbox.TextBoxFormat.WidthRelativePercent = this.ParseFloatVal(propertyValue) / 10f;
        break;
      case "mso-height-percent":
        textbox.TextBoxFormat.HeightRelativePercent = this.ParseFloatVal(propertyValue) / 10f;
        break;
      case "mso-position-vertical":
        textbox.TextBoxFormat.VerticalAlignment = this.GetVertAlign(propertyValue);
        break;
      case "v-text-anchor":
        textbox.TextBoxFormat.TextVerticalAlignment = this.GetTextVertAlign(propertyValue);
        break;
      case "mso-height-relative":
        textbox.TextBoxFormat.HeightOrigin = this.GetHeightOrigin(propertyValue);
        break;
      case "mso-width-relative":
        textbox.TextBoxFormat.WidthOrigin = this.GetWidthOrigin(propertyValue);
        break;
      case "mso-position-vertical-relative":
        textbox.TextBoxFormat.VerticalOrigin = this.GetVertOrigin(propertyValue);
        break;
      case "mso-position-horizontal-relative":
        textbox.TextBoxFormat.HorizontalOrigin = this.GetHorizOrigin(propertyValue);
        break;
      case "mso-left-percent":
        textbox.TextBoxFormat.HorizontalRelativePercent = this.ParseFloatVal(propertyValue) / 10f;
        break;
      case "mso-top-percent":
        textbox.TextBoxFormat.VerticalRelativePercent = this.ParseFloatVal(propertyValue) / 10f;
        break;
      case "mso-wrap-distance-left":
        textbox.TextBoxFormat.WrapDistanceLeft = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-top":
        textbox.TextBoxFormat.WrapDistanceTop = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-right":
        textbox.TextBoxFormat.WrapDistanceRight = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-distance-bottom":
        textbox.TextBoxFormat.WrapDistanceBottom = this.GetPointValue(propertyValue);
        break;
      case "mso-wrap-style":
        this.ParseTextBoxWrapType(textbox, propertyValue);
        break;
      default:
        if (propertyName == "position" && (propertyValue == "absolute" || propertyValue == "relative") && textbox.TextBoxFormat.TextWrappingStyle == TextWrappingStyle.Inline)
          textbox.TextBoxFormat.TextWrappingStyle = TextWrappingStyle.InFrontOfText;
        textbox.TextBoxFormat.DocxStyleProps.Add($"{propertyName}:{propertyValue}");
        break;
    }
  }

  private void ParseTextBoxWrapType(WTextBox textbox, string value)
  {
    switch (value)
    {
      case "square":
        textbox.TextBoxFormat.WrappingMode = WrapMode.Square;
        break;
      case "through":
        textbox.TextBoxFormat.WrappingMode = WrapMode.Through;
        break;
      case "top-and-bottom":
        textbox.TextBoxFormat.WrappingMode = WrapMode.TopBottom;
        break;
      case "none":
        textbox.TextBoxFormat.WrappingMode = WrapMode.None;
        break;
    }
  }

  private string[] GetPropertyValues(string value)
  {
    char[] chArray = new char[1]{ ':' };
    string[] strArray = value.Split(chArray);
    return strArray.Length == 2 ? strArray : (string[]) null;
  }

  private ShapeType DetectShapeType(
    MemoryStream shapeStream,
    ref Syncfusion.DocIO.DLS.AutoShapeType autoShapeType,
    ref Dictionary<string, Stream> docxProps,
    ref string shapeTypeId)
  {
    XmlReader reader = UtilityMethods.CreateReader((Stream) shapeStream);
    if (reader.LocalName != "pict")
      throw new XmlException("picture shape element");
    string text = (string) null;
    string str1 = (string) null;
    string id = (string) null;
    string str2 = (string) null;
    bool flag1 = false;
    bool flag2 = false;
    bool flag3 = false;
    int num = 0;
    reader.Read();
    while (reader.LocalName != "pict" && !reader.EOF)
    {
      bool flag4 = false;
      this.SkipWhitespaces(reader);
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "group":
            return ShapeType.GroupedShape;
          case "OLEObject":
            return ShapeType.OleObject;
          case "shape":
            str1 = reader.GetAttribute("type");
            text = reader.GetAttribute("id");
            break;
          case "textbox":
          case "rect":
            flag2 = true;
            if (reader.LocalName == "rect")
            {
              autoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Rectangle;
              break;
            }
            break;
          case "txbxContent":
            flag3 = true;
            reader.Skip();
            break;
          case "shapetype":
            if (!this.IsWord2003ML)
            {
              shapeTypeId = reader.GetAttribute("id");
              this.ReadSingleNodeIntoStream(reader);
              flag4 = true;
              break;
            }
            break;
          case "imagedata":
            flag1 = true;
            id = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            str2 = reader.GetAttribute("href", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            break;
          case "roundrect":
            autoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.RoundedRectangle;
            break;
          case "oval":
            autoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Oval;
            break;
          case "line":
            autoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Line;
            break;
          case "callout":
          case "stroke":
          case "fill":
          case "wrap":
          case "extrusion":
            if (!this.IsWord2003ML && !docxProps.ContainsKey(reader.LocalName))
            {
              docxProps.Add(reader.LocalName, (Stream) this.ReadSingleNodeIntoStream(reader));
              flag4 = true;
              break;
            }
            break;
          case "shadow":
            if (!this.IsWord2003ML)
            {
              ++num;
              if (!docxProps.ContainsKey(reader.LocalName))
              {
                docxProps.Add(reader.LocalName + (object) num, (Stream) this.ReadSingleNodeIntoStream(reader));
                flag4 = true;
                break;
              }
              break;
            }
            break;
          case "textpath":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 31 /*0x1F*/);
            break;
        }
      }
      if (!flag4)
        reader.Read();
    }
    if (text != null && (this.StartsWithExt(text, "PowerPlusWaterMarkObject") || this.StartsWithExt(text, "WordPictureWatermark")))
      return ShapeType.WatermarkShape;
    if (flag2 && (str1 == "_s13" || str1 == "_s62" || str1 == "#_x0000_t202") || flag2 && flag3 && (str1 == null || id != null))
      return ShapeType.TextboxShape;
    if (shapeTypeId != null && str1 != null && shapeTypeId == "_x0000_t75" && str1 == "#_x0000_t75" && flag1 && !flag2 || shapeTypeId == null && str1 == "#_x0000_t75" && !flag2 || str2 != null && str2 != string.Empty || id != null && this.GetRelation(id).Key != null)
      return ShapeType.PictureShape;
    if (!string.IsNullOrEmpty(str1))
      autoShapeType = this.AutoShapeHelper.GetAutoShapeType(str1.Replace("#", "").Replace("_x0000_t", ""));
    return ShapeType.XmlParagraphItem;
  }

  private void ParseTextBoxGraphics(WTextBox textbox, XmlParagraphItem choiceItem)
  {
    XmlReader reader = UtilityMethods.CreateReader(choiceItem.DataNode);
    reader.ReadToFollowing("fontRef", this.IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
    if (reader.NodeType == XmlNodeType.None)
      return;
    reader.Read();
    if (!(reader.LocalName == "schemeClr"))
      return;
    textbox.TextBoxFormat.TextThemeColor = this.GetSchemeColor(reader);
  }

  private ParagraphItem ParseDrawing(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    ref MemoryStream drawingStream,
    bool isMappedPictureContentControl)
  {
    if (reader.LocalName != "drawing")
      throw new XmlException("Drawing element");
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 14);
    drawingStream = this.ReadSingleNodeIntoStream(reader);
    XmlReader reader1 = UtilityMethods.CreateReader((Stream) drawingStream);
    while (reader1.NodeType != XmlNodeType.Element)
      reader1.Read();
    DocxParser.GraphicDataContentType graphicDataContentType = this.CheckPicture(reader1);
    switch (graphicDataContentType)
    {
      case DocxParser.GraphicDataContentType.None:
        drawingStream.Position = 0L;
        return (ParagraphItem) this.ParseXmlParaItem((Stream) drawingStream);
      case DocxParser.GraphicDataContentType.Chart:
        drawingStream.Position = 0L;
        return this.ParseChart(reader1, paraItems, drawingStream);
      case DocxParser.GraphicDataContentType.Group:
        drawingStream.Position = 0L;
        return (ParagraphItem) this.ParseGroupShape((Stream) drawingStream);
      default:
        bool flag = false;
        if (graphicDataContentType == DocxParser.GraphicDataContentType.Picture)
          flag = this.ParseImageHyperlink(UtilityMethods.CreateReader((Stream) drawingStream), paraItems);
        XmlReader reader2 = UtilityMethods.CreateReader((Stream) drawingStream);
        while (reader2.NodeType != XmlNodeType.Element)
          reader2.Read();
        if (graphicDataContentType != DocxParser.GraphicDataContentType.Picture)
          return this.ParseShape(reader2, paraItems, drawingStream);
        WPicture picture1 = new WPicture((IWordDocument) this.m_doc);
        reader2.ReadToFollowing("blip", this.IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
        string attribute1 = reader2.GetAttribute("embed", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
        string attribute2 = reader2.GetAttribute("link", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
        bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
        if (!string.IsNullOrEmpty(attribute1))
          this.LoadImage(picture1, attribute1, isHeaderFooter, false);
        if (!string.IsNullOrEmpty(attribute2))
        {
          bool isImageRelation = true;
          string imageName = this.GetImageName(attribute2, isHeaderFooter, false, ref isImageRelation);
          if (isImageRelation && this.m_isExternalHyperlink != null && this.m_docRelations.ContainsKey(attribute2) && this.IsExternalHyperlink.ContainsKey(attribute2) && this.IsExternalHyperlink[attribute2])
            picture1.ExternalLink = imageName;
          if (!string.IsNullOrEmpty(attribute1))
            picture1.HasImageRecordReference = true;
          Image image = this.DownloadImage(picture1.ExternalLink);
          if (image != null)
            picture1.LoadImage(image);
          else if (picture1.ExternalLink != null && !picture1.HasImageRecordReference)
          {
            Image defaultImage = picture1.GetDefaultImage();
            picture1.LoadImage(defaultImage);
          }
        }
        if (picture1.ImageRecord == null && picture1.ImageBytes == null && isMappedPictureContentControl)
        {
          Image image = Image.FromStream(WPicture.GetManifestResourceStream("ImageNotFound.jpg"), true, false);
          picture1.LoadImage(image);
        }
        if (picture1.ImageRecord == null && picture1.ImageBytes == null)
          return (ParagraphItem) null;
        reader2.Close();
        ParagraphItem picture2 = this.ParsePicture(UtilityMethods.CreateReader((Stream) drawingStream), picture1);
        if (!flag || picture2 == null)
          return picture2;
        paraItems.Add((IEntity) picture2);
        this.CheckTrackChange(picture2);
        WFieldMark wfieldMark = new WFieldMark((IWordDocument) this.m_doc, FieldMarkType.FieldEnd);
        this.AddToParagraph((ParagraphItem) wfieldMark, paraItems);
        this.FieldStack.Pop().FieldEnd = wfieldMark;
        return (ParagraphItem) null;
    }
  }

  private ParagraphItem ParseShape(
    XmlReader picReader,
    ParagraphItemCollection paraItems,
    MemoryStream drawingStream)
  {
    picReader = UtilityMethods.CreateReader((Stream) drawingStream);
    if (picReader.ReadToFollowing("prstGeom", this.IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main"))
    {
      string attribute = picReader.GetAttribute("prst");
      if (!string.IsNullOrEmpty(attribute) && attribute.Length > 0 && this.AutoShapeHelper.GetAutoShapeType(this.AutoShapeHelper.GetAutoShapeConstant(attribute)) == Syncfusion.DocIO.DLS.AutoShapeType.Unknown)
      {
        this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 10);
        return (ParagraphItem) this.ParseXmlParaItem((Stream) drawingStream);
      }
    }
    Shape shape = new Shape((IWordDocument) this.m_doc);
    shape.ApplyCharacterFormat(this.m_currentRunFormat);
    this.ApplyDirectionalOverride(shape.GetCharFormat());
    this.ParseXMLRelations(shape, drawingStream);
    picReader = UtilityMethods.CreateReader((Stream) drawingStream);
    picReader.Read();
    this.ParseShapeBaseProperties(picReader, (Syncfusion.DocIO.DLS.ShapeBase) shape, drawingStream);
    return (ParagraphItem) shape;
  }

  private void ParseCustomGeometry(XmlReader reader, ShapeCommon shape)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    Dictionary<string, string> gdValues1 = shape is Shape ? (shape as Shape).GetGuideList() : (shape as ChildShape).GetGuideList();
    Dictionary<string, string> gdValues2 = shape is Shape ? (shape as Shape).GetAvList() : (shape as ChildShape).GetAvList();
    while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "avLst":
            DocxParser.ParseGuideList(reader, gdValues2);
            reader.Skip();
            continue;
          case "gdLst":
            DocxParser.ParseGuideList(reader, gdValues1);
            reader.Skip();
            continue;
          case "pathLst":
            if (shape is Shape)
              (shape as Shape).Path2DList = new List<Path2D>();
            else
              (shape as ChildShape).Path2DList = new List<Path2D>();
            DocxParser.ParsePath2D(reader, shape);
            reader.Skip();
            continue;
          default:
            shape.DocxProps.Add(reader.LocalName, (Stream) this.ReadSingleNodeIntoStream(reader));
            continue;
        }
      }
      else
        reader.Skip();
    }
    DocxParser.SetReaderPosition(reader);
  }

  internal static void SetReaderPosition(XmlReader reader)
  {
    while (reader.LocalName != "custGeom")
      reader.Read();
  }

  internal static void ParseGuideList(XmlReader reader, Dictionary<string, string> gdValues)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        if (reader.LocalName == "gd")
        {
          string key = (string) null;
          string str = (string) null;
          if (reader.MoveToAttribute("name"))
            key = reader.Value;
          if (reader.MoveToAttribute("fmla"))
            str = reader.Value;
          if (!gdValues.ContainsKey(key))
            gdValues.Add(key, str);
          else
            gdValues[key] = str;
        }
        reader.Skip();
      }
      else
        reader.Skip();
    }
  }

  internal static void ParsePath2D(XmlReader reader, ShapeCommon shape)
  {
    List<Path2D> path2DList = shape is Shape ? (shape as Shape).Path2DList : (shape as ChildShape).Path2DList;
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        if (reader.LocalName == "path")
        {
          Path2D path = new Path2D();
          if (reader.MoveToAttribute("w"))
            path.Width = double.Parse(reader.Value, (IFormatProvider) CultureInfo.InvariantCulture);
          if (reader.MoveToAttribute("h"))
            path.Height = double.Parse(reader.Value, (IFormatProvider) CultureInfo.InvariantCulture);
          if (reader.MoveToAttribute("stroke"))
            path.IsStroke = reader.Value == "1";
          if (path.Width == 0.0)
            path.Width = (double) shape.Width;
          if (path.Height == 0.0)
            path.Height = (double) shape.Height;
          reader.MoveToElement();
          DocxParser.Parse2DElements(reader, path);
          path2DList.Add(path);
        }
        reader.Skip();
      }
      else
        reader.Skip();
    }
  }

  private static void Parse2DElements(XmlReader reader, Path2D path)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "close":
            path.PathElements.Add((ushort) 1.ToString());
            path.PathElements.Add("0");
            reader.Skip();
            continue;
          case "moveTo":
            path.PathElements.Add((ushort) 2.ToString());
            path.PathElements.Add("1");
            DocxParser.ParsePath2DPoint(reader, path.PathElements);
            reader.Skip();
            continue;
          case "lnTo":
            path.PathElements.Add((ushort) 3.ToString());
            path.PathElements.Add("1");
            DocxParser.ParsePath2DPoint(reader, path.PathElements);
            reader.Skip();
            continue;
          case "quadBezTo":
            path.PathElements.Add((ushort) 5.ToString());
            path.PathElements.Add("2");
            DocxParser.ParsePath2DPoint(reader, path.PathElements);
            reader.Skip();
            continue;
          case "cubicBezTo":
            path.PathElements.Add((ushort) 6.ToString());
            path.PathElements.Add("3");
            DocxParser.ParsePath2DPoint(reader, path.PathElements);
            reader.Skip();
            continue;
          case "arcTo":
            path.PathElements.Add((ushort) 4.ToString());
            path.PathElements.Add("4");
            if (reader.MoveToAttribute("wR"))
              path.PathElements.Add(reader.Value);
            if (reader.MoveToAttribute("hR"))
              path.PathElements.Add(reader.Value);
            if (reader.MoveToAttribute("stAng"))
              path.PathElements.Add(reader.Value);
            if (reader.MoveToAttribute("swAng"))
              path.PathElements.Add(reader.Value);
            reader.Skip();
            continue;
          default:
            reader.Skip();
            continue;
        }
      }
      else
        reader.Skip();
    }
  }

  private static void ParsePath2DPoint(XmlReader reader, List<string> pathElements)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    while (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        if (!(reader.LocalName == "pt"))
          break;
        if (reader.MoveToAttribute("x"))
          pathElements.Add(reader.Value);
        if (reader.MoveToAttribute("y"))
          pathElements.Add(reader.Value);
        reader.Skip();
      }
      else
        reader.Skip();
    }
  }

  private Syncfusion.DocIO.DLS.ShapeBase ParseShapeBaseProperties(
    XmlReader picReader,
    Syncfusion.DocIO.DLS.ShapeBase shapeBase,
    MemoryStream drawingStream)
  {
    bool flag1 = false;
    while (!picReader.EOF && picReader.LocalName != "drawing")
    {
      if (picReader.LocalName == "drawing")
        picReader.Read();
      bool flag2 = false;
      this.SkipWhitespaces(picReader);
      if (picReader.NodeType == XmlNodeType.Element)
      {
        switch (picReader.LocalName)
        {
          case "effectExtent":
            if (!this.IsWord2003ML)
            {
              this.ProcessEffectExtent(picReader, shapeBase);
              shapeBase.DocxProps.Add("effectExtent", (Stream) this.ReadSingleNodeIntoStream(picReader));
              flag2 = true;
              goto case "AlternateContent";
            }
            goto case "AlternateContent";
          case "extent":
            string attribute1 = picReader.GetAttribute("cx");
            if (!string.IsNullOrEmpty(attribute1))
              shapeBase.Width = this.GetPropertyValue(attribute1, "cx");
            string attribute2 = picReader.GetAttribute("cy");
            if (!string.IsNullOrEmpty(attribute2))
            {
              shapeBase.Height = this.GetPropertyValue(attribute2, "cy");
              goto case "AlternateContent";
            }
            goto case "AlternateContent";
          case "positionH":
            this.ParsePictureHorizontalPosition(picReader, shapeBase);
            goto case "AlternateContent";
          case "positionV":
            this.ParsePictureVerticalPosition(picReader, shapeBase);
            goto case "AlternateContent";
          case "docPr":
            shapeBase.Title = picReader.GetAttribute("title");
            shapeBase.AlternativeText = picReader.GetAttribute("descr");
            string attribute3 = picReader.GetAttribute("id");
            if (!string.IsNullOrEmpty(attribute3))
              shapeBase.ShapeID = XmlConvert.ToInt64(attribute3);
            shapeBase.Name = picReader.GetAttribute("name");
            string attribute4 = picReader.GetAttribute("hidden");
            shapeBase.Visible = string.IsNullOrEmpty(attribute4) || !this.GetBoolValue(attribute4);
            goto case "AlternateContent";
          case "wrapSquare":
            shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Square);
            this.ParseWrappingType(picReader, shapeBase.WrapFormat);
            goto case "AlternateContent";
          case "wrapTight":
            shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
            this.ParseWrappingType(picReader, shapeBase.WrapFormat);
            this.ParseWrapPolygon(picReader, (IEntity) shapeBase);
            goto case "AlternateContent";
          case "wrapThrough":
            shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Through);
            this.ParseWrappingType(picReader, shapeBase.WrapFormat);
            this.ParseWrapPolygon(picReader, (IEntity) shapeBase);
            goto case "AlternateContent";
          case "wrapTopAndBottom":
            shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
            goto case "AlternateContent";
          case "wrapNone":
            if (!flag1)
            {
              if (shapeBase.IsBelowText)
              {
                shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
                goto case "AlternateContent";
              }
              shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
              goto case "AlternateContent";
            }
            goto case "AlternateContent";
          case "anchor":
            shapeBase.WrapFormat.DistanceLeft = 9f;
            shapeBase.WrapFormat.DistanceRight = 9f;
            if (picReader.AttributeCount != 0)
            {
              if (picReader.MoveToAttribute("distT"))
                shapeBase.WrapFormat.DistanceTop = this.GetPointValue(picReader.Value);
              if (picReader.MoveToAttribute("distB"))
                shapeBase.WrapFormat.DistanceBottom = this.GetPointValue(picReader.Value);
              if (picReader.MoveToAttribute("distL"))
                shapeBase.WrapFormat.DistanceLeft = this.GetPointValue(picReader.Value);
              if (picReader.MoveToAttribute("distR"))
                shapeBase.WrapFormat.DistanceRight = this.GetPointValue(picReader.Value);
              if (picReader.MoveToAttribute("relativeHeight") && !string.IsNullOrEmpty(picReader.Value))
              {
                int result = 0;
                int.TryParse(picReader.Value, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                shapeBase.ZOrderPosition = result;
              }
              if (picReader.MoveToAttribute("behindDoc"))
                shapeBase.IsBelowText = XmlConvert.ToBoolean(picReader.Value);
              if (picReader.MoveToAttribute("locked"))
                shapeBase.LockAnchor = XmlConvert.ToBoolean(picReader.Value);
              if (picReader.MoveToAttribute("layoutInCell"))
                shapeBase.LayoutInCell = XmlConvert.ToBoolean(picReader.Value);
              if (picReader.MoveToAttribute("allowOverlap"))
              {
                shapeBase.WrapFormat.AllowOverlap = XmlConvert.ToBoolean(picReader.Value);
                goto case "AlternateContent";
              }
              goto case "AlternateContent";
            }
            goto case "AlternateContent";
          case "AlternateContent":
          case "Choice":
          case "Fallback":
label_60:
            if (!flag2)
            {
              picReader.Read();
              continue;
            }
            continue;
          case "graphic":
            picReader.Read();
            switch (shapeBase)
            {
              case Shape _:
                this.ParseGraphicData(picReader, shapeBase as Shape);
                goto label_60;
              case GroupShape _:
                this.ParseGraphicData(picReader, shapeBase as GroupShape);
                goto label_60;
              default:
                this.ParseGraphicData(picReader, shapeBase as WChart, drawingStream);
                goto label_60;
            }
          case "sizeRelH":
            shapeBase.IsRelativeWidth = true;
            string attribute5 = picReader.GetAttribute("relativeFrom");
            if (!string.IsNullOrEmpty(attribute5))
              shapeBase.RelativeWidthHorizontalOrigin = this.GetHorizOrigin(attribute5);
            picReader.Read();
            this.SkipWhitespaces(picReader);
            if (picReader.LocalName == "pctWidth")
            {
              float result = float.MaxValue;
              float.TryParse(picReader.ReadString(), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              if ((double) result != 3.4028234663852886E+38)
              {
                shapeBase.RelativeWidth = (float) Math.Round((double) result / 1000.0, 2);
                goto case "AlternateContent";
              }
              goto case "AlternateContent";
            }
            goto case "AlternateContent";
          case "sizeRelV":
            shapeBase.IsRelativeHeight = true;
            string attribute6 = picReader.GetAttribute("relativeFrom");
            if (!string.IsNullOrEmpty(attribute6))
              shapeBase.RelativeHeightVerticalOrigin = this.GetVertOrigin(attribute6);
            picReader.Read();
            this.SkipWhitespaces(picReader);
            if (picReader.LocalName == "pctHeight")
            {
              float result = float.MaxValue;
              float.TryParse(picReader.ReadString(), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              if ((double) result != 3.4028234663852886E+38)
              {
                shapeBase.RelativeHeight = (float) Math.Round((double) result / 1000.0, 2);
                goto case "AlternateContent";
              }
              goto case "AlternateContent";
            }
            goto case "AlternateContent";
          case "inline":
            flag1 = true;
            shapeBase.WrapFormat.SetTextWrappingStyleValue(TextWrappingStyle.Inline);
            goto case "AlternateContent";
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(picReader);
              flag2 = true;
              goto case "AlternateContent";
            }
            goto case "AlternateContent";
        }
      }
      else
        picReader.Read();
    }
    return shapeBase;
  }

  private void ParsePictureHorizontalPosition(XmlReader reader, Syncfusion.DocIO.DLS.ShapeBase shapeBase)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "positionH")
      throw new XmlException("positionH");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    string attribute = reader.GetAttribute("relativeFrom");
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    HorizontalOrigin horizontalOrigin = HorizontalOrigin.Margin;
    if (!string.IsNullOrEmpty(attribute))
      horizontalOrigin = this.GetHorizOrigin(attribute);
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "positionH")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "align":
            string align = reader.ReadString();
            if (align != null)
              shapeBase.HorizontalAlignment = this.GetHorizAlign(align);
            shapeBase.HorizontalOrigin = horizontalOrigin;
            break;
          case "posOffset":
            float result1 = float.MaxValue;
            float.TryParse(reader.ReadString(), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
            if ((double) result1 != 3.4028234663852886E+38)
              shapeBase.HorizontalPosition = (float) Math.Round((double) result1 / 12700.0, 2);
            shapeBase.HorizontalOrigin = horizontalOrigin;
            break;
          case "pctPosHOffset":
            shapeBase.IsRelativeHorizontalPosition = true;
            float result2 = float.MaxValue;
            float.TryParse(reader.ReadString(), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
            if ((double) result2 != 3.4028234663852886E+38)
              shapeBase.RelativeHorizontalPosition = (float) Math.Round((double) result2 / 1000.0, 2);
            shapeBase.RelativeHorizontalOrigin = horizontalOrigin;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParsePictureVerticalPosition(XmlReader reader, Syncfusion.DocIO.DLS.ShapeBase shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "positionV")
      throw new XmlException("PositionV");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    string attribute = reader.GetAttribute("relativeFrom");
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    VerticalOrigin verticalOrigin = VerticalOrigin.Margin;
    if (!string.IsNullOrEmpty(attribute))
      verticalOrigin = this.GetVertOrigin(attribute);
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "positionV")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "align":
            string align = reader.ReadString();
            if (align != null)
              shape.VerticalAlignment = this.GetVertAlign(align);
            shape.VerticalOrigin = verticalOrigin;
            break;
          case "posOffset":
            float result1 = float.MaxValue;
            float.TryParse(reader.ReadString(), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
            if ((double) result1 != 3.4028234663852886E+38)
              shape.VerticalPosition = (float) Math.Round((double) result1 / 12700.0, 2);
            shape.VerticalOrigin = verticalOrigin;
            break;
          case "pctPosVOffset":
            shape.IsRelativeVerticalPosition = true;
            float result2 = float.MaxValue;
            float.TryParse(reader.ReadString(), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
            if ((double) result2 != 3.4028234663852886E+38)
              shape.RelativeVerticalPosition = (float) Math.Round((double) result2 / 1000.0, 2);
            shape.RelativeVerticalOrigin = verticalOrigin;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseWrappingType(XmlReader reader, WrapFormat wrapFormat)
  {
    string attribute = reader.GetAttribute("wrapText");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "bothSides":
        wrapFormat.TextWrappingType = TextWrappingType.Both;
        break;
      case "left":
        wrapFormat.TextWrappingType = TextWrappingType.Left;
        break;
      case "right":
        wrapFormat.TextWrappingType = TextWrappingType.Right;
        break;
      case "largest":
        wrapFormat.TextWrappingType = TextWrappingType.Largest;
        break;
    }
  }

  private void ParseWrapPolygon(XmlReader reader, IEntity entity)
  {
    reader.Read();
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "wrapPolygon")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    WrapPolygon wrapPolygon = (WrapPolygon) null;
    switch (entity)
    {
      case WPicture _:
        (entity as WPicture).WrapPolygon = new WrapPolygon();
        wrapPolygon = (entity as WPicture).WrapPolygon;
        break;
      case Shape _:
        (entity as Shape).WrapFormat.WrapPolygon = new WrapPolygon();
        wrapPolygon = (entity as Shape).WrapFormat.WrapPolygon;
        break;
      case GroupShape _:
        (entity as GroupShape).WrapFormat.WrapPolygon = new WrapPolygon();
        wrapPolygon = (entity as GroupShape).WrapFormat.WrapPolygon;
        break;
      case WChart _:
        (entity as WChart).WrapFormat.WrapPolygon = new WrapPolygon();
        wrapPolygon = (entity as WChart).WrapFormat.WrapPolygon;
        break;
      case WTextBox _:
        (entity as WTextBox).TextBoxFormat.WrapPolygon = new WrapPolygon();
        wrapPolygon = (entity as WTextBox).TextBoxFormat.WrapPolygon;
        break;
    }
    string attribute1 = reader.GetAttribute("edited");
    if (!string.IsNullOrEmpty(attribute1))
      wrapPolygon.Edited = !(attribute1 == "0") && !(attribute1 == "false");
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "wrapPolygon")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "start":
          case "lineTo":
            float result1 = float.MaxValue;
            float result2 = float.MaxValue;
            string attribute2 = reader.GetAttribute("x");
            if (!string.IsNullOrEmpty(attribute2))
              float.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
            string attribute3 = reader.GetAttribute("y");
            if (!string.IsNullOrEmpty(attribute3))
              float.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
            if ((double) result1 != 4294967296.0 && (double) result2 != 4294967296.0)
            {
              wrapPolygon.Vertices.Add(new PointF(result1, result2));
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    reader.Read();
  }

  private ParagraphItem ParseChart(
    XmlReader picReader,
    ParagraphItemCollection paraItems,
    MemoryStream drawingStream)
  {
    WChart chart = new WChart(this.m_doc);
    picReader = UtilityMethods.CreateReader((Stream) drawingStream);
    picReader.Read();
    this.ParseShapeBaseProperties(picReader, (Syncfusion.DocIO.DLS.ShapeBase) chart, drawingStream);
    return (ParagraphItem) chart;
  }

  private void ParseChartRelations(Stream stream, Dictionary<string, DictionaryEntry> relations)
  {
    this.ParseRelations(UtilityMethods.CreateReader(stream), relations);
  }

  private void ParseGraphicData(XmlReader reader, WChart chart, MemoryStream drawingStream)
  {
    ChartParser chartParser = new ChartParser(chart.Workbook);
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "graphicData")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    string attribute1 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    string key1 = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer") || this.IsInFootnote || this.IsInEndnote || this.IsInComments ? (string) (!this.IsInComments ? this.GetFileRelations(this.m_currentFile) : this.GetFileRelations("comments.xml.rels"))[attribute1].Value : this.m_docRelations[attribute1].Value.ToString();
    int num1 = key1.LastIndexOf('/');
    if (num1 > 0 && key1.Substring(num1 + 1, key1.Length - (num1 + 1)).Length > 0)
      key1 = key1.Replace(key1.Substring(0, num1 + 1), (string) null);
    PartContainer partContainer1 = this.m_doc.DocxPackage.FindPartContainer("word/charts/");
    if (partContainer1 != null && partContainer1.Relations.ContainsKey($"word/charts/_rels/{key1}.rels"))
      this.ParseChartRelations(partContainer1.Relations[$"word/charts/_rels/{key1}.rels"].DataStream, this.ChartRelations);
    XmlReader reader1 = UtilityMethods.CreateReader(partContainer1.XmlParts[key1].DataStream);
    reader1.ReadToDescendant("c:externalData");
    string attribute2 = reader1.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    string str1 = string.Empty;
    ChartImpl officeChart = chart.OfficeChart as ChartImpl;
    while (reader1.Read())
    {
      this.SkipWhitespaces(reader1);
      if (!(reader1.LocalName == "chartSpace"))
      {
        if (reader1.LocalName == "userShapes")
        {
          str1 = reader1.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          break;
        }
      }
      else
        break;
    }
    foreach (string key2 in this.ChartRelations.Keys)
    {
      DictionaryEntry chartRelation = this.ChartRelations[key2];
      string str2 = chartRelation.Value.ToString();
      int num2 = str2.Length - (str2.Contains(".") ? str2.LastIndexOf('.') : 0);
      string str3 = str2.Substring(0, str2.Length - num2);
      if (!object.Equals(chartRelation.Key, (object) "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject") && string.Equals(this.GetExtension(str2), ".xlsx") || object.Equals(chartRelation.Key, (object) "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject") && str2.EndsWith(".xltx"))
      {
        int num3 = str2.Contains("/") ? str2.LastIndexOf('/') : 0;
        string key3 = str2.Substring(num3 + 1, str2.Length - num3 - 1);
        int num4 = key3.Length - (key3.Contains(".") ? key3.LastIndexOf('.') : 0);
        string key4 = key3.Substring(0, key3.Length - num4);
        PartContainer partContainer2 = this.m_doc.DocxPackage.FindPartContainer("word/embeddings/");
        if (partContainer2 != null && partContainer2.XmlParts.ContainsKey(key3))
          chart.DocxProps.Add(key4, partContainer2.XmlParts[key3].DataStream);
        if (key2 == attribute2)
          chart.InternalDataPath = key3.EndsWith(".xltx") ? key3 : key4;
      }
      else if (object.Equals(chartRelation.Key, (object) "http://schemas.microsoft.com/office/2011/relationships/chartColorStyle"))
      {
        if (partContainer1 != null && partContainer1.XmlParts.ContainsKey(str2))
          chart.DocxProps.Add(str3 + "/chartColorStyle", partContainer1.XmlParts[str2].DataStream);
      }
      else if (object.Equals(chartRelation.Key, (object) "http://schemas.microsoft.com/office/2011/relationships/chartStyle"))
      {
        if (partContainer1 != null && partContainer1.XmlParts.ContainsKey(str2))
          chart.DocxProps.Add(str3 + "/chartStyle", partContainer1.XmlParts[str2].DataStream);
      }
      else if (object.Equals(chartRelation.Key, (object) "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes"))
      {
        int num5 = str2.Contains("/") ? str2.LastIndexOf('/') : 0;
        string key5 = str2.Substring(num5 + 1, str2.Length - num5 - 1);
        int num6 = key5.Length - (key5.Contains(".") ? key5.LastIndexOf('.') : 0);
        string str4 = key5.Substring(0, key5.Length - num6);
        PartContainer partContainer3 = this.m_doc.DocxPackage.FindPartContainer("word/drawings/");
        if (partContainer3 != null && partContainer3.XmlParts.ContainsKey(key5))
        {
          chart.DocxProps.Add(str4 + "/chartUserShapes", partContainer3.XmlParts[key5].DataStream);
          if (partContainer3.Relations.Count > 0 && partContainer3.Relations.ContainsKey($"word/drawings/_rels/{key5}.rels"))
            chart.DocxProps.Add(str4 + "/relation", partContainer3.Relations[$"word/drawings/_rels/{key5}.rels"].DataStream);
        }
        if (key2 == str1)
          chart.UserShapes = str4;
      }
      else if (object.Equals(chartRelation.Key, (object) "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject") && this.IsExcelSheet(str2) && this.IsExternalHyperlink.ContainsKey(key2) && this.IsExternalHyperlink[key2])
      {
        chart.ExternalDataPath = str2;
        chart.IsExternalRelation = true;
      }
      else if (object.Equals(chartRelation.Key, (object) "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"))
      {
        int num7 = str2.Contains("/") ? str2.LastIndexOf('/') : 0;
        string key6 = str2.Substring(num7 + 1, str2.Length - num7 - 1);
        int num8 = key6.Length - (key6.Contains(".") ? key6.LastIndexOf('.') : 0);
        key6.Substring(0, key6.Length - num8);
        PartContainer partContainer4 = this.m_doc.DocxPackage.FindPartContainer("word/media/");
        if (partContainer4 != null && partContainer4.XmlParts.ContainsKey(key6))
          officeChart.RelationPreservedStreamCollection.Add(key2, partContainer4.XmlParts[key6].DataStream);
      }
    }
    XmlReader reader2 = UtilityMethods.CreateReader(partContainer1.XmlParts[key1].DataStream);
    RelationCollection relations = new RelationCollection();
    foreach (KeyValuePair<string, DictionaryEntry> chartRelation in this.ChartRelations)
    {
      DictionaryEntry dictionaryEntry = chartRelation.Value;
      Relation relation = new Relation(dictionaryEntry.Value.ToString(), dictionaryEntry.Key.ToString());
      relations[chartRelation.Key] = relation;
    }
    if (!string.IsNullOrEmpty(chart.InternalDataPath) && chart.DocxProps.ContainsKey(chart.InternalDataPath))
      chart.Workbook.DataHolder.ParseDocument(chart.DocxProps[chart.InternalDataPath]);
    else
      officeChart.HasExternalWorkbook = true;
    this.ParseChartWorkbookThemes(chart.Workbook);
    double appVersion = string.IsNullOrEmpty(this.m_appVersion) ? 16.0 : Convert.ToDouble(this.m_appVersion, (IFormatProvider) CultureInfo.InvariantCulture);
    chartParser.ParseChart(reader2, chart.OfficeChart as ChartImpl, relations, appVersion);
    this.ChartRelations.Clear();
    string[] array = new string[officeChart.RelationPreservedStreamCollection.Keys.Count];
    officeChart.RelationPreservedStreamCollection.Keys.CopyTo(array, 0);
    for (int index = 0; index < array.Length; ++index)
    {
      if (array[index].StartsWith("rId") && officeChart.RelationPreservedStreamCollection.ContainsKey(array[index]))
        officeChart.RelationPreservedStreamCollection.Remove(array[index]);
    }
  }

  private bool IsExcelSheet(string relation)
  {
    string extension = this.GetExtension(relation);
    return string.Equals(extension, ".xlsx") || string.Equals(extension, ".xlsm");
  }

  private string GetExtension(string path)
  {
    if (string.IsNullOrEmpty(path))
      return string.Empty;
    return !path.Contains(".") ? path : path.Substring(path.LastIndexOf("."));
  }

  private void ParseChartWorkbookThemes(WorkbookImpl workBook)
  {
    workBook.DataHolder.Parser.m_dicThemeColors = new Dictionary<string, Color>(this.m_doc.Themes.SchemeColor.Count);
    foreach (KeyValuePair<string, Color> keyValuePair in this.m_doc.Themes.SchemeColor)
      workBook.DataHolder.Parser.m_dicThemeColors.Add(keyValuePair.Key, keyValuePair.Value);
    string name = "windowText";
    string s = "44546A";
    if (!workBook.DataHolder.Parser.m_dicThemeColors.ContainsKey("tx1"))
      workBook.DataHolder.Parser.m_dicThemeColors.Add("tx1", Color.FromName(name));
    if (!workBook.DataHolder.Parser.m_dicThemeColors.ContainsKey("tx2"))
      workBook.DataHolder.Parser.m_dicThemeColors.Add("tx2", Color.FromArgb(int.Parse(s, NumberStyles.HexNumber)));
    if (workBook.MajorFonts != null)
      workBook.MajorFonts.Clear();
    else
      workBook.MajorFonts = new Dictionary<string, FontImpl>();
    if (workBook.MinorFonts != null)
      workBook.MinorFonts.Clear();
    else
      workBook.MinorFonts = new Dictionary<string, FontImpl>();
    string[] strArray = new string[3]{ "latin", "ea", "cs" };
    for (int index = 0; index < strArray.Length; ++index)
    {
      switch (strArray[index])
      {
        case "latin":
          FontImpl font1 = workBook.CreateFont((IOfficeFont) null, false) as FontImpl;
          font1.Size = 11.0;
          font1.FontName = this.m_majorLatinFontName;
          workBook.MajorFonts.Add(strArray[index], font1);
          FontImpl font2 = workBook.CreateFont((IOfficeFont) null, false) as FontImpl;
          font2.Size = 11.0;
          font2.FontName = this.m_minorLatinFontName;
          workBook.MinorFonts.Add(strArray[index], font2);
          break;
        case "ea":
          FontImpl font3 = workBook.CreateFont((IOfficeFont) null, false) as FontImpl;
          font3.Size = 11.0;
          font3.FontName = this.m_majorEaFontName;
          workBook.MajorFonts.Add(strArray[index], font3);
          FontImpl font4 = workBook.CreateFont((IOfficeFont) null, false) as FontImpl;
          font4.Size = 11.0;
          font4.FontName = this.m_minorEaFontName;
          workBook.MinorFonts.Add(strArray[index], font4);
          break;
        case "cs":
          FontImpl font5 = workBook.CreateFont((IOfficeFont) null, false) as FontImpl;
          font5.Size = 11.0;
          font5.FontName = this.m_minorCsFontName;
          workBook.MajorFonts.Add(strArray[index], font5);
          FontImpl font6 = workBook.CreateFont((IOfficeFont) null, false) as FontImpl;
          font6.Size = 11.0;
          font6.FontName = this.m_minorCsFontName;
          workBook.MinorFonts.Add(strArray[index], font6);
          break;
      }
    }
  }

  private void SetCategortyRange(string categoryRange, WorksheetImpl chartSheet, ChartImpl chart)
  {
    List<string> stringList = new List<string>();
    if (categoryRange.Contains(","))
    {
      string[] strArray = categoryRange.Split(',');
      for (int index = 0; index < strArray.Length; ++index)
        stringList.Add(categoryRange.Split(',')[index]);
    }
    else
      stringList.Add(categoryRange);
    string[] array = stringList.ToArray();
    if (array == null || array.Length <= 0)
      return;
    int index1 = 0;
    int num = 0;
    for (; index1 < array.Length; ++index1)
    {
      foreach (IRange range in (IEnumerable) chartSheet[array[index1].Split('!')[1]])
      {
        if (chart.CategoryLabelValues == null)
        {
          if ((chart.Series[0] as ChartSerieImpl).EnteredDirectlyCategoryLabels != null)
          {
            if (num < (chart.Series[0] as ChartSerieImpl).EnteredDirectlyCategoryLabels.Length)
              chartSheet[range.AddressLocal].Value2 = (chart.Series[0] as ChartSerieImpl).EnteredDirectlyCategoryLabels[num++];
            else
              break;
          }
          else
            break;
        }
        else if (num < chart.CategoryLabelValues.Length)
          chartSheet[range.AddressLocal].Value2 = chart.CategoryLabelValues[num++];
        else
          break;
      }
    }
  }

  private void ParseGraphicData(XmlReader reader, Shape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "graphicData")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool isToApplyFarEast = false;
    shape.LineFormat = new LineFormat((Syncfusion.DocIO.DLS.ShapeBase) shape);
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "graphicData")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "wsp":
            string attribute1 = reader.GetAttribute("normalEastAsianFlow");
            if (!string.IsNullOrEmpty(attribute1) && !isToApplyFarEast)
            {
              shape.TextFrame.TextDirection = this.GetBoolValue(attribute1) ? Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast : Syncfusion.DocIO.DLS.TextDirection.Horizontal;
              isToApplyFarEast = shape.TextFrame.TextDirection == Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast;
              break;
            }
            break;
          case "xfrm":
            string attribute2 = reader.GetAttribute("flipH");
            if (!string.IsNullOrEmpty(attribute2))
              shape.FlipHorizontal = attribute2 == "1" || attribute2 == "true";
            string attribute3 = reader.GetAttribute("flipV");
            if (!string.IsNullOrEmpty(attribute3))
              shape.FlipVertical = attribute3 == "1" || attribute3 == "true";
            string attribute4 = reader.GetAttribute("rot");
            if (!string.IsNullOrEmpty(attribute4))
            {
              shape.Rotation = this.GetNumericValue(attribute4) / 60000f;
              break;
            }
            break;
          case "prstGeom":
            string attribute5 = reader.GetAttribute("prst");
            if (!string.IsNullOrEmpty(attribute5) && attribute5.Length > 0)
            {
              Syncfusion.DocIO.DLS.AutoShapeType autoShapeType = this.AutoShapeHelper.GetAutoShapeType(this.AutoShapeHelper.GetAutoShapeConstant(attribute5));
              shape.AutoShapeType = autoShapeType;
              break;
            }
            break;
          case "avLst":
            this.ParseShapeAdjustValues(reader, shape);
            break;
          case "custGeom":
            if (!this.IsWord2003ML)
            {
              shape.AutoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Unknown;
              this.ParseCustomGeometry(reader, (ShapeCommon) shape);
              break;
            }
            break;
          case "ln":
            shape.IsLineStyleInline = true;
            this.ParseLineFormat(reader, shape);
            break;
          case "pattFill":
            shape.IsFillStyleInline = true;
            shape.FillFormat.Fill = true;
            shape.FillFormat.IsDefaultFill = false;
            shape.FillFormat.FillType = FillType.FillPatterned;
            string attribute6 = reader.GetAttribute("prst");
            if (!string.IsNullOrEmpty(attribute6))
              shape.FillFormat.Pattern = this.GetPatternType(attribute6);
            this.ParsePatternFill(reader, shape.FillFormat);
            break;
          case "gradFill":
            shape.IsFillStyleInline = true;
            shape.FillFormat.Fill = true;
            shape.FillFormat.IsDefaultFill = false;
            shape.FillFormat.FillType = FillType.FillGradient;
            this.ParseGradientFill(reader, shape.FillFormat.GradientFill);
            break;
          case "blipFill":
            shape.IsFillStyleInline = true;
            shape.FillFormat.Fill = true;
            shape.FillFormat.IsDefaultFill = false;
            shape.FillFormat.FillType = FillType.FillPicture;
            this.ParseBlipFill(reader, shape.FillFormat);
            break;
          case "solidFill":
            shape.IsFillStyleInline = true;
            shape.FillFormat.Fill = true;
            shape.FillFormat.IsDefaultFill = false;
            shape.FillFormat.FillType = FillType.FillSolid;
            uint maxValue = uint.MaxValue;
            Color color = this.ParseColor(reader, "solidFill", ref maxValue, reader.LocalName, false);
            shape.FillFormat.Color = color;
            if (maxValue != uint.MaxValue)
            {
              shape.FillFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
              break;
            }
            break;
          case "noFill":
            shape.IsFillStyleInline = true;
            shape.FillFormat.Fill = false;
            shape.FillFormat.IsDefaultFill = false;
            break;
          case "effectLst":
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              reader.Read();
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                shape.IsEffectStyleInline = true;
                this.ParseEffectList(reader, shape, localName2);
                break;
              }
              break;
            }
            break;
          case "scene3d":
            EffectFormat effectFormat1 = new EffectFormat(shape);
            shape.IsScenePropertiesInline = true;
            effectFormat1.IsSceneProperties = true;
            EffectFormat sceneProperties = this.ParseSceneProperties(reader, effectFormat1);
            if (sceneProperties != null)
            {
              shape.EffectList.Add(sceneProperties);
              break;
            }
            break;
          case "sp3d":
            EffectFormat effectFormat2 = new EffectFormat(shape);
            shape.IsShapePropertiesInline = true;
            effectFormat2.IsShapeProperties = true;
            if (reader.HasAttributes)
            {
              string attribute7 = reader.GetAttribute("contourW");
              if (!string.IsNullOrEmpty(attribute7))
                effectFormat2.ThreeDFormat.ContourWidth = this.GetPropertyValue(attribute7, "contourW");
              string attribute8 = reader.GetAttribute("extrusionH");
              if (!string.IsNullOrEmpty(attribute8))
                effectFormat2.ThreeDFormat.ExtrusionHeight = this.GetPropertyValue(attribute8, "extrusionH");
              string attribute9 = reader.GetAttribute("z");
              if (!string.IsNullOrEmpty(attribute9))
                effectFormat2.ThreeDFormat.DistanceFromGround = this.GetPropertyValue(attribute9, "z");
              string attribute10 = reader.GetAttribute("prstMaterial");
              if (!string.IsNullOrEmpty(attribute10) && attribute10.Length > 2)
                effectFormat2.ThreeDFormat.PresetMaterialType = System.Enum.IsDefined(typeof (PresetMaterialType), (object) (char.ToUpper(attribute10[0]).ToString() + attribute10.Substring(1))) ? (PresetMaterialType) System.Enum.Parse(typeof (PresetMaterialType), attribute10, true) : PresetMaterialType.None;
            }
            EffectFormat shapeProperties = this.ParseShapeProperties(reader, effectFormat2);
            if (shapeProperties != null)
            {
              shape.EffectList.Add(shapeProperties);
              break;
            }
            break;
          case "style":
            MemoryStream memoryStream = new MemoryStream();
            MemoryStream stream1 = this.ReadSingleNodeIntoStream(reader);
            if (this.m_doc.DocHasThemes)
              this.ParseStyleItems(stream1, shape);
            shape.DocxProps.Add("style", (Stream) stream1);
            flag = true;
            break;
          case "bodyPr":
            if ((!shape.IsLineStyleInline || shape.LineFormat.LineFormatType == ~(LineFormatType.None | LineFormatType.Solid)) && !shape.DocxProps.ContainsKey("style"))
              shape.LineFormat.Line = false;
            if (reader.AttributeCount != 0)
            {
              string attribute11 = reader.GetAttribute("vert");
              shape.TextFrame.TextDirection = this.GetTextDirection(attribute11, isToApplyFarEast);
              string attribute12 = reader.GetAttribute("anchor");
              shape.TextFrame.TextVerticalAlignment = this.GetTextVertAlign(attribute12);
              string attribute13 = reader.GetAttribute("lIns");
              if (!string.IsNullOrEmpty(attribute13))
                shape.TextFrame.InternalMargin.Left = this.GetShapeInternalMargin(attribute13);
              string attribute14 = reader.GetAttribute("tIns");
              if (!string.IsNullOrEmpty(attribute14))
                shape.TextFrame.InternalMargin.Top = this.GetShapeInternalMargin(attribute14);
              string attribute15 = reader.GetAttribute("rIns");
              if (!string.IsNullOrEmpty(attribute15))
                shape.TextFrame.InternalMargin.Right = this.GetShapeInternalMargin(attribute15);
              string attribute16 = reader.GetAttribute("bIns");
              if (!string.IsNullOrEmpty(attribute16))
                shape.TextFrame.InternalMargin.Bottom = this.GetShapeInternalMargin(attribute16);
              if (this.GetBoolValue(reader.GetAttribute("fromWordArt")))
                this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 31 /*0x1F*/);
              if (reader.GetAttribute("wrap") == "none")
                shape.TextFrame.NoWrap = true;
              string attribute17 = reader.GetAttribute("upright");
              if (!string.IsNullOrEmpty(attribute17))
                shape.TextFrame.Upright = attribute17 == "1" || attribute17 == "true";
              MemoryStream stream2 = this.ReadSingleNodeIntoStream(reader);
              shape.DocxProps.Add("BodyPr", (Stream) stream2);
              this.ParseBodyProperties(stream2, shape);
              flag = true;
              break;
            }
            break;
          case "txbx":
            reader.Read();
            this.SkipWhitespaces(reader);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 13);
            WTextBox textbox = new WTextBox((IWordDocument) this.m_doc);
            RevisionType trackChangeType = this.m_trackChangeType;
            Stack<Revision> collection1 = new Stack<Revision>((IEnumerable<Revision>) this.m_trackchangeRevisionDetails);
            this.m_trackchangeRevisionDetails.Clear();
            Stack<RevisionType> collection2 = new Stack<RevisionType>((IEnumerable<RevisionType>) this.m_trackchangeStack);
            this.m_trackchangeStack.Clear();
            this.m_trackChangeType = RevisionType.None;
            this.m_currentRunFormat = (WCharacterFormat) null;
            this.ParseTextboxContent(reader, textbox);
            shape.TextBody = textbox.TextBoxBody;
            shape.TextBody.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
            this.m_trackChangeType = trackChangeType;
            this.m_trackchangeRevisionDetails = new Stack<Revision>((IEnumerable<Revision>) collection1);
            collection1.Clear();
            this.m_trackchangeStack = new Stack<RevisionType>((IEnumerable<RevisionType>) collection2);
            collection2.Clear();
            reader.Read();
            break;
          case "extLst":
            if (shape != null)
            {
              if (!shape.DocxProps.ContainsKey("extLst"))
                shape.DocxProps.Add("extLst", (Stream) this.ReadSingleNodeIntoStream(reader));
              else
                this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
          case "grpFill":
            if (shape != null)
            {
              shape.DocxProps.Add("grpFill", (Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseGraphicData(XmlReader reader, GroupShape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "graphicData")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool isToApplyFarEast = false;
    shape.LineFormat = new LineFormat((Syncfusion.DocIO.DLS.ShapeBase) shape);
    this.SkipWhitespaces(reader);
    ChildShape childShape = (ChildShape) null;
    while (reader.LocalName != "graphicData")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "grpSpPr":
            this.ParseGroupShapeProperties(reader, shape);
            break;
          case "wsp":
            childShape = new ChildShape((IWordDocument) this.m_doc);
            childShape.LineFormat = new LineFormat(childShape);
            string attribute1 = reader.GetAttribute("normalEastAsianFlow");
            if (!string.IsNullOrEmpty(attribute1) && !isToApplyFarEast)
            {
              childShape.TextFrame.TextDirection = this.GetBoolValue(attribute1) ? Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast : Syncfusion.DocIO.DLS.TextDirection.Horizontal;
              isToApplyFarEast = childShape.TextFrame.TextDirection == Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast;
              break;
            }
            break;
          case "graphicFrame":
            this.ParseGraphicFrame(this.ReadSingleNodeIntoStream(reader), shape, (ChildGroupShape) null);
            flag = true;
            break;
          case "cNvPr":
            this.ParseGraphicFrameNonVisualProperties(reader, childShape);
            shape.Add((ParagraphItem) childShape);
            childShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
            break;
          case "xfrm":
            this.Parse2DTransform(reader, childShape);
            break;
          case "ext":
            this.ParseExtent(reader, childShape);
            break;
          case "off":
            this.ParseOffset(reader, childShape);
            break;
          case "prstGeom":
            string attribute2 = reader.GetAttribute("prst");
            if (!string.IsNullOrEmpty(attribute2) && attribute2.Length > 0)
            {
              Syncfusion.DocIO.DLS.AutoShapeType autoShapeType = this.AutoShapeHelper.GetAutoShapeType(this.AutoShapeHelper.GetAutoShapeConstant(attribute2));
              childShape.AutoShapeType = autoShapeType;
              childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.AutoShape;
              break;
            }
            break;
          case "avLst":
            this.ParseShapeAdjustValues(reader, childShape);
            break;
          case "custGeom":
            if (!this.IsWord2003ML)
            {
              childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.AutoShape;
              childShape.AutoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Unknown;
              this.ParseCustomGeometry(reader, (ShapeCommon) childShape);
              break;
            }
            break;
          case "ln":
            childShape.IsLineStyleInline = true;
            childShape.LineFormat = new LineFormat(childShape);
            this.ParseLineFormat(reader, childShape);
            break;
          case "pattFill":
            childShape.IsFillStyleInline = true;
            childShape.FillFormat.Fill = true;
            childShape.FillFormat.IsDefaultFill = false;
            childShape.FillFormat.FillType = FillType.FillPatterned;
            string attribute3 = reader.GetAttribute("prst");
            if (!string.IsNullOrEmpty(attribute3))
              childShape.FillFormat.Pattern = this.GetPatternType(attribute3);
            this.ParsePatternFill(reader, childShape.FillFormat);
            break;
          case "gradFill":
            childShape.IsFillStyleInline = true;
            childShape.FillFormat.Fill = true;
            childShape.FillFormat.IsDefaultFill = false;
            childShape.FillFormat.FillType = FillType.FillGradient;
            this.ParseGradientFill(reader, childShape.FillFormat.GradientFill);
            break;
          case "blipFill":
            childShape.IsFillStyleInline = true;
            childShape.FillFormat.Fill = true;
            childShape.FillFormat.IsDefaultFill = false;
            childShape.FillFormat.FillType = FillType.FillPicture;
            this.ParseBlipFill(reader, childShape.FillFormat);
            break;
          case "solidFill":
            childShape.IsFillStyleInline = true;
            childShape.FillFormat.Fill = true;
            childShape.FillFormat.IsDefaultFill = false;
            childShape.FillFormat.FillType = FillType.FillSolid;
            uint maxValue = uint.MaxValue;
            Color color = this.ParseColor(reader, "solidFill", ref maxValue, reader.LocalName, false);
            childShape.FillFormat.Color = color;
            if (maxValue != uint.MaxValue)
            {
              childShape.FillFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
              break;
            }
            break;
          case "noFill":
            childShape.IsFillStyleInline = true;
            childShape.FillFormat.Fill = false;
            childShape.FillFormat.IsDefaultFill = false;
            break;
          case "grpFill":
            if (childShape != null)
            {
              childShape.DocxProps.Add("grpFill", (Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              break;
            }
            break;
          case "effectLst":
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              reader.Read();
              if ((!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement) && reader.NodeType == XmlNodeType.Element)
              {
                childShape.IsEffectStyleInline = true;
                this.ParseEffectList(reader, childShape, localName2);
                break;
              }
              break;
            }
            break;
          case "scene3d":
            EffectFormat effectFormat1 = new EffectFormat(childShape);
            childShape.IsScenePropertiesInline = true;
            effectFormat1.IsSceneProperties = true;
            childShape.EffectList.Add(this.ParseSceneProperties(reader, effectFormat1));
            break;
          case "sp3d":
            EffectFormat effectFormat2 = new EffectFormat(childShape);
            childShape.IsShapePropertiesInline = true;
            effectFormat2.IsShapeProperties = true;
            if (reader.HasAttributes)
            {
              string attribute4 = reader.GetAttribute("contourW");
              if (!string.IsNullOrEmpty(attribute4))
                effectFormat2.ThreeDFormat.ContourWidth = this.GetPropertyValue(attribute4, "contourW");
              string attribute5 = reader.GetAttribute("extrusionH");
              if (!string.IsNullOrEmpty(attribute5))
                effectFormat2.ThreeDFormat.ExtrusionHeight = this.GetPropertyValue(attribute5, "extrusionH");
              string attribute6 = reader.GetAttribute("z");
              if (!string.IsNullOrEmpty(attribute6))
                effectFormat2.ThreeDFormat.DistanceFromGround = this.GetPropertyValue(attribute6, "z");
              string attribute7 = reader.GetAttribute("prstMaterial");
              if (!string.IsNullOrEmpty(attribute7) && attribute7.Length > 2)
                effectFormat2.ThreeDFormat.PresetMaterialType = this.ParsePresetMaterialType(attribute7);
            }
            EffectFormat shapeProperties = this.ParseShapeProperties(reader, effectFormat2);
            if (shapeProperties != null)
            {
              childShape.EffectList.Add(shapeProperties);
              break;
            }
            break;
          case "style":
            MemoryStream memoryStream1 = new MemoryStream();
            MemoryStream stream = this.ReadSingleNodeIntoStream(reader);
            if (this.m_doc.DocHasThemes && childShape != null)
            {
              this.ParseStyleItems(stream, childShape);
              childShape.DocxProps.Add("style", (Stream) stream);
            }
            flag = true;
            break;
          case "bodyPr":
            if (childShape != null && !childShape.IsLineStyleInline && !childShape.DocxProps.ContainsKey("style"))
              childShape.LineFormat.Line = false;
            if (reader.AttributeCount != 0)
            {
              string attribute8 = reader.GetAttribute("vert");
              childShape.TextFrame.TextDirection = this.GetTextDirection(attribute8, isToApplyFarEast);
              string attribute9 = reader.GetAttribute("anchor");
              childShape.TextFrame.TextVerticalAlignment = this.GetTextVertAlign(attribute9);
              string attribute10 = reader.GetAttribute("lIns");
              if (!string.IsNullOrEmpty(attribute10))
                childShape.TextFrame.InternalMargin.Left = this.GetShapeInternalMargin(attribute10);
              string attribute11 = reader.GetAttribute("tIns");
              if (!string.IsNullOrEmpty(attribute11))
                childShape.TextFrame.InternalMargin.Top = this.GetShapeInternalMargin(attribute11);
              string attribute12 = reader.GetAttribute("rIns");
              if (!string.IsNullOrEmpty(attribute12))
                childShape.TextFrame.InternalMargin.Right = this.GetShapeInternalMargin(attribute12);
              string attribute13 = reader.GetAttribute("bIns");
              if (!string.IsNullOrEmpty(attribute13))
                childShape.TextFrame.InternalMargin.Bottom = this.GetShapeInternalMargin(attribute13);
              if (reader.GetAttribute("wrap") == "none")
                childShape.TextFrame.NoWrap = true;
              string attribute14 = reader.GetAttribute("upright");
              if (!string.IsNullOrEmpty(attribute14))
                childShape.TextFrame.Upright = attribute14 == "1" || attribute14 == "true";
              MemoryStream memoryStream2 = this.ReadSingleNodeIntoStream(reader);
              childShape.DocxProps.Add("BodyPr", (Stream) memoryStream2);
              flag = true;
              break;
            }
            break;
          case "txbx":
            reader.Read();
            this.SkipWhitespaces(reader);
            WTextBox textbox = new WTextBox((IWordDocument) this.m_doc);
            this.m_currentRunFormat = (WCharacterFormat) null;
            RevisionType trackChangeType = this.m_trackChangeType;
            this.m_trackChangeType = RevisionType.None;
            Stack<Revision> collection1 = new Stack<Revision>((IEnumerable<Revision>) this.m_trackchangeRevisionDetails);
            this.m_trackchangeRevisionDetails.Clear();
            Stack<RevisionType> collection2 = new Stack<RevisionType>((IEnumerable<RevisionType>) this.m_trackchangeStack);
            this.m_trackchangeStack.Clear();
            this.ParseTextboxContent(reader, textbox);
            this.m_trackChangeType = trackChangeType;
            this.m_trackchangeRevisionDetails = new Stack<Revision>((IEnumerable<Revision>) collection1);
            collection1.Clear();
            this.m_trackchangeStack = new Stack<RevisionType>((IEnumerable<RevisionType>) collection2);
            collection2.Clear();
            childShape.TextBody = textbox.TextBoxBody;
            childShape.TextBody.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) childShape);
            childShape.ElementType = childShape.AutoShapeType != Syncfusion.DocIO.DLS.AutoShapeType.Rectangle ? Syncfusion.DocIO.DLS.EntityType.AutoShape : Syncfusion.DocIO.DLS.EntityType.TextBox;
            reader.Read();
            break;
          case "grpSp":
            ChildGroupShape childGroupShape = new ChildGroupShape((IWordDocument) this.m_doc);
            childGroupShape.ElementType = Syncfusion.DocIO.DLS.EntityType.ChildGroupShape;
            childGroupShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
            this.ParseNestedGroup(reader, childGroupShape);
            shape.Add((ParagraphItem) childGroupShape);
            flag = true;
            break;
          case "extLst":
            if (childShape != null)
            {
              if (!childShape.DocxProps.ContainsKey("extLst"))
                childShape.DocxProps.Add("extLst", (Stream) this.ReadSingleNodeIntoStream(reader));
              else
                this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
          case "pic":
            WPicture wpicture = new WPicture((IWordDocument) this.m_doc);
            MemoryStream data = this.ReadSingleNodeIntoStream(reader);
            flag = true;
            XmlReader reader1 = UtilityMethods.CreateReader((Stream) data);
            reader1.ReadToFollowing("blip", "http://schemas.openxmlformats.org/drawingml/2006/main");
            string attribute15 = reader1.GetAttribute("embed", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            string attribute16 = reader1.GetAttribute("link", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            bool isHeaderFooter = this.m_currentFile.StartsWith("header") || this.m_currentFile.StartsWith("footer");
            if (!string.IsNullOrEmpty(attribute15))
              this.LoadImage(wpicture, attribute15, isHeaderFooter, false);
            if (!string.IsNullOrEmpty(attribute16))
            {
              bool isImageRelation = true;
              wpicture.ExternalLink = this.GetImageName(attribute16, isHeaderFooter, false, ref isImageRelation);
              if (!string.IsNullOrEmpty(attribute15))
                wpicture.HasImageRecordReference = true;
              Image image = this.DownloadImage(wpicture.ExternalLink);
              if (image != null)
                wpicture.LoadImage(image);
            }
            if (wpicture.ImageRecord != null || wpicture.ImageBytes != null)
            {
              reader1.Close();
              this.ParseGroupShapePictureData(UtilityMethods.CreateReader((Stream) data), wpicture);
              wpicture.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
              shape.Add((ParagraphItem) wpicture);
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private PresetMaterialType ParsePresetMaterialType(string value)
  {
    switch (value)
    {
      case "dkEdge":
        return PresetMaterialType.DarkEdge;
      case "softmetal":
        return PresetMaterialType.SoftMetal;
      default:
        return !System.Enum.IsDefined(typeof (PresetMaterialType), (object) (char.ToUpper(value[0]).ToString() + value.Substring(1))) ? PresetMaterialType.None : (PresetMaterialType) System.Enum.Parse(typeof (PresetMaterialType), value, true);
    }
  }

  private void ParseGraphicFrame(
    MemoryStream graphicStream,
    GroupShape groupShape,
    ChildGroupShape childGroupShape)
  {
    XmlReader reader1 = UtilityMethods.CreateReader((Stream) graphicStream);
    while (reader1.NodeType != XmlNodeType.Element)
      reader1.Read();
    if (reader1.LocalName != "graphicFrame")
      throw new XmlException("Unexpected xml tag " + reader1.LocalName);
    if (reader1.IsEmptyElement)
      return;
    string localName = reader1.LocalName;
    reader1.Read();
    if (localName == reader1.LocalName && reader1.NodeType == XmlNodeType.EndElement)
      return;
    DocxParser.GraphicDataContentType graphicDataContentType = this.CheckPicture(reader1);
    graphicStream.Position = 0L;
    ChildShape childShape = new ChildShape((IWordDocument) this.m_doc);
    if (groupShape != null)
    {
      groupShape.Add((ParagraphItem) childShape);
      childShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) groupShape);
    }
    else
    {
      childGroupShape.Add((ParagraphItem) childShape);
      childShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) childGroupShape);
    }
    switch (graphicDataContentType)
    {
      case DocxParser.GraphicDataContentType.None:
        childShape.XmlParagraphItem = this.ParseXmlParaItem((Stream) graphicStream);
        childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.XmlParaItem;
        break;
      case DocxParser.GraphicDataContentType.Chart:
        graphicStream.Position = 0L;
        XmlReader reader2 = UtilityMethods.CreateReader((Stream) graphicStream);
        reader2.Read();
        childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.Chart;
        while (reader2.LocalName != "graphicFrame")
        {
          bool flag = false;
          if (reader2.NodeType == XmlNodeType.Element)
          {
            switch (reader2.LocalName)
            {
              case "graphic":
                reader2.Read();
                this.ParseGraphicData(reader2, childShape.Chart, (MemoryStream) null);
                reader2.Read();
                if (reader2.LocalName != "graphicData")
                {
                  reader2.Read();
                  break;
                }
                break;
              case "cNvPr":
                this.ParseGraphicFrameNonVisualProperties(reader2, childShape);
                break;
              case "xfrm":
                this.Parse2DTransform(reader2, childShape);
                break;
              case "ext":
                this.ParseExtent(reader2, childShape);
                break;
              case "off":
                this.ParseOffset(reader2, childShape);
                break;
              case "extLst":
                if (childShape != null)
                {
                  if (!childShape.DocxProps.ContainsKey("extLst"))
                    childShape.DocxProps.Add("extLst", (Stream) this.ReadSingleNodeIntoStream(reader2));
                  else
                    this.ReadSingleNodeIntoStream(reader2);
                  flag = true;
                  break;
                }
                break;
            }
            if (!flag)
              reader2.Read();
          }
          else
            reader2.Read();
          this.SkipWhitespaces(reader2);
        }
        break;
    }
  }

  private void ParseGraphicFrameNonVisualProperties(XmlReader reader, ChildShape childShape)
  {
    string attribute1 = reader.GetAttribute("id");
    if (!string.IsNullOrEmpty(attribute1))
      childShape.ShapeID = Convert.ToInt64(attribute1.ToString());
    string attribute2 = reader.GetAttribute("name");
    if (!string.IsNullOrEmpty(attribute2))
      childShape.Name = attribute2.ToString();
    string attribute3 = reader.GetAttribute("descr");
    if (!string.IsNullOrEmpty(attribute3))
      childShape.AlternativeText = attribute3.ToString();
    string attribute4 = reader.GetAttribute("title");
    if (!string.IsNullOrEmpty(attribute4))
      childShape.Title = attribute4.ToString();
    string attribute5 = reader.GetAttribute("hidden");
    if (!string.IsNullOrEmpty(attribute5))
      childShape.Visible = !this.GetBoolValue(attribute5);
    if (childShape.ElementType != Syncfusion.DocIO.DLS.EntityType.WordDocument)
      return;
    childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.AutoShape;
  }

  private void Parse2DTransform(XmlReader reader, ChildShape childShape)
  {
    string attribute1 = reader.GetAttribute("flipH");
    if (!string.IsNullOrEmpty(attribute1))
      childShape.FlipHorizantal = attribute1 == "1" || attribute1 == "true";
    string attribute2 = reader.GetAttribute("flipV");
    if (!string.IsNullOrEmpty(attribute2))
      childShape.FlipVertical = attribute2 == "1" || attribute2 == "true";
    string attribute3 = reader.GetAttribute("rot");
    if (string.IsNullOrEmpty(attribute3))
      return;
    childShape.Rotation = this.GetNumericValue(attribute3) / 60000f;
  }

  private void ParseExtent(XmlReader reader, ChildShape childShape)
  {
    string attribute1 = reader.GetAttribute("cx");
    if (!string.IsNullOrEmpty(attribute1))
      childShape.Width = this.GetPropertyValue(attribute1, "cx");
    string attribute2 = reader.GetAttribute("cy");
    if (string.IsNullOrEmpty(attribute2))
      return;
    childShape.Height = this.GetPropertyValue(attribute2, "cy");
  }

  private void ParseOffset(XmlReader reader, ChildShape childShape)
  {
    string attribute1 = reader.GetAttribute("x");
    if (!string.IsNullOrEmpty(attribute1))
      childShape.X = this.GetPropertyValue(attribute1, "x");
    string attribute2 = reader.GetAttribute("y");
    if (string.IsNullOrEmpty(attribute2))
      return;
    childShape.Y = this.GetPropertyValue(attribute2, "y");
  }

  private void ParseNestedGroup(XmlReader reader, ChildGroupShape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "grpSp")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool isToApplyFarEast = false;
    shape.LineFormat = new LineFormat((ChildShape) shape);
    this.SkipWhitespaces(reader);
    ChildShape childShape = (ChildShape) null;
    while (reader.LocalName != "grpSp" || reader.LocalName == "grpSp" && reader.NodeType == XmlNodeType.Element)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        string empty = string.Empty;
        switch (reader.LocalName)
        {
          case "grpSpPr":
            if (childShape == null)
            {
              this.ParseGroupShapeProperties(reader, shape);
              break;
            }
            break;
          case "wsp":
            childShape = new ChildShape((IWordDocument) this.m_doc);
            childShape.LineFormat = new LineFormat(childShape);
            string attribute1 = reader.GetAttribute("normalEastAsianFlow");
            if (!string.IsNullOrEmpty(attribute1) && !isToApplyFarEast)
            {
              childShape.TextFrame.TextDirection = this.GetBoolValue(attribute1) ? Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast : Syncfusion.DocIO.DLS.TextDirection.Horizontal;
              isToApplyFarEast = childShape.TextFrame.TextDirection == Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast;
              break;
            }
            break;
          case "grpSp":
            ChildGroupShape childGroupShape = new ChildGroupShape((IWordDocument) this.m_doc);
            childGroupShape.ElementType = Syncfusion.DocIO.DLS.EntityType.ChildGroupShape;
            childGroupShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
            this.ParseNestedGroup(reader, childGroupShape);
            shape.Add((ParagraphItem) childGroupShape);
            break;
          case "graphicFrame":
            this.ParseGraphicFrame(this.ReadSingleNodeIntoStream(reader), (GroupShape) null, shape);
            flag = true;
            break;
          case "pic":
            WPicture wpicture = new WPicture((IWordDocument) this.m_doc);
            MemoryStream data = this.ReadSingleNodeIntoStream(reader);
            XmlReader reader1 = UtilityMethods.CreateReader((Stream) data);
            reader1.ReadToFollowing("blip", "http://schemas.openxmlformats.org/drawingml/2006/main");
            string attribute2 = reader1.GetAttribute("embed", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            string attribute3 = reader1.GetAttribute("link", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            bool isHeaderFooter = this.m_currentFile.StartsWith("header") || this.m_currentFile.StartsWith("footer");
            if (!string.IsNullOrEmpty(attribute2))
              this.LoadImage(wpicture, attribute2, isHeaderFooter, false);
            if (!string.IsNullOrEmpty(attribute3))
            {
              bool isImageRelation = true;
              wpicture.ExternalLink = this.GetImageName(attribute3, isHeaderFooter, false, ref isImageRelation);
              if (!string.IsNullOrEmpty(attribute2))
                wpicture.HasImageRecordReference = true;
              Image image = this.DownloadImage(wpicture.ExternalLink);
              if (image != null)
                wpicture.LoadImage(image);
            }
            if (wpicture.ImageRecord != null || wpicture.ImageBytes != null)
            {
              reader1.Close();
              this.ParseGroupShapePictureData(UtilityMethods.CreateReader((Stream) data), wpicture);
              wpicture.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
              shape.Add((ParagraphItem) wpicture);
              flag = true;
              break;
            }
            break;
          case "cNvPr":
            if (childShape != null)
            {
              string attribute4 = reader.GetAttribute("id");
              if (!string.IsNullOrEmpty(attribute4))
                childShape.ShapeID = Convert.ToInt64(attribute4.ToString());
              string attribute5 = reader.GetAttribute("name");
              if (!string.IsNullOrEmpty(attribute5))
                childShape.Name = attribute5.ToString();
              shape.Add((ParagraphItem) childShape);
              childShape.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) shape);
              break;
            }
            if (shape != null)
            {
              string attribute6 = reader.GetAttribute("id");
              if (!string.IsNullOrEmpty(attribute6))
                shape.ShapeID = Convert.ToInt64(attribute6.ToString());
              string attribute7 = reader.GetAttribute("name");
              if (!string.IsNullOrEmpty(attribute7))
              {
                shape.Name = attribute7.ToString();
                break;
              }
              break;
            }
            break;
          case "xfrm":
            if (childShape != null)
            {
              string attribute8 = reader.GetAttribute("flipH");
              if (!string.IsNullOrEmpty(attribute8))
                childShape.FlipHorizantal = attribute8 == "1" || attribute8 == "true";
              string attribute9 = reader.GetAttribute("flipV");
              if (!string.IsNullOrEmpty(attribute9))
                childShape.FlipVertical = attribute9 == "1" || attribute9 == "true";
              string attribute10 = reader.GetAttribute("rot");
              if (!string.IsNullOrEmpty(attribute10))
              {
                childShape.Rotation = this.GetNumericValue(attribute10) / 60000f;
                break;
              }
              break;
            }
            break;
          case "ext":
            if (childShape != null)
            {
              string attribute11 = reader.GetAttribute("cx");
              if (!string.IsNullOrEmpty(attribute11))
                childShape.Width = this.GetPropertyValue(attribute11, "cx");
              string attribute12 = reader.GetAttribute("cy");
              if (!string.IsNullOrEmpty(attribute12))
              {
                childShape.Height = this.GetPropertyValue(attribute12, "cy");
                break;
              }
              break;
            }
            break;
          case "off":
            if (childShape != null)
            {
              string attribute13 = reader.GetAttribute("x");
              if (!string.IsNullOrEmpty(attribute13))
                childShape.X = this.GetPropertyValue(attribute13, "x");
              string attribute14 = reader.GetAttribute("y");
              if (!string.IsNullOrEmpty(attribute14))
              {
                childShape.Y = this.GetPropertyValue(attribute14, "y");
                break;
              }
              break;
            }
            break;
          case "prstGeom":
            if (childShape != null)
            {
              string attribute15 = reader.GetAttribute("prst");
              if (!string.IsNullOrEmpty(attribute15) && attribute15.Length > 0)
              {
                Syncfusion.DocIO.DLS.AutoShapeType autoShapeType = this.AutoShapeHelper.GetAutoShapeType(this.AutoShapeHelper.GetAutoShapeConstant(attribute15));
                childShape.AutoShapeType = autoShapeType;
                childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.AutoShape;
                break;
              }
              break;
            }
            break;
          case "avLst":
            if (childShape != null)
            {
              this.ParseShapeAdjustValues(reader, childShape);
              break;
            }
            break;
          case "custGeom":
            if (childShape != null && !this.IsWord2003ML)
            {
              childShape.ElementType = Syncfusion.DocIO.DLS.EntityType.AutoShape;
              childShape.AutoShapeType = Syncfusion.DocIO.DLS.AutoShapeType.Unknown;
              this.ParseCustomGeometry(reader, (ShapeCommon) childShape);
              break;
            }
            break;
          case "ln":
            if (childShape != null)
            {
              childShape.IsLineStyleInline = true;
              this.ParseLineFormat(reader, childShape);
              break;
            }
            break;
          case "pattFill":
            if (childShape != null)
            {
              childShape.IsFillStyleInline = true;
              childShape.FillFormat.Fill = true;
              childShape.FillFormat.IsDefaultFill = false;
              childShape.FillFormat.FillType = FillType.FillPatterned;
              string attribute16 = reader.GetAttribute("prst");
              if (!string.IsNullOrEmpty(attribute16))
                childShape.FillFormat.Pattern = this.GetPatternType(attribute16);
              this.ParsePatternFill(reader, childShape.FillFormat);
              break;
            }
            break;
          case "gradFill":
            if (childShape != null)
            {
              childShape.IsFillStyleInline = true;
              childShape.FillFormat.Fill = true;
              childShape.FillFormat.IsDefaultFill = false;
              childShape.FillFormat.FillType = FillType.FillGradient;
              this.ParseGradientFill(reader, childShape.FillFormat.GradientFill);
              break;
            }
            break;
          case "blipFill":
            if (childShape != null)
            {
              childShape.IsFillStyleInline = true;
              childShape.FillFormat.Fill = true;
              childShape.FillFormat.IsDefaultFill = false;
              childShape.FillFormat.FillType = FillType.FillPicture;
              this.ParseBlipFill(reader, childShape.FillFormat);
              break;
            }
            break;
          case "solidFill":
            if (childShape != null)
            {
              childShape.IsFillStyleInline = true;
              childShape.FillFormat.Fill = true;
              childShape.FillFormat.IsDefaultFill = false;
              childShape.FillFormat.FillType = FillType.FillSolid;
              uint maxValue = uint.MaxValue;
              Color color = this.ParseColor(reader, "solidFill", ref maxValue, reader.LocalName, false);
              childShape.FillFormat.Color = color;
              if (maxValue != uint.MaxValue)
              {
                childShape.FillFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
                break;
              }
              break;
            }
            break;
          case "noFill":
            if (childShape != null)
            {
              childShape.IsFillStyleInline = true;
              childShape.FillFormat.Fill = false;
              childShape.FillFormat.IsDefaultFill = false;
              break;
            }
            break;
          case "effectLst":
            if (childShape != null && !reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              reader.Read();
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                childShape.IsEffectStyleInline = true;
                this.ParseEffectList(reader, childShape, localName2);
                break;
              }
              break;
            }
            break;
          case "scene3d":
            if (childShape != null)
            {
              EffectFormat effectFormat = new EffectFormat(childShape);
              childShape.IsScenePropertiesInline = true;
              effectFormat.IsSceneProperties = true;
              childShape.EffectList.Add(this.ParseSceneProperties(reader, effectFormat));
              break;
            }
            break;
          case "sp3d":
            if (childShape != null)
            {
              EffectFormat effectFormat = new EffectFormat(childShape);
              childShape.IsShapePropertiesInline = true;
              effectFormat.IsShapeProperties = true;
              if (reader.HasAttributes)
              {
                string attribute17 = reader.GetAttribute("contourW");
                if (!string.IsNullOrEmpty(attribute17))
                  effectFormat.ThreeDFormat.ContourWidth = this.GetPropertyValue(attribute17, "contourW");
                string attribute18 = reader.GetAttribute("extrusionH");
                if (!string.IsNullOrEmpty(attribute18))
                  effectFormat.ThreeDFormat.ExtrusionHeight = this.GetPropertyValue(attribute18, "extrusionH");
                string attribute19 = reader.GetAttribute("z");
                if (!string.IsNullOrEmpty(attribute19))
                  effectFormat.ThreeDFormat.DistanceFromGround = this.GetPropertyValue(attribute19, "z");
                string attribute20 = reader.GetAttribute("prstMaterial");
                if (!string.IsNullOrEmpty(attribute20) && attribute20.Length > 2)
                  effectFormat.ThreeDFormat.PresetMaterialType = System.Enum.IsDefined(typeof (PresetMaterialType), (object) (char.ToUpper(attribute20[0]).ToString() + attribute20.Substring(1))) ? (PresetMaterialType) System.Enum.Parse(typeof (PresetMaterialType), attribute20, true) : PresetMaterialType.None;
              }
              EffectFormat shapeProperties = this.ParseShapeProperties(reader, effectFormat);
              if (shapeProperties != null)
              {
                childShape.EffectList.Add(shapeProperties);
                break;
              }
              break;
            }
            break;
          case "style":
            if (childShape != null)
            {
              MemoryStream memoryStream = new MemoryStream();
              MemoryStream stream = this.ReadSingleNodeIntoStream(reader);
              if (this.m_doc.DocHasThemes && childShape != null)
              {
                this.ParseStyleItems(stream, childShape);
                childShape.DocxProps.Add("style", (Stream) stream);
              }
            }
            flag = true;
            break;
          case "bodyPr":
            if (childShape != null)
            {
              if (!childShape.IsLineStyleInline && !childShape.DocxProps.ContainsKey("style"))
                childShape.LineFormat.Line = false;
              if (reader.AttributeCount != 0)
              {
                string attribute21 = reader.GetAttribute("vert");
                childShape.TextFrame.TextDirection = this.GetTextDirection(attribute21, isToApplyFarEast);
                string attribute22 = reader.GetAttribute("anchor");
                childShape.TextFrame.TextVerticalAlignment = this.GetTextVertAlign(attribute22);
                string attribute23 = reader.GetAttribute("lIns");
                if (!string.IsNullOrEmpty(attribute23))
                  childShape.TextFrame.InternalMargin.Left = this.GetShapeInternalMargin(attribute23);
                string attribute24 = reader.GetAttribute("tIns");
                if (!string.IsNullOrEmpty(attribute24))
                  childShape.TextFrame.InternalMargin.Top = this.GetShapeInternalMargin(attribute24);
                string attribute25 = reader.GetAttribute("rIns");
                if (!string.IsNullOrEmpty(attribute25))
                  childShape.TextFrame.InternalMargin.Right = this.GetShapeInternalMargin(attribute25);
                string attribute26 = reader.GetAttribute("bIns");
                if (!string.IsNullOrEmpty(attribute26))
                  childShape.TextFrame.InternalMargin.Bottom = this.GetShapeInternalMargin(attribute26);
                if (reader.GetAttribute("wrap") == "none")
                  childShape.TextFrame.NoWrap = true;
                string attribute27 = reader.GetAttribute("upright");
                if (!string.IsNullOrEmpty(attribute27))
                  childShape.TextFrame.Upright = attribute27 == "1" || attribute27 == "true";
                MemoryStream memoryStream = this.ReadSingleNodeIntoStream(reader);
                childShape.DocxProps.Add("BodyPr", (Stream) memoryStream);
                flag = true;
                break;
              }
              break;
            }
            break;
          case "txbx":
            if (childShape != null)
            {
              reader.Read();
              this.SkipWhitespaces(reader);
              WTextBox textbox = new WTextBox((IWordDocument) this.m_doc);
              this.m_currentRunFormat = (WCharacterFormat) null;
              RevisionType trackChangeType = this.m_trackChangeType;
              this.m_trackChangeType = RevisionType.None;
              Stack<Revision> collection1 = new Stack<Revision>((IEnumerable<Revision>) this.m_trackchangeRevisionDetails);
              this.m_trackchangeRevisionDetails.Clear();
              Stack<RevisionType> collection2 = new Stack<RevisionType>((IEnumerable<RevisionType>) this.m_trackchangeStack);
              this.m_trackchangeStack.Clear();
              this.ParseTextboxContent(reader, textbox);
              this.m_trackChangeType = trackChangeType;
              this.m_trackchangeRevisionDetails = new Stack<Revision>((IEnumerable<Revision>) collection1);
              collection1.Clear();
              this.m_trackchangeStack = new Stack<RevisionType>((IEnumerable<RevisionType>) collection2);
              collection2.Clear();
              childShape.TextBody = textbox.TextBoxBody;
              childShape.TextBody.SetOwner((Syncfusion.DocIO.DLS.OwnerHolder) childShape);
              childShape.ElementType = childShape.AutoShapeType != Syncfusion.DocIO.DLS.AutoShapeType.Rectangle ? Syncfusion.DocIO.DLS.EntityType.AutoShape : Syncfusion.DocIO.DLS.EntityType.TextBox;
              reader.Read();
              break;
            }
            break;
          case "extLst":
            if (childShape != null)
            {
              if (!childShape.DocxProps.ContainsKey("extLst"))
                childShape.DocxProps.Add("extLst", (Stream) this.ReadSingleNodeIntoStream(reader));
              else
                this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
          case "grpFill":
            if (childShape != null)
            {
              childShape.DocxProps.Add("grpFill", (Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private long GenerateShapeID() => this.shapeID++;

  private void ParseGroupShapeProperties(XmlReader reader, ChildGroupShape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "grpSpPr")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "grpSpPr")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        bool flag = false;
        switch (reader.LocalName)
        {
          case "xfrm":
            string attribute1 = reader.GetAttribute("rot");
            if (!string.IsNullOrEmpty(attribute1))
              shape.Rotation = this.GetNumericValue(attribute1) / 60000f;
            string attribute2 = reader.GetAttribute("flipH");
            if (!string.IsNullOrEmpty(attribute2))
              shape.FlipHorizantal = attribute2 == "1" || attribute2 == "true";
            string attribute3 = reader.GetAttribute("flipV");
            if (!string.IsNullOrEmpty(attribute3))
            {
              shape.FlipVertical = attribute3 == "1" || attribute3 == "true";
              break;
            }
            break;
          case "chOff":
            string attribute4 = reader.GetAttribute("x");
            if (!string.IsNullOrEmpty(attribute4))
              shape.X = this.GetPropertyValue(attribute4, "x");
            string attribute5 = reader.GetAttribute("y");
            if (!string.IsNullOrEmpty(attribute5))
            {
              shape.Y = this.GetPropertyValue(attribute5, "y");
              break;
            }
            break;
          case "off":
            string attribute6 = reader.GetAttribute("x");
            if (!string.IsNullOrEmpty(attribute6))
              shape.OffsetXValue = this.GetPropertyValue(attribute6, "x");
            string attribute7 = reader.GetAttribute("y");
            if (!string.IsNullOrEmpty(attribute7))
            {
              shape.OffsetYValue = this.GetPropertyValue(attribute7, "y");
              break;
            }
            break;
          case "ext":
            string attribute8 = reader.GetAttribute("cx");
            if (!string.IsNullOrEmpty(attribute8))
              shape.Width = this.GetPropertyValue(attribute8, "cx");
            string attribute9 = reader.GetAttribute("cy");
            if (!string.IsNullOrEmpty(attribute9))
            {
              shape.Height = this.GetPropertyValue(attribute9, "cy");
              break;
            }
            break;
          case "chExt":
            string attribute10 = reader.GetAttribute("cx");
            if (!string.IsNullOrEmpty(attribute10))
              shape.ExtentXValue = this.GetPropertyValue(attribute10, "x");
            string attribute11 = reader.GetAttribute("cy");
            if (!string.IsNullOrEmpty(attribute11))
            {
              shape.ExtentYValue = this.GetPropertyValue(attribute11, "y");
              break;
            }
            break;
          case "effectLst":
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              reader.Read();
              if ((!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement) && reader.NodeType == XmlNodeType.Element)
              {
                shape.IsEffectStyleInline = true;
                this.ParseEffectList(reader, (ChildShape) shape, localName2);
                break;
              }
              break;
            }
            break;
          case "scene3d":
            EffectFormat effectFormat1 = new EffectFormat((ChildShape) shape);
            shape.IsScenePropertiesInline = true;
            effectFormat1.IsSceneProperties = true;
            shape.EffectList.Add(this.ParseSceneProperties(reader, effectFormat1));
            break;
          case "sp3d":
            EffectFormat effectFormat2 = new EffectFormat((ChildShape) shape);
            shape.IsShapePropertiesInline = true;
            effectFormat2.IsShapeProperties = true;
            if (reader.HasAttributes)
            {
              string attribute12 = reader.GetAttribute("contourW");
              if (!string.IsNullOrEmpty(attribute12))
                effectFormat2.ThreeDFormat.ContourWidth = this.GetPropertyValue(attribute12, "contourW");
              string attribute13 = reader.GetAttribute("extrusionH");
              if (!string.IsNullOrEmpty(attribute13))
                effectFormat2.ThreeDFormat.ExtrusionHeight = this.GetPropertyValue(attribute13, "extrusionH");
              string attribute14 = reader.GetAttribute("z");
              if (!string.IsNullOrEmpty(attribute14))
                effectFormat2.ThreeDFormat.DistanceFromGround = this.GetPropertyValue(attribute14, "z");
              string attribute15 = reader.GetAttribute("prstMaterial");
              if (!string.IsNullOrEmpty(attribute15) && attribute15.Length > 2)
                effectFormat2.ThreeDFormat.PresetMaterialType = System.Enum.IsDefined(typeof (PresetMaterialType), (object) (char.ToUpper(attribute15[0]).ToString() + attribute15.Substring(1))) ? (PresetMaterialType) System.Enum.Parse(typeof (PresetMaterialType), attribute15, true) : PresetMaterialType.None;
            }
            EffectFormat shapeProperties = this.ParseShapeProperties(reader, effectFormat2);
            if (shapeProperties != null)
            {
              shape.EffectList.Add(shapeProperties);
              break;
            }
            break;
          case "solidFill":
            if (shape != null)
            {
              shape.IsFillStyleInline = true;
              shape.FillFormat.Fill = true;
              shape.FillFormat.IsDefaultFill = false;
              shape.FillFormat.FillType = FillType.FillSolid;
              uint maxValue = uint.MaxValue;
              Color color = this.ParseColor(reader, "solidFill", ref maxValue, reader.LocalName, false);
              shape.FillFormat.Color = color;
              if (maxValue != uint.MaxValue)
              {
                shape.FillFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
                break;
              }
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseGroupShapeProperties(XmlReader reader, GroupShape shape)
  {
    reader.Read();
    while (reader.LocalName != "grpSpPr")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        bool flag = false;
        switch (reader.LocalName)
        {
          case "xfrm":
            string attribute1 = reader.GetAttribute("rot");
            if (!string.IsNullOrEmpty(attribute1))
              shape.Rotation = this.GetNumericValue(attribute1) / 60000f;
            string attribute2 = reader.GetAttribute("flipH");
            if (!string.IsNullOrEmpty(attribute2))
              shape.FlipHorizontal = attribute2 == "1" || attribute2 == "true";
            string attribute3 = reader.GetAttribute("flipV");
            if (!string.IsNullOrEmpty(attribute3))
            {
              shape.FlipVertical = attribute3 == "1" || attribute3 == "true";
              break;
            }
            break;
          case "chOff":
            string attribute4 = reader.GetAttribute("x");
            if (!string.IsNullOrEmpty(attribute4))
              shape.X = this.GetPropertyValue(attribute4, "x");
            string attribute5 = reader.GetAttribute("y");
            if (!string.IsNullOrEmpty(attribute5))
            {
              shape.Y = this.GetPropertyValue(attribute5, "y");
              break;
            }
            break;
          case "chExt":
            string attribute6 = reader.GetAttribute("cx");
            if (!string.IsNullOrEmpty(attribute6))
              shape.ExtentXValue = this.GetPropertyValue(attribute6, "x");
            string attribute7 = reader.GetAttribute("cy");
            if (!string.IsNullOrEmpty(attribute7))
            {
              shape.ExtentYValue = this.GetPropertyValue(attribute7, "y");
              break;
            }
            break;
          case "effectLst":
            if (!reader.IsEmptyElement)
            {
              string localName = reader.LocalName;
              reader.Read();
              if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                shape.IsEffectStyleInline = true;
                this.ParseEffectList(reader, shape, localName);
                break;
              }
              break;
            }
            break;
          case "scene3d":
            EffectFormat effectFormat1 = new EffectFormat(shape);
            shape.IsScenePropertiesInline = true;
            effectFormat1.IsSceneProperties = true;
            shape.EffectList.Add(this.ParseSceneProperties(reader, effectFormat1));
            break;
          case "sp3d":
            EffectFormat effectFormat2 = new EffectFormat(shape);
            shape.IsShapePropertiesInline = true;
            effectFormat2.IsShapeProperties = true;
            if (reader.HasAttributes)
            {
              string attribute8 = reader.GetAttribute("contourW");
              if (!string.IsNullOrEmpty(attribute8))
                effectFormat2.ThreeDFormat.ContourWidth = this.GetPropertyValue(attribute8, "contourW");
              string attribute9 = reader.GetAttribute("extrusionH");
              if (!string.IsNullOrEmpty(attribute9))
                effectFormat2.ThreeDFormat.ExtrusionHeight = this.GetPropertyValue(attribute9, "extrusionH");
              string attribute10 = reader.GetAttribute("z");
              if (!string.IsNullOrEmpty(attribute10))
                effectFormat2.ThreeDFormat.DistanceFromGround = this.GetPropertyValue(attribute10, "z");
              string attribute11 = reader.GetAttribute("prstMaterial");
              if (!string.IsNullOrEmpty(attribute11) && attribute11.Length > 2)
                effectFormat2.ThreeDFormat.PresetMaterialType = System.Enum.IsDefined(typeof (PresetMaterialType), (object) (char.ToUpper(attribute11[0]).ToString() + attribute11.Substring(1))) ? (PresetMaterialType) System.Enum.Parse(typeof (PresetMaterialType), attribute11, true) : PresetMaterialType.None;
            }
            EffectFormat shapeProperties = this.ParseShapeProperties(reader, effectFormat2);
            if (shapeProperties != null)
            {
              shape.EffectList.Add(shapeProperties);
              break;
            }
            break;
          case "solidFill":
            if (shape != null)
            {
              shape.IsFillStyleInline = true;
              shape.FillFormat.Fill = true;
              shape.FillFormat.IsDefaultFill = false;
              shape.FillFormat.FillType = FillType.FillSolid;
              uint maxValue = uint.MaxValue;
              Color color = this.ParseColor(reader, "solidFill", ref maxValue, reader.LocalName, false);
              shape.FillFormat.Color = color;
              if (maxValue != uint.MaxValue)
              {
                shape.FillFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
                break;
              }
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseEffectList(XmlReader reader, GroupShape shape, string localName)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (localName != "effectLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    uint maxValue = uint.MaxValue;
    while (reader.LocalName != "effectLst")
    {
      EffectFormat effectFormat = new EffectFormat(shape);
      effectFormat.IsEffectListItem = true;
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "outerShdw":
          case "innerShdw":
            effectFormat.ShadowFormat.m_type = reader.LocalName;
            effectFormat.IsShadowEffect = true;
            this.ParseShadowEffect(reader, reader.LocalName, effectFormat);
            shape.EffectList.Add(effectFormat);
            break;
          case "reflection":
            if (reader.HasAttributes)
            {
              effectFormat.IsReflection = true;
              this.ParseReflectionEffect(reader, effectFormat);
              shape.EffectList.Add(effectFormat);
            }
            flag = false;
            break;
          case "glow":
            effectFormat.IsGlowEffect = true;
            if (reader.HasAttributes)
            {
              string attribute = reader.GetAttribute("rad");
              if (!string.IsNullOrEmpty(attribute))
              {
                effectFormat.GlowFormat.IsInlineRadius = true;
                effectFormat.GlowFormat.Radius = this.GetPropertyValue(attribute, "rad");
              }
            }
            if (!reader.IsEmptyElement)
            {
              localName = reader.LocalName;
              reader.Read();
              if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                effectFormat.GlowFormat.Color = this.ParseColor(reader, reader.LocalName, ref maxValue, localName, true);
                effectFormat.GlowFormat.IsInlineColor = true;
                if (maxValue != uint.MaxValue)
                {
                  float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
                  effectFormat.GlowFormat.Transparency = (float) Math.Round(1.0 - (double) num, 2);
                  effectFormat.GlowFormat.IsInlineTransparency = true;
                }
              }
            }
            shape.EffectList.Add(effectFormat);
            break;
          case "softEdge":
            effectFormat.IsSoftEdge = true;
            if (reader.HasAttributes)
            {
              string attribute = reader.GetAttribute("rad");
              effectFormat.SoftEdgeRadius = this.GetPropertyValue(attribute, "rad");
              if ((double) effectFormat.SoftEdgeRadius == 0.0)
                effectFormat.NoSoftEdges = true;
            }
            shape.EffectList.Add(effectFormat);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseEffectList(XmlReader reader, ChildShape shape, string localName)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (localName != "effectLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    uint maxValue = uint.MaxValue;
    while (reader.LocalName != "effectLst")
    {
      EffectFormat effectFormat = new EffectFormat(shape);
      effectFormat.IsEffectListItem = true;
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "outerShdw":
          case "innerShdw":
            effectFormat.ShadowFormat.m_type = reader.LocalName;
            effectFormat.IsShadowEffect = true;
            this.ParseShadowEffect(reader, reader.LocalName, effectFormat);
            shape.EffectList.Add(effectFormat);
            break;
          case "reflection":
            if (reader.HasAttributes)
            {
              effectFormat.IsReflection = true;
              this.ParseReflectionEffect(reader, effectFormat);
              shape.EffectList.Add(effectFormat);
            }
            flag = false;
            break;
          case "glow":
            effectFormat.IsGlowEffect = true;
            if (reader.HasAttributes)
            {
              string attribute = reader.GetAttribute("rad");
              if (!string.IsNullOrEmpty(attribute))
              {
                effectFormat.GlowFormat.IsInlineRadius = true;
                effectFormat.GlowFormat.Radius = this.GetPropertyValue(attribute, "rad");
              }
            }
            if (!reader.IsEmptyElement)
            {
              localName = reader.LocalName;
              reader.Read();
              if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                effectFormat.GlowFormat.Color = this.ParseColor(reader, localName, ref maxValue, localName, true);
                effectFormat.GlowFormat.IsInlineColor = true;
                if (maxValue != uint.MaxValue)
                {
                  float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
                  effectFormat.GlowFormat.Transparency = (float) Math.Round(1.0 - (double) num, 2);
                  effectFormat.GlowFormat.IsInlineTransparency = true;
                }
              }
            }
            shape.EffectList.Add(effectFormat);
            break;
          case "softEdge":
            effectFormat.IsSoftEdge = true;
            if (reader.HasAttributes)
            {
              string attribute = reader.GetAttribute("rad");
              effectFormat.SoftEdgeRadius = this.GetPropertyValue(attribute, "rad");
              if ((double) effectFormat.SoftEdgeRadius == 0.0)
                effectFormat.NoSoftEdges = true;
            }
            shape.EffectList.Add(effectFormat);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseEffectList(XmlReader reader, Shape shape, string localName)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (localName != "effectLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    uint maxValue = uint.MaxValue;
    while (reader.LocalName != "effectLst")
    {
      EffectFormat effectFormat = new EffectFormat(shape);
      effectFormat.IsEffectListItem = true;
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "outerShdw":
          case "innerShdw":
            effectFormat.ShadowFormat.m_type = reader.LocalName;
            effectFormat.IsShadowEffect = true;
            this.ParseShadowEffect(reader, reader.LocalName, effectFormat);
            shape.EffectList.Add(effectFormat);
            break;
          case "reflection":
            if (reader.HasAttributes)
            {
              effectFormat.IsReflection = true;
              this.ParseReflectionEffect(reader, effectFormat);
              shape.EffectList.Add(effectFormat);
            }
            flag = false;
            break;
          case "glow":
            effectFormat.IsGlowEffect = true;
            if (reader.HasAttributes)
            {
              string attribute = reader.GetAttribute("rad");
              if (!string.IsNullOrEmpty(attribute))
              {
                effectFormat.GlowFormat.IsInlineRadius = true;
                effectFormat.GlowFormat.Radius = this.GetPropertyValue(attribute, "rad");
              }
            }
            if (!reader.IsEmptyElement)
            {
              localName = reader.LocalName;
              reader.Read();
              if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                effectFormat.GlowFormat.Color = this.ParseColor(reader, localName, ref maxValue, localName, true);
                effectFormat.GlowFormat.IsInlineColor = true;
                if (maxValue != uint.MaxValue)
                {
                  float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
                  effectFormat.GlowFormat.Transparency = (float) Math.Round(1.0 - (double) num, 2);
                  effectFormat.GlowFormat.IsInlineTransparency = true;
                }
              }
            }
            shape.EffectList.Add(effectFormat);
            break;
          case "softEdge":
            effectFormat.IsSoftEdge = true;
            if (reader.HasAttributes)
            {
              string attribute = reader.GetAttribute("rad");
              effectFormat.SoftEdgeRadius = this.GetPropertyValue(attribute, "rad");
              if ((double) effectFormat.SoftEdgeRadius == 0.0)
                effectFormat.NoSoftEdges = true;
            }
            shape.EffectList.Add(effectFormat);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseReflectionEffect(XmlReader reader, EffectFormat effectFormat)
  {
    string attribute1 = reader.GetAttribute("blurRad");
    if (!string.IsNullOrEmpty(attribute1))
      effectFormat.ReflectionFormat.Blur = this.GetPointValue(attribute1);
    string attribute2 = reader.GetAttribute("stA");
    if (!string.IsNullOrEmpty(attribute2))
    {
      effectFormat.ReflectionFormat.Transparency = 100f - (float) this.GetPercentage(attribute2);
      if ((double) effectFormat.ReflectionFormat.Transparency >= 0.0 && (double) effectFormat.ReflectionFormat.Transparency > 100.0)
        effectFormat.ReflectionFormat.Transparency = 0.0f;
    }
    string attribute3 = reader.GetAttribute("stPos");
    if (!string.IsNullOrEmpty(attribute3))
    {
      effectFormat.ReflectionFormat.StartPosition = (float) this.GetPercentage(attribute3);
      if ((double) effectFormat.ReflectionFormat.StartPosition >= 0.0 && (double) effectFormat.ReflectionFormat.StartPosition > 100.0)
        effectFormat.ReflectionFormat.StartPosition = 0.0f;
    }
    string attribute4 = reader.GetAttribute("endA");
    if (!string.IsNullOrEmpty(attribute4))
    {
      effectFormat.ReflectionFormat.EndOpacity = (float) this.GetPercentage(attribute4);
      if ((double) effectFormat.ReflectionFormat.EndOpacity >= 0.0 && (double) effectFormat.ReflectionFormat.EndOpacity > 100.0)
        effectFormat.ReflectionFormat.EndOpacity = 0.0f;
    }
    string attribute5 = reader.GetAttribute("endPos");
    if (!string.IsNullOrEmpty(attribute5))
    {
      effectFormat.ReflectionFormat.Size = (float) this.GetPercentage(attribute5);
      if ((double) effectFormat.ReflectionFormat.Size >= 0.0 && (double) effectFormat.ReflectionFormat.Size > 100.0)
        effectFormat.ReflectionFormat.Size = 0.0f;
    }
    string attribute6 = reader.GetAttribute("dist");
    if (!string.IsNullOrEmpty(attribute6))
      effectFormat.ReflectionFormat.Offset = this.GetPointValue(attribute6);
    string attribute7 = reader.GetAttribute("dir");
    if (!string.IsNullOrEmpty(attribute7))
      effectFormat.ReflectionFormat.Direction = Convert.ToInt32(Math.Round(Convert.ToDouble(attribute7, (IFormatProvider) CultureInfo.InvariantCulture) / 60000.0, 0));
    string attribute8 = reader.GetAttribute("fadeDir");
    if (!string.IsNullOrEmpty(attribute8))
      effectFormat.ReflectionFormat.FadeDirection = Convert.ToInt32(Math.Round(Convert.ToDouble(attribute8, (IFormatProvider) CultureInfo.InvariantCulture) / 60000.0, 0));
    string attribute9 = reader.GetAttribute("rotWithShape");
    effectFormat.ReflectionFormat.RotateWithShape = attribute9 == "1" || attribute9 == "true";
    string attribute10 = reader.GetAttribute("algn");
    if (!string.IsNullOrEmpty(attribute10))
      effectFormat.ReflectionFormat.Alignment = this.GetTextureAlignment(attribute10);
    string attribute11 = reader.GetAttribute("kx");
    if (!string.IsNullOrEmpty(attribute11))
    {
      int int32 = Convert.ToInt32(Math.Round(Convert.ToDouble(attribute11, (IFormatProvider) CultureInfo.InvariantCulture) / 60000.0, 0));
      if (int32 > -90 && int32 < 90)
        effectFormat.ReflectionFormat.HorizontalSkew = int32;
    }
    string attribute12 = reader.GetAttribute("ky");
    if (!string.IsNullOrEmpty(attribute12))
    {
      int int32 = Convert.ToInt32(Math.Round(Convert.ToDouble(attribute12, (IFormatProvider) CultureInfo.InvariantCulture) / 60000.0, 0));
      if (int32 > -90 && int32 < 90)
        effectFormat.ReflectionFormat.VerticalSkew = int32;
    }
    string attribute13 = reader.GetAttribute("sx");
    if (!string.IsNullOrEmpty(attribute13))
    {
      effectFormat.ReflectionFormat.HorizontalRatio = (float) this.GetPercentage(attribute13) / 100f;
      if ((double) effectFormat.ReflectionFormat.HorizontalRatio >= -100.0 && (double) effectFormat.ReflectionFormat.HorizontalRatio > 100.0)
        effectFormat.ReflectionFormat.HorizontalRatio = 0.0f;
    }
    string attribute14 = reader.GetAttribute("sy");
    if (string.IsNullOrEmpty(attribute14))
      return;
    effectFormat.ReflectionFormat.VerticalRatio = (float) this.GetPercentage(attribute14) / 100f;
    if ((double) effectFormat.ReflectionFormat.VerticalRatio < -100.0 || (double) effectFormat.ReflectionFormat.VerticalRatio <= 100.0)
      return;
    effectFormat.ReflectionFormat.VerticalRatio = 0.0f;
  }

  private void ParseShadowEffect(XmlReader reader, string localName, EffectFormat effectFormat)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != localName)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    if (reader.HasAttributes)
      this.ParseShadowAttributes(reader, effectFormat.ShadowFormat);
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    uint maxValue = uint.MaxValue;
    effectFormat.ShadowFormat.Color = this.ParseColor(reader, localName1, ref maxValue, localName1, true);
    if (maxValue == uint.MaxValue)
      return;
    float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
    effectFormat.ShadowFormat.Transparency = 1f - num;
  }

  private void ParseShadowAttributes(XmlReader reader, ShadowFormat shadowFormat)
  {
    string attribute1 = reader.GetAttribute("blurRad");
    if (!string.IsNullOrEmpty(attribute1))
      shadowFormat.Blur = (double) this.GetPropertyValue(attribute1, "blurRad");
    string attribute2 = reader.GetAttribute("dist");
    if (!string.IsNullOrEmpty(attribute2))
      shadowFormat.Distance = (double) this.GetPropertyValue(attribute2, "dist");
    string attribute3 = reader.GetAttribute("dir");
    if (!string.IsNullOrEmpty(attribute3))
    {
      uint result;
      uint.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      shadowFormat.Direction = (double) (short) Math.Round((double) result / 60000.0);
    }
    string attribute4 = reader.GetAttribute("rotWithShape");
    if (!string.IsNullOrEmpty(attribute4))
      shadowFormat.RotateWithShape = this.GetBoolValue(attribute4);
    string attribute5 = reader.GetAttribute("kx");
    if (!string.IsNullOrEmpty(attribute5))
    {
      uint result;
      uint.TryParse(attribute5, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      shadowFormat.HorizontalSkewAngle = (short) Math.Round((double) result / 60000.0);
    }
    string attribute6 = reader.GetAttribute("ky");
    if (!string.IsNullOrEmpty(attribute6))
    {
      uint result;
      uint.TryParse(attribute6, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      shadowFormat.VerticalSkewAngle = (short) Math.Round((double) result / 60000.0);
    }
    string attribute7 = reader.GetAttribute("sx");
    if (!string.IsNullOrEmpty(attribute7))
      shadowFormat.HorizontalScalingFactor = (double) this.GetPropertyValue(attribute7, "sx");
    string attribute8 = reader.GetAttribute("sy");
    if (string.IsNullOrEmpty(attribute8))
      return;
    shadowFormat.VerticalScalingFactor = (double) this.GetPropertyValue(attribute8, "sy");
  }

  private void ParseBodyProperties(MemoryStream stream, Shape shape)
  {
    XmlReader reader = UtilityMethods.CreateReader((Stream) stream);
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "bodyPr")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool flag = false;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "bodyPr")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "noAutofit":
            shape.TextFrame.NoAutoFit = true;
            break;
          case "normAutofit":
            shape.TextFrame.NormalAutoFit = true;
            break;
          case "spAutoFit":
            shape.TextFrame.ShapeAutoFit = true;
            break;
          case "prstTxWarp":
            if (reader.AttributeCount != 0)
            {
              string attribute = reader.GetAttribute("prst");
              if (!string.IsNullOrEmpty(attribute) && attribute.Trim() != "textNoShape")
              {
                this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 31 /*0x1F*/);
                break;
              }
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseStyleItems(MemoryStream stream, Shape shape)
  {
    XmlReader reader = UtilityMethods.CreateReader((Stream) stream);
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "style")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    ShapeStyleReference shapeStyleReference1 = new ShapeStyleReference();
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "style") || reader.NodeType != XmlNodeType.EndElement)
    {
      string empty1 = string.Empty;
      Color empty2 = Color.Empty;
      uint maxValue = uint.MaxValue;
      ShapeStyleReference shapeStyleReference2 = new ShapeStyleReference();
      bool flag = true;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "lnRef":
            int num1 = Convert.ToInt32(reader.GetAttribute("idx"));
            Color color1 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            shapeStyleReference2.StyleRefIndex = num1;
            shapeStyleReference2.StyleRefColor = color1;
            if (maxValue != uint.MaxValue)
              shapeStyleReference2.StyleRefOpacity = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
            shape.ShapeStyleReferences.Add(shapeStyleReference2);
            if (num1 > this.m_doc.Themes.FmtScheme.LnStyleScheme.Count)
              num1 = this.m_doc.Themes.FmtScheme.LnStyleScheme.Count;
            if (num1 != 0)
            {
              LineFormat lineFormat = this.m_doc.Themes.FmtScheme.LnStyleScheme[num1 - 1];
              if (!shape.LineFormat.HasKey(11) && lineFormat.HasKey(11))
                shape.LineFormat.Weight = lineFormat.Weight;
              if (!shape.LineFormat.HasKey(0) && lineFormat.HasKey(0))
                shape.LineFormat.LineJoin = lineFormat.LineJoin;
              if (!shape.LineFormat.HasKey(1) && lineFormat.HasKey(1))
                shape.LineFormat.LineCap = lineFormat.LineCap;
              if (!shape.LineFormat.HasKey(2) && lineFormat.HasKey(2))
                shape.LineFormat.BeginArrowheadLength = lineFormat.BeginArrowheadLength;
              if (!shape.LineFormat.HasKey(3) && lineFormat.HasKey(3))
                shape.LineFormat.BeginArrowheadStyle = lineFormat.BeginArrowheadStyle;
              if (!shape.LineFormat.HasKey(4) && lineFormat.HasKey(4))
                shape.LineFormat.BeginArrowheadWidth = lineFormat.BeginArrowheadWidth;
              if (!shape.LineFormat.HasKey(5) && lineFormat.HasKey(5))
                shape.LineFormat.DashStyle = lineFormat.DashStyle;
              if (!shape.LineFormat.HasKey(6) && lineFormat.HasKey(6))
                shape.LineFormat.EndArrowheadLength = lineFormat.EndArrowheadLength;
              if (!shape.LineFormat.HasKey(7) && lineFormat.HasKey(7))
                shape.LineFormat.EndArrowheadStyle = lineFormat.EndArrowheadStyle;
              if (!shape.LineFormat.HasKey(8) && lineFormat.HasKey(8))
                shape.LineFormat.EndArrowheadWidth = lineFormat.EndArrowheadWidth;
              if (!shape.LineFormat.HasKey(9) && lineFormat.HasKey(9))
                shape.LineFormat.InsetPen = lineFormat.InsetPen;
              if (!shape.LineFormat.HasKey(10) && lineFormat.HasKey(10))
                shape.LineFormat.Style = lineFormat.Style;
              if (shape.LineFormat.LineFormatType == ~(LineFormatType.None | LineFormatType.Solid) && lineFormat.LineFormatType == ~(LineFormatType.None | LineFormatType.Solid))
                shape.LineFormat.Line = false;
              if (!shape.LineFormat.HasKey(12) && lineFormat.HasKey(12))
              {
                if (lineFormat.LineFormatType == LineFormatType.Solid)
                {
                  if (lineFormat.LineSchemeColorTransforms.Count > 0)
                  {
                    shape.LineFormat.Color = shape.StyleColorTransform(lineFormat.LineSchemeColorTransforms, color1, ref maxValue);
                    maxValue = uint.MaxValue;
                  }
                  else
                    shape.LineFormat.Color = lineFormat.Color.IsEmpty ? color1 : lineFormat.Color;
                }
                else if (lineFormat.LineFormatType == LineFormatType.Gradient)
                {
                  for (int index = 0; index < lineFormat.GradientFill.GradientStops.Count; ++index)
                  {
                    if (lineFormat.GradientFill.GradientStops[index].FillSchemeColorTransforms.Count > 0)
                    {
                      if (lineFormat.GradientFill.GradientStops[index].Color.IsEmpty)
                      {
                        lineFormat.GradientFill.GradientStops[index].Color = shape.StyleColorTransform(lineFormat.GradientFill.GradientStops[index].FillSchemeColorTransforms, color1, ref maxValue);
                        maxValue = uint.MaxValue;
                      }
                    }
                    else
                      lineFormat.GradientFill.GradientStops[index].Color = color1;
                  }
                  shape.LineFormat.GradientFill = lineFormat.GradientFill;
                }
                else if (lineFormat.LineFormatType == LineFormatType.Patterned)
                {
                  if (lineFormat.LineSchemeColorTransforms.Count > 0)
                  {
                    List<DictionaryEntry> fillTransformation1 = new List<DictionaryEntry>();
                    List<DictionaryEntry> fillTransformation2 = new List<DictionaryEntry>();
                    for (int index = 0; index < lineFormat.LineSchemeColorTransforms.Count; ++index)
                    {
                      if (this.StartsWithExt(lineFormat.LineSchemeColorTransforms[index].Key.ToString(), "fgClr"))
                        fillTransformation1.Add(lineFormat.LineSchemeColorTransforms[index]);
                      if (this.StartsWithExt(lineFormat.LineSchemeColorTransforms[index].Key.ToString(), "bgClr"))
                        fillTransformation2.Add(lineFormat.LineSchemeColorTransforms[index]);
                    }
                    shape.LineFormat.ForeColor = shape.StyleColorTransform(fillTransformation1, color1, ref maxValue);
                    maxValue = uint.MaxValue;
                    shape.LineFormat.Color = shape.StyleColorTransform(fillTransformation2, color1, ref maxValue);
                    maxValue = uint.MaxValue;
                  }
                  else
                  {
                    shape.LineFormat.Color = lineFormat.Color.IsEmpty ? color1 : lineFormat.Color;
                    shape.LineFormat.ForeColor = lineFormat.ForeColor.IsEmpty ? color1 : lineFormat.ForeColor;
                  }
                }
                else
                  shape.LineFormat = lineFormat;
              }
            }
            flag = false;
            break;
          case "fillRef":
            int num2 = Convert.ToInt32(reader.GetAttribute("idx"));
            Color color2 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            shapeStyleReference2.StyleRefIndex = num2;
            shapeStyleReference2.StyleRefColor = color2;
            if (maxValue != uint.MaxValue)
              shapeStyleReference2.StyleRefOpacity = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
            shape.ShapeStyleReferences.Add(shapeStyleReference2);
            if (!shape.IsFillStyleInline && shape.FillFormat.Fill && this.m_doc.Themes.FmtScheme.FillFormats.Count > 0 && num2 != 0)
            {
              if (num2 > this.m_doc.Themes.FmtScheme.FillFormats.Count)
                num2 = this.m_doc.Themes.FmtScheme.FillFormats.Count;
              FillFormat fillFormat = this.m_doc.Themes.FmtScheme.FillFormats[num2 - 1];
              if (fillFormat.FillType == FillType.None)
                shape.FillFormat.Fill = fillFormat.Fill;
              if (fillFormat.FillType == FillType.FillSolid && fillFormat.Color == Color.Empty)
              {
                if (fillFormat.FillSchemeColorTransforms.Count > 0)
                {
                  shape.FillFormat.Color = shape.StyleColorTransform(fillFormat.FillSchemeColorTransforms, color2, ref maxValue);
                  shape.FillFormat = fillFormat;
                  maxValue = uint.MaxValue;
                }
                shape.FillFormat.Color = fillFormat.Color.IsEmpty ? color2 : fillFormat.Color;
              }
              else if (fillFormat.FillType == FillType.FillGradient)
              {
                for (int index = 0; index < fillFormat.GradientFill.GradientStops.Count; ++index)
                {
                  if (fillFormat.GradientFill.GradientStops[index].FillSchemeColorTransforms.Count > 0)
                  {
                    fillFormat.GradientFill.GradientStops[index].Color = shape.StyleColorTransform(fillFormat.GradientFill.GradientStops[index].FillSchemeColorTransforms, color2, ref maxValue);
                    maxValue = uint.MaxValue;
                  }
                  else if (fillFormat.GradientFill.GradientStops[index].Color.IsEmpty)
                    fillFormat.GradientFill.GradientStops[index].Color = color2;
                }
                shape.FillFormat.GradientFill = fillFormat.GradientFill;
              }
              else if (fillFormat.FillType == FillType.FillPatterned)
              {
                shape.FillFormat = fillFormat;
                List<DictionaryEntry> fillTransformation3 = new List<DictionaryEntry>();
                List<DictionaryEntry> fillTransformation4 = new List<DictionaryEntry>();
                if (fillFormat.FillSchemeColorTransforms.Count > 0)
                {
                  for (int index = 0; index < fillFormat.FillSchemeColorTransforms.Count; ++index)
                  {
                    if (this.StartsWithExt(fillFormat.FillSchemeColorTransforms[index].Key.ToString(), "fgClr"))
                      fillTransformation3.Add(fillFormat.FillSchemeColorTransforms[index]);
                    if (this.StartsWithExt(fillFormat.FillSchemeColorTransforms[index].Key.ToString(), "bgClr"))
                      fillTransformation4.Add(fillFormat.FillSchemeColorTransforms[index]);
                  }
                  shape.FillFormat.ForeColor = shape.StyleColorTransform(fillTransformation3, color2, ref maxValue);
                  maxValue = uint.MaxValue;
                  shape.FillFormat.Color = shape.StyleColorTransform(fillTransformation4, color2, ref maxValue);
                  maxValue = uint.MaxValue;
                }
                else
                {
                  shape.FillFormat.Color = fillFormat.Color.IsEmpty ? color2 : fillFormat.Color;
                  shape.FillFormat.ForeColor = fillFormat.ForeColor.IsEmpty ? color2 : fillFormat.ForeColor;
                }
              }
              else if (fillFormat.FillType == FillType.FillPicture || fillFormat.FillType == FillType.FillTextured || fillFormat.FillType == FillType.FillMixed)
                shape.FillFormat = fillFormat;
            }
            flag = false;
            break;
          case "effectRef":
            int num3 = Convert.ToInt32(reader.GetAttribute("idx"));
            Color color3 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            shapeStyleReference2.StyleRefIndex = num3;
            shapeStyleReference2.StyleRefColor = color3;
            if (maxValue != uint.MaxValue)
              shapeStyleReference2.StyleRefOpacity = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
            shape.ShapeStyleReferences.Add(shapeStyleReference2);
            if (!shape.IsEffectStyleInline && num3 != 0)
            {
              if (num3 > this.m_doc.Themes.FmtScheme.EffectStyles.Count)
                num3 = this.m_doc.Themes.FmtScheme.EffectStyles.Count;
              shape.EffectList.Add(this.m_doc.Themes.FmtScheme.EffectStyles[num3 - 1]);
              foreach (EffectFormat effect in shape.EffectList)
              {
                if (effect.IsShadowEffect && effect.ShadowFormat.Color.IsEmpty)
                {
                  effect.ShadowFormat.Color = color3;
                  if (maxValue != uint.MaxValue)
                    effect.ShadowFormat.Transparency = (float) maxValue;
                }
                if (effect.IsShapeProperties)
                {
                  if (effect.ThreeDFormat.HasContourColor && effect.ThreeDFormat.ContourColor.IsEmpty)
                  {
                    effect.ThreeDFormat.ContourColor = color3;
                    if (maxValue != uint.MaxValue)
                      effect.ThreeDFormat.ContourOpacity = (float) maxValue;
                  }
                  if (effect.ThreeDFormat.HasExtrusionColor && effect.ThreeDFormat.ExtrusionColor.IsEmpty)
                  {
                    effect.ThreeDFormat.ExtrusionColor = color3;
                    if (maxValue != uint.MaxValue)
                      effect.ThreeDFormat.ExtrusionOpacity = (float) maxValue;
                  }
                }
              }
            }
            flag = false;
            break;
          case "fontRef":
            string attribute = reader.GetAttribute("idx");
            shape.FontRefColor = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            shapeStyleReference2.StyleRefIndex = attribute == "minor" ? 1 : 2;
            shapeStyleReference2.StyleRefColor = shape.FontRefColor;
            if (maxValue != uint.MaxValue)
              shapeStyleReference2.StyleRefOpacity = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
            shape.ShapeStyleReferences.Add(shapeStyleReference2);
            flag = false;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseStyleItems(MemoryStream stream, ChildShape shape)
  {
    XmlReader reader = UtilityMethods.CreateReader((Stream) stream);
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "style")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    ShapeStyleReference shapeStyleReference1 = new ShapeStyleReference();
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == "style") || reader.NodeType != XmlNodeType.EndElement)
    {
      string empty1 = string.Empty;
      Color empty2 = Color.Empty;
      uint maxValue = uint.MaxValue;
      ShapeStyleReference shapeStyleReference2 = new ShapeStyleReference();
      bool flag = true;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "lnRef":
            int num1 = Convert.ToInt32(reader.GetAttribute("idx"));
            Color color1 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            shapeStyleReference2.StyleRefIndex = num1;
            shapeStyleReference2.StyleRefColor = color1;
            if (maxValue != uint.MaxValue)
              shapeStyleReference2.StyleRefOpacity = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
            shape.ShapeStyleReferences.Add(shapeStyleReference2);
            if (num1 > this.m_doc.Themes.FmtScheme.LnStyleScheme.Count)
              num1 = this.m_doc.Themes.FmtScheme.LnStyleScheme.Count;
            if (num1 != 0)
            {
              LineFormat lineFormat = this.m_doc.Themes.FmtScheme.LnStyleScheme[num1 - 1];
              if (!shape.LineFormat.HasKey(11) && lineFormat.HasKey(11))
                shape.LineFormat.Weight = lineFormat.Weight;
              if (!shape.LineFormat.HasKey(0) && lineFormat.HasKey(0))
                shape.LineFormat.LineJoin = lineFormat.LineJoin;
              if (!shape.LineFormat.HasKey(1) && lineFormat.HasKey(1))
                shape.LineFormat.LineCap = lineFormat.LineCap;
              if (!shape.LineFormat.HasKey(2) && lineFormat.HasKey(2))
                shape.LineFormat.BeginArrowheadLength = lineFormat.BeginArrowheadLength;
              if (!shape.LineFormat.HasKey(3) && lineFormat.HasKey(3))
                shape.LineFormat.BeginArrowheadStyle = lineFormat.BeginArrowheadStyle;
              if (!shape.LineFormat.HasKey(4) && lineFormat.HasKey(4))
                shape.LineFormat.BeginArrowheadWidth = lineFormat.BeginArrowheadWidth;
              if (!shape.LineFormat.HasKey(5) && lineFormat.HasKey(5))
                shape.LineFormat.DashStyle = lineFormat.DashStyle;
              if (!shape.LineFormat.HasKey(6) && lineFormat.HasKey(6))
                shape.LineFormat.EndArrowheadLength = lineFormat.EndArrowheadLength;
              if (!shape.LineFormat.HasKey(7) && lineFormat.HasKey(7))
                shape.LineFormat.EndArrowheadStyle = lineFormat.EndArrowheadStyle;
              if (!shape.LineFormat.HasKey(8) && lineFormat.HasKey(8))
                shape.LineFormat.EndArrowheadWidth = lineFormat.EndArrowheadWidth;
              if (!shape.LineFormat.HasKey(9) && lineFormat.HasKey(9))
                shape.LineFormat.InsetPen = lineFormat.InsetPen;
              if (!shape.LineFormat.HasKey(10) && lineFormat.HasKey(10))
                shape.LineFormat.Style = lineFormat.Style;
              if (shape.LineFormat.LineFormatType == ~(LineFormatType.None | LineFormatType.Solid) && lineFormat.LineFormatType == ~(LineFormatType.None | LineFormatType.Solid))
                shape.LineFormat.Line = false;
              if (!shape.LineFormat.HasKey(12) && lineFormat.HasKey(12) && shape.LineFormat.Line)
              {
                if (lineFormat.LineFormatType == LineFormatType.Solid)
                {
                  if (lineFormat.LineSchemeColorTransforms.Count > 0)
                  {
                    shape.LineFormat.Color = shape.StyleColorTransform(lineFormat.LineSchemeColorTransforms, color1, ref maxValue);
                    maxValue = uint.MaxValue;
                  }
                  else
                    shape.LineFormat.Color = lineFormat.Color.IsEmpty ? color1 : lineFormat.Color;
                }
                else if (lineFormat.LineFormatType == LineFormatType.Gradient)
                {
                  for (int index = 0; index < lineFormat.GradientFill.GradientStops.Count; ++index)
                  {
                    if (lineFormat.GradientFill.GradientStops[index].FillSchemeColorTransforms.Count > 0)
                    {
                      if (lineFormat.GradientFill.GradientStops[index].Color.IsEmpty)
                      {
                        lineFormat.GradientFill.GradientStops[index].Color = shape.StyleColorTransform(lineFormat.GradientFill.GradientStops[index].FillSchemeColorTransforms, color1, ref maxValue);
                        maxValue = uint.MaxValue;
                      }
                    }
                    else
                      lineFormat.GradientFill.GradientStops[index].Color = color1;
                  }
                  shape.LineFormat.GradientFill = lineFormat.GradientFill;
                }
                else if (lineFormat.LineFormatType == LineFormatType.Patterned)
                {
                  if (lineFormat.LineSchemeColorTransforms.Count > 0)
                  {
                    List<DictionaryEntry> fillTransformation1 = new List<DictionaryEntry>();
                    List<DictionaryEntry> fillTransformation2 = new List<DictionaryEntry>();
                    for (int index = 0; index < lineFormat.LineSchemeColorTransforms.Count; ++index)
                    {
                      if (lineFormat.LineSchemeColorTransforms[index].Key.ToString().StartsWith("fgClr"))
                        fillTransformation1.Add(lineFormat.LineSchemeColorTransforms[index]);
                      if (lineFormat.LineSchemeColorTransforms[index].Key.ToString().StartsWith("bgClr"))
                        fillTransformation2.Add(lineFormat.LineSchemeColorTransforms[index]);
                    }
                    shape.LineFormat.ForeColor = shape.StyleColorTransform(fillTransformation1, color1, ref maxValue);
                    maxValue = uint.MaxValue;
                    shape.LineFormat.Color = shape.StyleColorTransform(fillTransformation2, color1, ref maxValue);
                    maxValue = uint.MaxValue;
                  }
                  else
                  {
                    shape.LineFormat.Color = lineFormat.Color.IsEmpty ? color1 : lineFormat.Color;
                    shape.LineFormat.ForeColor = lineFormat.ForeColor.IsEmpty ? color1 : lineFormat.ForeColor;
                  }
                }
                else
                  shape.LineFormat = lineFormat;
              }
            }
            else if (shape.LineFormat.LineFormatType == ~(LineFormatType.None | LineFormatType.Solid))
              shape.LineFormat.Line = false;
            flag = false;
            break;
          case "fillRef":
            int num2 = Convert.ToInt32(reader.GetAttribute("idx"));
            Color color2 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            shapeStyleReference2.StyleRefIndex = num2;
            shapeStyleReference2.StyleRefColor = color2;
            if (maxValue != uint.MaxValue)
              shapeStyleReference2.StyleRefOpacity = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
            shape.ShapeStyleReferences.Add(shapeStyleReference2);
            if (!shape.IsFillStyleInline && shape.FillFormat.Fill && num2 != 0)
            {
              if (num2 > this.m_doc.Themes.FmtScheme.FillFormats.Count)
                num2 = this.m_doc.Themes.FmtScheme.FillFormats.Count;
              FillFormat fillFormat = this.m_doc.Themes.FmtScheme.FillFormats[num2 - 1];
              if (fillFormat.FillType == FillType.FillSolid && fillFormat.Color == Color.Empty)
              {
                if (fillFormat.FillSchemeColorTransforms.Count > 0)
                {
                  shape.FillFormat.Color = shape.StyleColorTransform(fillFormat.FillSchemeColorTransforms, color2, ref maxValue);
                  shape.FillFormat = fillFormat;
                  maxValue = uint.MaxValue;
                }
                shape.FillFormat.Color = fillFormat.Color.IsEmpty ? color2 : fillFormat.Color;
              }
              else if (fillFormat.FillType == FillType.FillGradient)
              {
                for (int index = 0; index < fillFormat.GradientFill.GradientStops.Count; ++index)
                {
                  if (fillFormat.GradientFill.GradientStops[index].FillSchemeColorTransforms.Count > 0)
                  {
                    fillFormat.GradientFill.GradientStops[index].Color = shape.StyleColorTransform(fillFormat.GradientFill.GradientStops[index].FillSchemeColorTransforms, color2, ref maxValue);
                    maxValue = uint.MaxValue;
                  }
                  else if (fillFormat.GradientFill.GradientStops[index].Color.IsEmpty)
                    fillFormat.GradientFill.GradientStops[index].Color = color2;
                }
                shape.FillFormat.GradientFill = fillFormat.GradientFill;
              }
              else if (fillFormat.FillType == FillType.FillPatterned)
              {
                shape.FillFormat = fillFormat;
                List<DictionaryEntry> fillTransformation3 = new List<DictionaryEntry>();
                List<DictionaryEntry> fillTransformation4 = new List<DictionaryEntry>();
                if (fillFormat.FillSchemeColorTransforms.Count > 0)
                {
                  for (int index = 0; index < fillFormat.FillSchemeColorTransforms.Count; ++index)
                  {
                    if (fillFormat.FillSchemeColorTransforms[index].Key.ToString().StartsWith("fgClr"))
                      fillTransformation3.Add(fillFormat.FillSchemeColorTransforms[index]);
                    if (fillFormat.FillSchemeColorTransforms[index].Key.ToString().StartsWith("bgClr"))
                      fillTransformation4.Add(fillFormat.FillSchemeColorTransforms[index]);
                  }
                  shape.FillFormat.ForeColor = shape.StyleColorTransform(fillTransformation3, color2, ref maxValue);
                  maxValue = uint.MaxValue;
                  shape.FillFormat.Color = shape.StyleColorTransform(fillTransformation4, color2, ref maxValue);
                  maxValue = uint.MaxValue;
                }
                else
                {
                  shape.FillFormat.Color = fillFormat.Color.IsEmpty ? color2 : fillFormat.Color;
                  shape.FillFormat.ForeColor = fillFormat.ForeColor.IsEmpty ? color2 : fillFormat.ForeColor;
                }
              }
              else if (fillFormat.FillType == FillType.FillPicture || fillFormat.FillType == FillType.FillTextured || fillFormat.FillType == FillType.FillMixed)
                shape.FillFormat = fillFormat;
            }
            flag = false;
            break;
          case "effectRef":
            int num3 = Convert.ToInt32(reader.GetAttribute("idx"));
            Color color3 = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            shapeStyleReference2.StyleRefIndex = num3;
            shapeStyleReference2.StyleRefColor = color3;
            if (maxValue != uint.MaxValue)
              shapeStyleReference2.StyleRefOpacity = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
            shape.ShapeStyleReferences.Add(shapeStyleReference2);
            if (!shape.IsEffectStyleInline && num3 != 0)
            {
              if (num3 > this.m_doc.Themes.FmtScheme.EffectStyles.Count)
                num3 = this.m_doc.Themes.FmtScheme.EffectStyles.Count;
              shape.EffectList.Add(this.m_doc.Themes.FmtScheme.EffectStyles[num3 - 1]);
              foreach (EffectFormat effect in shape.EffectList)
              {
                if (effect.IsShadowEffect && effect.ShadowFormat.Color.IsEmpty)
                {
                  effect.ShadowFormat.Color = color3;
                  if (maxValue != uint.MaxValue)
                    effect.ShadowFormat.Transparency = (float) maxValue;
                }
                if (effect.IsShapeProperties)
                {
                  if (effect.ThreeDFormat.HasContourColor && effect.ThreeDFormat.ContourColor.IsEmpty)
                  {
                    effect.ThreeDFormat.ContourColor = color3;
                    if (maxValue != uint.MaxValue)
                      effect.ThreeDFormat.ContourOpacity = (float) maxValue;
                  }
                  if (effect.ThreeDFormat.HasExtrusionColor && effect.ThreeDFormat.ExtrusionColor.IsEmpty)
                  {
                    effect.ThreeDFormat.ExtrusionColor = color3;
                    if (maxValue != uint.MaxValue)
                      effect.ThreeDFormat.ExtrusionOpacity = (float) maxValue;
                  }
                }
              }
            }
            flag = false;
            break;
          case "fontRef":
            string attribute = reader.GetAttribute("idx");
            shape.FontRefColor = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            shapeStyleReference2.StyleRefIndex = attribute == "minor" ? 1 : 2;
            shapeStyleReference2.StyleRefColor = shape.FontRefColor;
            if (maxValue != uint.MaxValue)
              shapeStyleReference2.StyleRefOpacity = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
            shape.ShapeStyleReferences.Add(shapeStyleReference2);
            flag = false;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseShapeAdjustValues(XmlReader reader, Shape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "avLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "avLst")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "gd":
            string attribute1 = reader.GetAttribute("name");
            string attribute2 = reader.GetAttribute("fmla");
            if (!string.IsNullOrEmpty(attribute1) && !string.IsNullOrEmpty(attribute2))
            {
              shape.ShapeGuide.Add(attribute1, attribute2);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseShapeAdjustValues(XmlReader reader, ChildShape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "avLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "avLst")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "gd":
            string attribute1 = reader.GetAttribute("name");
            string attribute2 = reader.GetAttribute("fmla");
            if (!string.IsNullOrEmpty(attribute1) && !string.IsNullOrEmpty(attribute2))
            {
              shape.ShapeGuide.Add(attribute1, attribute2);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseBlipFill(XmlReader reader, FillFormat fillFormat)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    fillFormat.RotateWithObject = this.GetBoolValue(reader.GetAttribute("rotWithShape"));
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string empty = string.Empty;
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == localName2))
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "blip":
            string attribute1 = reader.GetAttribute("cstate");
            if (!string.IsNullOrEmpty(attribute1) && attribute1.Length > 2)
              fillFormat.BlipCompressionMode = System.Enum.IsDefined(typeof (BlipCompressionType), (object) (char.ToUpper(attribute1[0]).ToString() + attribute1.Substring(1))) ? (BlipCompressionType) System.Enum.Parse(typeof (BlipCompressionType), attribute1, true) : BlipCompressionType.None;
            string attribute2 = reader.GetAttribute("embed", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            string attribute3 = reader.GetAttribute("link", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            if (!string.IsNullOrEmpty(attribute2))
            {
              bool isImageRelation = true;
              string imageName = this.GetImageName(attribute2, isHeaderFooter, false, ref isImageRelation);
              if (isImageRelation)
              {
                if (this.ImageIds.ContainsKey(imageName))
                {
                  fillFormat.ImageRecord = new ImageRecord(this.m_doc, this.m_doc.Images[this.ImageIds[imageName]]);
                  ++fillFormat.ImageRecord.OccurenceCount;
                }
                else
                {
                  byte[] imageBytes = this.GetImageBytes(imageName);
                  fillFormat.ImageRecord = new ImageRecord(this.m_doc, imageBytes);
                }
              }
            }
            else if (!string.IsNullOrEmpty(attribute3))
            {
              Image image = this.GetLinkedImageBytes(attribute3, isHeaderFooter, false) ?? Image.FromStream(WPicture.GetManifestResourceStream("ImageNotFound.jpg"), true, false);
              MemoryStream memoryStream = new MemoryStream();
              image.Save((Stream) memoryStream, image.RawFormat);
              byte[] array = memoryStream.ToArray();
              fillFormat.ImageRecord = new ImageRecord(this.m_doc, array);
              memoryStream.Dispose();
            }
            this.ParseBlipImage(reader, fillFormat.BlipFormat, (WPicture) null);
            break;
          case "srcRect":
            string attribute4 = reader.GetAttribute("b");
            if (!string.IsNullOrEmpty(attribute4))
              fillFormat.SourceRectangle.BottomOffset = this.GetPropertyValue(attribute4, "srcRect");
            string attribute5 = reader.GetAttribute("l");
            if (!string.IsNullOrEmpty(attribute5))
              fillFormat.SourceRectangle.LeftOffset = this.GetPropertyValue(attribute5, "srcRect");
            string attribute6 = reader.GetAttribute("r");
            if (!string.IsNullOrEmpty(attribute6))
              fillFormat.SourceRectangle.RightOffset = this.GetPropertyValue(attribute6, "srcRect");
            string attribute7 = reader.GetAttribute("t");
            if (!string.IsNullOrEmpty(attribute7))
            {
              fillFormat.SourceRectangle.TopOffset = this.GetPropertyValue(attribute7, "srcRect");
              break;
            }
            break;
          case "stretch":
            fillFormat.FillRectangle.HasAttributes = this.ParseFillRectangle(reader, fillFormat);
            break;
          case "tile":
            fillFormat.TextureTile = true;
            fillFormat.TextureAlignment = this.GetTextureAlignment(reader.GetAttribute("algn"));
            double result1 = 0.0;
            double result2 = 0.0;
            double result3 = 0.0;
            double result4 = 0.0;
            string attribute8 = reader.GetAttribute("tx");
            if (!string.IsNullOrEmpty(attribute8) && double.TryParse(attribute8, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1))
              fillFormat.TextureOffsetX = result1 / 12700.0;
            string attribute9 = reader.GetAttribute("ty");
            if (!string.IsNullOrEmpty(attribute9) && double.TryParse(attribute9, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2))
              fillFormat.TextureOffsetY = result2 / 12700.0;
            string attribute10 = reader.GetAttribute("sx");
            if (!string.IsNullOrEmpty(attribute10) && double.TryParse(attribute10, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result3))
              fillFormat.TextureHorizontalScale = result3 / 1000.0;
            string attribute11 = reader.GetAttribute("sy");
            if (!string.IsNullOrEmpty(attribute11) && double.TryParse(attribute11, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result4))
              fillFormat.TextureVerticalScale = result4 / 1000.0;
            fillFormat.FlipOrientation = this.GetFlipOrientation(reader.GetAttribute("flip"));
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseBlipImage(XmlReader reader, BlipFormat blipFormat, WPicture picture)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string empty = string.Empty;
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == localName2))
    {
      uint maxValue1 = uint.MaxValue;
      if (reader.NodeType == XmlNodeType.Element)
      {
        bool flag = false;
        switch (reader.LocalName.ToLower())
        {
          case "alphabilevel":
            string attribute1 = reader.GetAttribute("thresh");
            if (!string.IsNullOrEmpty(attribute1))
            {
              blipFormat.Threshold = this.GetBlipImageValue(attribute1);
              break;
            }
            break;
          case "alphaceiling":
            blipFormat.BlipTransparency = BlipTransparency.AlphaCeiling;
            break;
          case "alphafloor":
            blipFormat.BlipTransparency = BlipTransparency.AlphaFloor;
            break;
          case "grayscl":
            blipFormat.BlipTransparency = BlipTransparency.GrayScale;
            break;
          case "filloverlay":
            blipFormat.BlipTransparency = BlipTransparency.FillOverlay;
            break;
          case "alphamod":
            blipFormat.BlipTransparency = BlipTransparency.AlphaMod;
            break;
          case "alphainv":
            blipFormat.InverseColor = this.ParseColor(reader, "alphaInv", ref maxValue1, reader.LocalName, false);
            if (maxValue1 != uint.MaxValue)
            {
              float num = (float) Math.Round(1.0 - (double) maxValue1 / 65536.0, 2);
              blipFormat.InverseOpacity = 1f - num;
              break;
            }
            break;
          case "alpharepl":
            string attribute2 = reader.GetAttribute("a");
            if (!string.IsNullOrEmpty(attribute2))
            {
              blipFormat.AlphaReplaceAmount = this.GetBlipImageValue(attribute2);
              break;
            }
            break;
          case "bilevel":
            string attribute3 = reader.GetAttribute("thresh");
            if (!string.IsNullOrEmpty(attribute3))
            {
              blipFormat.BilevelThreshold = this.GetBlipImageValue(attribute3);
              break;
            }
            break;
          case "blur":
            string attribute4 = reader.GetAttribute("grow");
            if (!string.IsNullOrEmpty(attribute4))
              blipFormat.Grow = this.GetBoolValue(attribute4);
            string attribute5 = reader.GetAttribute("rad");
            if (!string.IsNullOrEmpty(attribute5))
            {
              blipFormat.BlurRadius = this.GetBlipImageValue(attribute5);
              break;
            }
            break;
          case "clrchange":
            string attribute6 = reader.GetAttribute("useA");
            if (!string.IsNullOrEmpty(attribute6))
              blipFormat.HasAlpha = this.GetBoolValue(attribute6);
            this.ParseColorChange(reader, blipFormat);
            break;
          case "hsl":
            string attribute7 = reader.GetAttribute("hue");
            if (!string.IsNullOrEmpty(attribute7))
              blipFormat.Hue = this.GetBlipImageValue(attribute7);
            string attribute8 = reader.GetAttribute("lum");
            if (!string.IsNullOrEmpty(attribute8))
              blipFormat.Luminance = this.GetBlipImageValue(attribute8);
            string attribute9 = reader.GetAttribute("sat");
            if (!string.IsNullOrEmpty(attribute9))
            {
              blipFormat.Saturation = this.GetBlipImageValue(attribute9);
              break;
            }
            break;
          case "lum":
            string attribute10 = reader.GetAttribute("bright");
            if (!string.IsNullOrEmpty(attribute10))
              blipFormat.Brightness = this.GetBlipImageValue(attribute10);
            string attribute11 = reader.GetAttribute("contrast");
            if (!string.IsNullOrEmpty(attribute11))
            {
              blipFormat.Contrast = this.GetBlipImageValue(attribute11);
              break;
            }
            break;
          case "tint":
            string attribute12 = reader.GetAttribute("amt");
            if (!string.IsNullOrEmpty(attribute12))
              blipFormat.TintAmount = this.GetBlipImageValue(attribute12);
            string attribute13 = reader.GetAttribute("hue");
            if (!string.IsNullOrEmpty(attribute13))
            {
              blipFormat.TintHue = this.GetBlipImageValue(attribute13);
              break;
            }
            break;
          case "duotone":
            uint maxValue2 = uint.MaxValue;
            blipFormat.DuotoneColor = this.ParseDuotoneColor(reader, reader.LocalName, ref maxValue2, blipFormat);
            if (maxValue2 != uint.MaxValue)
            {
              float num = (float) Math.Round(1.0 - (double) maxValue2 / 65536.0, 2);
              blipFormat.DuotoneOpacity = 1f - num;
              break;
            }
            break;
          case "extlst":
            this.ParseBlipExtensionList(reader, blipFormat, picture);
            break;
          case "alphamodfix":
            string attribute14 = reader.GetAttribute("amt");
            if (!string.IsNullOrEmpty(attribute14))
            {
              if (attribute14.EndsWith("%"))
              {
                float result = 0.0f;
                float.TryParse(attribute14.Replace("%", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                blipFormat.Transparency = result / 100f;
                break;
              }
              blipFormat.Transparency = this.GetBlipImageValue(attribute14);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private float GetBlipImageValue(string attrValue)
  {
    float result = 0.0f;
    float.TryParse(attrValue, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    return (float) Math.Round(100.0 - (double) result / 1000.0);
  }

  private Color ParseDuotoneColor(
    XmlReader reader,
    string parentElement,
    ref uint opacity,
    BlipFormat blipFormat)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != parentElement)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    Color themeColor = Color.Empty;
    if (reader.IsEmptyElement)
      return themeColor;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return themeColor;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != parentElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "srgbClr":
            themeColor = this.GetHexColor(reader.GetAttribute("val"));
            this.ParseColorTransform(reader, "srgbClr", ref themeColor, ref opacity);
            break;
          case "scrgbClr":
            themeColor = Color.FromArgb((int) byte.MaxValue, (int) (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("r")) / 100.0)), (int) (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("g")) / 100.0)), (int) (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("b")) / 100.0)));
            this.ParseColorTransform(reader, "scrgbClr", ref themeColor, ref opacity);
            break;
          case "prstClr":
            themeColor = Color.FromName(reader.GetAttribute("val"));
            this.ParseColorTransform(reader, "prstClr", ref themeColor, ref opacity);
            if (themeColor != Color.Empty)
            {
              blipFormat.DuotonePresetColor = themeColor;
              break;
            }
            break;
          case "hslClr":
            double result = 0.0;
            double.TryParse(reader.GetAttribute("hue"), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
            double hue = result / 60000.0 / 360.0;
            double luminance = this.GetPercentage(reader.GetAttribute("lum")) / 100.0;
            double saturation = this.GetPercentage(reader.GetAttribute("sat")) / 100.0;
            themeColor = WordColor.ConvertHSLToColor(hue, saturation, luminance);
            this.ParseColorTransform(reader, "hslClr", ref themeColor, ref opacity);
            break;
          case "sysClr":
            themeColor = this.GetSystemColor(reader);
            this.ParseColorTransform(reader, "sysClr", ref themeColor, ref opacity);
            break;
          case "schemeClr":
            themeColor = this.GetSchemeColor(reader);
            this.ParseColorTransform(reader, "schemeClr", ref themeColor, ref opacity);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return themeColor;
  }

  private void ParseBlipExtensionList(XmlReader reader, BlipFormat blipFormat, WPicture picture)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "extLst")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "ext":
            string attribute = reader.GetAttribute("uri");
            if (!string.IsNullOrEmpty(attribute))
              blipFormat.ExtensionURI.Add(attribute.ToString());
            this.ParseImageProperties(reader, blipFormat, picture);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseImageProperties(XmlReader reader, BlipFormat blipFormat, WPicture picture)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    bool flag = false;
    while (reader.LocalName != "ext")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "imgProps":
            blipFormat.ExtensionURI.Add(reader.LocalName);
            this.ParseImageLayer(reader, blipFormat);
            break;
          case "useLocalDpi":
            blipFormat.ExtensionURI.Add(reader.LocalName);
            string attribute = reader.GetAttribute("val");
            blipFormat.HasCompression = this.GetBoolValue(attribute);
            break;
          case "svgBlip":
            blipFormat.ExtensionURI.Add(reader.LocalName);
            this.ReadSvgData(reader, picture);
            break;
          default:
            byte[] array = this.ReadSingleNodeIntoStream(reader).ToArray();
            string str = Encoding.UTF8.GetString(array, 0, array.Length);
            blipFormat.ExtensionURI.Add(str);
            flag = true;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ReadSvgData(XmlReader reader, WPicture picture)
  {
    string attribute1 = reader.GetAttribute("embed", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    string attribute2 = reader.GetAttribute("link", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
    bool isImageRelation = true;
    if (!string.IsNullOrEmpty(attribute1))
    {
      string imageName = this.GetImageName(attribute1, isHeaderFooter, false, ref isImageRelation);
      if (!isImageRelation)
        return;
      if (this.SvgDataDict.ContainsKey(imageName))
      {
        picture.SvgData = this.SvgDataDict[imageName];
      }
      else
      {
        picture.SvgData = this.GetImageBytes(imageName);
        this.SvgDataDict.Add(imageName, picture.SvgData);
      }
    }
    else
    {
      if (string.IsNullOrEmpty(attribute2))
        return;
      string imageName = this.GetImageName(attribute2, isHeaderFooter, false, ref isImageRelation);
      if (!isImageRelation)
        return;
      picture.SvgData = this.GetSvgImageData(imageName);
      if (picture.SvgData == null)
        return;
      picture.SvgExternalLink = imageName;
    }
  }

  private void ParseImageLayer(XmlReader reader, BlipFormat blipFormat)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "imgProps")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "imgLayer":
            string attribute = reader.GetAttribute("embed", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            if (!string.IsNullOrEmpty(attribute))
            {
              bool isImageRelation = true;
              string imageName = this.GetImageName(attribute, isHeaderFooter, false, ref isImageRelation);
              if (isImageRelation)
              {
                if (this.ImageIds.ContainsKey(imageName))
                {
                  blipFormat.ImageRecord = new ImageRecord(this.m_doc, this.m_doc.Images[this.ImageIds[imageName]]);
                  ++blipFormat.ImageRecord.OccurenceCount;
                }
                else
                {
                  byte[] imageBytes = this.GetImageBytes(imageName);
                  blipFormat.ImageRecord = new ImageRecord(this.m_doc, imageBytes);
                }
              }
            }
            this.ParseImageEffect(reader, blipFormat);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseImageEffect(XmlReader reader, BlipFormat blipFormat)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "imgLayer")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "imgEffect":
            this.ParseImageEffectItem(reader, blipFormat.ImageEffect);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseImageEffectItem(XmlReader reader, ImageEffect imageEffect)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "imgEffect")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "sharpenSoften":
            string attribute1 = reader.GetAttribute("amount");
            if (!string.IsNullOrEmpty(attribute1))
            {
              imageEffect.SharpenAmount = this.GetImageEffectValue(attribute1);
              break;
            }
            break;
          case "colorTemperature":
            string attribute2 = reader.GetAttribute("colorTemp");
            if (!string.IsNullOrEmpty(attribute2))
            {
              imageEffect.ColorTemprature = this.GetImageEffectValue(attribute2);
              break;
            }
            break;
          case "saturation":
            string attribute3 = reader.GetAttribute("sat");
            if (!string.IsNullOrEmpty(attribute3))
            {
              imageEffect.Saturation = this.GetImageEffectValue(attribute3);
              break;
            }
            break;
          case "brightnessContrast":
            string attribute4 = reader.GetAttribute("bright");
            if (!string.IsNullOrEmpty(attribute4))
              imageEffect.Brightness = this.GetImageEffectValue(attribute4);
            string attribute5 = reader.GetAttribute("contrast");
            if (!string.IsNullOrEmpty(attribute5))
            {
              imageEffect.Contrast = this.GetImageEffectValue(attribute5);
              break;
            }
            break;
          case "artisticBlur":
            string attribute6 = reader.GetAttribute("radius");
            if (!string.IsNullOrEmpty(attribute6))
            {
              imageEffect.BlurRadius = this.GetImageEffectValue(attribute6);
              break;
            }
            break;
          case "artisticCement":
            string attribute7 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute7))
              imageEffect.CementTransparency = this.GetImageEffectValue(attribute7);
            string attribute8 = reader.GetAttribute("crackSpacing");
            if (!string.IsNullOrEmpty(attribute8))
            {
              imageEffect.CementCracking = this.GetImageEffectValue(attribute8);
              break;
            }
            break;
          case "artisticChalkSketch":
            string attribute9 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute9))
              imageEffect.ChalkSketchTransparency = this.GetImageEffectValue(attribute9);
            string attribute10 = reader.GetAttribute("pressure");
            if (!string.IsNullOrEmpty(attribute10))
            {
              imageEffect.ChalkSketchPressure = this.GetImageEffectValue(attribute10);
              break;
            }
            break;
          case "artisticCrisscrossEtching":
            string attribute11 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute11))
              imageEffect.CrisscrossEtchingTransparency = this.GetImageEffectValue(attribute11);
            string attribute12 = reader.GetAttribute("pressure");
            if (!string.IsNullOrEmpty(attribute12))
            {
              imageEffect.CrisscrossEtchingPressure = this.GetImageEffectValue(attribute12);
              break;
            }
            break;
          case "artisticCutout":
            string attribute13 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute13))
              imageEffect.CutoutTransparency = this.GetImageEffectValue(attribute13);
            string attribute14 = reader.GetAttribute("numberOfShades");
            if (!string.IsNullOrEmpty(attribute14))
            {
              imageEffect.CutoutShades = this.GetImageEffectValue(attribute14);
              break;
            }
            break;
          case "artisticFilmGrain":
            string attribute15 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute15))
              imageEffect.GrainTransparency = this.GetImageEffectValue(attribute15);
            string attribute16 = reader.GetAttribute("grainSize");
            if (!string.IsNullOrEmpty(attribute16))
            {
              imageEffect.GrainSize = this.GetImageEffectValue(attribute16);
              break;
            }
            break;
          case "artisticGlass":
            string attribute17 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute17))
              imageEffect.GlassTransparency = this.GetImageEffectValue(attribute17);
            string attribute18 = reader.GetAttribute("scaling");
            if (!string.IsNullOrEmpty(attribute18))
            {
              imageEffect.GlassScaling = this.GetImageEffectValue(attribute18);
              break;
            }
            break;
          case "artisticGlowDiffused":
            string attribute19 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute19))
              imageEffect.GlowDiffusedTransparency = this.GetImageEffectValue(attribute19);
            string attribute20 = reader.GetAttribute("intensity");
            if (!string.IsNullOrEmpty(attribute20))
            {
              imageEffect.GlowDiffusedIntensity = this.GetImageEffectValue(attribute20);
              break;
            }
            break;
          case "artisticGlowEdges":
            string attribute21 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute21))
              imageEffect.GlowEdgesTransparency = this.GetImageEffectValue(attribute21);
            string attribute22 = reader.GetAttribute("smoothness");
            if (!string.IsNullOrEmpty(attribute22))
            {
              imageEffect.GlowEdgesSmoothness = this.GetImageEffectValue(attribute22);
              break;
            }
            break;
          case "artisticLightScreen":
            string attribute23 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute23))
              imageEffect.LightScreenTransparency = this.GetImageEffectValue(attribute23);
            string attribute24 = reader.GetAttribute("gridSize");
            if (!string.IsNullOrEmpty(attribute24))
            {
              imageEffect.LightScreenGrid = this.GetImageEffectValue(attribute24);
              break;
            }
            break;
          case "artisticLineDrawing":
            string attribute25 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute25))
              imageEffect.LineDrawingTransparency = this.GetImageEffectValue(attribute25);
            string attribute26 = reader.GetAttribute("pencilSize");
            if (!string.IsNullOrEmpty(attribute26))
            {
              imageEffect.LineDrawingPensilSize = this.GetImageEffectValue(attribute26);
              break;
            }
            break;
          case "artisticMarker":
            string attribute27 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute27))
              imageEffect.MarkerTransparency = this.GetImageEffectValue(attribute27);
            string attribute28 = reader.GetAttribute("size");
            if (!string.IsNullOrEmpty(attribute28))
            {
              imageEffect.MarkerSize = this.GetImageEffectValue(attribute28);
              break;
            }
            break;
          case "artisticMosiaicBubbles":
            string attribute29 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute29))
              imageEffect.MosiaicBubbleTransparency = this.GetImageEffectValue(attribute29);
            string attribute30 = reader.GetAttribute("pressure");
            if (!string.IsNullOrEmpty(attribute30))
            {
              imageEffect.MosiaicBubblePressure = this.GetImageEffectValue(attribute30);
              break;
            }
            break;
          case "artisticPaintStrokes":
            string attribute31 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute31))
              imageEffect.StrokeTransparency = this.GetImageEffectValue(attribute31);
            string attribute32 = reader.GetAttribute("intensity");
            if (!string.IsNullOrEmpty(attribute32))
            {
              imageEffect.StrokeIntensity = this.GetImageEffectValue(attribute32);
              break;
            }
            break;
          case "artisticPaintBrush":
            string attribute33 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute33))
              imageEffect.BrushTransparency = this.GetImageEffectValue(attribute33);
            string attribute34 = reader.GetAttribute("brushSize");
            if (!string.IsNullOrEmpty(attribute34))
            {
              imageEffect.BrushSize = this.GetImageEffectValue(attribute34);
              break;
            }
            break;
          case "artisticPastelsSmooth":
            string attribute35 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute35))
              imageEffect.PastelTransparency = this.GetImageEffectValue(attribute35);
            string attribute36 = reader.GetAttribute("brushSize");
            if (!string.IsNullOrEmpty(attribute36))
            {
              imageEffect.PastelSize = this.GetImageEffectValue(attribute36);
              break;
            }
            break;
          case "artisticPencilGrayscale":
            string attribute37 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute37))
              imageEffect.PencilGrayScaleTransparency = this.GetImageEffectValue(attribute37);
            string attribute38 = reader.GetAttribute("pencilSize");
            if (!string.IsNullOrEmpty(attribute38))
            {
              imageEffect.PencilGraySize = this.GetImageEffectValue(attribute38);
              break;
            }
            break;
          case "artisticPencilSketch":
            string attribute39 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute39))
              imageEffect.PencilSketchTransparency = this.GetImageEffectValue(attribute39);
            string attribute40 = reader.GetAttribute("pencilSize");
            if (!string.IsNullOrEmpty(attribute40))
            {
              imageEffect.PencilSketchSize = this.GetImageEffectValue(attribute40);
              break;
            }
            break;
          case "artisticPhotocopy":
            string attribute41 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute41))
              imageEffect.PhotocopyTransparency = this.GetImageEffectValue(attribute41);
            string attribute42 = reader.GetAttribute("detail");
            if (!string.IsNullOrEmpty(attribute42))
            {
              imageEffect.PhotocopySize = this.GetImageEffectValue(attribute42);
              break;
            }
            break;
          case "artisticPlasticWrap":
            string attribute43 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute43))
              imageEffect.PlasticWrapTransparency = this.GetImageEffectValue(attribute43);
            string attribute44 = reader.GetAttribute("smoothness");
            if (!string.IsNullOrEmpty(attribute44))
            {
              imageEffect.PlasticWrapSmoothness = this.GetImageEffectValue(attribute44);
              break;
            }
            break;
          case "artisticTexturizer":
            string attribute45 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute45))
              imageEffect.TexturizerTransparency = this.GetImageEffectValue(attribute45);
            string attribute46 = reader.GetAttribute("scaling");
            if (!string.IsNullOrEmpty(attribute46))
            {
              imageEffect.TexturizerSize = this.GetImageEffectValue(attribute46);
              break;
            }
            break;
          case "artisticWatercolorSponge":
            string attribute47 = reader.GetAttribute("trans");
            if (!string.IsNullOrEmpty(attribute47))
              imageEffect.TexturizerTransparency = this.GetImageEffectValue(attribute47);
            string attribute48 = reader.GetAttribute("brushSize");
            if (!string.IsNullOrEmpty(attribute48))
            {
              imageEffect.TexturizerSize = this.GetImageEffectValue(attribute48);
              break;
            }
            break;
          case "backgroundRemoval":
            imageEffect.HasBackgroundRemovalEffect = true;
            string attribute49 = reader.GetAttribute("t");
            if (!string.IsNullOrEmpty(attribute49))
              imageEffect.BackgroundRemovalRectangle.TopOffset = this.GetImageEffectValue(attribute49) / 1000f;
            string attribute50 = reader.GetAttribute("b");
            if (!string.IsNullOrEmpty(attribute50))
              imageEffect.BackgroundRemovalRectangle.BottomOffset = this.GetImageEffectValue(attribute50) / 1000f;
            string attribute51 = reader.GetAttribute("l");
            if (!string.IsNullOrEmpty(attribute51))
              imageEffect.BackgroundRemovalRectangle.LeftOffset = this.GetImageEffectValue(attribute51) / 1000f;
            string attribute52 = reader.GetAttribute("r");
            if (!string.IsNullOrEmpty(attribute52))
              imageEffect.BackgroundRemovalRectangle.RightOffset = this.GetImageEffectValue(attribute52) / 1000f;
            this.ParseBackgroundRemoval(reader, imageEffect);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private float GetImageEffectValue(string value)
  {
    float result = 0.0f;
    if (value.EndsWith("%"))
    {
      float.TryParse(value.Replace("%", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result *= 1000f;
    }
    else
      float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    return result;
  }

  private void ParseBackgroundRemoval(XmlReader reader, ImageEffect imageEffect)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "backgroundRemoval")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "foregroundMark":
          case "backgroundMark":
            string attribute1 = reader.GetAttribute("x1");
            string attribute2 = reader.GetAttribute("y1");
            string attribute3 = reader.GetAttribute("x2");
            string attribute4 = reader.GetAttribute("y2");
            float result1 = 0.0f;
            float result2 = 0.0f;
            float result3 = 0.0f;
            float result4 = 0.0f;
            if (!string.IsNullOrEmpty(attribute1))
              float.TryParse(attribute1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
            if (!string.IsNullOrEmpty(attribute2))
              float.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result3);
            if (!string.IsNullOrEmpty(attribute3))
              float.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
            if (!string.IsNullOrEmpty(attribute4))
              float.TryParse(attribute4, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result4);
            if (reader.LocalName == "foregroundMark")
            {
              imageEffect.ForegroundVertices.Add(new PointF(result1, result3));
              imageEffect.ForegroundVertices.Add(new PointF(result2, result4));
              break;
            }
            imageEffect.BackgroundVertices.Add(new PointF(result1, result3));
            imageEffect.BackgroundVertices.Add(new PointF(result2, result4));
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseColorChange(XmlReader reader, BlipFormat blipFormat)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    string empty = string.Empty;
    while (!(reader.LocalName == localName))
    {
      uint maxValue = uint.MaxValue;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "clrFrom":
            blipFormat.ColorFrom = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (maxValue != uint.MaxValue)
            {
              float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
              blipFormat.ColorFromOpacity = 1f - num;
              break;
            }
            break;
          case "clrTo":
            blipFormat.ColorTo = this.ParseColor(reader, reader.LocalName, ref maxValue, reader.LocalName, false);
            if (maxValue != uint.MaxValue)
            {
              float num = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
              blipFormat.ColorToOpacity = 1f - num;
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private bool ParseFillRectangle(XmlReader reader, FillFormat fillFormat)
  {
    if (reader.IsEmptyElement)
      return false;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return false;
    string str = localName;
    this.SkipWhitespaces(reader);
    if (!reader.HasAttributes)
      return false;
    string empty = string.Empty;
    bool fillRectangle = false;
    while (!(reader.LocalName == str))
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "fillRect":
            int result = 0;
            string attribute1 = reader.GetAttribute("b");
            if (!string.IsNullOrEmpty(attribute1) && int.TryParse(attribute1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              fillFormat.FillRectangle.BottomOffset = (float) (result / 1000);
              fillRectangle = true;
            }
            string attribute2 = reader.GetAttribute("l");
            if (!string.IsNullOrEmpty(attribute2) && int.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              fillFormat.FillRectangle.LeftOffset = (float) (result / 1000);
              fillRectangle = true;
            }
            string attribute3 = reader.GetAttribute("r");
            if (!string.IsNullOrEmpty(attribute3) && int.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              fillFormat.FillRectangle.RightOffset = (float) (result / 1000);
              fillRectangle = true;
            }
            string attribute4 = reader.GetAttribute("t");
            if (!string.IsNullOrEmpty(attribute4) && int.TryParse(attribute4, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              fillFormat.FillRectangle.TopOffset = (float) (result / 1000);
              fillRectangle = true;
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return fillRectangle;
  }

  private TextureAlignment GetTextureAlignment(string textureAlign)
  {
    switch (textureAlign)
    {
      case "b":
        return TextureAlignment.Bottom;
      case "bl":
        return TextureAlignment.BottomLeft;
      case "br":
        return TextureAlignment.BottomRight;
      case "ctr":
        return TextureAlignment.Center;
      case "l":
        return TextureAlignment.Left;
      case "r":
        return TextureAlignment.Right;
      case "t":
        return TextureAlignment.Top;
      case "tl":
        return TextureAlignment.TopLeft;
      case "tr":
        return TextureAlignment.TopRight;
      default:
        return TextureAlignment.AlignmentMixed;
    }
  }

  private PatternType GetPatternType(string value)
  {
    switch (value)
    {
      case "cross":
        return PatternType.Cross;
      case "dashDnDiag":
        return PatternType.DashedDownwardDiagonal;
      case "dashHorz":
        return PatternType.DashedHorizontal;
      case "dashUpDiag":
        return PatternType.DashedUpwardDiagonal;
      case "dashVert":
        return PatternType.DashedVertical;
      case "diagBrick":
        return PatternType.DiagonalBrick;
      case "diagCross":
        return PatternType.DiagonalCross;
      case "divot":
        return PatternType.Divot;
      case "dkDnDiag":
        return PatternType.DarkDownwardDiagonal;
      case "dkHorz":
        return PatternType.DarkHorizontal;
      case "dkUpDiag":
        return PatternType.DarkUpwardDiagonal;
      case "dkVert":
        return PatternType.DarkVertical;
      case "dnDiag":
        return PatternType.DownwardDiagonal;
      case "dotDmnd":
        return PatternType.DottedDiamond;
      case "dotGrid":
        return PatternType.DottedGrid;
      case "horz":
        return PatternType.Horizontal;
      case "horzBrick":
        return PatternType.HorizontalBrick;
      case "lgCheck":
        return PatternType.LargeCheckerBoard;
      case "lgConfetti":
        return PatternType.LargeConfetti;
      case "lgGrid":
        return PatternType.LargeGrid;
      case "ltDnDiag":
        return PatternType.LightDownwardDiagonal;
      case "ltHorz":
        return PatternType.LightHorizontal;
      case "ltUpDiag":
        return PatternType.LightUpwardDiagonal;
      case "ltVert":
        return PatternType.LightVertical;
      case "narHorz":
        return PatternType.NarrowHorizontal;
      case "narVert":
        return PatternType.NarrowVertical;
      case "openDmnd":
        return PatternType.OutlinedDiamond;
      case "pct10":
        return PatternType.Pattern10Percent;
      case "pct20":
        return PatternType.Pattern20Percent;
      case "pct25":
        return PatternType.Pattern25Percent;
      case "pct30":
        return PatternType.Pattern30Percent;
      case "pct40":
        return PatternType.Pattern40Percent;
      case "pct5":
        return PatternType.Pattern5Percent;
      case "pct50":
        return PatternType.Pattern50Percent;
      case "pct60":
        return PatternType.Pattern60Percent;
      case "pct70":
        return PatternType.Pattern70Percent;
      case "pct75":
        return PatternType.Pattern75Percent;
      case "pct80":
        return PatternType.Pattern80Percent;
      case "pct90":
        return PatternType.Pattern90Percent;
      case "Plaid":
        return PatternType.Plaid;
      case "shingle":
        return PatternType.Shingle;
      case "smCheck":
        return PatternType.SmallCheckerBoard;
      case "smConfetti":
        return PatternType.SmallConfetti;
      case "smGrid":
        return PatternType.SmallGrid;
      case "solidDmnd":
        return PatternType.SolidDiamond;
      case "sphere":
        return PatternType.Sphere;
      case "trellis":
        return PatternType.Trellis;
      case "upDiag":
        return PatternType.UpwardDiagonal;
      case "vert":
        return PatternType.Vertical;
      case "wave":
        return PatternType.Wave;
      case "wdDnDiag":
        return PatternType.WideDownwardDiagonal;
      case "wdUpDiag":
        return PatternType.WideUpwardDiagonal;
      case "weave":
        return PatternType.Weave;
      case "zigZag":
        return PatternType.ZigZag;
      default:
        return PatternType.Pattern5Percent;
    }
  }

  private Syncfusion.DocIO.DLS.TextDirection GetTextDirection(string value, bool isToApplyFarEast)
  {
    switch (value)
    {
      case "vert":
        return Syncfusion.DocIO.DLS.TextDirection.VerticalTopToBottom;
      case "vert270":
        return Syncfusion.DocIO.DLS.TextDirection.VerticalBottomToTop;
      case "mongolianVert":
        return Syncfusion.DocIO.DLS.TextDirection.Vertical;
      case "eaVert":
        return Syncfusion.DocIO.DLS.TextDirection.VerticalFarEast;
      default:
        return isToApplyFarEast ? Syncfusion.DocIO.DLS.TextDirection.HorizontalFarEast : Syncfusion.DocIO.DLS.TextDirection.Horizontal;
    }
  }

  private void ParseLineFormat(XmlReader reader, Shape shape)
  {
    string attribute1 = reader.GetAttribute("w");
    if (!string.IsNullOrEmpty(attribute1))
      shape.LineFormat.Weight = this.GetPropertyValue(attribute1, "w");
    string attribute2 = reader.GetAttribute("cmpd");
    if (!string.IsNullOrEmpty(attribute2))
      shape.LineFormat.Style = this.GetShapeOutLineStyle(attribute2);
    if (reader.GetAttribute("algn") == "in")
      shape.LineFormat.InsetPen = true;
    string attribute3 = reader.GetAttribute("cap");
    if (!string.IsNullOrEmpty(attribute3))
      shape.LineFormat.LineCap = this.GetLineCapStyle(attribute3);
    this.ParseLineProps(reader, shape);
  }

  private void ParseLineFormat(XmlReader reader, ChildShape shape)
  {
    string attribute1 = reader.GetAttribute("w");
    if (!string.IsNullOrEmpty(attribute1))
      shape.LineFormat.Weight = this.GetPropertyValue(attribute1, "w");
    string attribute2 = reader.GetAttribute("cmpd");
    if (!string.IsNullOrEmpty(attribute2))
      shape.LineFormat.Style = this.GetShapeOutLineStyle(attribute2);
    if (reader.GetAttribute("algn") == "in")
      shape.LineFormat.InsetPen = true;
    string attribute3 = reader.GetAttribute("cap");
    if (!string.IsNullOrEmpty(attribute3))
      shape.LineFormat.LineCap = this.GetLineCapStyle(attribute3);
    this.ParseLineProps(reader, shape);
  }

  private LineStyle GetShapeOutLineStyle(string value)
  {
    switch (value)
    {
      case "dbl":
      case "thinThin":
        return LineStyle.ThinThin;
      case "thinThick":
        return LineStyle.ThinThick;
      case "thickThin":
        return LineStyle.ThickThin;
      case "thickBetweenThin":
      case "tri":
        return LineStyle.ThickBetweenThin;
      default:
        return LineStyle.Single;
    }
  }

  private bool ParseImageHyperlink(XmlReader reader, ParagraphItemCollection paraItems)
  {
    reader.ReadToFollowing("hlinkClick", this.IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
    return reader.LocalName == "hlinkClick" && !this.IsHyperLinkField && this.ParseHyperlink(reader, paraItems);
  }

  internal Image DownloadImage(string url)
  {
    if (string.IsNullOrEmpty(url))
      return (Image) null;
    Image image = (Image) null;
    try
    {
      if (this.StartsWithExt(url, "http") || this.StartsWithExt(url, "www"))
      {
        HttpWebRequest httpWebRequest = (HttpWebRequest) WebRequest.Create(url);
        httpWebRequest.AllowWriteStreamBuffering = true;
        WebResponse response = httpWebRequest.GetResponse();
        image = Image.FromStream(response.GetResponseStream());
        response.Close();
      }
      else
      {
        if (this.StartsWithExt(url, "file:///"))
          url = url.Replace("file:///", string.Empty);
        image = Image.FromFile(url);
      }
    }
    catch
    {
      FileLoadException fileLoadException = new FileLoadException("Can't load image, on this url: " + url);
    }
    return image;
  }

  internal byte[] GetSvgImageData(string url)
  {
    if (string.IsNullOrEmpty(url))
      return (byte[]) null;
    try
    {
      if (this.StartsWithExt(url, "http") || this.StartsWithExt(url, "www"))
      {
        HttpWebRequest httpWebRequest = (HttpWebRequest) WebRequest.Create(url);
        httpWebRequest.AllowWriteStreamBuffering = true;
        Stream responseStream = httpWebRequest.GetResponse().GetResponseStream();
        byte[] buffer = new byte[responseStream.Length];
        responseStream.Read(buffer, 0, (int) responseStream.Length);
        responseStream.Dispose();
        return buffer;
      }
      if (this.StartsWithExt(url, "file:///"))
        url = url.Replace("file:///", string.Empty);
      FileStream fileStream = new FileStream(url, FileMode.Open, FileAccess.Read);
      byte[] buffer1 = new byte[fileStream.Length];
      fileStream.Read(buffer1, 0, (int) fileStream.Length);
      fileStream.Dispose();
      return buffer1;
    }
    catch
    {
      FileLoadException fileLoadException = new FileLoadException("Can't load image, on this url: " + url);
    }
    return (byte[]) null;
  }

  private XmlParagraphItem ParseXmlParaItem(Stream XmlParaItemStream)
  {
    XmlParagraphItem xmlParaItem = new XmlParagraphItem(XmlParaItemStream, (IWordDocument) this.m_doc);
    xmlParaItem.ApplyCharacterFormat(this.m_currentRunFormat);
    List<string> relationshipIds1 = this.FindRelationshipIds(XmlParaItemStream);
    this.FindZIndex(XmlParaItemStream, xmlParaItem);
    if (relationshipIds1.Count > 0 && this.m_docRelations != null)
    {
      this.ParseShapeRelationId(xmlParaItem, relationshipIds1);
      int index1 = 0;
      for (int count1 = relationshipIds1.Count; index1 < count1; ++index1)
      {
        string str = relationshipIds1[index1];
        if (!this.ParseImageRelation((ParagraphItem) xmlParaItem, str))
        {
          DictionaryEntry dictionaryEntry = new DictionaryEntry();
          if (this.m_currentFile != null && this.m_currentFile != string.Empty)
          {
            Dictionary<string, DictionaryEntry> fileRelations = this.GetFileRelations(this.m_currentFile);
            if (fileRelations != null)
              dictionaryEntry = fileRelations[str];
          }
          else if (this.m_docRelations.ContainsKey(str))
            dictionaryEntry = this.m_docRelations[str];
          if (str != null && !xmlParaItem.Relations.ContainsKey(str))
            xmlParaItem.Relations.Add(str, dictionaryEntry);
          if (xmlParaItem.Relations.ContainsKey(str))
          {
            string fileName = dictionaryEntry.Value.ToString();
            Part part = this.FindPart(this.GetPartName(ref fileName), fileName);
            if (part != null)
            {
              string currentFile = this.m_currentFile;
              this.m_currentFile = dictionaryEntry.Value.ToString() + ".rels";
              List<string> relationshipIds2 = this.FindRelationshipIds(part.DataStream);
              for (int index2 = 0; index2 < relationshipIds2.Count; ++index2)
              {
                string id = relationshipIds2[index2];
                int count2 = xmlParaItem.ImageRelations.Count;
                this.ParseImageRelation((ParagraphItem) xmlParaItem, id);
                xmlParaItem.HasNestedImageRelations = count2 != xmlParaItem.ImageRelations.Count || xmlParaItem.HasNestedImageRelations;
              }
              this.m_currentFile = currentFile;
            }
          }
        }
      }
    }
    return xmlParaItem;
  }

  private bool ParseImageRelation(GroupShape shape, string id)
  {
    ImageRecord imageRecord = (ImageRecord) null;
    bool isHeaderFooter = this.m_currentFile.StartsWith("header") || this.m_currentFile.StartsWith("footer");
    bool isImageRelation = true;
    string imageName = this.GetImageName(id, isHeaderFooter, false, ref isImageRelation);
    if (this.ImageIds.ContainsKey(imageName))
    {
      imageRecord = this.m_doc.Images[this.ImageIds[imageName]];
      ++imageRecord.OccurenceCount;
    }
    else
    {
      byte[] imageBytes = this.GetImageBytes(imageName);
      if (imageBytes != null && imageBytes.Length > 0)
      {
        imageRecord = this.m_doc.Images.LoadXmlItemImage(imageBytes);
        this.ImageIds.Add(imageName, imageRecord.ImageId);
      }
    }
    if (id != null && imageRecord != null && !shape.ImageRelations.ContainsKey(id))
      shape.ImageRelations.Add(id, imageRecord);
    return imageRecord != null;
  }

  private bool ParseImageRelation(ChildShape shape, string id)
  {
    ImageRecord imageRecord = (ImageRecord) null;
    bool isHeaderFooter = this.m_currentFile.StartsWith("header") || this.m_currentFile.StartsWith("footer");
    bool isImageRelation = true;
    string imageName = this.GetImageName(id, isHeaderFooter, false, ref isImageRelation);
    if (this.ImageIds.ContainsKey(imageName))
    {
      imageRecord = this.m_doc.Images[this.ImageIds[imageName]];
      ++imageRecord.OccurenceCount;
    }
    else
    {
      byte[] imageBytes = this.GetImageBytes(imageName);
      if (imageBytes != null && imageBytes.Length > 0)
      {
        imageRecord = this.m_doc.Images.LoadXmlItemImage(imageBytes);
        this.ImageIds.Add(imageName, imageRecord.ImageId);
      }
    }
    if (id != null && imageRecord != null && !shape.ImageRelations.ContainsKey(id))
      shape.ImageRelations.Add(id, imageRecord);
    return imageRecord != null;
  }

  private bool ParseImageRelation(ParagraphItem paraItem, string id)
  {
    ImageRecord imageRecord = (ImageRecord) null;
    bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
    bool isImageRelation = true;
    string imageName = this.GetImageName(id, isHeaderFooter, false, ref isImageRelation);
    if (isImageRelation)
    {
      if (this.ImageIds.ContainsKey(imageName))
      {
        imageRecord = this.m_doc.Images[this.ImageIds[imageName]];
        ++imageRecord.OccurenceCount;
      }
      else
      {
        byte[] imageBytes = this.GetImageBytes(imageName);
        if (imageBytes != null && imageBytes.Length > 0)
        {
          imageRecord = this.m_doc.Images.LoadXmlItemImage(imageBytes);
          this.ImageIds.Add(imageName, imageRecord.ImageId);
        }
      }
      if (!string.IsNullOrEmpty(id) && imageRecord != null)
      {
        Shape shape = paraItem as Shape;
        XmlParagraphItem xmlParagraphItem = paraItem as XmlParagraphItem;
        if (shape != null)
        {
          if (!shape.ImageRelations.ContainsKey(id))
            shape.ImageRelations.Add(id, imageRecord);
        }
        else if (xmlParagraphItem != null && !xmlParagraphItem.ImageRelations.ContainsKey(id))
          xmlParagraphItem.ImageRelations.Add(id, imageRecord);
      }
    }
    return imageRecord != null;
  }

  private List<string> FindRelationshipIds(Stream XmlParaItemStream)
  {
    XmlParaItemStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(XmlParaItemStream);
    List<string> relationshipIds = new List<string>();
    do
    {
      bool flag = false;
      reader.Read();
      string str1 = string.Empty;
      string str2 = string.Empty;
      switch (reader.LocalName.ToLower())
      {
        case "fill":
        case "chart":
        case "imagedata":
        case "stroke":
        case "control":
        case "oleobject":
        case "hyperlink":
          str1 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          str2 = reader.GetAttribute("href", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          break;
        case "blip":
          str1 = reader.GetAttribute("embed", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          break;
        case "relids":
          string attribute1 = reader.GetAttribute("dm", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute1))
            relationshipIds.Add(attribute1);
          string attribute2 = reader.GetAttribute("lo", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute2))
            relationshipIds.Add(attribute2);
          string attribute3 = reader.GetAttribute("qs", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(attribute3))
            relationshipIds.Add(attribute3);
          str1 = reader.GetAttribute("cs", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
          if (!string.IsNullOrEmpty(str1))
            relationshipIds.Add(str1);
          flag = true;
          break;
      }
      if (!string.IsNullOrEmpty(str1) && !flag)
        relationshipIds.Add(str1);
      if (!string.IsNullOrEmpty(str2))
        relationshipIds.Add(str2);
    }
    while (!reader.EOF);
    return relationshipIds;
  }

  private void FindZIndex(Stream XmlParaItemStream, XmlParagraphItem xmlParaItem)
  {
    XmlParaItemStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(XmlParaItemStream);
    do
    {
      reader.Read();
      if (reader.NodeType == XmlNodeType.Element && reader.HasAttributes)
      {
        string attribute1 = reader.GetAttribute("style");
        string attribute2 = reader.GetAttribute("relativeHeight");
        if (!string.IsNullOrEmpty(attribute1) && attribute1.Contains("z-index"))
        {
          string str = attribute1.Trim();
          int startIndex = str.IndexOf("z-index");
          if (startIndex > -1 && startIndex < str.Length)
            str = str.Substring(startIndex);
          char[] separator = new char[1]{ ';' };
          string[] propertyValues = this.GetPropertyValues(str.Split(separator, StringSplitOptions.RemoveEmptyEntries)[0]);
          if (propertyValues != null && propertyValues[0].Contains("z-index") && !string.IsNullOrEmpty(propertyValues[1]))
          {
            int result = 0;
            int.TryParse(propertyValues[1], NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
            xmlParaItem.ZOrderIndex = result;
            break;
          }
        }
        if (!string.IsNullOrEmpty(attribute2))
        {
          int result = 0;
          int.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
          xmlParaItem.ZOrderIndex = result;
          break;
        }
      }
    }
    while (!reader.EOF);
  }

  private void ParseShapeRelationId(XmlParagraphItem xmlItem, List<string> relationIds)
  {
    int index = 0;
    for (int count = relationIds.Count; index < count; ++index)
    {
      string relationId = relationIds[index];
      if (this.IsExternalHyperlink.ContainsKey(relationId))
        xmlItem.m_shapeHyperlink = relationId;
    }
  }

  private ParagraphItem ParsePicture(XmlReader reader, WPicture picture)
  {
    if (this.m_currentRunFormat != null)
    {
      picture.CharacterFormat.ImportContainer((FormatBase) this.m_currentRunFormat);
      this.ApplyDirectionalOverride(picture.CharacterFormat);
    }
    this.m_currentRunFormat = (WCharacterFormat) null;
    this.ParsePictureProperties(reader, picture);
    return (ParagraphItem) picture;
  }

  private void ParsePictureProperties(XmlReader reader, WPicture picture)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "drawing")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool flag1 = false;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "drawing")
    {
      bool flag2 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "effectExtent":
            picture.DocxProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
            flag2 = true;
            break;
          case "extent":
            string attribute1 = reader.GetAttribute("cx");
            if (!string.IsNullOrEmpty(attribute1))
            {
              if ((double) picture.Width == -3.4028234663852886E+38)
                picture.Width = this.GetPropertyValue(attribute1, "cx");
              else
                picture.SetWidthScaleValue(this.GetPropertyValue(attribute1, "cx") * 100f / picture.Width);
            }
            string attribute2 = reader.GetAttribute("cy");
            if (!string.IsNullOrEmpty(attribute2))
            {
              if ((double) picture.Height == -3.4028234663852886E+38)
              {
                picture.Height = this.GetPropertyValue(attribute2, "cy");
                break;
              }
              picture.SetHeightScaleValue(this.GetPropertyValue(attribute2, "cy") * 100f / picture.Height);
              break;
            }
            break;
          case "positionH":
            this.ParsePictureHorizontalPosition(reader, picture);
            break;
          case "positionV":
            this.ParsePictureVerticalPosition(reader, picture);
            break;
          case "docPr":
            picture.Title = reader.GetAttribute("title");
            picture.AlternativeText = reader.GetAttribute("descr");
            picture.Name = reader.GetAttribute("name");
            string attribute3 = reader.GetAttribute("hidden");
            if (!string.IsNullOrEmpty(attribute3))
            {
              picture.Visible = !this.GetBoolValue(attribute3);
              break;
            }
            break;
          case "wrapSquare":
            picture.SetTextWrappingStyleValue(TextWrappingStyle.Square);
            this.ParseWrappingType(reader, picture);
            break;
          case "wrapTight":
            picture.SetTextWrappingStyleValue(TextWrappingStyle.Tight);
            this.ParseWrappingType(reader, picture);
            this.ParseWrapPolygon(reader, (IEntity) picture);
            break;
          case "wrapThrough":
            picture.SetTextWrappingStyleValue(TextWrappingStyle.Through);
            this.ParseWrappingType(reader, picture);
            this.ParseWrapPolygon(reader, (IEntity) picture);
            break;
          case "wrapTopAndBottom":
            picture.SetTextWrappingStyleValue(TextWrappingStyle.TopAndBottom);
            break;
          case "wrapNone":
            if (!flag1)
            {
              if (picture.IsBelowText)
              {
                picture.SetTextWrappingStyleValue(TextWrappingStyle.Behind);
                break;
              }
              picture.SetTextWrappingStyleValue(TextWrappingStyle.InFrontOfText);
              break;
            }
            break;
          case "anchor":
            if (reader.AttributeCount != 0)
            {
              string attribute4 = reader.GetAttribute("behindDoc");
              picture.IsBelowText = attribute4 == "1" || attribute4 == "true";
              string attribute5 = reader.GetAttribute("layoutInCell");
              picture.LayoutInCell = attribute5 == "1" || attribute5 == "true";
              string attribute6 = reader.GetAttribute("relativeHeight");
              int result = 0;
              int.TryParse(attribute6, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              picture.OrderIndex = result;
              string attribute7 = reader.GetAttribute("distT");
              if (!string.IsNullOrEmpty(attribute7))
                picture.DistanceFromTop = this.GetPointValue(attribute7);
              string attribute8 = reader.GetAttribute("distB");
              if (!string.IsNullOrEmpty(attribute8))
                picture.DistanceFromBottom = this.GetPointValue(attribute8);
              string attribute9 = reader.GetAttribute("distL");
              if (!string.IsNullOrEmpty(attribute9))
                picture.DistanceFromLeft = this.GetPointValue(attribute9);
              string attribute10 = reader.GetAttribute("distR");
              if (!string.IsNullOrEmpty(attribute10))
                picture.DistanceFromRight = this.GetPointValue(attribute10);
              string attribute11 = reader.GetAttribute("allowOverlap");
              if (!string.IsNullOrEmpty(attribute11))
              {
                picture.AllowOverlap = attribute11 == "1" || attribute11 == "true";
                break;
              }
              break;
            }
            break;
          case "cNvGraphicFramePr":
            this.ParseLockAspectRatio(reader, picture);
            break;
          case "graphic":
            reader.Read();
            this.ParseGraphicData(reader, picture);
            break;
          case "inline":
            flag1 = true;
            break;
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag2 = true;
              break;
            }
            break;
        }
        if (!flag2)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseGraphicData(XmlReader reader, WPicture picture)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "graphicData")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "graphicData")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "pic":
            this.ParsePictureData(reader, picture);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseLockAspectRatio(XmlReader reader, WPicture picture)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "cNvGraphicFramePr")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "cNvGraphicFramePr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "graphicFrameLocks":
            string attribute = reader.GetAttribute("noChangeAspect");
            picture.LockAspectRatio = this.GetBoolValue(attribute);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParsePictureData(XmlReader reader, WPicture picture)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "pic")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "pic")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "spPr":
            this.ParseVisualShapeProps(reader, picture);
            break;
          case "blipFill":
            picture.FillFormat.FillType = FillType.FillPicture;
            this.ParsePictureBlipFill(reader, picture);
            break;
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseGroupShapePictureData(XmlReader reader, WPicture picture)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "pic")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "pic")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "spPr":
            this.ParseGroupShapeVisualShapeProps(reader, picture);
            break;
          case "blipFill":
            this.ParsePictureBlipFill(reader, picture);
            break;
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParsePictureBlipFill(XmlReader reader, WPicture picture)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "blipFill")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "blipFill")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "blip":
            string attribute1 = reader.GetAttribute("cstate");
            if (!string.IsNullOrEmpty(attribute1) && attribute1.Length > 2)
              picture.FillFormat.BlipCompressionMode = System.Enum.IsDefined(typeof (BlipCompressionType), (object) (char.ToUpper(attribute1[0]).ToString() + attribute1.Substring(1))) ? (BlipCompressionType) System.Enum.Parse(typeof (BlipCompressionType), attribute1, true) : BlipCompressionType.None;
            string attribute2 = reader.GetAttribute("embed", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            string attribute3 = reader.GetAttribute("link", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            bool isHeaderFooter = this.StartsWithExt(this.m_currentFile, "header") || this.StartsWithExt(this.m_currentFile, "footer");
            if (!string.IsNullOrEmpty(attribute2))
            {
              bool isImageRelation = true;
              string imageName = this.GetImageName(attribute2, isHeaderFooter, false, ref isImageRelation);
              if (isImageRelation)
              {
                if (this.ImageIds.ContainsKey(imageName))
                {
                  picture.FillFormat.ImageRecord = new ImageRecord(this.m_doc, this.m_doc.Images[this.ImageIds[imageName]]);
                  ++picture.FillFormat.ImageRecord.OccurenceCount;
                }
                else
                {
                  byte[] imageBytes = this.GetImageBytes(imageName);
                  picture.FillFormat.ImageRecord = new ImageRecord(this.m_doc, imageBytes);
                }
              }
            }
            else if (!string.IsNullOrEmpty(attribute3))
            {
              Image image = this.GetLinkedImageBytes(attribute3, isHeaderFooter, false) ?? Image.FromStream(WPicture.GetManifestResourceStream("ImageNotFound.jpg"), true, false);
              MemoryStream memoryStream = new MemoryStream();
              image.Save((Stream) memoryStream, image.RawFormat);
              byte[] array = memoryStream.ToArray();
              memoryStream.Dispose();
              picture.FillFormat.ImageRecord = new ImageRecord(this.m_doc, array);
            }
            this.ParseBlipImage(reader, picture.FillFormat.BlipFormat, picture);
            break;
          case "srcRect":
            string attribute4 = reader.GetAttribute("b");
            float result = 0.0f;
            if (!string.IsNullOrEmpty(attribute4) && float.TryParse(attribute4, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
              picture.FillRectangle.BottomOffset = result / 1000f;
            string attribute5 = reader.GetAttribute("l");
            if (!string.IsNullOrEmpty(attribute5) && float.TryParse(attribute5, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
              picture.FillRectangle.LeftOffset = result / 1000f;
            string attribute6 = reader.GetAttribute("r");
            if (!string.IsNullOrEmpty(attribute6) && float.TryParse(attribute6, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
              picture.FillRectangle.RightOffset = result / 1000f;
            string attribute7 = reader.GetAttribute("t");
            if (!string.IsNullOrEmpty(attribute7) && float.TryParse(attribute7, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
            {
              picture.FillRectangle.TopOffset = result / 1000f;
              break;
            }
            break;
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseVisualShapeProps(XmlReader reader, WPicture picture)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "spPr")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "spPr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "xfrm":
            string attribute1 = reader.GetAttribute("rot");
            if (!string.IsNullOrEmpty(attribute1))
              picture.Rotation = this.GetNumericValue(attribute1) / 60000f;
            string attribute2 = reader.GetAttribute("flipH");
            if (!string.IsNullOrEmpty(attribute2))
              picture.FlipHorizontal = attribute2 == "1" || attribute2 == "true";
            string attribute3 = reader.GetAttribute("flipV");
            if (!string.IsNullOrEmpty(attribute3))
            {
              picture.FlipVertical = attribute3 == "1" || attribute3 == "true";
              break;
            }
            break;
          case "ln":
            picture.PictureShape.ShapeContainer = new MsofbtSpContainer(this.m_doc);
            picture.PictureShape.ShapeContainer.Children.Add((object) new MsofbtOPT(this.m_doc));
            picture.PictureShape.ShapeContainer.Children.Add((object) new MsofbtTertiaryFOPT(this.m_doc));
            picture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(511 /*0x01FF*/, 46U);
            picture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.UsefLine = true;
            picture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.Line = true;
            if (reader.GetAttribute("algn") == "in")
              picture.PictureShape.ShapeContainer.ShapeOptions.LineProperties.PenAlignInset = true;
            string attribute4 = reader.GetAttribute("cap");
            if (!string.IsNullOrEmpty(attribute4))
              picture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(471, (uint) this.GetLineCapStyle(attribute4));
            string attribute5 = reader.GetAttribute("cmpd");
            if (!string.IsNullOrEmpty(attribute5))
              picture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(461, (uint) this.GetLineStyle(attribute5));
            string attribute6 = reader.GetAttribute("w");
            if (!string.IsNullOrEmpty(attribute6))
            {
              uint pictureBorderWidth = (uint) this.GetPictureBorderWidth(attribute6, string.Empty);
              picture.PictureShape.ShapeContainer.ShapeOptions.SetPropertyValue(459, pictureBorderWidth);
            }
            this.ParseLineProps(reader, picture.PictureShape);
            break;
          case "effectLst":
          case "scene3d":
          case "sp3d":
          case "extLst":
            picture.DocxVisualShapeProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
            flag = true;
            break;
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseGroupShapeVisualShapeProps(XmlReader reader, WPicture picture)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "spPr")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "spPr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "xfrm":
            string attribute1 = reader.GetAttribute("rot");
            if (!string.IsNullOrEmpty(attribute1))
              picture.Rotation = this.GetNumericValue(attribute1) / 60000f;
            string attribute2 = reader.GetAttribute("flipH");
            if (!string.IsNullOrEmpty(attribute2))
              picture.FlipHorizontal = attribute2 == "1" || attribute2 == "true";
            string attribute3 = reader.GetAttribute("flipV");
            if (!string.IsNullOrEmpty(attribute3))
            {
              picture.FlipVertical = attribute3 == "1" || attribute3 == "true";
              break;
            }
            break;
          case "off":
            string attribute4 = reader.GetAttribute("x");
            if (!string.IsNullOrEmpty(attribute4))
              picture.HorizontalPosition = this.GetPropertyValue(attribute4, "offX");
            string attribute5 = reader.GetAttribute("y");
            if (!string.IsNullOrEmpty(attribute5))
            {
              picture.VerticalPosition = this.GetPropertyValue(attribute5, "offY");
              break;
            }
            break;
          case "ext":
            string attribute6 = reader.GetAttribute("cx");
            if (!string.IsNullOrEmpty(attribute6))
              picture.Width = this.GetPropertyValue(attribute6, "cx");
            string attribute7 = reader.GetAttribute("cy");
            if (!string.IsNullOrEmpty(attribute7))
            {
              picture.Height = this.GetPropertyValue(attribute7, "cy");
              break;
            }
            break;
          case "ln":
          case "effectLst":
          case "scene3d":
          case "sp3d":
          case "extLst":
            picture.DocxVisualShapeProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
            flag = true;
            break;
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private float GetPictureBorderWidth(string value, string pictureType)
  {
    float result = 0.0f;
    if (value.EndsWith("cm"))
      return float.TryParse(value.Remove(value.IndexOf("cm"), 2), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (float) ((double) result * 28.35 * 8.0) : 0.75f;
    if (value.EndsWith("mm"))
      return float.TryParse(value.Remove(value.IndexOf("mm"), 2), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (float) ((double) result * 2.835 * 8.0) : 0.75f;
    if (value.EndsWith("pt"))
      return float.TryParse(value.Remove(value.IndexOf("pt"), 2), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? result * 8f : 0.75f;
    if (value.EndsWith("pi"))
      return float.TryParse(value.Remove(value.IndexOf("pi"), 2), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (float) ((double) result * 12.0 * 8.0) : 0.75f;
    return pictureType == "inline" ? (float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (float) Math.Round((double) result / 12700.0 * 8.0) : 0.75f) : (float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? result : 0.75f);
  }

  private void ProcessEffectExtent(XmlReader picReader, Syncfusion.DocIO.DLS.ShapeBase shapeBase)
  {
    string attribute1 = picReader.GetAttribute("l");
    if (!string.IsNullOrEmpty(attribute1))
      shapeBase.LeftEdgeExtent = this.GetPropertyValue(attribute1, "l");
    string attribute2 = picReader.GetAttribute("t");
    if (!string.IsNullOrEmpty(attribute2))
      shapeBase.TopEdgeExtent = this.GetPropertyValue(attribute2, "t");
    string attribute3 = picReader.GetAttribute("r");
    if (!string.IsNullOrEmpty(attribute3))
      shapeBase.RightEdgeExtent = this.GetPropertyValue(attribute3, "r");
    string attribute4 = picReader.GetAttribute("b");
    if (string.IsNullOrEmpty(attribute4))
      return;
    shapeBase.BottomEdgeExtent = this.GetPropertyValue(attribute4, "b");
  }

  private LineCap GetLineCapStyle(string lineCap)
  {
    switch (lineCap)
    {
      case "flat":
        return LineCap.Flat;
      case "rnd":
      case "round":
        return LineCap.Round;
      default:
        return LineCap.Square;
    }
  }

  private void ParseLineProps(XmlReader reader, InlineShapeObject shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "ln")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "ln")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "bevel":
            shape.ShapeContainer.ShapeOptions.SetPropertyValue(470, 0U);
            break;
          case "gradFill":
            this.ParseGradientFill(reader, shape.LineGradient);
            break;
          case "headEnd":
            string attribute1 = reader.GetAttribute("type");
            if (!string.IsNullOrEmpty(attribute1))
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(464, (uint) this.GetLineEnd(attribute1));
            string attribute2 = reader.GetAttribute("w");
            if (!string.IsNullOrEmpty(attribute2))
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(466, (uint) this.GetLineEndWidth(attribute2));
            string attribute3 = reader.GetAttribute("len");
            if (!string.IsNullOrEmpty(attribute3))
            {
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(467, (uint) this.GetLineEndLength(attribute3));
              break;
            }
            break;
          case "miter":
            shape.ShapeContainer.ShapeOptions.SetPropertyValue(470, 1U);
            string attribute4 = reader.GetAttribute("lim");
            if (!string.IsNullOrEmpty(attribute4))
            {
              uint num = (uint) (this.GetPercentage(attribute4) * 65536.0 / 100.0);
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(460, num);
              break;
            }
            break;
          case "noFill":
            shape.ShapeContainer.ShapeOptions.LineProperties.Line = false;
            break;
          case "prstDash":
            string attribute5 = reader.GetAttribute("val");
            if (!string.IsNullOrEmpty(attribute5))
            {
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(462, (uint) this.GetDashStyle(attribute5));
              break;
            }
            break;
          case "round":
            shape.ShapeContainer.ShapeOptions.SetPropertyValue(470, 2U);
            break;
          case "solidFill":
            uint maxValue = uint.MaxValue;
            Color color = this.ParseColor(reader, "solidFill", ref maxValue, reader.LocalName, false);
            if (maxValue != uint.MaxValue)
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(449, maxValue);
            shape.ShapeContainer.ShapeOptions.SetPropertyValue(448, WordColor.ConvertColorToRGB(color));
            break;
          case "tailEnd":
            string attribute6 = reader.GetAttribute("type");
            if (!string.IsNullOrEmpty(attribute6))
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(465, (uint) this.GetLineEnd(attribute6));
            string attribute7 = reader.GetAttribute("w");
            if (!string.IsNullOrEmpty(attribute7))
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(468, (uint) this.GetLineEndWidth(attribute7));
            string attribute8 = reader.GetAttribute("len");
            if (!string.IsNullOrEmpty(attribute8))
            {
              shape.ShapeContainer.ShapeOptions.SetPropertyValue(469, (uint) this.GetLineEndLength(attribute8));
              break;
            }
            break;
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseLineProps(XmlReader reader, Shape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "ln")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    string empty = string.Empty;
    while (reader.LocalName != "ln")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "prstDash":
            string attribute1 = reader.GetAttribute("val");
            if (!string.IsNullOrEmpty(attribute1))
            {
              shape.LineFormat.DashStyle = this.GetDashStyle(attribute1);
              break;
            }
            break;
          case "solidFill":
            shape.LineFormat.LineFormatType = LineFormatType.Solid;
            uint maxValue = uint.MaxValue;
            Color color = this.ParseColor(reader, "solidFill", ref maxValue, reader.LocalName, false);
            shape.LineFormat.Line = true;
            shape.LineFormat.Color = color;
            if (maxValue != uint.MaxValue)
            {
              shape.LineFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
              break;
            }
            break;
          case "noFill":
            shape.LineFormat.Line = false;
            shape.LineFormat.LineFormatType = LineFormatType.None;
            break;
          case "gradFill":
            shape.LineFormat.Line = true;
            shape.LineFormat.LineFormatType = LineFormatType.Gradient;
            this.ParseGradientFill(reader, shape.LineFormat.GradientFill);
            break;
          case "pattFill":
            shape.LineFormat.Line = true;
            shape.LineFormat.LineFormatType = LineFormatType.Patterned;
            string attribute2 = reader.GetAttribute("prst");
            if (!string.IsNullOrEmpty(attribute2))
              shape.LineFormat.Pattern = this.GetPatternType(attribute2);
            this.ParsePatternFill(reader, shape.LineFormat);
            break;
          case "bevel":
            shape.LineFormat.LineJoin = LineJoin.Bevel;
            break;
          case "miter":
            shape.LineFormat.LineJoin = LineJoin.Miter;
            shape.LineFormat.MiterJoinLimit = reader.GetAttribute("lim");
            break;
          case "round":
            shape.LineFormat.LineJoin = LineJoin.Round;
            break;
          case "headEnd":
            this.ParseHeadEnd(reader, shape.LineFormat);
            break;
          case "tailEnd":
            this.ParseTailEnd(reader, shape.LineFormat);
            break;
          case "custDash":
          case "extLst":
            shape.LineFormat.DocxProps.Add(reader.LocalName, (Stream) this.ReadSingleNodeIntoStream(reader));
            flag = true;
            break;
          default:
            if (!this.IsWord2003ML)
            {
              this.ReadSingleNodeIntoStream(reader);
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseLineProps(XmlReader reader, ChildShape shape)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "ln")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (!reader.IsEmptyElement)
    {
      string localName = reader.LocalName;
      reader.Read();
      if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
      {
        this.SkipWhitespaces(reader);
        string empty = string.Empty;
        while (reader.LocalName != "ln")
        {
          bool flag = false;
          if (reader.NodeType == XmlNodeType.Element)
          {
            switch (reader.LocalName)
            {
              case "prstDash":
                string attribute1 = reader.GetAttribute("val");
                if (!string.IsNullOrEmpty(attribute1))
                {
                  shape.LineFormat.DashStyle = this.GetDashStyle(attribute1);
                  break;
                }
                break;
              case "solidFill":
                shape.LineFormat.LineFormatType = LineFormatType.Solid;
                uint maxValue = uint.MaxValue;
                Color color = this.ParseColor(reader, "solidFill", ref maxValue, reader.LocalName, false);
                shape.LineFormat.Line = true;
                shape.LineFormat.Color = color;
                if (maxValue != uint.MaxValue)
                {
                  shape.LineFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2);
                  break;
                }
                break;
              case "noFill":
                shape.LineFormat.Line = false;
                shape.LineFormat.LineFormatType = LineFormatType.None;
                break;
              case "gradFill":
                shape.LineFormat.Line = true;
                shape.LineFormat.LineFormatType = LineFormatType.Gradient;
                this.ParseGradientFill(reader, shape.LineFormat.GradientFill);
                break;
              case "pattFill":
                shape.LineFormat.Line = true;
                shape.LineFormat.LineFormatType = LineFormatType.Patterned;
                string attribute2 = reader.GetAttribute("prst");
                if (!string.IsNullOrEmpty(attribute2))
                  shape.LineFormat.Pattern = this.GetPatternType(attribute2);
                this.ParsePatternFill(reader, shape.LineFormat);
                break;
              case "bevel":
                shape.LineFormat.LineJoin = LineJoin.Bevel;
                break;
              case "miter":
                shape.LineFormat.LineJoin = LineJoin.Miter;
                shape.LineFormat.MiterJoinLimit = reader.GetAttribute("lim");
                break;
              case "round":
                shape.LineFormat.LineJoin = LineJoin.Round;
                break;
              case "headEnd":
                this.ParseHeadEnd(reader, shape.LineFormat);
                break;
              case "tailEnd":
                this.ParseTailEnd(reader, shape.LineFormat);
                break;
              case "custDash":
              case "extLst":
                shape.LineFormat.DocxProps.Add(reader.LocalName, (Stream) this.ReadSingleNodeIntoStream(reader));
                flag = true;
                break;
              default:
                this.ReadSingleNodeIntoStream(reader);
                flag = true;
                break;
            }
            if (!flag)
              reader.Read();
          }
          else
            reader.Read();
          this.SkipWhitespaces(reader);
        }
      }
      else
        shape.LineFormat.LineFormatType = LineFormatType.None;
    }
    else
      shape.LineFormat.LineFormatType = LineFormatType.None;
  }

  private void ParseTailEnd(XmlReader reader, LineFormat lineFormat)
  {
    string attribute1 = reader.GetAttribute("type");
    if (!string.IsNullOrEmpty(attribute1))
      lineFormat.EndArrowheadStyle = this.GetLineEnd(attribute1);
    string attribute2 = reader.GetAttribute("w");
    if (!string.IsNullOrEmpty(attribute2))
      lineFormat.EndArrowheadWidth = this.GetLineEndWidth(attribute2);
    string attribute3 = reader.GetAttribute("len");
    if (string.IsNullOrEmpty(attribute3))
      return;
    lineFormat.EndArrowheadLength = this.GetLineEndLength(attribute3);
  }

  private void ParseHeadEnd(XmlReader reader, LineFormat lineFormat)
  {
    string attribute1 = reader.GetAttribute("type");
    if (!string.IsNullOrEmpty(attribute1))
      lineFormat.BeginArrowheadStyle = this.GetLineEnd(attribute1);
    string attribute2 = reader.GetAttribute("w");
    if (!string.IsNullOrEmpty(attribute2))
      lineFormat.BeginArrowheadWidth = this.GetLineEndWidth(attribute2);
    string attribute3 = reader.GetAttribute("len");
    if (string.IsNullOrEmpty(attribute3))
      return;
    lineFormat.BeginArrowheadLength = this.GetLineEndLength(attribute3);
  }

  private void ParsePatternFill(XmlReader reader, LineFormat lineFormat)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string str = localName;
    uint maxValue = uint.MaxValue;
    this.SkipWhitespaces(reader);
    while (!(reader.LocalName == str))
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "fgClr":
            lineFormat.ForeColor = this.ParseColor(reader, "fgClr", ref maxValue, reader.LocalName, false);
            maxValue = uint.MaxValue;
            break;
          case "bgClr":
            lineFormat.Color = this.ParseColor(reader, "bgClr", ref maxValue, reader.LocalName, false);
            if (maxValue != uint.MaxValue)
            {
              lineFormat.Transparency = (float) Math.Round(1.0 - (double) maxValue / 65536.0, 2) * 100f;
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private ArrowheadStyle GetLineEnd(string lineEnd)
  {
    switch (lineEnd)
    {
      case "triangle":
      case "block":
        return ArrowheadStyle.ArrowheadTriangle;
      case "arrow":
      case "open":
        return ArrowheadStyle.ArrowheadOpen;
      case "oval":
        return ArrowheadStyle.ArrowheadOval;
      case "stealth":
      case "classic":
        return ArrowheadStyle.ArrowheadStealth;
      case "diamond":
        return ArrowheadStyle.ArrowheadDiamond;
      default:
        return ArrowheadStyle.ArrowheadNone;
    }
  }

  private LineEndWidth GetLineEndWidth(string lineEndWidth)
  {
    switch (lineEndWidth)
    {
      case "sm":
      case "narrow":
        return LineEndWidth.NarrowArrow;
      case "lg":
      case "wide":
        return LineEndWidth.WideArrow;
      default:
        return LineEndWidth.MediumWidthArrow;
    }
  }

  private LineEndLength GetLineEndLength(string lineEndLength)
  {
    switch (lineEndLength)
    {
      case "sm":
      case "short":
        return LineEndLength.ShortArrow;
      case "lg":
      case "long":
        return LineEndLength.LongArrow;
      default:
        return LineEndLength.MediumLenArrow;
    }
  }

  private short GetLanguageID(string value)
  {
    switch (value)
    {
      case "ar":
        return 1;
      case "bg":
        return 2;
      case "ca":
        return 3;
      case "zh":
        return 4;
      case "cs":
        return 5;
      case "da":
        return 6;
      case "de":
        return 7;
      case "el":
        return 8;
      case "en":
        return 9;
      case "es":
        return 10;
      case "fi":
        return 11;
      case "fr":
        return 12;
      case "he":
        return 13;
      case "hu":
        return 14;
      case "is":
        return 15;
      case "it":
        return 16 /*0x10*/;
      case "ja":
        return 17;
      case "ko":
        return 18;
      case "nl":
        return 19;
      case "nb":
        return 20;
      case "pl":
        return 21;
      case "pt":
        return 22;
      case "rm":
        return 23;
      case "ro":
        return 24;
      case "ru":
        return 25;
      case "hr":
        return 26;
      case "sk":
        return 27;
      case "sq":
        return 28;
      case "sv":
        return 29;
      case "th":
        return 30;
      case "tr":
        return 31 /*0x1F*/;
      case "ur":
        return 32 /*0x20*/;
      case "id":
        return 33;
      case "uk":
        return 34;
      case "be":
        return 35;
      case "sl":
        return 36;
      case "et":
        return 37;
      case "lv":
        return 38;
      case "lt":
        return 39;
      case "tg":
        return 40;
      case "fa":
        return 41;
      case "vi":
        return 42;
      case "hy":
        return 43;
      case "az":
        return 44;
      case "eu":
        return 45;
      case "hsb":
        return 46;
      case "mk":
        return 47;
      case "tn":
        return 50;
      case "xh":
        return 52;
      case "zu":
        return 53;
      case "af":
        return 54;
      case "ka":
        return 55;
      case "fo":
        return 56;
      case "hi":
        return 57;
      case "mt":
        return 58;
      case "smn":
        return 59;
      case "ms":
        return 62;
      case "kk":
        return 63 /*0x3F*/;
      case "ky":
        return 64 /*0x40*/;
      case "sw":
        return 65;
      case "tk":
        return 66;
      case "uz":
        return 67;
      case "tt":
        return 68;
      case "bn":
        return 69;
      case "pa":
        return 70;
      case "gu":
        return 71;
      case "or":
        return 72;
      case "ta":
        return 73;
      case "te":
        return 74;
      case "kn":
        return 75;
      case "ml":
        return 76;
      case "mr":
        return 78;
      case "sa":
        return 79;
      case "mn":
        return 80 /*0x50*/;
      case "bo":
        return 81;
      case "cy":
        return 82;
      case "lo":
        return 84;
      case "gl":
        return 86;
      case "kok":
        return 87;
      case "syr":
        return 90;
      case "si":
        return 91;
      case "chr":
        return 92;
      case "iu":
        return 93;
      case "am":
        return 94;
      case "ne":
        return 97;
      case "fy":
        return 98;
      case "ps":
        return 99;
      case "fil":
        return 100;
      case "dv":
        return 101;
      case "ff":
        return 103;
      case "ha":
        return 104;
      case "quz":
        return 107;
      case "nso":
        return 108;
      case "ba":
        return 109;
      case "lb":
        return 110;
      case "kl":
        return 111;
      case "ig":
        return 112 /*0x70*/;
      case "ti":
        return 115;
      case "haw":
        return 117;
      case "ii":
        return 120;
      case "arn":
        return 122;
      case "br":
        return 126;
      case "ug":
        return 128 /*0x80*/;
      case "mi":
        return 129;
      case "oc":
        return 130;
      case "co":
        return 131;
      case "gsw":
        return 132;
      case "sah":
        return 133;
      case "qut":
        return 134;
      case "rw":
        return 135;
      case "prs":
        return 140;
      default:
        return 1033;
    }
  }

  private FlipOrientation GetFlipOrientation(string flip)
  {
    switch (flip)
    {
      case "x":
        return FlipOrientation.Horizontal;
      case "y":
        return FlipOrientation.Vertical;
      case "xy":
        return FlipOrientation.Both;
      default:
        return FlipOrientation.None;
    }
  }

  private FlipOrientation GetChildShapeFlipOrientation(string flip)
  {
    switch (flip)
    {
      case "x":
        return FlipOrientation.Horizontal;
      case "y":
        return FlipOrientation.Vertical;
      case "x y":
      case "xy":
        return FlipOrientation.Both;
      default:
        return FlipOrientation.None;
    }
  }

  private GradientShadeType GetGradientShadeType(string shade)
  {
    switch (shade)
    {
      case "circle":
        return GradientShadeType.Circle;
      case "rect":
        return GradientShadeType.Rectangle;
      default:
        return GradientShadeType.Shape;
    }
  }

  private void ParseGradientFill(XmlReader reader, GradientFill gradientFill)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "gradFill")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (!reader.IsEmptyElement)
    {
      string localName1 = reader.LocalName;
      reader.GetAttribute("flip");
      string attribute1 = reader.GetAttribute("rotWithShape");
      reader.Read();
      if (!(localName1 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
      {
        if (!string.IsNullOrEmpty(attribute1))
          gradientFill.Flip = this.GetFlipOrientation(attribute1);
        if (!string.IsNullOrEmpty(attribute1))
          gradientFill.RotateWithShape = this.GetBoolValue(attribute1);
        this.SkipWhitespaces(reader);
        while (reader.LocalName != "gradFill")
        {
          bool flag = false;
          if (reader.NodeType == XmlNodeType.Element)
          {
            switch (reader.LocalName)
            {
              case "gsLst":
                this.ParseGradientStop(reader, gradientFill);
                break;
              case "lin":
                this.ParseLinearGradient(reader, gradientFill);
                break;
              case "path":
                gradientFill.PathGradient = new PathGradient();
                string attribute2 = reader.GetAttribute("path");
                gradientFill.PathGradient.PathShade = this.GetGradientShadeType(attribute2);
                if (!reader.IsEmptyElement)
                {
                  string localName2 = reader.LocalName;
                  reader.Read();
                  if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
                  {
                    this.ParsePathGradient(reader, gradientFill.PathGradient, localName2);
                    break;
                  }
                  break;
                }
                break;
              case "tileRect":
                this.ParseTileRectangle(reader, gradientFill);
                break;
            }
            if (!flag)
              reader.Read();
          }
          else
            reader.Read();
          this.SkipWhitespaces(reader);
        }
      }
      else
        gradientFill.IsEmptyElement = true;
    }
    else
      gradientFill.IsEmptyElement = true;
  }

  private void ParseTileRectangle(XmlReader reader, GradientFill gradientFill)
  {
    string attribute1 = reader.GetAttribute("b");
    int result;
    if (!string.IsNullOrEmpty(attribute1))
    {
      int.TryParse(attribute1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      gradientFill.TileRectangle.BottomOffset = (float) (result / 1000);
    }
    string attribute2 = reader.GetAttribute("l");
    if (!string.IsNullOrEmpty(attribute2))
    {
      int.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      gradientFill.TileRectangle.LeftOffset = (float) (result / 1000);
    }
    string attribute3 = reader.GetAttribute("r");
    if (!string.IsNullOrEmpty(attribute3))
    {
      int.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      gradientFill.TileRectangle.RightOffset = (float) (result / 1000);
    }
    string attribute4 = reader.GetAttribute("t");
    if (string.IsNullOrEmpty(attribute4))
      return;
    int.TryParse(attribute4, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    gradientFill.TileRectangle.TopOffset = (float) (result / 1000);
  }

  private void ParseLinearGradient(XmlReader reader, GradientFill gradientFill)
  {
    gradientFill.LinearGradient = new LinearGradient();
    string attribute1 = reader.GetAttribute("ang");
    if (!string.IsNullOrEmpty(attribute1))
    {
      uint result;
      uint.TryParse(attribute1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      gradientFill.LinearGradient.Angle = (short) Math.Round((double) result / 60000.0);
    }
    string attribute2 = reader.GetAttribute("scaled");
    if (string.IsNullOrEmpty(attribute2))
      return;
    gradientFill.LinearGradient.Scaled = this.GetBoolValue(attribute2);
  }

  private void ParseGradientStop(XmlReader reader, GradientFill gradientFill)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "gsLst")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "gsLst")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "gs":
            string attribute = reader.GetAttribute("pos");
            GradientStop gradientStop = new GradientStop();
            if (!string.IsNullOrEmpty(attribute))
            {
              double result;
              if (double.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
                gradientStop.Position = (byte) Math.Round(result / 1000.0);
              else if (gradientFill.GradientStops.Count == 0)
                gradientStop.Position = (byte) result;
              else
                break;
            }
            uint maxValue = uint.MaxValue;
            gradientStop.Color = this.ParseColor(reader, "gs", ref maxValue, reader.LocalName, false);
            if (maxValue != uint.MaxValue)
              gradientStop.Opacity = (byte) Math.Round((double) maxValue / 65536.0 * 100.0);
            gradientFill.GradientStops.Add(gradientStop);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParsePathGradient(XmlReader reader, PathGradient pathGradient, string localName)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (localName != "path")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "path")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "fillToRect":
            string attribute1 = reader.GetAttribute("b");
            int result;
            if (!string.IsNullOrEmpty(attribute1))
            {
              int.TryParse(attribute1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              pathGradient.BottomOffset = (short) (result / 1000);
            }
            string attribute2 = reader.GetAttribute("l");
            if (!string.IsNullOrEmpty(attribute2))
            {
              int.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              pathGradient.LeftOffset = (short) (result / 1000);
            }
            string attribute3 = reader.GetAttribute("r");
            if (!string.IsNullOrEmpty(attribute3))
            {
              int.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              pathGradient.RightOffset = (short) (result / 1000);
            }
            string attribute4 = reader.GetAttribute("t");
            if (!string.IsNullOrEmpty(attribute4))
            {
              int.TryParse(attribute4, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              pathGradient.TopOffset = (short) (result / 1000);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private Color ParseColor(
    XmlReader reader,
    string parentElement,
    ref uint opacity,
    string localName,
    bool isAlreadyChecked)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (localName != parentElement)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    Color color = Color.Empty;
    if (isAlreadyChecked)
      color = this.ParseColorValues(reader, parentElement, ref opacity, localName, color);
    else if (!reader.IsEmptyElement)
    {
      localName = reader.LocalName;
      reader.Read();
      if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return color;
      color = this.ParseColorValues(reader, parentElement, ref opacity, localName, color);
    }
    return color;
  }

  private Color ParseColorValues(
    XmlReader reader,
    string parentElement,
    ref uint opacity,
    string localName,
    Color color)
  {
    this.SkipWhitespaces(reader);
    while (reader.LocalName != parentElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "srgbClr":
            color = this.GetHexColor(reader.GetAttribute("val"));
            this.ParseColorTransform(reader, "srgbClr", ref color, ref opacity);
            break;
          case "scrgbClr":
            color = Color.FromArgb((int) byte.MaxValue, (int) (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("r")) / 100.0)), (int) (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("g")) / 100.0)), (int) (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(reader.GetAttribute("b")) / 100.0)));
            this.ParseColorTransform(reader, "scrgbClr", ref color, ref opacity);
            break;
          case "prstClr":
            color = Color.FromName(reader.GetAttribute("val"));
            this.ParseColorTransform(reader, "prstClr", ref color, ref opacity);
            break;
          case "hslClr":
            double result = 0.0;
            double.TryParse(reader.GetAttribute("hue"), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
            double hue = result / 60000.0 / 360.0;
            double luminance = this.GetPercentage(reader.GetAttribute("lum")) / 100.0;
            double saturation = this.GetPercentage(reader.GetAttribute("sat")) / 100.0;
            color = WordColor.ConvertHSLToColor(hue, saturation, luminance);
            this.ParseColorTransform(reader, "hslClr", ref color, ref opacity);
            break;
          case "sysClr":
            color = this.GetSystemColor(reader);
            this.ParseColorTransform(reader, "sysClr", ref color, ref opacity);
            break;
          case "schemeClr":
            color = this.GetSchemeColor(reader);
            this.ParseColorTransform(reader, "schemeClr", ref color, ref opacity);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    return color;
  }

  private Color GetSystemColor(XmlReader reader)
  {
    Color systemColor = Color.Empty;
    string attribute1 = reader.GetAttribute("lastClr");
    if (!string.IsNullOrEmpty(attribute1))
      systemColor = this.GetHexColor(attribute1);
    string attribute2 = reader.GetAttribute("val");
    if (!string.IsNullOrEmpty(attribute2))
    {
      KnownColor color = KnownColor.Black;
      switch (attribute2)
      {
        case "3dDkShadow":
          color = KnownColor.ControlDarkDark;
          break;
        case "3dLight":
          color = KnownColor.ControlLight;
          break;
        case "activeBorder":
          color = KnownColor.ActiveBorder;
          break;
        case "activeCaption":
          color = KnownColor.ActiveCaption;
          break;
        case "appWorkspace":
          color = KnownColor.AppWorkspace;
          break;
        case "background":
          color = KnownColor.Desktop;
          break;
        case "btnFace":
          color = KnownColor.ButtonFace;
          break;
        case "btnHighlight":
          color = KnownColor.ButtonHighlight;
          break;
        case "btnShadow":
          color = KnownColor.ButtonShadow;
          break;
        case "btnText":
          color = KnownColor.ControlText;
          break;
        case "captionText":
          color = KnownColor.ActiveCaptionText;
          break;
        case "gradientActiveCaption":
          color = KnownColor.GradientActiveCaption;
          break;
        case "gradientInactiveCaption":
          color = KnownColor.GradientInactiveCaption;
          break;
        case "grayText":
          color = KnownColor.GrayText;
          break;
        case "highlight":
          color = KnownColor.Highlight;
          break;
        case "highlightText":
          color = KnownColor.HighlightText;
          break;
        case "hotLight":
          color = KnownColor.HotTrack;
          break;
        case "inactiveBorder":
          color = KnownColor.InactiveBorder;
          break;
        case "inactiveCaption":
          color = KnownColor.InactiveCaption;
          break;
        case "inactiveCaptionText":
          color = KnownColor.InactiveCaptionText;
          break;
        case "infoBk":
          color = KnownColor.Info;
          break;
        case "infoText":
          color = KnownColor.InfoText;
          break;
        case "menu":
          color = KnownColor.Menu;
          break;
        case "menuBar":
          color = KnownColor.MenuBar;
          break;
        case "menuHighlight":
          color = KnownColor.MenuHighlight;
          break;
        case "menuText":
          color = KnownColor.MenuText;
          break;
        case "scrollBar":
          color = KnownColor.ScrollBar;
          break;
        case "window":
          color = KnownColor.Window;
          break;
        case "windowFrame":
          color = KnownColor.WindowFrame;
          break;
        case "windowText":
          color = KnownColor.WindowText;
          break;
      }
      systemColor = Color.FromKnownColor(color);
    }
    return systemColor;
  }

  private Color GetSchemeColor(XmlReader reader)
  {
    Color empty = Color.Empty;
    return this.GetThemeFillColor(reader.GetAttribute("val"));
  }

  private void ParseColorTransform(
    XmlReader reader,
    string parentElement,
    ref Color themeColor,
    ref uint opacity)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != parentElement)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    bool flag1 = false;
    while (reader.LocalName != parentElement)
    {
      bool flag2 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "alpha":
            flag1 = false;
            string attribute1 = reader.GetAttribute("val");
            if (!string.IsNullOrEmpty(attribute1))
            {
              double percentage = this.GetPercentage(attribute1);
              opacity = (uint) (percentage * 65536.0 / 100.0);
              if (opacity > 65536U /*0x010000*/)
              {
                opacity = 65536U /*0x010000*/;
                break;
              }
              break;
            }
            break;
          case "alphaMod":
            flag1 = false;
            string attribute2 = reader.GetAttribute("val");
            if (!string.IsNullOrEmpty(attribute2))
            {
              double percentage = this.GetPercentage(attribute2);
              opacity = (uint) ((opacity == uint.MaxValue ? 65536.0 : (double) opacity) * (percentage / 100.0));
              if (opacity > 65536U /*0x010000*/)
              {
                opacity = 65536U /*0x010000*/;
                break;
              }
              break;
            }
            break;
          case "alphaOff":
            if (!flag1)
            {
              string attribute3 = reader.GetAttribute("val");
              if (!string.IsNullOrEmpty(attribute3))
              {
                double percentage = this.GetPercentage(attribute3);
                opacity = (uint) ((opacity == uint.MaxValue ? 0.0 : (double) opacity) + Math.Round(percentage * 65536.0 / 100.0));
                if (opacity > 65536U /*0x010000*/)
                {
                  opacity = 65536U /*0x010000*/;
                  break;
                }
                break;
              }
              break;
            }
            break;
          default:
            string str = reader.GetAttribute("val");
            if (string.IsNullOrEmpty(str) && (reader.LocalName == "comp" || reader.LocalName == "gamma" || reader.LocalName == "gray" || reader.LocalName == "invGamma" || reader.LocalName == "inv"))
              str = string.Empty;
            if (!string.IsNullOrEmpty(str))
              flag1 = this.ParseColorTransform(reader.LocalName, str, ref themeColor);
            if (flag1)
            {
              opacity = uint.MaxValue;
              break;
            }
            break;
        }
        if (!flag2)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private bool ParseColorTransform(string localName, string value, ref Color themeColor)
  {
    switch (localName)
    {
      case "blue":
        string str1 = value;
        if (!string.IsNullOrEmpty(str1))
        {
          byte blue = (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(str1) / 100.0));
          themeColor = Color.FromArgb((int) themeColor.A, (int) themeColor.R, (int) themeColor.G, (int) blue);
        }
        return true;
      case "blueMod":
        string str2 = value;
        if (!string.IsNullOrEmpty(str2))
        {
          double percentage = this.GetPercentage(str2);
          themeColor = Color.FromArgb((int) themeColor.A, (int) themeColor.R, (int) themeColor.G, (int) WordColor.ConvertbyModulation(themeColor.B, percentage));
        }
        return true;
      case "blueOff":
        string str3 = value;
        if (!string.IsNullOrEmpty(str3))
        {
          double percentage = this.GetPercentage(str3);
          themeColor = Color.FromArgb((int) themeColor.A, (int) themeColor.R, (int) themeColor.G, (int) WordColor.ConvertbyOffset(themeColor.B, percentage));
        }
        return true;
      case "green":
        string str4 = value;
        if (!string.IsNullOrEmpty(str4))
        {
          byte green = (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(str4) / 100.0));
          themeColor = Color.FromArgb((int) themeColor.A, (int) themeColor.R, (int) green, (int) themeColor.B);
        }
        return true;
      case "greenMod":
        string str5 = value;
        if (!string.IsNullOrEmpty(str5))
        {
          double percentage = this.GetPercentage(str5);
          themeColor = Color.FromArgb((int) themeColor.A, (int) themeColor.R, (int) WordColor.ConvertbyModulation(themeColor.G, percentage), (int) themeColor.B);
        }
        return true;
      case "greenOff":
        string str6 = value;
        if (!string.IsNullOrEmpty(str6))
        {
          double percentage = this.GetPercentage(str6);
          themeColor = Color.FromArgb((int) themeColor.A, (int) themeColor.R, (int) WordColor.ConvertbyOffset(themeColor.G, percentage), (int) themeColor.B);
        }
        return true;
      case "red":
        string str7 = value;
        if (!string.IsNullOrEmpty(str7))
        {
          byte red = (byte) Math.Round((double) byte.MaxValue * WordColor.ConvertsLinearRGBtoRGB(this.GetPercentage(str7) / 100.0));
          themeColor = Color.FromArgb((int) themeColor.A, (int) red, (int) themeColor.G, (int) themeColor.B);
        }
        return true;
      case "redMod":
        string str8 = value;
        if (!string.IsNullOrEmpty(str8))
        {
          double percentage = this.GetPercentage(str8);
          themeColor = Color.FromArgb((int) themeColor.A, (int) WordColor.ConvertbyModulation(themeColor.R, percentage), (int) themeColor.G, (int) themeColor.B);
        }
        return true;
      case "redOff":
        string str9 = value;
        if (!string.IsNullOrEmpty(str9))
        {
          double percentage = this.GetPercentage(str9);
          themeColor = Color.FromArgb((int) themeColor.A, (int) WordColor.ConvertbyOffset(themeColor.R, percentage), (int) themeColor.G, (int) themeColor.B);
        }
        return true;
      case "hue":
        string s1 = value;
        if (!string.IsNullOrEmpty(s1))
        {
          double result;
          double.TryParse(s1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
          result /= 60000.0;
          WordColor.ConvertbyHue(ref themeColor, result);
        }
        return true;
      case "hueMod":
        string str10 = value;
        if (!string.IsNullOrEmpty(str10))
        {
          double ratio = this.GetPercentage(str10) / 100.0;
          WordColor.ConvertbyHueMod(ref themeColor, ratio);
        }
        return true;
      case "hueOff":
        string s2 = value;
        if (!string.IsNullOrEmpty(s2))
        {
          double result;
          double.TryParse(s2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
          result /= 60000.0;
          WordColor.ConvertbyHueOffset(ref themeColor, result);
        }
        return true;
      case "sat":
        string str11 = value;
        if (!string.IsNullOrEmpty(str11))
        {
          double percentage = this.GetPercentage(str11);
          WordColor.ConvertbySat(ref themeColor, percentage);
        }
        return true;
      case "satMod":
        string str12 = value;
        if (!string.IsNullOrEmpty(str12))
        {
          double percentage = this.GetPercentage(str12);
          WordColor.ConvertbySatMod(ref themeColor, percentage);
        }
        return true;
      case "satOff":
        string str13 = value;
        if (!string.IsNullOrEmpty(str13))
        {
          double percentage = this.GetPercentage(str13);
          WordColor.ConvertbySatOffset(ref themeColor, percentage);
        }
        return true;
      case "lum":
        string str14 = value;
        if (!string.IsNullOrEmpty(str14))
        {
          double percentage = this.GetPercentage(str14);
          WordColor.ConvertbyLum(ref themeColor, percentage);
        }
        return true;
      case "lumMod":
        string str15 = value;
        if (!string.IsNullOrEmpty(str15))
        {
          double percentage = this.GetPercentage(str15);
          WordColor.ConvertbyLumMod(ref themeColor, percentage);
        }
        return true;
      case "lumOff":
        string str16 = value;
        if (str16 != null)
        {
          double percentage = this.GetPercentage(str16);
          WordColor.ConvertbyLumOffset(ref themeColor, percentage);
        }
        return true;
      case "comp":
        themeColor = WordColor.ComplementColor(themeColor);
        return true;
      case "gamma":
        themeColor = WordColor.GammaColor(themeColor);
        return true;
      case "gray":
        themeColor = WordColor.GrayColor(themeColor);
        return true;
      case "invGamma":
        themeColor = WordColor.InverseGammaColor(themeColor);
        return true;
      case "inv":
        themeColor = WordColor.InverseColor(themeColor);
        return true;
      case "tint":
        string str17 = value;
        if (!string.IsNullOrEmpty(str17))
        {
          double tint = this.GetPercentage(str17) / 100.0;
          themeColor = WordColor.ConvertColorByTint(themeColor, tint);
        }
        return true;
      case "shade":
        string str18 = value;
        if (!string.IsNullOrEmpty(str18))
        {
          double shade = this.GetPercentage(str18) / 100.0;
          themeColor = WordColor.ConvertColorByShade(themeColor, shade);
        }
        return true;
      default:
        return false;
    }
  }

  private double GetPercentage(string value)
  {
    double result;
    if (value.EndsWith("%"))
    {
      double.TryParse(value.Replace("%", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    }
    else
    {
      double.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      result /= 1000.0;
    }
    return result;
  }

  private void ParseWrappingType(XmlReader reader, WPicture picture)
  {
    string attribute = reader.GetAttribute("wrapText");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "bothSides":
        picture.TextWrappingType = TextWrappingType.Both;
        break;
      case "left":
        picture.TextWrappingType = TextWrappingType.Left;
        break;
      case "right":
        picture.TextWrappingType = TextWrappingType.Right;
        break;
      case "largest":
        picture.TextWrappingType = TextWrappingType.Largest;
        break;
    }
  }

  private void ParsePictureHorizontalPosition(XmlReader reader, WPicture picture)
  {
    if (reader.LocalName != "positionH")
      throw new XmlException("positionH");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    string attribute = reader.GetAttribute("relativeFrom");
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (!string.IsNullOrEmpty(attribute))
      picture.HorizontalOrigin = this.GetHorizOrigin(attribute);
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "positionH")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "align":
            string align = reader.ReadString();
            if (!string.IsNullOrEmpty(align))
            {
              picture.HorizontalAlignment = this.GetHorizAlign(align);
              break;
            }
            break;
          case "posOffset":
            float result = float.MaxValue;
            float.TryParse(reader.ReadString(), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
            if ((double) result != 3.4028234663852886E+38)
            {
              picture.HorizontalPosition = (float) Math.Round((double) result / 12700.0, 2);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private ShapeHorizontalAlignment GetHorizAlign(string align)
  {
    switch (align)
    {
      case "center":
        return ShapeHorizontalAlignment.Center;
      case "left":
        return ShapeHorizontalAlignment.Left;
      case "right":
        return ShapeHorizontalAlignment.Right;
      case "inside":
        return ShapeHorizontalAlignment.Inside;
      case "outside":
        return ShapeHorizontalAlignment.Outside;
      default:
        return ShapeHorizontalAlignment.None;
    }
  }

  private HorizontalOrigin GetHorizOrigin(string origin)
  {
    switch (origin)
    {
      case "page":
        return HorizontalOrigin.Page;
      case "text":
      case "column":
        return HorizontalOrigin.Column;
      case "char":
      case "character":
        return HorizontalOrigin.Character;
      case "left-margin-area":
      case "leftMargin":
        return HorizontalOrigin.LeftMargin;
      case "right-margin-area":
      case "rightMargin":
        return HorizontalOrigin.RightMargin;
      case "inner-margin-area":
      case "insideMargin":
        return HorizontalOrigin.InsideMargin;
      case "outer-margin-area":
      case "outsideMargin":
        return HorizontalOrigin.OutsideMargin;
      default:
        return HorizontalOrigin.Margin;
    }
  }

  private void ParsePictureVerticalPosition(XmlReader reader, WPicture picture)
  {
    if (reader.LocalName != "positionV")
      throw new XmlException("PositionV");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    string attribute = reader.GetAttribute("relativeFrom");
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    picture.VerticalOrigin = this.GetVertOrigin(attribute);
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "positionV")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "align":
            string align = reader.ReadString();
            if (!string.IsNullOrEmpty(align))
            {
              picture.VerticalAlignment = this.GetVertAlign(align);
              break;
            }
            break;
          case "posOffset":
            float result = float.MaxValue;
            float.TryParse(reader.ReadString(), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
            if ((double) result != 3.4028234663852886E+38)
            {
              picture.VerticalPosition = (float) Math.Round((double) result / 12700.0, 2);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private ShapeVerticalAlignment GetVertAlign(string align)
  {
    switch (align)
    {
      case "top":
        return ShapeVerticalAlignment.Top;
      case "bottom":
        return ShapeVerticalAlignment.Bottom;
      case "center":
        return ShapeVerticalAlignment.Center;
      case "inside":
        return ShapeVerticalAlignment.Inside;
      case "inline":
        return ShapeVerticalAlignment.Inline;
      case "outside":
        return ShapeVerticalAlignment.Outside;
      default:
        return ShapeVerticalAlignment.None;
    }
  }

  private VerticalAlignment GetTextVertAlign(string align)
  {
    switch (align)
    {
      case "b":
      case "bottom":
        return VerticalAlignment.Bottom;
      case "ctr":
      case "middle":
        return VerticalAlignment.Middle;
      default:
        return VerticalAlignment.Top;
    }
  }

  private HeightOrigin GetHeightOrigin(string rel)
  {
    switch (rel)
    {
      case "page":
        return HeightOrigin.Page;
      case "top-margin-area":
        return HeightOrigin.TopMargin;
      case "inner-margin-area":
        return HeightOrigin.InsideMargin;
      case "outer-margin-area":
        return HeightOrigin.OutsideMargin;
      case "bottom-margin-area":
        return HeightOrigin.BottomMargin;
      default:
        return HeightOrigin.Margin;
    }
  }

  private WidthOrigin GetWidthOrigin(string rel)
  {
    switch (rel)
    {
      case "page":
        return WidthOrigin.Page;
      case "left-margin-area":
        return WidthOrigin.LeftMargin;
      case "inner-margin-area":
        return WidthOrigin.InsideMargin;
      case "outer-margin-area":
        return WidthOrigin.OutsideMargin;
      case "right-margin-area":
        return WidthOrigin.RightMargin;
      default:
        return WidthOrigin.Margin;
    }
  }

  private VerticalOrigin GetVertOrigin(string origin)
  {
    switch (origin.ToLower())
    {
      case "page":
        return VerticalOrigin.Page;
      case "paragraph":
      case "text":
        return VerticalOrigin.Paragraph;
      case "line":
        return VerticalOrigin.Line;
      case "topmargin":
      case "top-margin-area":
        return VerticalOrigin.TopMargin;
      case "bottommargin":
      case "bottom-margin-area":
        return VerticalOrigin.BottomMargin;
      case "innermargin":
      case "insidemargin":
      case "inner-margin-area":
        return VerticalOrigin.InsideMargin;
      case "outsidemargin":
      case "outermargin":
      case "outer-margin-area":
        return VerticalOrigin.OutsideMargin;
      default:
        return VerticalOrigin.Margin;
    }
  }

  private DocxParser.GraphicDataContentType CheckPicture(XmlReader reader)
  {
    reader.ReadToFollowing("graphicData", this.IsStrict ? "http://purl.oclc.org/ooxml/drawingml/main" : "http://schemas.openxmlformats.org/drawingml/2006/main");
    if (reader.LocalName != "graphicData")
      return DocxParser.GraphicDataContentType.None;
    string attribute = reader.GetAttribute("uri");
    if (!string.IsNullOrEmpty(attribute) && attribute == "http://schemas.openxmlformats.org/drawingml/2006/diagram")
      this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 28);
    if (!string.IsNullOrEmpty(attribute) && attribute == "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas")
      this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 10);
    if (attribute == null)
      return DocxParser.GraphicDataContentType.None;
    if (attribute == (this.IsStrict ? "http://purl.oclc.org/ooxml/drawingml/picture" : "http://schemas.openxmlformats.org/drawingml/2006/picture"))
      return DocxParser.GraphicDataContentType.Picture;
    if (attribute == (this.IsStrict ? "http://purl.oclc.org/ooxml/drawingml/chart" : "http://schemas.openxmlformats.org/drawingml/2006/chart"))
    {
      this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 8);
      return DocxParser.GraphicDataContentType.Chart;
    }
    switch (attribute)
    {
      case "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing":
      case "http://schemas.microsoft.com/office/word/2010/wordprocessingShape":
        return DocxParser.GraphicDataContentType.Shape;
      case "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup":
        this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 18);
        return DocxParser.GraphicDataContentType.Group;
      default:
        return DocxParser.GraphicDataContentType.None;
    }
  }

  private void ParseBreak(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    IOfficeMathRunElement mathRunElement)
  {
    if (reader.LocalName != "br" && reader.LocalName != "cr")
      throw new XmlException("break item");
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, reader.LocalName == "br" ? 6 : 7);
    string attribute1 = reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    Break @break;
    switch (attribute1)
    {
      case "column":
        @break = new Break((IWordDocument) this.m_doc, BreakType.ColumnBreak);
        break;
      case "page":
        @break = new Break((IWordDocument) this.m_doc, BreakType.PageBreak);
        break;
      default:
        @break = new Break((IWordDocument) this.m_doc, BreakType.LineBreak);
        WCharacterFormat charFormat = this.m_currentRunFormat != null ? this.m_currentRunFormat : @break.CharacterFormat;
        this.ApplyDirectionalOverride(charFormat);
        string str = this.IsWord2003ML ? "text-wrapping" : "textWrapping";
        if (attribute1 == str)
        {
          string attribute2 = reader.GetAttribute("clear", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
          if (!string.IsNullOrEmpty(attribute2))
          {
            switch (attribute2)
            {
              case "left":
                charFormat.BreakClear = BreakClearType.Left;
                break;
              case "right":
                charFormat.BreakClear = BreakClearType.Right;
                break;
              case "all":
                charFormat.BreakClear = BreakClearType.All;
                break;
              default:
                charFormat.BreakClear = BreakClearType.None;
                break;
            }
          }
        }
        @break.TextRange.Text = !(reader.LocalName == "cr") ? ControlChar.LineBreak : ControlChar.CarriegeReturn;
        break;
    }
    if (this.m_currentRunFormat != null)
    {
      @break.TextRange.ApplyCharacterFormat(this.m_currentRunFormat);
      this.ApplyDirectionalOverride(@break.CharacterFormat);
    }
    if (mathRunElement != null)
      mathRunElement.Item = (IOfficeRun) @break;
    else
      this.AddItem((ParagraphItem) @break, paraItems);
    this.CheckTrackChange((ParagraphItem) @break);
  }

  private ParagraphItem ParseSymbol(XmlReader reader, ParagraphItemCollection paraItems)
  {
    if (reader.LocalName != "sym")
      throw new XmlException("Excepting Symbol element");
    if (reader.AttributeCount != 2)
      return (ParagraphItem) null;
    string attribute1 = reader.GetAttribute("font", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    string attribute2 = reader.GetAttribute("char", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute1 == null || attribute2 == null)
      return (ParagraphItem) null;
    int result = 0;
    int.TryParse(attribute2, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    if (this.StartsWithExt(attribute2, "F0"))
      result -= 61440 /*0xF000*/;
    if (result <= (int) byte.MaxValue)
    {
      WSymbol symbol = new WSymbol((IWordDocument) this.m_doc);
      symbol.CharacterCode = (byte) result;
      symbol.FontName = attribute1;
      if (this.StartsWithExt(attribute2, "F0"))
        symbol.CharCodeExt = (byte) 240 /*0xF0*/;
      if (this.m_currentRunFormat != null)
      {
        symbol.CharacterFormat.ImportContainer((FormatBase) this.m_currentRunFormat);
        this.ApplyDirectionalOverride(symbol.CharacterFormat);
      }
      return (ParagraphItem) symbol;
    }
    WTextRange symbol1 = new WTextRange((IWordDocument) this.m_doc);
    if (this.m_currentRunFormat != null)
    {
      symbol1.CharacterFormat.ImportContainer((FormatBase) this.m_currentRunFormat);
      this.ApplyDirectionalOverride(symbol1.CharacterFormat);
    }
    symbol1.CharacterFormat.FontName = attribute1;
    symbol1.Text = Convert.ToString((char) result, (IFormatProvider) CultureInfo.InvariantCulture);
    return (ParagraphItem) symbol1;
  }

  private void UpdateTextRange(WTextRange textRange, string text, WCharacterFormat runFormat)
  {
    textRange.ApplyCharacterFormat(runFormat);
    textRange.Text = text;
    this.ApplyDirectionalOverride(textRange.CharacterFormat);
  }

  private WTextRange ParseText(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    bool isNestedInRunProperties,
    bool isMathRunText)
  {
    WTextRange txtRange = new WTextRange((IWordDocument) this.m_doc);
    if (this.m_currentRunFormat != null)
    {
      txtRange.ApplyCharacterFormat(this.m_currentRunFormat);
      txtRange.CharacterFormat.CharStyleId = this.m_currentRunFormat.CharStyleId;
    }
    this.ApplyDirectionalOverride(txtRange.CharacterFormat);
    if (reader.LocalName == "instrText" || reader.LocalName == "delInstrText")
    {
      string str = reader.ReadString();
      if (str != null)
      {
        txtRange.Text = str;
        this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, reader.LocalName == "delInstrText" ? 11 : 19);
      }
    }
    else
    {
      if (reader.LocalName == "t")
        this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 12);
      if (reader.LocalName == "delText")
        this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 13);
      bool preservespace = false;
      if (reader.HasAttributes && reader.MoveToAttribute("xml:space"))
        preservespace = reader.GetAttribute("xml:space") == "preserve";
      reader.MoveToElement();
      bool hasAnotherBodyInText = false;
      string m_localName = (string) null;
      txtRange.Text = this.GetNestedText(reader, ref hasAnotherBodyInText, paraItems, isNestedInRunProperties, false, ref m_localName, preservespace, isMathRunText);
      if (reader.LocalName == "r" && reader.NodeType == XmlNodeType.EndElement && txtRange.Text == string.Empty)
        return (WTextRange) null;
      if (!preservespace && !this.PreserveSpace && !isMathRunText)
        txtRange.Text = txtRange.Text.Trim(' ');
      if (hasAnotherBodyInText && !isNestedInRunProperties)
      {
        if (m_localName == "tbl")
        {
          this.m_currentRunFormat = (WCharacterFormat) null;
          WTable nestedTable = this.ParseNestedTable(reader, (paraItems.Owner as WParagraph).Owner, m_localName);
          if (nestedTable != null && nestedTable.Rows.Count > 0)
            this.MoveParaItemsToNestedTable(nestedTable, paraItems, txtRange);
          else
            this.AddToParagraph((ParagraphItem) txtRange, paraItems);
        }
        else
        {
          this.AddToParagraph((ParagraphItem) txtRange, paraItems);
          this.ParseNestedBody(reader, hasAnotherBodyInText);
        }
        return (WTextRange) null;
      }
    }
    return txtRange;
  }

  private WTable ParseNestedTable(XmlReader reader, Entity ownerTextBody, string localName)
  {
    IWTable table = this.AddTable((IEntity) ownerTextBody);
    table.TableFormat.IsAutoResized = true;
    short gridCount = this.m_gridCount;
    this.ParseTable(reader, table as WTable, true, localName);
    this.m_gridCount = gridCount;
    if (table.Rows.Count == 0)
      (table.Owner as WTextBody).ChildEntities.RemoveAt((table as WTable).Index);
    return table as WTable;
  }

  private void MoveParaItemsToNestedTable(
    WTable table,
    ParagraphItemCollection paraItems,
    WTextRange txtRange)
  {
    WParagraph wparagraph = table.Rows[0].Cells.Count <= 0 || table.Rows[0].Cells[0].ChildEntities.Count <= 0 || !(table.Rows[0].Cells[0].ChildEntities[0] is WParagraph) ? new WParagraph((IWordDocument) this.m_doc) : table.Rows[0].Cells[0].ChildEntities[0] as WParagraph;
    if (wparagraph.Owner == null)
      table.Rows[0].Cells[0].ChildEntities.Insert(0, (IEntity) wparagraph);
    int index = 0;
    wparagraph.ChildEntities.Insert(index, (IEntity) txtRange);
    while (paraItems.Count > 0)
    {
      wparagraph.ChildEntities.Insert(index, (IEntity) paraItems[0]);
      ++index;
    }
    (table.Owner as WTextBody).ChildEntities.RemoveAt(table.Index - 1);
  }

  private void ParseNestedBody(XmlReader reader, bool isFirstNestedBody)
  {
    while (reader.NodeType == XmlNodeType.Element && reader.LocalName.Equals("body"))
    {
      this.ParseBody(reader, (IEntity) null, isFirstNestedBody, false, false);
      if (reader.NodeType == XmlNodeType.EndElement)
        reader.Read();
      this.SkipWhitespaces(reader);
      isFirstNestedBody = false;
    }
  }

  private string GetNestedText(
    XmlReader reader,
    ref bool hasAnotherBodyInText,
    ParagraphItemCollection paraItems,
    bool isNestedInRunProperties,
    bool isAlreadyCheck,
    ref string m_localName,
    bool preservespace,
    bool isMathRunText)
  {
    string nestedText = string.Empty;
    if (isAlreadyCheck)
      nestedText = this.GetNestedTextValue(reader, ref hasAnotherBodyInText, paraItems, isNestedInRunProperties, ref m_localName, preservespace, isMathRunText);
    else if (!reader.IsEmptyElement)
    {
      string localName = reader.LocalName;
      reader.Read();
      if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return nestedText;
      nestedText = this.GetNestedTextValue(reader, ref hasAnotherBodyInText, paraItems, isNestedInRunProperties, ref m_localName, preservespace, isMathRunText);
    }
    return nestedText;
  }

  private string GetNestedTextValue(
    XmlReader reader,
    ref bool hasAnotherBodyInText,
    ParagraphItemCollection paraItems,
    bool isNestedInRunProperties,
    ref string m_localName,
    bool preservespace,
    bool isMathRunText)
  {
    string nestedTextValue = string.Empty;
    int num = 0;
    string str1 = reader.Value;
    if (reader.XmlSpace != XmlSpace.None || !this.PreserveSpace)
      this.SkipWhitespaces(reader);
    while (num > 0 || reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Text || reader.NodeType == XmlNodeType.SignificantWhitespace || reader.NodeType == XmlNodeType.CDATA || reader.NodeType == XmlNodeType.Whitespace && reader.XmlSpace == XmlSpace.None && this.PreserveSpace)
      {
        string str2 = reader.Value;
        nestedTextValue = preservespace || this.PreserveSpace || isMathRunText || !str2.Contains("\t") ? nestedTextValue + str2 : nestedTextValue + str2.Replace("\t", " ");
        if (nestedTextValue.Contains(ControlChar.LineFeed))
          nestedTextValue = nestedTextValue.Trim(ControlChar.LineFeedChar).Replace(ControlChar.LineFeedChar, ' ');
      }
      else if (!isNestedInRunProperties && reader.NodeType == XmlNodeType.Element)
      {
        if (!reader.IsEmptyElement)
        {
          string localName = reader.LocalName;
          XmlNodeType nodeType = reader.NodeType;
          reader.Read();
          if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
          {
            if (nodeType == XmlNodeType.Element && localName == "r")
              this.ParseRun(reader, paraItems, (IOfficeMathRunElement) null, true, nodeType, false);
            else if (nodeType == XmlNodeType.Element)
            {
              if (nodeType == XmlNodeType.Element && (localName == "body" || localName == "tbl"))
              {
                m_localName = localName;
                hasAnotherBodyInText = true;
                break;
              }
              ++num;
              string str3 = this.GetNestedText(reader, ref hasAnotherBodyInText, paraItems, false, true, ref m_localName, preservespace, isMathRunText).Replace(ControlChar.CrLf, " ").Replace(ControlChar.ParagraphBreak, " ").Replace(ControlChar.LineFeedChar, ' ');
              nestedTextValue += str3;
            }
            else if (nodeType == XmlNodeType.Element && localName == "br")
              nestedTextValue += "\v";
            else if (isNestedInRunProperties && nodeType == XmlNodeType.Element)
              this.SkipCurrentElement(reader, reader.LocalName);
          }
        }
        else if (reader.NodeType == XmlNodeType.Element && reader.LocalName == "br")
          nestedTextValue += "\v";
        else if (isNestedInRunProperties && reader.NodeType == XmlNodeType.Element)
          this.SkipCurrentElement(reader, reader.LocalName);
      }
      else if (!isNestedInRunProperties && reader.NodeType == XmlNodeType.Element && reader.LocalName == "br")
        nestedTextValue += "\v";
      else if (isNestedInRunProperties && reader.NodeType == XmlNodeType.Element)
        this.SkipCurrentElement(reader, reader.LocalName);
      if (reader.NodeType == XmlNodeType.EndElement)
      {
        if (num != 0)
          --num;
        else
          break;
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
    return nestedTextValue;
  }

  private void SkipCurrentElement(XmlReader reader, string element)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.NodeType != XmlNodeType.EndElement || !(reader.LocalName == element))
      reader.Read();
  }

  private string RotateText(string text)
  {
    char[] charArray = text.ToCharArray();
    string empty = string.Empty;
    for (int index = charArray.Length - 1; index >= 0; --index)
      empty += charArray[index].ToString();
    return empty;
  }

  private string ModifyText(string text)
  {
    text = text.Replace("&amp;", "&");
    text = text.Replace("&lt;", "<");
    text = text.Replace("&gt;", ">");
    return text;
  }

  private void ParseDocumentBackground(XmlReader reader)
  {
    XmlReader reader1 = !(reader.LocalName != "background") ? UtilityMethods.CreateReader((Stream) this.ReadSingleNodeIntoStream(reader)) : throw new XmlException("background");
    this.m_doc.Background.SetBackgroundColor(this.GetColorValue(reader1.GetAttribute("color", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main")));
    this.m_doc.Background.Type = BackgroundType.Color;
    while (reader1.Read())
    {
      if (reader1.NodeType == XmlNodeType.Element)
      {
        switch (reader1.LocalName)
        {
          case "background":
            string attribute1 = reader1.GetAttribute("fillcolor");
            Color color = Color.White;
            if (attribute1 != null)
              color = this.GetColorValue(attribute1);
            if (!color.Equals((object) Color.White))
            {
              this.m_doc.Background.SetBackgroundColor(color);
              continue;
            }
            continue;
          case "fill":
            string attribute2 = reader1.GetAttribute("type");
            if (this.StartsWithExt(attribute2, "gradient"))
            {
              this.ParseGradientFill(reader1, this.m_doc.Background);
              continue;
            }
            if (attribute2 == "frame" || attribute2 == "tile")
            {
              this.ParseBackgroundPicture(reader1, this.m_doc.Background);
              continue;
            }
            continue;
          default:
            continue;
        }
      }
    }
  }

  private void ParseBackgroundPicture(XmlReader reader, Background background)
  {
    string attribute1 = reader.GetAttribute("type");
    string attribute2 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    if (attribute1 == null || attribute2 == null)
      return;
    background.Type = attribute1 == "tile" ? BackgroundType.Texture : BackgroundType.Picture;
    bool isImageRelation = true;
    string imageName = this.GetImageName(attribute2, false, false, ref isImageRelation);
    if (!isImageRelation)
      return;
    if (this.ImageIds.ContainsKey(imageName))
    {
      background.ImageRecord = this.m_doc.Images[this.ImageIds[imageName]];
    }
    else
    {
      byte[] imageBytes = this.GetImageBytes(imageName);
      if (imageBytes != null)
      {
        background.ImageBytes = imageBytes;
        this.ImageIds.Add(imageName, background.ImageRecord.ImageId);
      }
      else
        background.Type = BackgroundType.NoBackground;
    }
  }

  private AlternateChunk AddAlternateChunk(IEntity entity)
  {
    AlternateChunk alternateChunk;
    if (entity != null)
    {
      switch (entity.EntityType)
      {
        case Syncfusion.DocIO.DLS.EntityType.HeaderFooter:
          alternateChunk = (entity as HeaderFooter).AddAlternateChunk();
          break;
        case Syncfusion.DocIO.DLS.EntityType.BlockContentControl:
          alternateChunk = (entity as BlockContentControl).TextBody.AddAlternateChunk();
          break;
        case Syncfusion.DocIO.DLS.EntityType.TableCell:
          alternateChunk = (entity as WTableCell).AddAlternateChunk();
          Entity ownerTextBody = alternateChunk.GetOwnerTextBody((Entity) entity);
          if (ownerTextBody is WFootnote)
          {
            (ownerTextBody as WFootnote).TextBody.AlternateChunkCollection.Add(alternateChunk);
            break;
          }
          break;
        case Syncfusion.DocIO.DLS.EntityType.Shape:
          alternateChunk = (entity as Shape).TextBody.AddAlternateChunk();
          break;
        case Syncfusion.DocIO.DLS.EntityType.Comment:
          alternateChunk = (entity as WComment).TextBody.AddAlternateChunk();
          break;
        case Syncfusion.DocIO.DLS.EntityType.Footnote:
          alternateChunk = (entity as WFootnote).TextBody.AddAlternateChunk();
          (entity as WFootnote).TextBody.AlternateChunkCollection.Add(alternateChunk);
          break;
        case Syncfusion.DocIO.DLS.EntityType.TextBox:
          alternateChunk = (entity as WTextBox).TextBoxBody.AddAlternateChunk();
          break;
        default:
          alternateChunk = this.m_doc.LastSection.AddAlternateChunk();
          break;
      }
    }
    else
      alternateChunk = this.m_doc.LastSection.AddAlternateChunk();
    if (this.m_doc.LastSection != null)
      this.m_doc.LastSection.Body.AlternateChunkCollection.Add(alternateChunk);
    return alternateChunk;
  }

  private void ParseAlternateChunk(XmlReader reader, AlternateChunk altChunk)
  {
    string attribute = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
    altChunk.TargetId = attribute;
    string fileName = (string) this.GetRelation(attribute).Value;
    string str = this.GetPartName(ref fileName);
    if (!string.IsNullOrEmpty(str))
      str = str.Replace("word/", (string) null);
    altChunk.ContentPath = str + fileName;
    altChunk.ContentType = this.GetExtensionContentType(altChunk.ContentExtension);
    string localName1 = reader.LocalName;
    if (reader.IsEmptyElement)
      return;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName1)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "matchSrc":
            if (this.GetBooleanValue(reader))
            {
              altChunk.ImportOption = ImportOptions.KeepSourceFormatting;
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private IBlockContentControl AddStructureDocumentTagBlock(IEntity entity)
  {
    IBlockContentControl blockContentControl;
    switch (entity)
    {
      case HeaderFooter _:
        blockContentControl = (entity as HeaderFooter).AddStructureDocumentTag();
        break;
      case WFootnote _:
        blockContentControl = (entity as WFootnote).TextBody.AddStructureDocumentTag();
        break;
      case WComment _:
        blockContentControl = (entity as WComment).TextBody.AddStructureDocumentTag();
        break;
      case BlockContentControl _:
        blockContentControl = (entity as BlockContentControl).TextBody.AddStructureDocumentTag();
        break;
      case WTableCell _:
        blockContentControl = (entity as WTableCell).AddStructureDocumentTag();
        break;
      default:
        blockContentControl = this.m_doc.LastSection.AddStructureDocumentTag();
        break;
    }
    return blockContentControl;
  }

  private void ParseStructureDocumentTagInline(XmlReader reader, InlineContentControl sdTagInline)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "sdtPr":
            this.ParseSDTProperties(reader, sdTagInline.ContentControlProperties);
            break;
          case "sdtContent":
            this.ParseSDTContentInline(reader, sdTagInline);
            if (sdTagInline.ContentControlProperties.XmlMapping != null)
            {
              this.InlineContentControls.Add(sdTagInline);
              break;
            }
            break;
          case "sdtEndPr":
            this.ParseSDTEndCharacterFormat(reader, sdTagInline.BreakCharacterFormat);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseSDTContentInline(XmlReader reader, InlineContentControl sdtInlineContent)
  {
    this.ParseParagraphItems(reader, sdtInlineContent.ParagraphItems, (string) null, (IOfficeMathRunElement) null, sdtInlineContent.ContentControlProperties.XmlMapping.IsMapped);
    this.contentRevision = (Revision) null;
  }

  private void ParseStructureDocumentTagBlock(XmlReader reader, BlockContentControl sdTagBlock)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 2);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "sdtPr":
            this.ParseSDTProperties(reader, sdTagBlock.ContentControlProperties);
            break;
          case "sdtContent":
            this.ParseSDTContent(reader, sdTagBlock);
            flag = true;
            if (sdTagBlock.ContentControlProperties.XmlMapping != null && sdTagBlock.ContentControlProperties.XmlMapping.IsMapped && sdTagBlock.ContentControlProperties.Type == ContentControlType.Picture)
              this.MapPictureContentControl(sdTagBlock);
            else if (sdTagBlock.ContentControlProperties.XmlMapping != null)
              this.BlockContentControls.Add(sdTagBlock);
            if (this.BreakCollection.Count > 0)
            {
              this.InsertPostBreakElements(this.AddParagraph((IEntity) sdTagBlock));
              break;
            }
            break;
          case "sdtEndPr":
            this.ParseSDTEndCharacterFormat(reader, sdTagBlock.BreakCharacterFormat);
            break;
          case "p":
            IWParagraph paragraph = this.AddParagraph((IEntity) sdTagBlock);
            (paragraph as WParagraph).ParaId = reader.GetAttribute("paraId", "http://schemas.microsoft.com/office/word/2010/wordml");
            this.AddPostElements(paragraph);
            this.InsertPostBreakElements(paragraph);
            this.ParseParagraphItems(reader, paragraph.Items, (string) null, (IOfficeMathRunElement) null, false);
            this.m_doc.UpdateLastItemRevision(paragraph, paragraph.Items);
            if (!string.IsNullOrEmpty(paragraph.StyleName))
            {
              (paragraph as WParagraph).ApplyStyle(paragraph.StyleName, false);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void MapPictureContentControl(BlockContentControl sdTagBlock)
  {
    List<BlockContentControl> ContentControls = new List<BlockContentControl>();
    ContentControls.Add(sdTagBlock);
    Dictionary<string, List<BlockContentControl>> resultBlockControls = new Dictionary<string, List<BlockContentControl>>();
    PartContainer partContainer = this.m_doc.DocxPackage.FindPartContainer("customXml/");
    if (!(partContainer.Name == "customXml/"))
      return;
    string empty = string.Empty;
    foreach (KeyValuePair<string, Part> xmlPart in partContainer.XmlParts)
    {
      string key = xmlPart.Key;
      if (key.Contains("Props") && partContainer.XmlParts[xmlPart.Key].DataStream.Length > 0L)
      {
        List<BlockContentControl> blockContentControlList = new List<BlockContentControl>();
        Stream input = UtilityMethods.CloneStream(partContainer.XmlParts[xmlPart.Key].DataStream);
        XmlDocument xmlDocument = new XmlDocument();
        using (XmlTextReader reader = new XmlTextReader(input))
        {
          reader.Namespaces = false;
          xmlDocument.Load((XmlReader) reader);
        }
        XmlElement documentElement = xmlDocument.DocumentElement;
        if (documentElement != null)
        {
          foreach (XmlAttribute attribute in (XmlNamedNodeMap) documentElement.Attributes)
          {
            if (attribute.Name.Contains("itemID"))
            {
              foreach (BlockContentControl blockContentControl in ContentControls)
              {
                if (attribute.Value.Equals(blockContentControl.ContentControlProperties.XmlMapping.StoreItemID))
                  blockContentControlList.Add(blockContentControl);
                else if (!string.IsNullOrEmpty(blockContentControl.ContentControlProperties.XmlMapping.XPath) && string.IsNullOrEmpty(blockContentControl.ContentControlProperties.XmlMapping.StoreItemID) || this.m_doc != null && this.m_doc.m_AltChunkOwner != null)
                  blockContentControlList.Add(blockContentControl);
              }
            }
          }
        }
        if (blockContentControlList.Count > 0)
          resultBlockControls.Add(key, blockContentControlList);
        blockContentControlList.Clear();
      }
    }
    List<BlockContentControl> matchedContentControl = this.GetIdMisMatchedContentControl(resultBlockControls, ContentControls);
    if (matchedContentControl.Count > 0)
      resultBlockControls.Add("", matchedContentControl);
    if (resultBlockControls.Count > 0)
      this.ResetBlockControlWithMappedItem(partContainer, resultBlockControls);
    matchedContentControl.Clear();
    resultBlockControls.Clear();
  }

  private void ParseSDTEndCharacterFormat(XmlReader reader, WCharacterFormat charFormat)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "rPr":
            this.ParseCharacterFormat(reader, charFormat, (ParagraphItemCollection) null);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseSDTContent(XmlReader reader, BlockContentControl sdTagBlock)
  {
    this.ParseBody(reader, (IEntity) sdTagBlock, false, false, sdTagBlock.ContentControlProperties.Type == ContentControlType.Picture && sdTagBlock.ContentControlProperties.XmlMapping != null && sdTagBlock.ContentControlProperties.XmlMapping.IsMapped);
  }

  private void ParseSDTProperties(XmlReader reader, ContentControlProperties properties)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "rPr":
            this.ParseCharacterFormat(reader, properties.CharacterFormat, (ParagraphItemCollection) null);
            break;
          case "id":
            properties.ID = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
          case "showingPlcHdr":
            properties.HasPlaceHolderText = true;
            break;
          case "alias":
            properties.Title = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
          case "bibliography":
            properties.Bibliograph = true;
            break;
          case "citation":
            properties.Citation = true;
            break;
          case "temporary":
            properties.IsTemporary = true;
            break;
          case "appearance":
            string attribute1 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2012/wordml");
            if (!string.IsNullOrEmpty(attribute1))
            {
              properties.Appearance = this.GetAppearance(attribute1);
              break;
            }
            break;
          case "color":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute2))
            {
              properties.Color = this.GetColorValue(attribute2);
              break;
            }
            break;
          case "picture":
            properties.Type = ContentControlType.Picture;
            break;
          case "text":
            properties.Type = ContentControlType.Text;
            string attribute3 = reader.GetAttribute("multiLine", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute3))
            {
              properties.Multiline = this.GetBoolValue(attribute3);
              break;
            }
            break;
          case "richText":
            properties.Type = ContentControlType.RichText;
            break;
          case "comboBox":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_2, 14);
            properties.Type = ContentControlType.ComboBox;
            properties.ContentControlListItems.LastValue = reader.GetAttribute("lastValue", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            this.ParseSDTComboBox(reader, properties.ContentControlListItems);
            break;
          case "dropDownList":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 15);
            properties.Type = ContentControlType.DropDownList;
            properties.ContentControlListItems.LastValue = reader.GetAttribute("lastValue", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            this.ParseSDTDropDownList(reader, properties.ContentControlListItems);
            break;
          case "group":
            properties.Type = ContentControlType.Group;
            break;
          case "repeatingSection":
            properties.Type = ContentControlType.RepeatingSection;
            break;
          case "placeholder":
            this.ParseSDTPlaceHolder(reader, properties);
            break;
          case "lock":
            switch (reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
            {
              case "sdtLocked":
                properties.LockContentControl = true;
                break;
              case "sdtContentLocked":
                properties.LockContentControl = true;
                properties.LockContents = true;
                break;
              case "contentLocked":
                properties.LockContents = true;
                break;
              case "unlocked":
                properties.Unlocked = true;
                break;
            }
            break;
          case "date":
            properties.Type = ContentControlType.Date;
            string attribute4 = reader.GetAttribute("fullDate", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (attribute4 != string.Empty)
              properties.FullDate = attribute4;
            this.ParseSDTDate(reader, properties);
            break;
          case "dataBinding":
            properties.XmlMapping = new XmlMapping(properties.Owner);
            properties.XmlMapping.XPath = reader.GetAttribute("xpath", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            properties.XmlMapping.StoreItemID = reader.GetAttribute("storeItemID", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            properties.XmlMapping.PrefixMapping = reader.GetAttribute("prefixMappings", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            properties.XmlMapping.IsMapped = true;
            if (reader.NamespaceURI == "http://schemas.microsoft.com/office/word/2010/wordml" || reader.NamespaceURI == "http://schemas.microsoft.com/office/word/2012/wordml")
            {
              properties.XmlMapping.IsSupportWordML = true;
              break;
            }
            break;
          case "checkbox":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 9);
            properties.Type = ContentControlType.CheckBox;
            this.parseSDTCheckBox(reader, properties);
            break;
          case "docPartObj":
            properties.DocPartObj = new DocPartObj();
            this.ParseDocPartObj(reader, properties.DocPartObj, properties);
            break;
          case "docPartList":
            properties.DocPartList = new DocPartList();
            this.ParseDocPartList(reader, properties.DocPartList, properties);
            break;
          case "repeatingSectionItem":
            properties.ContentRepeatingType = ContentRepeatingType.RepeatingSectionItem;
            break;
          case "tag":
            properties.Tag = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseSDTPlaceHolder(XmlReader reader, ContentControlProperties properties)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "docPart":
            string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (attribute != string.Empty)
            {
              properties.PlaceHolderDocPartId = attribute;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private ContentControlAppearance GetAppearance(string appearance)
  {
    switch (appearance)
    {
      case "hidden":
        return ContentControlAppearance.Hidden;
      case "tags":
        return ContentControlAppearance.Tags;
      default:
        return ContentControlAppearance.BoundingBox;
    }
  }

  private void ParseDocPartList(
    XmlReader reader,
    DocPartList docPartList,
    ContentControlProperties controlProperties)
  {
    this.ParseDocPartItem(reader, (DocPartItem) docPartList, controlProperties);
  }

  private void ParseDocPartItem(
    XmlReader reader,
    DocPartItem docPartItem,
    ContentControlProperties controlProperties)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "docPartUnique":
            docPartItem.IsDocPartUnique = true;
            break;
          case "docPartGallery":
            controlProperties.Type = ContentControlType.BuildingBlockGallery;
            docPartItem.DocPartGallery = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (docPartItem.DocPartGallery.Equals("Cover Pages"))
            {
              this.m_doc.HasCoverPage = true;
              break;
            }
            break;
          case "docPartCategory":
            controlProperties.Type = ContentControlType.BuildingBlockGallery;
            docPartItem.DocPartCategory = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseDocPartObj(
    XmlReader reader,
    DocPartObj docPartobj,
    ContentControlProperties controlProperties)
  {
    this.ParseDocPartItem(reader, (DocPartItem) docPartobj, controlProperties);
  }

  private void parseSDTCheckBox(XmlReader reader, ContentControlProperties properties)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "checked":
            properties.IsChecked = this.GetBooleanValue(reader, "http://schemas.microsoft.com/office/word/2010/wordml");
            break;
          case "checkedState":
            int result1;
            int.TryParse(reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"), NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
            properties.CheckedState.Value = ((char) result1).ToString();
            properties.CheckedState.Font = reader.GetAttribute("font", "http://schemas.microsoft.com/office/word/2010/wordml");
            break;
          case "uncheckedState":
            int result2;
            int.TryParse(reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"), NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
            properties.UncheckedState.Font = reader.GetAttribute("font", "http://schemas.microsoft.com/office/word/2010/wordml");
            properties.UncheckedState.Value = ((char) result2).ToString();
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseSDTDropDownList(XmlReader reader, ContentControlListItems dropDownList)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "listItem":
            dropDownList.Add(new ContentControlListItem()
            {
              DisplayText = reader.GetAttribute("displayText", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"),
              Value = reader.GetAttribute("value", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main")
            });
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseSDTComboBox(XmlReader reader, ContentControlListItems comboBox)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName2 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName1)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "listItem":
            comboBox.Add(new ContentControlListItem()
            {
              DisplayText = reader.GetAttribute("displayText", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"),
              Value = reader.GetAttribute("value", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main")
            });
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseSDTDate(XmlReader reader, ContentControlProperties controlProperties)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName2)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "dateFormat":
            controlProperties.DateDisplayFormat = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
          case "lid":
            string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute))
            {
              controlProperties.DateDisplayLocale = (LocaleIDs) System.Enum.Parse(typeof (LocaleIDs), attribute.Replace('-', '_'));
              break;
            }
            break;
          case "storeMappedDataAs":
            if (!string.IsNullOrEmpty(reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main")))
            {
              controlProperties.DateStorageFormat = this.GetDateStorageType(reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
              break;
            }
            break;
          case "calendar":
            if (!string.IsNullOrEmpty(reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main")))
            {
              CalendarType calendarType = this.GetCalendarType(reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"));
              controlProperties.DateCalendarType = calendarType;
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private CalendarType GetCalendarType(string type)
  {
    switch (type)
    {
      case "gregorian":
        return CalendarType.Gregorian;
      case "gregorianArabic":
        return CalendarType.GregorianArabic;
      case "gregorianMeFrench":
        return CalendarType.GregorianMiddleEastFrench;
      case "gregorianUs":
        return CalendarType.GregorianEnglish;
      case "gregorianXlitEnglish":
        return CalendarType.GregorianTransliteratedEnglish;
      case "gregorianXlitFrench":
        return CalendarType.GregorianTransliteratedFrench;
      case "hebrew":
        return CalendarType.Hebrew;
      case "hijri":
        return CalendarType.Hijri;
      case "japan":
        return CalendarType.Japan;
      case "korea":
        return CalendarType.Korean;
      case "saka":
        return CalendarType.Saka;
      case "taiwan":
        return CalendarType.Taiwan;
      case "thai":
        return CalendarType.Thai;
      default:
        return CalendarType.Gregorian;
    }
  }

  private ContentControlDateStorageFormat GetDateStorageType(string type)
  {
    switch (type)
    {
      case "date":
        return ContentControlDateStorageFormat.DateStorageDate;
      case "text":
        return ContentControlDateStorageFormat.DateStorageText;
      default:
        return ContentControlDateStorageFormat.DateStorageDateTime;
    }
  }

  private void ParseMathMlElement(XmlReader reader, ParagraphItemCollection paraItems)
  {
    MathMLParser mathMlParser = new MathMLParser();
    XmlParagraphItem xmlParagraphItem = new XmlParagraphItem((Stream) this.ReadSingleNodeIntoStream(reader), (IWordDocument) this.m_doc);
    WMath wmath = new WMath((IWordDocument) this.m_doc);
    paraItems.Add((IEntity) wmath);
    XmlReader reader1 = UtilityMethods.CreateReader(xmlParagraphItem.DataNode);
    if (reader1.LocalName == "oMathPara")
    {
      mathMlParser.ParseMathPara(reader1, wmath.MathParagraph, (DocumentParser) this);
    }
    else
    {
      OfficeMath officeMath = wmath.MathParagraph.Maths.Add(wmath.MathParagraph.Maths.Count) as OfficeMath;
      mathMlParser.ParseMath(reader1, officeMath, (DocumentParser) this);
    }
  }

  internal override IOfficeRunFormat ParseMathControlFormat(
    XmlReader reader,
    IOfficeMathFunctionBase mathFunction)
  {
    WParagraph wparagraph = (WParagraph) null;
    if (mathFunction != null)
      wparagraph = this.GetMathOwnerParagraph(mathFunction);
    WCharacterFormat charFormat = new WCharacterFormat((IWordDocument) this.m_doc);
    this.ApplyDirectionalOverride(charFormat);
    if (wparagraph != null && wparagraph.ParaStyle != null)
      charFormat.ApplyBase((FormatBase) wparagraph.ParaStyle.CharacterFormat);
    this.ParseCharacterFormat(reader, charFormat, (ParagraphItemCollection) null);
    return (IOfficeRunFormat) charFormat;
  }

  internal override void ParseMathRun(XmlReader reader, IOfficeMathRunElement mathParaItem)
  {
    this.ParseRun(reader, (ParagraphItemCollection) null, mathParaItem, false, reader.NodeType, false);
  }

  private void ParseDocumentRelations(Stream stream)
  {
    this.ParseRelations(UtilityMethods.CreateReader(stream), this.DocumentRelations);
  }

  private void ParseFontTableRelations(Stream stream)
  {
    this.ParseRelations(UtilityMethods.CreateReader(stream), this.FontTableRelations);
  }

  private void ParseRelations(XmlReader relReader, Dictionary<string, DictionaryEntry> relations)
  {
    int content = (int) relReader.MoveToContent();
    if (relReader.LocalName != "Relationships")
    {
      relReader.ReadInnerXml();
    }
    else
    {
      if (relReader.IsEmptyElement)
        return;
      string localName = relReader.LocalName;
      relReader.Read();
      bool flag1 = true;
      if (localName == relReader.LocalName && relReader.NodeType == XmlNodeType.EndElement)
        return;
      do
      {
        if (!flag1)
          relReader.Read();
        string attribute1 = relReader.GetAttribute("Id");
        string attribute2 = relReader.GetAttribute("Target");
        string attribute3 = relReader.GetAttribute("Type");
        if (attribute1 != null && attribute2 != null && attribute3 != null)
        {
          DictionaryEntry dictionaryEntry = new DictionaryEntry((object) attribute3, (object) attribute2);
          relations.Add(attribute1, dictionaryEntry);
          bool flag2 = relReader.GetAttribute("TargetMode") == "External";
          if (flag2 && !this.IsExternalHyperlink.ContainsKey(attribute1))
            this.IsExternalHyperlink.Add(attribute1, flag2);
        }
        flag1 = false;
      }
      while (relReader.LocalName != "Relationships");
    }
  }

  private void ParseCustomProperties(XmlReader reader)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "Properties")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    CustomDocumentProperties documentProperties = this.m_doc.CustomDocumentProperties;
    this.SkipWhitespaces(reader);
    if (reader.EOF)
      return;
    do
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        if (reader.LocalName == "property")
          this.ParseCustomProperty(reader, documentProperties);
      }
      else
        reader.Skip();
      reader.Read();
      this.SkipWhitespaces(reader);
    }
    while (!reader.EOF);
  }

  private void ParseCustomProperty(XmlReader reader, CustomDocumentProperties customProperties)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    if (customProperties == null)
      throw new ArgumentNullException(nameof (customProperties));
    if (reader.LocalName != "property")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    reader.GetAttribute("name");
    reader.MoveToElement();
    string strName = (string) null;
    int result1 = 0;
    if (!(reader.LocalName == "property"))
      return;
    do
    {
      if (reader.NodeType == XmlNodeType.Element && reader.LocalName == "property")
      {
        if (reader.MoveToAttribute("name"))
          strName = reader.Value;
        if (reader.MoveToAttribute("pid"))
          int.TryParse(reader.Value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
      }
      else if (reader.NodeType == XmlNodeType.Element && strName != null)
      {
        string localName = reader.LocalName;
        reader.Read();
        if (!localName.Equals("lpstr") && !localName.Equals("lpwstr"))
          this.SkipWhitespaces(reader);
        switch (localName)
        {
          case "i4":
            float result2 = 0.0f;
            string s1 = reader.Value;
            if (!string.IsNullOrEmpty(s1))
            {
              float.TryParse(s1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
              DocumentProperty documentProperty = new DocumentProperty(strName, (object) (int) Math.Round((double) result2));
              this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
              break;
            }
            break;
          case "r8":
            double result3 = 0.0;
            string s2 = reader.Value;
            if (!string.IsNullOrEmpty(s2))
            {
              double.TryParse(s2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result3);
              DocumentProperty documentProperty = new DocumentProperty(strName, (object) result3);
              this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
              break;
            }
            break;
          case "lpstr":
          case "lpwstr":
            string text = reader.Value;
            if (text != null)
            {
              DocumentProperty documentProperty = new DocumentProperty(strName, (object) this.UpdateText(text));
              this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
              break;
            }
            break;
          case "filetime":
            string s3 = reader.Value;
            if (!string.IsNullOrEmpty(s3))
            {
              DateTime result4 = new DateTime();
              DateTime.TryParse(s3, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result4);
              DocumentProperty documentProperty = new DocumentProperty(strName, (object) result4);
              this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
              break;
            }
            break;
          case "bool":
            string str = reader.Value;
            if (!string.IsNullOrEmpty(str))
            {
              DocumentProperty documentProperty = new DocumentProperty(strName, (object) this.GetBoolValue(str));
              this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
              break;
            }
            break;
        }
      }
      reader.Read();
    }
    while (!reader.EOF && reader.LocalName != "property");
  }

  private string UpdateText(string text)
  {
    text = XmlConvert.DecodeName(text);
    return text;
  }

  private void ParseCoreProperties(XmlReader reader)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "coreProperties")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    BuiltinDocumentProperties documentProperties = this.m_doc.BuiltinDocumentProperties;
    while (reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "category":
            documentProperties.Category = this.GetReaderElementValue(reader);
            continue;
          case "created":
            DateTime result1 = new DateTime();
            DateTime.TryParse(this.GetReaderElementValue(reader), (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result1);
            documentProperties.CreateDate = result1;
            continue;
          case "creator":
            documentProperties.Author = this.GetReaderElementValue(reader);
            continue;
          case "description":
            documentProperties.Comments = this.GetReaderElementValue(reader);
            continue;
          case "keywords":
            documentProperties.Keywords = this.GetReaderElementValue(reader);
            continue;
          case "lastModifiedBy":
            documentProperties.LastAuthor = this.GetReaderElementValue(reader);
            continue;
          case "lastPrinted":
            DateTime result2 = new DateTime();
            DateTime.TryParse(this.GetReaderElementValue(reader), (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result2);
            documentProperties.LastPrinted = result2;
            continue;
          case "modified":
            DateTime result3 = new DateTime();
            DateTime.TryParse(this.GetReaderElementValue(reader), (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result3);
            documentProperties.LastSaveDate = result3;
            continue;
          case "subject":
            documentProperties.Subject = this.GetReaderElementValue(reader);
            continue;
          case "title":
            documentProperties.Title = this.GetReaderElementValue(reader);
            continue;
          case "revision":
            documentProperties.RevisionNumber = this.GetReaderElementValue(reader);
            continue;
          case "contentStatus":
            documentProperties.ContentStatus = this.GetReaderElementValue(reader);
            continue;
          default:
            reader.Skip();
            continue;
        }
      }
      else
        reader.Skip();
    }
  }

  private void ParseAppProperties(XmlReader reader)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "Properties")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    BuiltinDocumentProperties documentProperties = this.m_doc.BuiltinDocumentProperties;
    while (reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "Template":
            documentProperties.Template = this.GetReaderElementValue(reader);
            continue;
          case "TotalTime":
            string readerElementValue1 = this.GetReaderElementValue(reader);
            double result = 0.0;
            double.TryParse(readerElementValue1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
            documentProperties.TotalEditingTime = TimeSpan.FromMinutes(Math.Round(result));
            continue;
          case "Pages":
            string readerElementValue2 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(PIDSI.Pagecount, (object) this.GetAppProperty(readerElementValue2));
            continue;
          case "Words":
            string readerElementValue3 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(PIDSI.Wordcount, (object) this.GetAppProperty(readerElementValue3));
            continue;
          case "Characters":
            string readerElementValue4 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(PIDSI.Charcount, (object) this.GetAppProperty(readerElementValue4));
            continue;
          case "Application":
            documentProperties.ApplicationName = this.GetReaderElementValue(reader);
            continue;
          case "DocSecurity":
            string readerElementValue5 = this.GetReaderElementValue(reader);
            documentProperties.DocSecurity = this.GetAppProperty(readerElementValue5);
            continue;
          case "Lines":
            string readerElementValue6 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(BuiltInProperty.LineCount, (object) this.GetAppProperty(readerElementValue6));
            continue;
          case "Paragraphs":
            string readerElementValue7 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(BuiltInProperty.ParagraphCount, (object) this.GetAppProperty(readerElementValue7));
            continue;
          case "Company":
            documentProperties.Company = this.GetReaderElementValue(reader);
            continue;
          case "Manager":
            documentProperties.Manager = this.GetReaderElementValue(reader);
            continue;
          case "AppVersion":
            this.AppVersion = this.GetReaderElementValue(reader);
            continue;
          default:
            reader.Skip();
            continue;
        }
      }
      else
        reader.Skip();
    }
  }

  private int GetAppProperty(string attrValue)
  {
    float result = 0.0f;
    float.TryParse(attrValue, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    return (int) result;
  }

  private void ParseWord2003DocumentProperties(XmlReader reader)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "DocumentProperties")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    BuiltinDocumentProperties documentProperties = this.m_doc.BuiltinDocumentProperties;
    while (reader.NodeType != XmlNodeType.EndElement)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "Title":
            documentProperties.Title = this.GetReaderElementValue(reader);
            continue;
          case "Subject":
            documentProperties.Subject = this.GetReaderElementValue(reader);
            continue;
          case "Author":
            documentProperties.Author = this.GetReaderElementValue(reader);
            continue;
          case "Keywords":
            documentProperties.Keywords = this.GetReaderElementValue(reader);
            continue;
          case "Description":
            documentProperties.Comments = this.GetReaderElementValue(reader);
            continue;
          case "LastAuthor":
            documentProperties.LastAuthor = this.GetReaderElementValue(reader);
            continue;
          case "Revision":
            documentProperties.RevisionNumber = this.GetReaderElementValue(reader);
            continue;
          case "AppName":
            documentProperties.ApplicationName = this.GetReaderElementValue(reader);
            continue;
          case "TotalTime":
            string readerElementValue1 = this.GetReaderElementValue(reader);
            double result1 = 0.0;
            double.TryParse(readerElementValue1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
            documentProperties.TotalEditingTime = TimeSpan.FromMinutes(Math.Round(result1));
            continue;
          case "LastPrinted":
            DateTime result2 = new DateTime();
            DateTime.TryParse(this.GetReaderElementValue(reader), (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result2);
            documentProperties.LastPrinted = result2;
            continue;
          case "Created":
            DateTime result3 = new DateTime();
            DateTime.TryParse(this.GetReaderElementValue(reader), (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result3);
            documentProperties.CreateDate = result3;
            continue;
          case "LastSaved":
            DateTime result4 = new DateTime();
            DateTime.TryParse(this.GetReaderElementValue(reader), (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result4);
            documentProperties.LastSaveDate = result4;
            continue;
          case "Pages":
            string readerElementValue2 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(PIDSI.Pagecount, (object) this.GetAppProperty(readerElementValue2));
            continue;
          case "Words":
            string readerElementValue3 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(PIDSI.Wordcount, (object) this.GetAppProperty(readerElementValue3));
            continue;
          case "Characters":
            string readerElementValue4 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(PIDSI.Charcount, (object) this.GetAppProperty(readerElementValue4));
            continue;
          case "Category":
            documentProperties.Category = this.GetReaderElementValue(reader);
            continue;
          case "Manager":
            documentProperties.Manager = this.GetReaderElementValue(reader);
            continue;
          case "Company":
            documentProperties.Company = this.GetReaderElementValue(reader);
            continue;
          case "Lines":
            string readerElementValue5 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(BuiltInProperty.LineCount, (object) this.GetAppProperty(readerElementValue5));
            continue;
          case "Paragraphs":
            string readerElementValue6 = this.GetReaderElementValue(reader);
            documentProperties.SetPropertyValue(BuiltInProperty.ParagraphCount, (object) this.GetAppProperty(readerElementValue6));
            continue;
          case "Version":
            this.AppVersion = this.GetReaderElementValue(reader);
            continue;
          default:
            reader.Skip();
            continue;
        }
      }
      else
        reader.Skip();
    }
  }

  private void ParseWord2003CustomDocumentproperties(XmlReader reader)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "CustomDocumentProperties")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    if (this.m_doc.CustomDocumentProperties == null)
      throw new ArgumentNullException("customProperties");
    this.SkipWhitespaces(reader);
    while (reader.NodeType != XmlNodeType.EndElement && reader.LocalName != "CustomDocumentProperties")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        string localName2 = reader.LocalName;
        string attribute = reader.GetAttribute("dt", "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882");
        reader.Read();
        this.SkipWhitespaces(reader);
        string str = reader.Value;
        if (localName2 != null && attribute != null)
        {
          switch (attribute)
          {
            case "float":
              if (!string.IsNullOrEmpty(str))
              {
                float result = 0.0f;
                float.TryParse(str, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                DocumentProperty documentProperty = new DocumentProperty(localName2, (object) (int) Math.Round((double) result));
                this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
                break;
              }
              break;
            case "double":
              if (!string.IsNullOrEmpty(str))
              {
                double result = 0.0;
                double.TryParse(str, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                DocumentProperty documentProperty = new DocumentProperty(localName2, (object) result);
                this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
                break;
              }
              break;
            case "string":
              if (!string.IsNullOrEmpty(str))
              {
                DocumentProperty documentProperty = new DocumentProperty(localName2, (object) this.UpdateText(str));
                this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
                break;
              }
              break;
            case "dateTime.tz":
              if (!string.IsNullOrEmpty(str))
              {
                DateTime result = new DateTime();
                DateTime.TryParse(str, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result);
                DocumentProperty documentProperty = new DocumentProperty(localName2, (object) result);
                this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
                break;
              }
              break;
            case "boolean":
              if (!string.IsNullOrEmpty(str))
              {
                DocumentProperty documentProperty = new DocumentProperty(localName2, (object) this.GetBoolValue(str));
                this.m_doc.CustomDocumentProperties.CustomHash.Add(documentProperty.Name, documentProperty);
                break;
              }
              break;
          }
        }
        reader.Read();
      }
      else
        reader.Skip();
      reader.Read();
    }
  }

  private void ParseList(XmlReader reader, FormatBase format)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    WParagraphFormat wparagraphFormat = format as WParagraphFormat;
    if (wparagraphFormat.OwnerBase == null)
      return;
    bool flag = false;
    WListFormat listFormat = (WListFormat) null;
    if (wparagraphFormat.OwnerBase is WParagraph)
    {
      listFormat = (wparagraphFormat.OwnerBase as WParagraph).ListFormat;
      listFormat.IsFormattingChange = wparagraphFormat.IsFormattingChange;
    }
    else if (wparagraphFormat.OwnerBase is WParagraphStyle)
    {
      listFormat = (wparagraphFormat.OwnerBase as WParagraphStyle).ListFormat;
      listFormat.IsFormattingChange = wparagraphFormat.IsFormattingChange;
      flag = true;
    }
    else if (wparagraphFormat.OwnerBase is WTableStyle)
      listFormat = (wparagraphFormat.OwnerBase as WTableStyle).ListFormat;
    else if (wparagraphFormat.OwnerBase is WNumberingStyle)
      listFormat = (wparagraphFormat.OwnerBase as WNumberingStyle).ListFormat;
    this.ParseListFormat(reader, listFormat, localName);
    if (!flag)
      return;
    string key = (string) null;
    if (listFormat.CurrentListLevel != null)
    {
      foreach (KeyValuePair<string, string> keyValuePair in this.StyleNameId)
      {
        if (keyValuePair.Value == (wparagraphFormat.OwnerBase as WParagraphStyle).Name)
        {
          key = keyValuePair.Key;
          break;
        }
      }
      if (listFormat.CurrentListLevel.ParaStyleName != null)
        return;
      if (this.StyleNameId.ContainsKey(key))
        key = this.StyleNameId[key];
      listFormat.CurrentListLevel.ParaStyleName = key;
    }
    else
    {
      if (!(wparagraphFormat.OwnerBase is WParagraphStyle) || listFormat.ListLevelNumber <= 0)
        return;
      ListStyle listStyle = this.FindListStyle(wparagraphFormat.OwnerBase as WParagraphStyle);
      if (listStyle == null || listStyle.Levels.Count <= listFormat.ListLevelNumber)
        return;
      string name = (wparagraphFormat.OwnerBase as WParagraphStyle).Name;
      listStyle.Levels[listFormat.ListLevelNumber].ParaStyleName = name;
    }
  }

  private ListStyle FindListStyle(WParagraphStyle style)
  {
    WParagraphStyle baseStyle = style.BaseStyle;
    if (baseStyle == null)
      return (ListStyle) null;
    for (; baseStyle != null; baseStyle = baseStyle.BaseStyle)
    {
      if (baseStyle.ListFormat.CurrentListStyle != null)
        return baseStyle.ListFormat.CurrentListStyle;
    }
    return (ListStyle) null;
  }

  private void ParseListFormat(XmlReader reader, WListFormat listFormat, string localName)
  {
    while (reader.LocalName != localName)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "ilvl":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
            {
              int result = 0;
              int.TryParse(attribute1, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              if (result > 8)
                result = 8;
              listFormat.ListLevelNumber = result;
              break;
            }
            break;
          case "numId":
          case "ilfo":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (attribute2 == "0" || string.IsNullOrEmpty(attribute2))
            {
              listFormat.IsEmptyList = true;
              break;
            }
            if (this.m_doc.ListStyleNames.ContainsKey(attribute2))
            {
              string listStyleName = this.m_doc.ListStyleNames[attribute2];
              this.m_doc.ListStyles.FindByName(listStyleName);
              if (listStyleName != null)
                listFormat.ApplyStyle(listStyleName);
              if (this.OverrideListStyleNames.ContainsKey(attribute2))
              {
                listFormat.LFOStyleName = this.OverrideListStyleNames[attribute2];
                break;
              }
              break;
            }
            this.UpdateListStyleForInvalidNumId(attribute2, listFormat);
            break;
        }
      }
      reader.Read();
    }
  }

  private void UpdateListStyleForInvalidNumId(string id, WListFormat listFormat)
  {
    if (!this.IsFirstInvalidNumID)
    {
      ListStyle listStyle = new ListStyle(this.m_doc);
      listStyle.CreateDefListLevels(ListType.Numbered);
      foreach (WListLevel level in (Syncfusion.DocIO.DLS.CollectionImpl) listStyle.Levels)
      {
        level.PatternType = ListPatternType.Arabic;
        level.NumberAlignment = ListNumberAlignment.Left;
        level.ParagraphFormat.SetPropertyValue(5, (object) -36f);
      }
      this.UpdateListType(listStyle);
      this.UpdateStyleName(listStyle);
      if (!this.AbstractListStyleNames.ContainsKey(id))
        this.AbstractListStyleNames.Add(id, listStyle.Name);
      this.m_doc.ListStyleNames.Add(id, listStyle.Name);
      this.m_doc.ListStyles.Add(listStyle);
      this.IsFirstInvalidNumID = true;
      this.m_firstInvalidNumId = id;
    }
    else
    {
      this.m_doc.ListStyleNames.Add(id, this.AbstractListStyleNames[this.m_firstInvalidNumId]);
      if (!this.OverrideListStyleNames.ContainsKey(id))
      {
        ListOverrideStyle listOverrideStyle = new ListOverrideStyle(this.m_doc);
        listOverrideStyle.Name = "LfoStyle_" + (object) Guid.NewGuid();
        listOverrideStyle.listStyleName = this.m_doc.ListStyleNames[id];
        this.OverrideListStyleNames.Add(id, listOverrideStyle.Name);
        this.m_doc.ListOverrides.Add(listOverrideStyle);
        for (int levelNumber = 0; levelNumber < 9; ++levelNumber)
        {
          OverrideLevelFormat lfoLevel = new OverrideLevelFormat(this.m_doc);
          listOverrideStyle.OverrideLevels.Add(levelNumber, lfoLevel);
          lfoLevel.StartAt = 1;
          lfoLevel.OverrideStartAtValue = true;
        }
      }
    }
    listFormat.ApplyStyle(this.m_doc.ListStyleNames[id]);
    if (!this.OverrideListStyleNames.ContainsKey(id))
      return;
    listFormat.LFOStyleName = this.OverrideListStyleNames[id];
  }

  private void GetListFormatBaseStyleName(ListStyle listStyle, ref string styleName)
  {
    if (listStyle == null || listStyle.BaseListStyleName == null || !(listStyle.BaseListStyleName != string.Empty))
      return;
    if (this.m_doc.ListStyleNames.ContainsKey(listStyle.BaseListStyleName))
    {
      string listStyleName = this.m_doc.ListStyleNames[listStyle.BaseListStyleName];
      if (!this.m_doc.ListStyleNames.ContainsKey(listStyleName))
        return;
      styleName = this.m_doc.ListStyleNames[listStyleName];
    }
    else
    {
      if (!this.StyleNameId.ContainsKey(listStyle.BaseListStyleName))
        return;
      Syncfusion.DocIO.DLS.IStyle byName = this.m_doc.Styles.FindByName(this.StyleNameId[listStyle.BaseListStyleName]);
      if (byName == null || byName.StyleType != StyleType.NumberingStyle || (byName as WNumberingStyle).ListFormat == null || (byName as WNumberingStyle).ListFormat.CurrentListStyle == null)
        return;
      styleName = (byName as WNumberingStyle).ListFormat.CurrentListStyle.Name;
    }
  }

  private void ParseNumberings(XmlReader reader)
  {
    if (reader.NamespaceURI == this.m_strictNameSpace)
      this.IsStrict = true;
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.NodeType != XmlNodeType.Element && (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement))
      reader.Read();
    string str = this.IsWord2003ML ? "lists" : "numbering";
    if (localName != str)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    this.SkipWhitespaces(reader);
    Dictionary<long, string> nsidCollection = new Dictionary<long, string>();
    Dictionary<string, long> abstractNumCollection = new Dictionary<string, long>();
    while (reader.LocalName != localName)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        if (this.IsWord2003ML)
          this.ParseWord2003MLNumberings(reader, nsidCollection, abstractNumCollection);
        else
          this.ParseDocxNumberings(reader, nsidCollection, abstractNumCollection);
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    nsidCollection.Clear();
    abstractNumCollection.Clear();
    this.UpdateLinkedListStyles();
    this.UpdateListStyleNames();
  }

  private void UpdateListStyleNames()
  {
    foreach (string key in new List<string>((IEnumerable<string>) this.m_doc.ListStyleNames.Keys))
    {
      string listStyleName = this.m_doc.ListStyleNames[key];
      this.m_doc.ListStyleNames[key] = this.AbstractListStyleNames[listStyleName];
      if (this.OverrideListStyleNames.ContainsKey(key))
      {
        ListOverrideStyle byName1 = this.m_doc.ListOverrides.FindByName(this.OverrideListStyleNames[key]);
        byName1.listStyleName = this.m_doc.ListStyleNames[key];
        ListStyle byName2 = this.m_doc.ListStyles.FindByName(byName1.listStyleName);
        if (byName2 != null)
          byName1.ListID = byName2.ListID;
      }
    }
  }

  private void UpdateLinkedListStyles()
  {
    for (int index = 0; index < this.m_doc.ListStyles.Count; ++index)
    {
      ListStyle listStyle1 = this.m_doc.ListStyles[index];
      if (!string.IsNullOrEmpty(listStyle1.BaseListStyleName))
      {
        ListStyle byStyleLink = this.FindByStyleLink(listStyle1.BaseListStyleName);
        if (byStyleLink != null)
        {
          ListStyle listStyle2 = byStyleLink.Clone() as ListStyle;
          listStyle2.SetNewListID(this.m_doc);
          listStyle2.SetNewName(this.m_doc);
          this.UpdateAbstractStyleName(listStyle1.Name, listStyle2.Name);
          this.m_doc.ListStyles.InnerList.Insert(index, (object) listStyle2);
          this.m_doc.ListStyles.InnerList.Remove((object) listStyle1);
        }
        else
          listStyle1.BaseListStyleName = string.Empty;
      }
    }
  }

  private void UpdateAbstractStyleName(string oldName, string newName)
  {
    List<string> stringList = new List<string>();
    foreach (KeyValuePair<string, string> abstractListStyleName in this.AbstractListStyleNames)
    {
      if (abstractListStyleName.Value == oldName)
      {
        this.AbstractListStyleNames[abstractListStyleName.Key] = newName;
        break;
      }
    }
  }

  private ListStyle FindByStyleLink(string styleLinkName)
  {
    foreach (ListStyle listStyle in (Syncfusion.DocIO.DLS.CollectionImpl) this.m_doc.ListStyles)
    {
      if (listStyle.StyleLink == styleLinkName)
        return listStyle;
    }
    return (ListStyle) null;
  }

  private void ParseWord2003MLNumberings(
    XmlReader reader,
    Dictionary<long, string> nsidCollection,
    Dictionary<string, long> abstractNumCollection)
  {
    switch (reader.LocalName)
    {
      case "listPicBullet":
        this.ParsePictureBullet(reader);
        break;
      case "listDef":
        this.ParseAbstractNum(reader, nsidCollection, abstractNumCollection);
        break;
      case "list":
        this.ParseListNum(reader, nsidCollection, abstractNumCollection);
        break;
    }
  }

  private void ParseDocxNumberings(
    XmlReader reader,
    Dictionary<long, string> nsidCollection,
    Dictionary<string, long> abstractNumCollection)
  {
    switch (reader.LocalName)
    {
      case "numPicBullet":
        this.ParsePictureBullet(reader);
        break;
      case "abstractNum":
        this.ParseAbstractNum(reader, nsidCollection, abstractNumCollection);
        break;
      case "num":
        this.ParseListNum(reader, nsidCollection, abstractNumCollection);
        break;
    }
  }

  private void ParseListNum(
    XmlReader reader,
    Dictionary<long, string> nsidCollection,
    Dictionary<string, long> abstractNumCollection)
  {
    if (reader == null)
      throw new ArgumentException(nameof (reader));
    string str = this.IsWord2003ML ? "list" : "num";
    string name = this.IsWord2003ML ? "ilfo" : "numId";
    if (reader.LocalName != str)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    string attribute = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.NodeType != XmlNodeType.EndElement && reader.LocalName != str)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "abstractNumId":
          case "ilst":
            if ((this.IsWord2003ML ? (reader.LocalName == "ilst" ? 1 : 0) : (reader.LocalName == "abstractNumId" ? 1 : 0)) != 0)
            {
              string abstractNumId = this.GetAbstractNumID(nsidCollection, abstractNumCollection, reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace));
              if (this.AbstractListStyleNames.ContainsKey(abstractNumId) && !this.m_doc.ListStyleNames.ContainsKey(attribute))
              {
                this.m_doc.ListStyleNames.Add(attribute, abstractNumId);
                break;
              }
              break;
            }
            break;
          case "lvlOverride":
            this.ParseLevelOverride(reader, attribute);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private string GetAbstractNumID(
    Dictionary<long, string> nsidCollection,
    Dictionary<string, long> abstractNumCollection,
    string abstractNumId)
  {
    if (abstractNumCollection.ContainsKey(abstractNumId))
    {
      long abstractNum = abstractNumCollection[abstractNumId];
      if (nsidCollection.ContainsKey(abstractNum))
        return nsidCollection[abstractNum];
    }
    return abstractNumId;
  }

  private void ParseLevelOverride(XmlReader reader, string numId)
  {
    if (reader == null)
      throw new ArgumentException(nameof (reader));
    if (reader.LocalName != "lvlOverride")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    string attribute = reader.GetAttribute("ilvl", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    ListOverrideStyle listOverrideStyle;
    if (!this.OverrideListStyleNames.ContainsKey(numId))
    {
      listOverrideStyle = new ListOverrideStyle(this.m_doc);
      listOverrideStyle.Name = "LfoStyle_" + (object) Guid.NewGuid();
      this.OverrideListStyleNames.Add(numId, listOverrideStyle.Name);
      this.m_doc.ListOverrides.Add(listOverrideStyle);
    }
    else
      listOverrideStyle = this.m_doc.ListOverrides.FindByName(this.OverrideListStyleNames[numId]);
    OverrideLevelFormat overrideLevelFormat = new OverrideLevelFormat(this.m_doc);
    if (string.IsNullOrEmpty(attribute))
      return;
    int integerValue = this.ParseIntegerValue(attribute);
    listOverrideStyle.OverrideLevels.Add(integerValue, overrideLevelFormat);
    if (!(localName == "lvlOverride"))
      return;
    this.ParseLevelOverride(reader, overrideLevelFormat);
  }

  private void ParseLevelOverride(XmlReader reader, OverrideLevelFormat levelFormat)
  {
    this.SkipWhitespaces(reader);
    while (reader.NodeType != XmlNodeType.EndElement && reader.LocalName != "lvlOverride")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "startOverride":
            string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute))
            {
              float result = 0.0f;
              levelFormat.StartAt = float.TryParse(attribute, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (int) result : 0;
            }
            levelFormat.OverrideStartAtValue = true;
            break;
          case "lvl":
            levelFormat.OverrideFormatting = true;
            this.ParseListLevel(reader, levelFormat.OverrideListLevel);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseAbstractNum(
    XmlReader reader,
    Dictionary<long, string> nsidCollection,
    Dictionary<string, long> abstractNumCollection)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    string str = this.IsWord2003ML ? "listDef" : "abstractNum";
    string name = this.IsWord2003ML ? "listDefId" : "abstractNumId";
    if (reader.LocalName != str)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    string attribute = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute == null || this.AbstractListStyleNames.ContainsKey(attribute))
    {
      reader.Skip();
    }
    else
    {
      ListStyle listStyle = new ListStyle(this.m_doc);
      this.ParseListStyle(reader, listStyle);
      abstractNumCollection.Add(attribute, listStyle.ListID);
      long num = 1720085641;
      if (listStyle.ListID != num && nsidCollection.ContainsKey(listStyle.ListID))
        return;
      if (listStyle.ListID != num)
        nsidCollection.Add(listStyle.ListID, attribute);
      this.m_doc.ListStyles.Add(listStyle);
      this.UpdateListType(listStyle);
      this.UpdateStyleName(listStyle);
      listStyle.IsSimple = listStyle.Levels.Count == 1;
      this.AbstractListStyleNames.Add(attribute, listStyle.Name);
    }
  }

  private void ParseListStyle(XmlReader reader, ListStyle listStyle)
  {
    if (listStyle == null)
      throw new ArgumentException("list style");
    string str = this.IsWord2003ML ? "listDef" : "abstractNum";
    if (reader.LocalName != str)
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    bool flag1 = false;
    this.SkipWhitespaces(reader);
    listStyle.CreateEmptyListLevels(false);
    while (reader.LocalName != str)
    {
      bool flag2 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "nsid":
          case "lsid":
            if ((this.IsWord2003ML ? (reader.LocalName == "lsid" ? 1 : 0) : (reader.LocalName == "nsid" ? 1 : 0)) != 0)
            {
              string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute))
              {
                long result = 0;
                long.TryParse(attribute, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                listStyle.ListID = result;
                flag1 = true;
                break;
              }
              break;
            }
            break;
          case "multiLevelType":
          case "plt":
            if ((this.IsWord2003ML ? (reader.LocalName == "plt" ? 1 : 0) : (reader.LocalName == "multiLevelType" ? 1 : 0)) != 0 && reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace).ToLower() == "hybridmultilevel")
            {
              listStyle.IsHybrid = true;
              break;
            }
            break;
          case "numStyleLink":
          case "listStyleLink":
            if ((this.IsWord2003ML ? (reader.LocalName == "listStyleLink" ? 1 : 0) : (reader.LocalName == "numStyleLink" ? 1 : 0)) != 0)
            {
              listStyle.BaseListStyleName = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              break;
            }
            break;
          case "styleLink":
            if (reader.LocalName == "styleLink")
            {
              listStyle.StyleLink = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              break;
            }
            break;
          case "lvl":
            string attribute1 = reader.GetAttribute("ilvl", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            WListLevel level = listStyle.Levels[0];
            if (!string.IsNullOrEmpty(attribute1))
            {
              int result = 0;
              int.TryParse(attribute1, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              level = listStyle.Levels[result];
            }
            this.ParseListLevel(reader, level);
            break;
        }
        if (!flag2)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    if (flag1)
      return;
    listStyle.SetNewListID(this.m_doc);
  }

  private void ParseListLevel(XmlReader reader, WListLevel level)
  {
    if (level == null)
      throw new ArgumentException("list level");
    if (reader.LocalName != "lvl")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "lvl")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "start":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
            {
              float result = 0.0f;
              level.StartAt = float.TryParse(attribute1, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (int) result : 1;
              break;
            }
            break;
          case "pPr":
            this.ParseParagraphFormat(reader, level.ParagraphFormat);
            break;
          case "rPr":
            this.ParseCharacterFormat(reader, level.CharacterFormat, (ParagraphItemCollection) null);
            break;
          case "isLgl":
            level.IsLegalStyleNumbering = this.GetBooleanValue(reader);
            break;
          case "lvlRestart":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            level.restartLevel = this.ParseIntegerValue(attribute2);
            if (attribute2 == "0")
            {
              level.NoRestartByHigher = true;
              break;
            }
            break;
          case "pStyle":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute3) && this.StyleNameId.ContainsKey(attribute3))
            {
              level.ParaStyleName = this.StyleNameId[attribute3];
              break;
            }
            break;
          case "lvlPicBulletId":
            string attribute4 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute4) && this.PictureBullet.ContainsKey(attribute4))
              level.PicBullet = this.PictureBullet[attribute4];
            if (level.PicBullet != null && level.PicBullet.ImageRecord == null && level.PicBullet.OPictureHRef == null)
            {
              level.IsEmptyPicture = true;
              break;
            }
            break;
          case "numFmt":
          case "nfc":
            if ((this.IsWord2003ML ? (reader.LocalName == "nfc" ? 1 : 0) : (reader.LocalName == "numFmt" ? 1 : 0)) != 0)
            {
              string attribute5 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              level.PatternType = this.GetLevelNumberFormat(attribute5);
              break;
            }
            break;
          case "lvlText":
            string attribute6 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute6))
            {
              this.ParseLevelText(level, attribute6);
              break;
            }
            break;
          case "lvlJc":
            string attribute7 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            level.NumberAlignment = this.ParseLevelJc(attribute7);
            break;
          case "suff":
            string attribute8 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            level.FollowCharacter = this.GetFollowChar(attribute8.ToLower());
            break;
          case "legacy":
            this.ParseLegacyProperties(reader, level);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseLegacyProperties(XmlReader reader, WListLevel level)
  {
    string attribute1 = reader.GetAttribute("legacy", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    level.Word6Legacy = !(attribute1 == "0") && !(attribute1 == "false") && !(attribute1 == "off");
    string attribute2 = reader.GetAttribute("legacySpace", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
    {
      float result = 0.0f;
      if (float.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
        level.LegacySpace = (int) result;
    }
    string attribute3 = reader.GetAttribute("legacyIndent", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute3))
      return;
    float result1 = 0.0f;
    if (!float.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1))
      return;
    level.LegacyIndent = (int) result1;
  }

  private FollowCharacterType GetFollowChar(string levelFollow)
  {
    switch (levelFollow)
    {
      case "tab":
        return FollowCharacterType.Tab;
      case "space":
        return FollowCharacterType.Space;
      default:
        return FollowCharacterType.Nothing;
    }
  }

  private ListNumberAlignment ParseLevelJc(string justification)
  {
    switch (justification)
    {
      case "center":
        return ListNumberAlignment.Center;
      case "end":
      case "right":
        return ListNumberAlignment.Right;
      default:
        return ListNumberAlignment.Left;
    }
  }

  private void ParseLevelText(WListLevel level, string levelText)
  {
    string str1 = "%" + (level.LevelNumber + 1).ToString();
    int length = levelText.IndexOf(str1);
    if (length == -1 && levelText.Length > 1 && levelText.IndexOf('%') == 0 && levelText.IndexOf('.') == 2 && level.LevelNumber == int.Parse(levelText[1].ToString()))
    {
      int num = int.Parse(levelText[1].ToString());
      level.LevelText = levelText;
      string str2 = "%" + num.ToString();
      length = levelText.IndexOf(str2);
    }
    string prefix = (string) null;
    string str3 = (string) null;
    if (length != -1)
    {
      prefix = levelText.Substring(0, length);
      if (level.PatternType != ListPatternType.Bullet)
        prefix = this.CheckNumberPrefix(prefix);
      int startIndex = length + 2;
      str3 = levelText.Substring(startIndex, levelText.Length - startIndex);
    }
    if (level.PatternType == ListPatternType.Bullet)
    {
      if (length != -1)
      {
        level.BulletCharacter = prefix;
        level.BulletCharacter += str3;
      }
      else
        level.BulletCharacter = levelText;
    }
    else
    {
      level.NumberPrefix = prefix;
      level.NumberSuffix = str3;
      if (level.PatternType == ListPatternType.None)
      {
        if (length != -1)
        {
          level.BulletCharacter = prefix;
          level.BulletCharacter += str3;
        }
        else
          level.BulletCharacter = levelText;
      }
      if (prefix != null || str3 != null)
        return;
      level.LevelText = levelText;
    }
  }

  private string CheckNumberPrefix(string prefix)
  {
    return prefix == null || prefix == string.Empty ? prefix : prefix.Replace("%1", "\0").Replace("%2", "\u0001").Replace("%3", "\u0002").Replace("%4", "\u0003").Replace("%5", "\u0004").Replace("%6", "\u0005").Replace("%7", "\u0006").Replace("%8", "\a").Replace("%9", "\b");
  }

  private ListPatternType GetLevelNumberFormat(string pattern)
  {
    if (this.IsWord2003ML)
    {
      switch (pattern)
      {
        case "47":
          return ListPatternType.None;
        case "0":
          return ListPatternType.Arabic;
        case "1":
          return ListPatternType.UpRoman;
        case "2":
          return ListPatternType.LowRoman;
        case "3":
          return ListPatternType.UpLetter;
        case "4":
          return ListPatternType.LowLetter;
        case "5":
          return ListPatternType.Ordinal;
        case "7":
          return ListPatternType.OrdinalText;
        case "22":
          return ListPatternType.LeadingZero;
        case "6":
          return ListPatternType.Number;
        case "20":
          return ListPatternType.FarEast;
        case "45":
          return ListPatternType.Special;
      }
    }
    else
    {
      switch (pattern)
      {
        case "none":
          return ListPatternType.None;
        case "decimal":
          return ListPatternType.Arabic;
        case "upperRoman":
          return ListPatternType.UpRoman;
        case "lowerRoman":
          return ListPatternType.LowRoman;
        case "upperLetter":
          return ListPatternType.UpLetter;
        case "lowerLetter":
          return ListPatternType.LowLetter;
        case "ordinal":
          return ListPatternType.Ordinal;
        case "ordinalText":
          return ListPatternType.OrdinalText;
        case "decimalZero":
          return ListPatternType.LeadingZero;
        case "cardinalText":
          return ListPatternType.Number;
        case "aiueoFullWidth":
          return ListPatternType.FarEast;
        case "russianLower":
          return ListPatternType.Special;
        case "chineseCountingThousand":
          return ListPatternType.ChineseCountingThousand;
        case "japaneseCounting":
          return ListPatternType.KanjiDigit;
      }
    }
    return ListPatternType.Bullet;
  }

  private void UpdateListType(ListStyle listStyle)
  {
    listStyle.ListType = ListType.Bulleted;
    foreach (WListLevel level in (Syncfusion.DocIO.DLS.CollectionImpl) listStyle.Levels)
    {
      if (level.PatternType != ListPatternType.Bullet)
      {
        listStyle.ListType = ListType.Numbered;
        break;
      }
    }
  }

  private void UpdateStyleName(ListStyle listStyle)
  {
    if (listStyle.ListType == ListType.Numbered)
      listStyle.Name = "Numbered_" + Guid.NewGuid().ToString();
    else
      listStyle.Name = "Bulleted_" + Guid.NewGuid().ToString();
  }

  private void ParsePictureBullet(XmlReader reader)
  {
    string name = this.IsWord2003ML ? "listPicBulletId" : "numPicBulletId";
    string str = this.IsWord2003ML ? "listPicBullet" : "numPicBullet";
    string attribute1 = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    byte[] imageBytes = (byte[]) null;
    while (reader.LocalName != "shape")
    {
      reader.Read();
      if (reader.LocalName == "binData" && this.IsWord2003ML)
      {
        string attribute2 = reader.GetAttribute("name", "http://schemas.microsoft.com/office/word/2003/wordml");
        if (!string.IsNullOrEmpty(attribute2) && !attribute2.ToLower().Contains(".wmz"))
        {
          if (!attribute2.ToLower().Contains(".emz"))
          {
            try
            {
              imageBytes = Convert.FromBase64String(this.Read2003ImageBase64String(reader, (string) null));
            }
            catch
            {
              return;
            }
          }
        }
      }
      if (reader.LocalName == str)
        return;
    }
    string pictureBulletStyle = this.ParsePictureBulletStyle(reader);
    if (!reader.IsEmptyElement)
    {
      string localName = reader.LocalName;
      string id = (string) null;
      if (localName == "imagedata")
        id = this.ParsePictureId(reader);
      reader.Read();
      if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
      {
        if (localName != "imagedata" && (!(localName == "shape") || reader.NodeType != XmlNodeType.EndElement))
          localName = reader.LocalName;
        for (; localName != "imagedata" && (!(localName == "shape") || reader.NodeType != XmlNodeType.EndElement); localName = reader.LocalName)
          reader.Read();
        if (localName == "imagedata")
        {
          if (id == null)
            id = this.ParsePictureId(reader);
          if ((id == null || id.Length == 0) && !this.IsWord2003ML)
            return;
          WPicture picture = new WPicture((IWordDocument) this.m_doc);
          if (this.IsWord2003ML && imageBytes != null)
            picture.LoadImage(imageBytes);
          else
            this.LoadImage(picture, id, false, true);
          this.ProcessPictureStyle(picture, pictureBulletStyle);
          if (attribute1 == string.Empty || picture.ImageRecord == null)
            return;
          this.PictureBullet.Add(attribute1, picture);
        }
      }
      else
      {
        while (reader.LocalName != str)
          reader.Read();
      }
    }
    else if (reader.LocalName == "shape")
    {
      WPicture picture = new WPicture((IWordDocument) this.m_doc);
      this.ProcessPictureStyle(picture, pictureBulletStyle);
      if (attribute1 == string.Empty)
        return;
      this.PictureBullet.Add(attribute1, picture);
    }
    while (reader.LocalName != str)
      reader.Read();
  }

  private void ProcessPictureStyle(WPicture picture, string size)
  {
    string[] strArray = size.Split(';');
    int index = 0;
    for (int length = strArray.Length; index < length; ++index)
    {
      string text = strArray[index];
      if (this.StartsWithExt(text, "width:"))
      {
        string str = text.Replace("width:", string.Empty);
        picture.Width = this.GetPointValue(str);
      }
      else if (this.StartsWithExt(text, "height:"))
      {
        string str = text.Replace("height:", string.Empty);
        picture.Height = this.GetPointValue(str);
      }
    }
  }

  private float ParseSize(string partString)
  {
    if (partString.EndsWith("in"))
    {
      int result = 0;
      int.TryParse(partString.Replace("in", string.Empty), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      return (float) UnitsConvertor.Instance.ConvertUnits((double) result, PrintUnits.Inch, PrintUnits.Point);
    }
    partString = partString.Replace("pt", string.Empty);
    return this.ParseFloatVal(partString);
  }

  private string ParsePictureId(XmlReader reader)
  {
    return !(reader.LocalName != "imagedata") ? reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships") : throw new XmlException("imagedata - relationship id of shape");
  }

  private string ParsePictureBulletStyle(XmlReader reader)
  {
    return !(reader.LocalName != "shape") ? reader.GetAttribute("style") : throw new XmlException("shape - Picture bullet");
  }

  private void ParseStyles(XmlReader reader)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "styles")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    Dictionary<int, string> linkStyleNamesReferByCharacterStyle = new Dictionary<int, string>();
    List<int> paraLinkStyleIndex = new List<int>();
    while (reader.LocalName != "styles")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "docDefaults":
            if (!this.IsWord2003ML)
            {
              this.ParseDocDefaults(reader);
              break;
            }
            break;
          case "latentStyles":
            if (this.IsWord2003ML)
              reader.Read();
            else
              this.ParseLatentStyles(reader);
            flag = true;
            break;
          case "style":
            flag = this.ParseStyle(reader, linkStyleNamesReferByCharacterStyle, paraLinkStyleIndex);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Skip();
      this.SkipWhitespaces(reader);
    }
    this.UpdateBaseStyles();
    this.UpdateLinkName(linkStyleNamesReferByCharacterStyle, paraLinkStyleIndex);
    linkStyleNamesReferByCharacterStyle.Clear();
    this.UpdateListInStyles();
  }

  private void Parse2003XmlStyles(XmlReader reader)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "styles")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    Dictionary<int, string> linkStyleNamesReferByCharacterStyle = new Dictionary<int, string>();
    List<int> paraLinkStyleIndex = new List<int>();
    while (reader.LocalName != "styles")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "docDefaults":
            this.ParseDocDefaults(reader);
            break;
          case "latentStyles":
            this.ParseLatentStyles(reader);
            flag = true;
            break;
          case "style":
            flag = this.ParseStyle(reader, linkStyleNamesReferByCharacterStyle, paraLinkStyleIndex);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Skip();
      this.SkipWhitespaces(reader);
    }
    this.UpdateBaseStyles();
    this.UpdateLinkName(linkStyleNamesReferByCharacterStyle, paraLinkStyleIndex);
    linkStyleNamesReferByCharacterStyle.Clear();
    this.UpdateListInStyles();
  }

  private void UpdateBaseStyles()
  {
    if (this.m_baseStyleNames == null)
      return;
    foreach (string key in this.m_baseStyleNames.Keys)
    {
      if (this.m_doc.Styles.FindByName(this.StyleNameId[key]) is Style byName && this.StyleNameId.ContainsKey(this.m_baseStyleNames[key]))
        byName.ApplyBaseStyle(this.StyleNameId[this.m_baseStyleNames[key]]);
    }
  }

  private void UpdateListInStyles()
  {
    foreach (Syncfusion.DocIO.DLS.IStyle style in (IEnumerable) this.m_doc.Styles)
    {
      if (style is WParagraphStyle)
      {
        string styleName = (string) null;
        this.GetListFormatBaseStyleName((style as WParagraphStyle).ListFormat.CurrentListStyle, ref styleName);
        if (styleName != null)
          (style as WParagraphStyle).ListFormat.ApplyStyle(styleName);
      }
    }
  }

  private void UpdateLinkName(
    Dictionary<int, string> linkStyleNamesReferByCharacterStyle,
    List<int> paraLinkStyleIndex)
  {
    if (this.m_linkStyleNames != null)
    {
      List<string> list = new List<string>();
      list.AddRange((IEnumerable<string>) this.m_linkStyleNames.Values);
      Dictionary<string, int> dictionary1 = this.CountOccurrencesOfValue(list);
      list.Clear();
      int index = 0;
      foreach (string key1 in this.m_linkStyleNames.Keys)
      {
        if (dictionary1[this.m_linkStyleNames[key1]] == 1)
        {
          Style style = this.m_doc.Styles[paraLinkStyleIndex[index]] as Style;
          string linkStyleName = this.m_linkStyleNames[key1];
          if (this.StyleNameId.ContainsKey(linkStyleName))
            style.LinkStyle = this.StyleNameId[linkStyleName];
        }
        else
        {
          if (linkStyleNamesReferByCharacterStyle.ContainsValue(key1))
          {
            foreach (int key2 in linkStyleNamesReferByCharacterStyle.Keys)
            {
              if (linkStyleNamesReferByCharacterStyle[key2] == key1)
                (this.m_doc.Styles[key2] as Style).LinkStyle = (string) null;
            }
          }
          linkStyleNamesReferByCharacterStyle.Clear();
          (this.m_doc.Styles[paraLinkStyleIndex[index]] as Style).LinkStyle = (string) null;
          Dictionary<string, int> dictionary2;
          string linkStyleName;
          (dictionary2 = dictionary1)[linkStyleName = this.m_linkStyleNames[key1]] = dictionary2[linkStyleName] - 1;
        }
        ++index;
      }
    }
    if (linkStyleNamesReferByCharacterStyle != null)
    {
      List<string> list = new List<string>();
      list.AddRange((IEnumerable<string>) linkStyleNamesReferByCharacterStyle.Values);
      Dictionary<string, int> dictionary3 = this.CountOccurrencesOfValue(list);
      list.Clear();
      foreach (int key3 in linkStyleNamesReferByCharacterStyle.Keys)
      {
        if (dictionary3[linkStyleNamesReferByCharacterStyle[key3]] > 1)
        {
          (this.m_doc.Styles[key3] as Style).LinkStyle = (string) null;
          Dictionary<string, int> dictionary4;
          string key4;
          (dictionary4 = dictionary3)[key4 = linkStyleNamesReferByCharacterStyle[key3]] = dictionary4[key4] - 1;
        }
      }
    }
    linkStyleNamesReferByCharacterStyle.Clear();
  }

  private Dictionary<string, int> CountOccurrencesOfValue(List<string> list)
  {
    Dictionary<string, int> dictionary1 = new Dictionary<string, int>();
    foreach (string key1 in list)
    {
      if (dictionary1.ContainsKey(key1))
      {
        Dictionary<string, int> dictionary2;
        string key2;
        (dictionary2 = dictionary1)[key2 = key1] = dictionary2[key2] + 1;
      }
      else
        dictionary1[key1] = 1;
    }
    return dictionary1;
  }

  private bool ParseStyle(
    XmlReader reader,
    Dictionary<int, string> linkStyleNamesReferByCharacterStyle,
    List<int> paraLinkStyleIndex)
  {
    string styleNameId = string.Empty;
    if (reader.NamespaceURI == this.m_strictNameSpace)
      this.IsStrict = true;
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "style")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (!reader.IsEmptyElement)
    {
      string styleType = "paragraph";
      string str = string.Empty;
      string s = (string) null;
      if (reader.HasAttributes)
      {
        string lower = reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace).ToLower();
        styleType = string.IsNullOrEmpty(lower) ? styleType : lower;
        string attribute1 = reader.GetAttribute("styleId", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
        str = string.IsNullOrEmpty(attribute1) ? str : attribute1;
        string attribute2 = reader.GetAttribute("customStyle", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
        s = string.IsNullOrEmpty(attribute2) ? s : attribute2;
      }
      string localName = reader.LocalName;
      reader.Read();
      if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return false;
      switch (styleType)
      {
        case "character":
        case "paragraph":
        case "table":
        case "numbering":
          Style style = this.CreateStyle(styleType);
          if (!string.IsNullOrEmpty(str))
            styleNameId = style.Name = str;
          if (!string.IsNullOrEmpty(s) && !this.IsWord2003ML)
            style.IsCustom = XmlConvert.ToBoolean(s);
          if (reader.NodeType != XmlNodeType.Element)
            reader.MoveToElement();
          this.ParseStyleProperties(reader, style, linkStyleNamesReferByCharacterStyle, paraLinkStyleIndex, ref styleNameId, localName);
          if (!string.IsNullOrEmpty(style.StyleIDName))
          {
            this.m_doc.Styles.Add((Syncfusion.DocIO.DLS.IStyle) style);
            break;
          }
          break;
        case "list":
          if (!this.IsWord2003ML)
            break;
          goto case "character";
      }
    }
    return false;
  }

  private void ParseStyleProperties(
    XmlReader reader,
    Style style,
    Dictionary<int, string> linkStyleNamesReferByCharacterStyle,
    List<int> paraLinkStyleIndex,
    ref string styleNameId,
    string localName)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    if (style == null)
      throw new ArgumentException(nameof (style));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (localName != nameof (style))
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    bool flag1 = false;
    string str = style.Name;
    bool flag2 = true;
    this.SkipWhitespaces(reader);
    bool flag3 = false;
    while (reader.LocalName != nameof (style))
    {
      bool flag4 = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "rPr":
            WCharacterFormat characterFormat = this.GetCharacterFormat(style);
            this.ParseCharacterFormat(reader, characterFormat, (ParagraphItemCollection) null);
            break;
          case "pPr":
            if (style.StyleType == StyleType.CharacterStyle)
            {
              this.SkipCurrentElement(reader, reader.LocalName);
              break;
            }
            WParagraphFormat paragraphFormat = this.GetParagraphFormat(style);
            this.ParseParagraphFormat(reader, paragraphFormat);
            break;
          case "tblPr":
            this.ParseTableStyleTableProperties(reader, (style as WTableStyle).TableProperties);
            break;
          case "trPr":
            this.ParseTableStyleRowProperties(reader, (style as WTableStyle).RowProperties);
            break;
          case "tcPr":
            this.ParseTableStyleCellProperties(reader, (style as WTableStyle).CellProperties);
            break;
          case "tblStylePr":
            this.ParseConditionalFormattingStyleProperties(reader, style);
            break;
          case "semiHidden":
            style.IsSemiHidden = this.GetBooleanValue(reader);
            break;
          case "unhideWhenUsed":
            if (!this.IsWord2003ML)
            {
              style.UnhideWhenUsed = this.GetBooleanValue(reader);
              break;
            }
            break;
          case "qFormat":
            if (!this.IsWord2003ML)
            {
              style.IsPrimaryStyle = this.GetBooleanValue(reader);
              break;
            }
            break;
          case "link":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (this.StyleNameId.ContainsKey(attribute1))
            {
              style.LinkStyle = this.StyleNameId[attribute1];
              if (!linkStyleNamesReferByCharacterStyle.ContainsKey(this.StyleNameId.Count - 1))
              {
                linkStyleNamesReferByCharacterStyle.Add(this.StyleNameId.Count - 1, this.StyleNameId[attribute1]);
                break;
              }
              break;
            }
            int index = 0;
            bool flag5 = false;
            foreach (KeyValuePair<string, string> linkStyleName in this.LinkStyleNames)
            {
              if (linkStyleName.Key == style.Name)
              {
                this.LinkStyleNames[style.Name] = attribute1;
                paraLinkStyleIndex.RemoveAt(index);
                paraLinkStyleIndex.Insert(index, this.StyleNameId.Count - 1);
                flag5 = true;
                break;
              }
              ++index;
            }
            if (!flag5)
            {
              this.LinkStyleNames.Add(style.Name, attribute1);
              flag3 = true;
              break;
            }
            break;
          case "next":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            style.NextStyle = attribute2;
            break;
          case "name":
            flag2 = false;
            while (reader.LocalName == "name" && reader.NodeType != XmlNodeType.EndElement)
            {
              str = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              reader.Read();
              this.SkipWhitespaces(reader);
            }
            if (string.IsNullOrEmpty(styleNameId))
            {
              styleNameId = str;
              if (string.IsNullOrEmpty(str))
                return;
              style.SetStyleName(str);
            }
            this.AddStyleNameID(style, str);
            flag4 = true;
            break;
          case "basedOn":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            flag1 = true;
            if (!this.StyleNameId.ContainsKey(attribute3))
            {
              if (!this.BaseStyleNames.ContainsKey(styleNameId))
              {
                this.BaseStyleNames.Add(styleNameId, attribute3);
                break;
              }
              break;
            }
            if (this.m_doc.Styles.FindByName(this.StyleNameId[attribute3]) == null)
            {
              this.BaseStyleNames.Add(styleNameId, attribute3);
              break;
            }
            style.ApplyBaseStyle(this.StyleNameId[attribute3]);
            break;
          case "numPr":
            if (!this.IsWord2003ML)
            {
              WParagraphFormat format = (WParagraphFormat) null;
              switch (style)
              {
                case WParagraphStyle _:
                  format = (style as WParagraphStyle).ParagraphFormat;
                  break;
                case WTableStyle _:
                  format = (style as WTableStyle).ParagraphFormat;
                  break;
                case WNumberingStyle _:
                  format = (style as WNumberingStyle).ParagraphFormat;
                  break;
              }
              this.ParseList(reader, (FormatBase) format);
              break;
            }
            break;
          case "uiPriority":
            string attribute4 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            style.UIPriority = Convert.ToInt32(attribute4);
            break;
        }
        if (!flag4)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    if (flag2)
      this.AddStyleNameID(style, str);
    if (flag3)
      paraLinkStyleIndex.Add(this.StyleNameId.Count - 1);
    if (flag1 || style.BaseStyle == null || !(style is WParagraphStyle))
      return;
    style.RemoveBaseStyle();
  }

  private void AddStyleNameID(Style style, string styleName)
  {
    if (!style.IsCustom)
    {
      Dictionary<string, string> builtinStyles = style.GetBuiltinStyles();
      if (builtinStyles.ContainsKey(styleName.ToLower()))
        styleName = builtinStyles[styleName.ToLower()];
    }
    if (string.IsNullOrEmpty(style.Name.Trim()) && !string.IsNullOrEmpty(styleName.Trim()))
      style.Name = styleName;
    if (!string.IsNullOrEmpty(style.Name) && !this.StyleNameId.ContainsKey(style.Name))
    {
      this.StyleNameId.Add(style.Name, styleName);
      style.StyleIDName = style.Name;
    }
    else if (!string.IsNullOrEmpty(style.Name) && this.StyleNameId.ContainsKey(style.Name))
    {
      Syncfusion.DocIO.DLS.IStyle byName = this.m_doc.Styles.FindByName(style.Name);
      if (byName != null)
      {
        (this.m_doc.Styles as StyleCollection).InnerList.Remove((object) byName);
        (byName as Style).RemoveBaseStyle();
      }
      this.StyleNameId[style.Name] = styleName;
    }
    style.StyleIDName = style.Name;
    style.Name = styleName;
  }

  private Style CreateStyle(string styleType)
  {
    Style style = (Style) null;
    switch (styleType)
    {
      case "character":
        style = (Style) new WCharacterStyle(this.m_doc);
        break;
      case "paragraph":
        style = (Style) new WParagraphStyle((IWordDocument) this.m_doc);
        break;
      case "table":
        style = (Style) new WTableStyle((IWordDocument) this.m_doc);
        break;
      case "numbering":
        style = (Style) new WNumberingStyle((IWordDocument) this.m_doc);
        break;
      default:
        if (this.IsWord2003ML && styleType == "list")
        {
          style = (Style) new WNumberingStyle((IWordDocument) this.m_doc);
          break;
        }
        break;
    }
    return style;
  }

  private void ParseLatentStyles(XmlReader reader)
  {
    this.m_doc.LatentStyles2010 = this.ReadSingleNodeIntoStream(reader);
  }

  private void ParseDocDefaults(XmlReader reader)
  {
    if (reader.LocalName != "docDefaults")
      throw new XmlException("docDefaults");
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "docDefaults")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "rPrDefault":
            if (!reader.IsEmptyElement)
            {
              string localName2 = reader.LocalName;
              reader.Read();
              if (!(localName2 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                this.SkipWhitespaces(reader);
                if (reader.LocalName == "rPrDefault" && reader.NodeType == XmlNodeType.EndElement)
                  return;
                this.m_doc.DefCharFormat = new WCharacterFormat((IWordDocument) this.m_doc);
                this.ParseCharacterFormat(reader, this.m_doc.DefCharFormat, (ParagraphItemCollection) null);
                reader.Read();
                break;
              }
              break;
            }
            break;
          case "pPrDefault":
            this.m_doc.m_defParaFormat = new WParagraphFormat((IWordDocument) this.m_doc);
            if (!reader.IsEmptyElement)
            {
              string localName3 = reader.LocalName;
              reader.Read();
              if (!(localName3 == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
              {
                this.SkipWhitespaces(reader);
                if (reader.LocalName == "pPrDefault" && reader.NodeType == XmlNodeType.EndElement)
                  return;
                this.ParseParagraphFormat(reader, this.m_doc.m_defParaFormat);
                reader.Read();
                break;
              }
              break;
            }
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private WCharacterFormat GetCharacterFormat(Style style)
  {
    if (style.StyleType == StyleType.TableStyle)
      return (style as WTableStyle).CharacterFormat;
    if (style.StyleType == StyleType.CharacterStyle)
      return (style as WCharacterStyle).CharacterFormat;
    return style.StyleType != StyleType.NumberingStyle ? (style as WParagraphStyle).CharacterFormat : (style as WNumberingStyle).CharacterFormat;
  }

  private WParagraphFormat GetParagraphFormat(Style style)
  {
    if (style.StyleType == StyleType.TableStyle)
      return (style as WTableStyle).ParagraphFormat;
    return style.StyleType != StyleType.NumberingStyle ? (style as WParagraphStyle).ParagraphFormat : (style as WNumberingStyle).ParagraphFormat;
  }

  private void ParseConditionalFormattingStyleProperties(XmlReader reader, Style style)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    if (style == null)
      throw new ArgumentException(nameof (style));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string attribute = reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute == "wholeTable")
    {
      this.SkipCurrentElement(reader, reader.LocalName);
      reader.Read();
    }
    else
    {
      string localName = reader.LocalName;
      reader.Read();
      if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
        return;
      ConditionalFormattingType conditionalFormattingCode = this.GetConditionalFormattingCode(attribute);
      ConditionalFormattingStyle conditionalFormattingStyle = (style as WTableStyle).ConditionalFormat(conditionalFormattingCode);
      this.SkipWhitespaces(reader);
      while (reader.LocalName != "tblStylePr")
      {
        if (reader.NodeType == XmlNodeType.Element)
        {
          switch (reader.LocalName)
          {
            case "rPr":
              this.ParseCharacterFormat(reader, conditionalFormattingStyle.CharacterFormat, (ParagraphItemCollection) null);
              break;
            case "pPr":
              this.ParseParagraphFormat(reader, conditionalFormattingStyle.ParagraphFormat);
              break;
            case "tblPr":
              this.ParseTableStyleTableProperties(reader, conditionalFormattingStyle.TableProperties);
              break;
            case "trPr":
              this.ParseTableStyleRowProperties(reader, conditionalFormattingStyle.RowProperties);
              break;
            case "tcPr":
              this.ParseTableStyleCellProperties(reader, conditionalFormattingStyle.CellProperties);
              break;
          }
          reader.Read();
        }
        else
          reader.Read();
        this.SkipWhitespaces(reader);
      }
    }
  }

  private ConditionalFormattingType GetConditionalFormattingCode(string styleType)
  {
    ConditionalFormattingType conditionalFormattingCode = ConditionalFormattingType.FirstRow;
    switch (styleType)
    {
      case "firstRow":
        conditionalFormattingCode = ConditionalFormattingType.FirstRow;
        break;
      case "lastRow":
        conditionalFormattingCode = ConditionalFormattingType.LastRow;
        break;
      case "band1Horz":
        conditionalFormattingCode = ConditionalFormattingType.OddRowBanding;
        break;
      case "band2Horz":
        conditionalFormattingCode = ConditionalFormattingType.EvenRowBanding;
        break;
      case "firstCol":
        conditionalFormattingCode = ConditionalFormattingType.FirstColumn;
        break;
      case "lastCol":
        conditionalFormattingCode = ConditionalFormattingType.LastColumn;
        break;
      case "band1Vert":
        conditionalFormattingCode = ConditionalFormattingType.OddColumnBanding;
        break;
      case "band2Vert":
        conditionalFormattingCode = ConditionalFormattingType.EvenColumnBanding;
        break;
      case "neCell":
        conditionalFormattingCode = ConditionalFormattingType.FirstRowLastCell;
        break;
      case "nwCell":
        conditionalFormattingCode = ConditionalFormattingType.FirstRowFirstCell;
        break;
      case "seCell":
        conditionalFormattingCode = ConditionalFormattingType.LastRowLastCell;
        break;
      case "swCell":
        conditionalFormattingCode = ConditionalFormattingType.LastRowFirstCell;
        break;
    }
    return conditionalFormattingCode;
  }

  private void ParseTableStyleTableProperties(XmlReader reader, TableStyleTableProperties props)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "tblStyleRowBandSize":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
            {
              double result = 0.0;
              props.RowStripe = double.TryParse(attribute1, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (long) result : 1L;
              break;
            }
            break;
          case "tblStyleColBandSize":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute2))
            {
              double result = 0.0;
              props.ColumnStripe = double.TryParse(attribute2, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (long) result : 1L;
              break;
            }
            break;
          case "tblCellSpacing":
            float num = 0.0f;
            string attribute3 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute3))
              num = this.GetFloatValue(attribute3, reader.LocalName);
            string attribute4 = reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if ((double) num != 3.4028234663852886E+38 && (string.IsNullOrEmpty(attribute4) || !(attribute4 == "nil")))
            {
              props.CellSpacing = num;
              break;
            }
            break;
          case "tblInd":
            string attribute5 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute5))
            {
              float floatValue = this.GetFloatValue(attribute5, reader.LocalName);
              props.LeftIndent = (double) floatValue < -1080.0 || (double) floatValue > 1080.0 || float.IsNaN(floatValue) ? 0.0f : floatValue;
              break;
            }
            break;
          case "jc":
            props.HorizontalAlignment = this.ParseTableJustification(reader);
            break;
          case "tblCellMar":
            this.ParseTableMargins(reader, props.Paddings);
            break;
          case "tblBorders":
            this.ParseBorder(reader, props.Borders);
            break;
          case "shd":
            this.ParseShading(reader, props);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseTableStyleRowProperties(XmlReader reader, TableStyleRowProperties props)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "hidden":
            props.IsHidden = this.GetBooleanValue(reader);
            break;
          case "tblHeader":
            props.IsHeader = this.GetBooleanValue(reader);
            break;
          case "cantSplit":
            props.IsBreakAcrossPages = this.GetBooleanValue(reader);
            break;
          case "tblCellSpacing":
            float num = 0.0f;
            string attribute1 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
              num = this.GetFloatValue(attribute1, reader.LocalName);
            string attribute2 = reader.GetAttribute("type", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if ((double) num != 3.4028234663852886E+38 && (string.IsNullOrEmpty(attribute2) || !(attribute2 == "nil")))
            {
              props.CellSpacing = num;
              break;
            }
            break;
          case "jc":
            props.HorizontalAlignment = this.ParseTableJustification(reader);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseTableStyleCellProperties(XmlReader reader, TableStyleCellProperties props)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "noWrap":
            props.TextWrap = !this.GetBooleanValue(reader);
            break;
          case "vAlign":
            props.VerticalAlignment = this.ParseCellVerticalAlignment(reader);
            break;
          case "tcMar":
            this.ParseTableMargins(reader, props.Paddings);
            break;
          case "tcBorders":
            this.ParseBorder(reader, props.Borders);
            break;
          case "shd":
            this.ParseShading(reader, props);
            break;
        }
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseShading(XmlReader reader, TableStyleTableProperties props)
  {
    string attribute1 = reader.GetAttribute("fill", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute1))
      props.BackColor = !(attribute1 == "auto") ? this.GetColorValue(attribute1) : Color.Empty;
    string attribute2 = reader.GetAttribute("color", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute2))
      props.ForeColor = !(attribute2 == "auto") ? this.GetColorValue(attribute2) : Color.Empty;
    string attribute3 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (string.IsNullOrEmpty(attribute3))
      return;
    props.TextureStyle = this.ParseTexture(attribute3);
  }

  private void ParseShading(XmlReader reader, TableStyleCellProperties props)
  {
    string attribute1 = reader.GetAttribute("fill", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute1))
      props.BackColor = !(attribute1 == "auto") ? this.GetColorValue(attribute1) : Color.Empty;
    string attribute2 = reader.GetAttribute("color", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (!string.IsNullOrEmpty(attribute2))
      props.ForeColor = !(attribute2 == "auto") ? this.GetColorValue(attribute2) : Color.Empty;
    string attribute3 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (string.IsNullOrEmpty(attribute3))
      return;
    props.TextureStyle = this.ParseTexture(attribute3);
  }

  private void ParseCharacterFormat(
    XmlReader reader,
    WCharacterFormat charFormat,
    ParagraphItemCollection paraItems)
  {
    if (reader.LocalName != "rPr")
      throw new XmlException("Run properties");
    if (charFormat == null)
      throw new ArgumentException("Character Format");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    float num = float.MaxValue;
    while (!(reader.LocalName == "rPr") || reader.NodeType != XmlNodeType.EndElement)
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "rFonts":
            this.ParseFonts(reader, charFormat);
            goto case "rPr";
          case "cs":
            if (reader.NodeType == XmlNodeType.Element)
            {
              charFormat.ComplexScript = this.GetBooleanValue(reader);
              goto case "rPr";
            }
            goto case "rPr";
          case "sz":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
            {
              charFormat.SetPropertyValue(3, (object) this.GetFloatValue(attribute1, reader.LocalName));
              goto case "rPr";
            }
            goto case "rPr";
          case "szCs":
          case "sz-cs":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute2))
            {
              charFormat.SetPropertyValue(62, (object) this.GetFloatValue(attribute2, reader.LocalName));
              goto case "rPr";
            }
            goto case "rPr";
          case "lang":
            this.ParseLanguage(reader, charFormat);
            goto case "rPr";
          case "u":
            if (this.IsWord2003ML)
            {
              this.Parse2003Underline(reader, charFormat);
              goto case "rPr";
            }
            this.ParseUnderline(reader, charFormat);
            goto case "rPr";
          case "em":
            this.ParseEmphasis(reader, charFormat);
            goto case "rPr";
          case "effect":
            this.ParseTextEffect(reader, charFormat);
            goto case "rPr";
          case "snapToGrid":
            if (reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace) == "off")
            {
              charFormat.SnapToGrid = false;
              goto case "rPr";
            }
            goto case "rPr";
          case "webHidden":
            charFormat.WebHidden = this.GetBooleanValue(reader);
            goto case "rPr";
          case "vertAlign":
            this.ParseVertAlign(reader, charFormat);
            goto case "rPr";
          case "color":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (attribute3 == "auto")
            {
              charFormat.TextColor = Color.Empty;
              goto case "rPr";
            }
            if (!string.IsNullOrEmpty(attribute3))
            {
              charFormat.TextColor = this.GetColorValue(attribute3);
              goto case "rPr";
            }
            goto case "rPr";
          case "highlight":
            this.ParseHighlight(reader, charFormat);
            goto case "rPr";
          case "outline":
            charFormat.OutLine = this.GetBooleanValue(reader);
            goto case "rPr";
          case "position":
            string attribute4 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute4))
            {
              charFormat.SetPositionValue(this.GetFloatValue(attribute4, reader.LocalName));
              goto case "rPr";
            }
            goto case "rPr";
          case "spacing":
            string attribute5 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute5))
            {
              charFormat.SetCharacterSpacingValue(this.GetFloatValue(attribute5, reader.LocalName));
              goto case "rPr";
            }
            goto case "rPr";
          case "rStyle":
            string attribute6 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute6) && this.StyleNameId.ContainsKey(attribute6))
              charFormat.CharStyleName = this.StyleNameId[attribute6];
            List<string> list = new List<string>();
            list.AddRange((IEnumerable<string>) this.StyleNameId.Values);
            Dictionary<string, int> dictionary = this.CountOccurrencesOfValue(list);
            if (charFormat.CharStyleName != null && dictionary[charFormat.CharStyleName] > 1)
            {
              charFormat.CharStyleId = attribute6;
              goto case "rPr";
            }
            goto case "rPr";
          case "shd":
            this.ParseRunShading(reader, charFormat);
            goto case "rPr";
          case "bdr":
            this.ParseBorder(reader, charFormat.Border);
            goto case "rPr";
          case "rPrChange":
            if (reader.AttributeCount > 0)
            {
              string attribute7 = reader.GetAttribute("author", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute7))
                charFormat.FormatChangeAuthorName = attribute7;
              string attribute8 = reader.GetAttribute("date", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute8))
              {
                DateTime result = new DateTime();
                DateTime.TryParse(attribute8, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result);
                charFormat.FormatChangeDateTime = result;
              }
            }
            this.ParseChangeCharacterFormat(reader, charFormat);
            this.m_doc.CharFormatChangeRevision(charFormat, (ParagraphItem) null);
            goto case "rPr";
          case "b":
            charFormat.Bold = this.GetBooleanValue(reader);
            goto case "rPr";
          case "bCs":
          case "b-cs":
            charFormat.BoldBidi = this.GetBooleanValue(reader);
            goto case "rPr";
          case "caps":
            charFormat.AllCaps = this.GetBooleanValue(reader);
            goto case "rPr";
          case "dstrike":
            charFormat.DoubleStrike = this.GetBooleanValue(reader);
            goto case "rPr";
          case "vanish":
            charFormat.Hidden = this.GetBooleanValue(reader);
            goto case "rPr";
          case "specVanish":
            charFormat.SpecVanish = this.GetBooleanValue(reader);
            goto case "rPr";
          case "smallCaps":
            charFormat.SmallCaps = this.GetBooleanValue(reader);
            goto case "rPr";
          case "imprint":
            charFormat.Engrave = this.GetBooleanValue(reader);
            goto case "rPr";
          case "emboss":
            charFormat.Emboss = this.GetBooleanValue(reader);
            goto case "rPr";
          case "i":
            charFormat.Italic = this.GetBooleanValue(reader);
            goto case "rPr";
          case "iCs":
          case "i-cs":
            charFormat.ItalicBidi = this.GetBooleanValue(reader);
            goto case "rPr";
          case "strike":
            charFormat.Strikeout = this.GetBooleanValue(reader);
            goto case "rPr";
          case "shadow":
            if (reader.NamespaceURI == "http://schemas.microsoft.com/office/word/2010/wordml" && !this.IsWord2003ML)
            {
              charFormat.XmlProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              goto case "rPr";
            }
            charFormat.Shadow = this.GetBooleanValue(reader);
            goto case "rPr";
          case "noProof":
            charFormat.NoProof = this.GetBooleanValue(reader);
            goto case "rPr";
          case "rtl":
            charFormat.Bidi = this.GetBooleanValue(reader);
            goto case "rPr";
          case "del":
            if (!charFormat.IsFormattingChange)
            {
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 12);
              this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
              charFormat.IsDeleteRevision = true;
              this.UpdateRevAuthorInformation(reader, charFormat);
              this.m_doc.BreakCharacterFormatRevision(RevisionType.Deletions, charFormat, (Revision) null, (WordReaderBase) null);
              goto case "rPr";
            }
            goto case "rPr";
          case "moveFrom":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 26);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            charFormat.IsDeleteRevision = true;
            this.UpdateRevAuthorInformation(reader, charFormat);
            this.m_doc.BreakCharacterFormatRevision(RevisionType.MoveFrom, charFormat, this.moveRevision, (WordReaderBase) null);
            goto case "rPr";
          case "ins":
            if (!charFormat.IsFormattingChange)
            {
              this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 24);
              this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
              charFormat.IsInsertRevision = true;
              this.UpdateRevAuthorInformation(reader, charFormat);
              this.m_doc.BreakCharacterFormatRevision(RevisionType.Insertions, charFormat, (Revision) null, (WordReaderBase) null);
              goto case "rPr";
            }
            goto case "rPr";
          case "moveTo":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, 27);
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 30);
            charFormat.IsInsertRevision = true;
            this.UpdateRevAuthorInformation(reader, charFormat);
            this.m_doc.BreakCharacterFormatRevision(RevisionType.MoveTo, charFormat, this.moveRevision, (WordReaderBase) null);
            goto case "rPr";
          case "cntxtAlts":
            charFormat.UseContextualAlternates = this.GetBooleanValue(reader, "http://schemas.microsoft.com/office/word/2010/wordml");
            goto case "rPr";
          case "ligatures":
            this.ParseLigatures(reader, charFormat);
            goto case "rPr";
          case "numForm":
            this.ParseNumberForm(reader, charFormat);
            goto case "rPr";
          case "numSpacing":
            this.ParseNumberSpacing(reader, charFormat);
            goto case "rPr";
          case "stylisticSets":
            this.ParseStylisticSet(reader, charFormat);
            goto case "rPr";
          case "kern":
            string attribute9 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute9))
            {
              num = this.GetFloatValue(attribute9, reader.LocalName);
              goto case "rPr";
            }
            goto case "rPr";
          case "w":
            string attribute10 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute10))
            {
              charFormat.SetScalingValue(this.GetFloatValue(attribute10, reader.LocalName));
              goto case "rPr";
            }
            goto case "rPr";
          case "eastAsianLayout":
            if (reader.AttributeCount > 0)
            {
              CFELayout cfeLayout = this.ParseCFELayout(reader);
              charFormat.CFELayout = cfeLayout;
              goto case "rPr";
            }
            goto case "rPr";
          case "fitText":
            if (reader.AttributeCount > 0)
            {
              string attribute11 = reader.GetAttribute("id", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute11))
              {
                int result = 0;
                int.TryParse(attribute11, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                charFormat.FitTextID = result;
              }
              string empty = string.Empty;
              string attribute12 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute12))
              {
                int result = 0;
                int.TryParse(attribute12, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
                charFormat.FitTextWidth = result / 20;
                goto case "rPr";
              }
              goto case "rPr";
            }
            goto case "rPr";
          case "delInstrText":
          case "instrText":
          case "delText":
          case "t":
            if (paraItems != null)
            {
              ParagraphItem text = (ParagraphItem) this.ParseText(reader, paraItems, true, false);
              if (text != null)
              {
                this.AddToParagraph(text, paraItems);
                this.CheckTrackChange(text);
                goto case "rPr";
              }
              goto case "rPr";
            }
            goto case "rPr";
          case "pPr":
            if (charFormat.OwnerBase != null && charFormat.OwnerBase is WParagraphStyle)
            {
              this.ParseParagraphFormat(reader, (charFormat.OwnerBase as WParagraphStyle).ParagraphFormat);
              goto case "rPr";
            }
            goto case "rPr";
          case "rPr":
            if (!flag)
            {
              reader.Read();
              break;
            }
            break;
          default:
            if (!this.IsWord2003ML && reader.LocalName != string.Empty && reader.LocalName != "rPr")
            {
              charFormat.XmlProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              goto case "rPr";
            }
            goto case "rPr";
        }
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
    this.UpdateUsedFontsCollection(charFormat);
    if ((double) num == 3.4028234663852886E+38)
      return;
    charFormat.SetKernSize(num);
  }

  private void UpdateRevAuthorInformation(XmlReader reader, WCharacterFormat charFormat)
  {
    this.m_revAuthorName = string.Empty;
    this.m_revDateTime = DateTime.MinValue;
    this.m_name = string.Empty;
    if (reader.AttributeCount <= 0)
      return;
    string attribute1 = reader.GetAttribute("author", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
    {
      if (charFormat != null)
        charFormat.AuthorName = attribute1;
      else
        this.m_revAuthorName = attribute1;
    }
    string attribute2 = reader.GetAttribute("date", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
    {
      DateTime result = new DateTime();
      DateTime.TryParse(attribute2, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result);
      if (charFormat != null)
        charFormat.RevDateTime = result;
      else
        this.m_revDateTime = result;
    }
    string attribute3 = reader.GetAttribute("name", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute3))
      return;
    if (charFormat != null)
      charFormat.RevisionName = attribute3;
    else
      this.m_name = attribute3;
  }

  private void UpdateRevAuthorInformation(
    RowFormat rowFormat,
    XmlReader reader,
    RevisionType revisionType)
  {
    if (reader.AttributeCount <= 0)
      return;
    string attribute1 = reader.GetAttribute("author", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
    {
      if (revisionType == RevisionType.Formatting)
        rowFormat.FormatChangeAuthorName = attribute1;
      else
        rowFormat.OwnerRow.CharacterFormat.AuthorName = attribute1;
    }
    string attribute2 = reader.GetAttribute("date", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute2))
      return;
    DateTime result = new DateTime();
    DateTime.TryParse(attribute2, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result);
    if (revisionType == RevisionType.Formatting)
      rowFormat.FormatChangeDateTime = result;
    else
      rowFormat.OwnerRow.CharacterFormat.RevDateTime = result;
  }

  private float GetFloatValue(string value, string elementName)
  {
    float floatValue = 0.0f;
    if (value.Contains(ControlChar.SpaceChar.ToString()))
      return floatValue;
    if (value.EndsWith("cm"))
      return this.GetNumericValue(value.Remove(value.IndexOf("cm"), 2)) * 28.35f;
    if (value.EndsWith("mm"))
      return this.GetNumericValue(value.Remove(value.IndexOf("mm"), 2)) * 2.835f;
    if (value.EndsWith("pt"))
      return this.GetNumericValue(value.Remove(value.IndexOf("pt"), 2));
    if (value.EndsWith("pi"))
      return this.GetNumericValue(value.Remove(value.IndexOf("pi"), 2)) * 12f;
    if (value.EndsWith("in"))
      return this.GetNumericValue(value.Remove(value.IndexOf("in"), 2)) * 72f;
    switch (elementName)
    {
      case "sz":
      case "szCs":
      case "position":
      case "kern":
      case "sz-cs":
        return (float) Math.Round((double) this.GetNumericValue(value) / 2.0, 2);
      case "w":
        return this.GetNumericValue(value);
      case "spacing":
      case "line":
      case "paraSpacing":
      case "pos":
      case "ind":
      case "frameWidth":
      case "frameHeight":
      case "vSpace":
      case "vspace":
      case "hSpace":
      case "hspace":
      case "y":
      case "x":
      case "col":
      case "distance":
      case "tblCellSpacing":
      case "top":
      case "left":
      case "right":
      case "bottom":
      case "linePitch":
      case "rowHeight":
      case "defaultTabStop":
      case "leftFromText":
      case "rightFromText":
      case "topFromText":
      case "bottomFromText":
      case "tblpX":
      case "tblpY":
      case "tblInd":
      case "pgSz":
      case "pgMar":
        return (float) Math.Round((double) this.GetNumericValue(value) / 20.0, 2);
      case "border":
        return this.GetNumericValue(value) / 8f;
      case "beforeLines":
      case "afterLines":
      case "before-lines":
      case "after-lines":
        return (float) Math.Round((double) this.GetNumericValue(value) / 100.0, 2);
      default:
        return 0.0f;
    }
  }

  private float GetNumericValue(string value)
  {
    float result = 0.0f;
    float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    if ((double) result == 0.0 && this.m_isFloatValue.IsMatch(value) && this.m_hasAlphabet.IsMatch(value))
    {
      string[] strArray = value.Split(new char[1]{ '.' }, StringSplitOptions.RemoveEmptyEntries);
      float.TryParse(this.StartsWithExt(value, ".") ? "0." + strArray[0] : (strArray.Length > 1 ? $"{strArray[0]}.{strArray[1]}" : strArray[0]), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    }
    return result;
  }

  private void ParseLigatures(XmlReader reader, WCharacterFormat charFormat)
  {
    switch (reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"))
    {
      case "none":
        charFormat.Ligatures = LigatureType.None;
        break;
      case "standard":
        charFormat.Ligatures = LigatureType.Standard;
        break;
      case "contextual":
        charFormat.Ligatures = LigatureType.Contextual;
        break;
      case "standardContextual":
        charFormat.Ligatures = LigatureType.StandardContextual;
        break;
      case "historical":
        charFormat.Ligatures = LigatureType.Historical;
        break;
      case "standardHistorical":
        charFormat.Ligatures = LigatureType.StandardHistorical;
        break;
      case "contextualHistorical":
        charFormat.Ligatures = LigatureType.ContextualHistorical;
        break;
      case "standardContextualHistorical":
        charFormat.Ligatures = LigatureType.StandardContextualHistorical;
        break;
      case "discretional":
        charFormat.Ligatures = LigatureType.Discretional;
        break;
      case "standardDiscretional":
        charFormat.Ligatures = LigatureType.StandardDiscretional;
        break;
      case "contextualDiscretional":
        charFormat.Ligatures = LigatureType.ContextualDiscretional;
        break;
      case "standardContextualDiscretional":
        charFormat.Ligatures = LigatureType.StandardContextualDiscretional;
        break;
      case "historicalDiscretional":
        charFormat.Ligatures = LigatureType.HistoricalDiscretional;
        break;
      case "standardHistoricalDiscretional":
        charFormat.Ligatures = LigatureType.StandardHistoricalDiscretional;
        break;
      case "contextualHistoricalDiscretional":
        charFormat.Ligatures = LigatureType.ContextualHistoricalDiscretional;
        break;
      case "all":
        charFormat.Ligatures = LigatureType.All;
        break;
    }
  }

  private void ParseNumberForm(XmlReader reader, WCharacterFormat charFormat)
  {
    switch (reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"))
    {
      case "default":
        charFormat.NumberForm = NumberFormType.Default;
        break;
      case "lining":
        charFormat.NumberForm = NumberFormType.Lining;
        break;
      case "oldStyle":
        charFormat.NumberForm = NumberFormType.OldStyle;
        break;
    }
  }

  private void ParseNumberSpacing(XmlReader reader, WCharacterFormat charFormat)
  {
    switch (reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2010/wordml"))
    {
      case "default":
        charFormat.NumberSpacing = NumberSpacingType.Default;
        break;
      case "proportional":
        charFormat.NumberSpacing = NumberSpacingType.Proportional;
        break;
      case "tabular":
        charFormat.NumberSpacing = NumberSpacingType.Tabular;
        break;
    }
  }

  private void ParseStylisticSet(XmlReader reader, WCharacterFormat charFormat)
  {
    if (reader == null)
      throw new Exception("reader is null");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "stylisticSets")
      throw new XmlException("Expected xml tag \"stylisticSets\"");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "stylisticSets")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "styleSet":
            string attribute = reader.GetAttribute("id", "http://schemas.microsoft.com/office/word/2010/wordml");
            charFormat.StylisticSet = this.GetStylisticSet(attribute);
            break;
        }
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private CFELayout ParseCFELayout(XmlReader reader)
  {
    CFELayout cfeLayout = new CFELayout();
    string attribute1 = reader.GetAttribute("id", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
    {
      int result = 0;
      int.TryParse(attribute1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      cfeLayout.ID = result;
    }
    string empty = string.Empty;
    string attribute2 = reader.GetAttribute("combine", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    cfeLayout.Combine = this.GetBoolValue(attribute2);
    empty = string.Empty;
    string attribute3 = reader.GetAttribute("vert", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    cfeLayout.Vertical = this.GetBoolValue(attribute3);
    empty = string.Empty;
    string attribute4 = reader.GetAttribute("vertCompress", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    cfeLayout.VerticalCompress = this.GetBoolValue(attribute4);
    empty = string.Empty;
    string attribute5 = reader.GetAttribute("combineBrackets", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute5))
    {
      switch (attribute5)
      {
        case "angle":
          cfeLayout.CombineBracketsType = CombineBracketsType.Angle;
          break;
        case "curly":
          cfeLayout.CombineBracketsType = CombineBracketsType.Curly;
          break;
        case "none":
          cfeLayout.CombineBracketsType = CombineBracketsType.None;
          break;
        case "round":
          cfeLayout.CombineBracketsType = CombineBracketsType.Round;
          break;
        case "square":
          cfeLayout.CombineBracketsType = CombineBracketsType.Square;
          break;
      }
    }
    return cfeLayout;
  }

  private StylisticSetType GetStylisticSet(string value)
  {
    StylisticSetType stylisticSet = StylisticSetType.StylisticSetDefault;
    switch (value)
    {
      case "0":
        stylisticSet = StylisticSetType.StylisticSetDefault;
        break;
      case "1":
        stylisticSet = StylisticSetType.StylisticSet01;
        break;
      case "2":
        stylisticSet = StylisticSetType.StylisticSet02;
        break;
      case "3":
        stylisticSet = StylisticSetType.StylisticSet03;
        break;
      case "4":
        stylisticSet = StylisticSetType.StylisticSet04;
        break;
      case "5":
        stylisticSet = StylisticSetType.StylisticSet05;
        break;
      case "6":
        stylisticSet = StylisticSetType.StylisticSet06;
        break;
      case "7":
        stylisticSet = StylisticSetType.StylisticSet07;
        break;
      case "8":
        stylisticSet = StylisticSetType.StylisticSet08;
        break;
      case "9":
        stylisticSet = StylisticSetType.StylisticSet09;
        break;
      case "10":
        stylisticSet = StylisticSetType.StylisticSet10;
        break;
      case "11":
        stylisticSet = StylisticSetType.StylisticSet11;
        break;
      case "12":
        stylisticSet = StylisticSetType.StylisticSet12;
        break;
      case "13":
        stylisticSet = StylisticSetType.StylisticSet13;
        break;
      case "14":
        stylisticSet = StylisticSetType.StylisticSet14;
        break;
      case "15":
        stylisticSet = StylisticSetType.StylisticSet15;
        break;
      case "16":
        stylisticSet = StylisticSetType.StylisticSet16;
        break;
      case "17":
        stylisticSet = StylisticSetType.StylisticSet17;
        break;
      case "18":
        stylisticSet = StylisticSetType.StylisticSet18;
        break;
      case "19":
        stylisticSet = StylisticSetType.StylisticSet19;
        break;
      case "20":
        stylisticSet = StylisticSetType.StylisticSet20;
        break;
    }
    return stylisticSet;
  }

  private void UpdateUsedFontsCollection(WCharacterFormat charFormat)
  {
    string fontName = charFormat.HasValue(68) ? charFormat.GetFontName((short) 68) : (string) null;
    if (string.IsNullOrEmpty(fontName))
      return;
    FontStyle fontStyle = FontStyle.Regular;
    if (charFormat.HasValue(4) && charFormat.Bold)
      fontStyle |= FontStyle.Bold;
    if (charFormat.HasValue(5) && charFormat.Italic)
      fontStyle |= FontStyle.Italic;
    if (charFormat.HasValue(7) && charFormat.UnderlineStyle != Syncfusion.DocIO.DLS.UnderlineStyle.None)
      fontStyle |= FontStyle.Underline;
    if (charFormat.HasValue(6) && charFormat.Strikeout)
      fontStyle |= FontStyle.Strikeout;
    Font font;
    try
    {
      font = charFormat.Document.FontSettings.GetFont(fontName, 11f, fontStyle);
    }
    catch (Exception ex)
    {
      FontFamily fontFamily = new FontFamily(fontName);
      if (fontFamily.IsStyleAvailable(FontStyle.Bold))
        fontStyle |= FontStyle.Bold;
      if (fontFamily.IsStyleAvailable(FontStyle.Italic))
        fontStyle |= FontStyle.Italic;
      if (fontFamily.IsStyleAvailable(FontStyle.Underline))
        fontStyle |= FontStyle.Underline;
      if (fontFamily.IsStyleAvailable(FontStyle.Strikeout))
        fontStyle |= FontStyle.Strikeout;
      font = charFormat.Document.FontSettings.GetFont(fontName, 11f, fontStyle);
    }
    if (this.m_doc.UsedFontNames.Contains(font))
      return;
    this.m_doc.UsedFontNames.Add(font);
  }

  private void ParseChangeCharacterFormat(XmlReader reader, WCharacterFormat charFormat)
  {
    charFormat.IsChangedFormat = true;
    charFormat.IsFormattingChange = true;
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    if (reader.LocalName == "rPrChange" && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.ParseCharacterFormat(reader, charFormat, (ParagraphItemCollection) null);
    charFormat.SetPropertyValue(105, (object) true);
    charFormat.IsFormattingChange = false;
  }

  private void ParseBorder(XmlReader reader, Border border)
  {
    border.IsRead = true;
    border.BorderType = this.GetBorderStyle(reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace), border);
    string attribute1 = reader.GetAttribute("sz", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
      border.LineWidth = (float) (byte) this.GetNumericValue(attribute1) / 8f;
    float result = float.MaxValue;
    string attribute2 = reader.GetAttribute("space", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      float.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    if ((double) result != 3.4028234663852886E+38)
      border.Space = result;
    string attribute3 = reader.GetAttribute("color", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
      border.Color = this.GetColorValue(attribute3);
    string attribute4 = reader.GetAttribute("shadow", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute4) && (attribute4 == "on" || attribute4 == "1" || attribute4 == "true"))
      border.Shadow = true;
    if (border.BorderType == BorderStyle.None && !border.HasNoneStyle && (double) border.LineWidth == 0.0 && border.Color == Color.Black)
    {
      border.BorderType = BorderStyle.Single;
      border.LineWidth = 0.5f;
    }
    border.IsRead = false;
  }

  private BorderStyle GetBorderStyle(string boderStyle, Border border)
  {
    BorderStyle borderStyle = BorderStyle.None;
    switch (boderStyle)
    {
      case "twistedLines1":
      case "twisted-lines-1":
        borderStyle = BorderStyle.TwistedLines1;
        break;
      case "triple":
        borderStyle = BorderStyle.Triple;
        break;
      case "dashSmallGap":
      case "dash-small-gap":
        borderStyle = BorderStyle.DashSmallGap;
        break;
      case "single":
        borderStyle = BorderStyle.Single;
        break;
      case "dotted":
        borderStyle = BorderStyle.Dot;
        break;
      case "dotDash":
      case "dot-dash":
        borderStyle = BorderStyle.DotDash;
        break;
      case "dotDotDash":
      case "dot-Dot-Dash":
        borderStyle = BorderStyle.DotDotDash;
        break;
      case "dashed":
        borderStyle = BorderStyle.DashLargeGap;
        break;
      case "double":
        borderStyle = BorderStyle.Double;
        break;
      case "thickThinSmallGap":
      case "thick-thin-small-gap":
        borderStyle = BorderStyle.ThinThinSmallGap;
        break;
      case "thinThickSmallGap":
      case "thin-thick-small-gap":
        borderStyle = BorderStyle.ThinThickSmallGap;
        break;
      case "thinThickThinSmallGap":
      case "thin-thick-thin-small-gap":
        borderStyle = BorderStyle.ThinThickThinSmallGap;
        break;
      case "thinThickThinMediumGap":
      case "thin-thick-thin-medium-gap":
        borderStyle = BorderStyle.ThickThickThinMediumGap;
        break;
      case "thickThinMediumGap":
      case "thick-thin-medium-gap":
        borderStyle = BorderStyle.ThickThinMediumGap;
        break;
      case "thinThickMediumGap":
      case "thin-thick-medium-gap":
        borderStyle = BorderStyle.ThinThickMediumGap;
        break;
      case "thickThinLargeGap":
      case "thick-thin-large-gap":
        borderStyle = BorderStyle.ThickThinLargeGap;
        break;
      case "thinThickLargeGap":
      case "thin-thick-large-gap":
        borderStyle = BorderStyle.ThinThickLargeGap;
        break;
      case "thinThickThinLargeGap":
      case "thin-thick-thin-large-gap":
        borderStyle = BorderStyle.ThinThickThinLargeGap;
        break;
      case "thick":
        borderStyle = BorderStyle.Thick;
        break;
      case "wave":
        borderStyle = BorderStyle.Wave;
        break;
      case "doubleWave":
      case "double-wave":
        borderStyle = BorderStyle.DoubleWave;
        break;
      case "dashDotStroked":
      case "dash-dot-stroked":
        borderStyle = BorderStyle.DashDotStroker;
        break;
      case "threeDEngrave":
      case "three-d-engrave":
        borderStyle = BorderStyle.Engrave3D;
        break;
      case "threeDEmboss":
      case "three-d-emboss":
        borderStyle = BorderStyle.Emboss3D;
        break;
      case "outset":
        borderStyle = BorderStyle.Outset;
        break;
      case "inset":
        borderStyle = BorderStyle.Inset;
        break;
      case "nil":
        borderStyle = BorderStyle.Cleared;
        break;
      case "apples":
        borderStyle = BorderStyle.Single;
        break;
      case "archedScallops":
        borderStyle = (BorderStyle) 97;
        break;
      case "babyPacifier":
        borderStyle = (BorderStyle) 70;
        break;
      case "babyRattle":
        borderStyle = (BorderStyle) 71;
        break;
      case "balloons3Colors":
        borderStyle = BorderStyle.ThinThickSmallGap;
        break;
      case "balloonsHotAir":
        borderStyle = BorderStyle.ThinThinSmallGap;
        break;
      case "basicBlackDashes":
        borderStyle = (BorderStyle) 155;
        break;
      case "basicBlackDots":
        borderStyle = (BorderStyle) 156;
        break;
      case "basicBlackSquares":
        borderStyle = (BorderStyle) 154;
        break;
      case "basicThinLines":
        borderStyle = (BorderStyle) 151;
        break;
      case "basicWhiteDashes":
        borderStyle = (BorderStyle) 152;
        break;
      case "basicWhiteDots":
        borderStyle = (BorderStyle) 147;
        break;
      case "basicWhiteSquares":
        borderStyle = (BorderStyle) 153;
        break;
      case "basicWideInline":
        borderStyle = (BorderStyle) 150;
        break;
      case "basicWideMidline":
        borderStyle = (BorderStyle) 148;
        break;
      case "basicWideOutline":
        borderStyle = (BorderStyle) 149;
        break;
      case "bats":
        borderStyle = (BorderStyle) 37;
        break;
      case "birds":
        borderStyle = (BorderStyle) 102;
        break;
      case "birdsFlight":
        borderStyle = (BorderStyle) 35;
        break;
      case "cabins":
        borderStyle = (BorderStyle) 72;
        break;
      case "cakeSlice":
        borderStyle = BorderStyle.Double;
        break;
      case "candyCorn":
        borderStyle = (BorderStyle) 4;
        break;
      case "celticKnotwork":
        borderStyle = (BorderStyle) 99;
        break;
      case "certificateBanner":
        borderStyle = (BorderStyle) 158;
        break;
      case "chainLink":
        borderStyle = (BorderStyle) 128 /*0x80*/;
        break;
      case "champagneBottle":
        borderStyle = BorderStyle.Dot;
        break;
      case "checkedBarBlack":
        borderStyle = (BorderStyle) 145;
        break;
      case "checkedBarColor":
        borderStyle = (BorderStyle) 61;
        break;
      case "checkered":
        borderStyle = (BorderStyle) 144 /*0x90*/;
        break;
      case "christmasTree":
        borderStyle = BorderStyle.DotDash;
        break;
      case "circlesLines":
        borderStyle = (BorderStyle) 91;
        break;
      case "circlesRectangles":
        borderStyle = (BorderStyle) 140;
        break;
      case "classicalWave":
        borderStyle = (BorderStyle) 56;
        break;
      case "clocks":
        borderStyle = BorderStyle.Inset;
        break;
      case "compass":
        borderStyle = (BorderStyle) 54;
        break;
      case "confetti":
        borderStyle = BorderStyle.ThickThinMediumGap | BorderStyle.ThickThickThinMediumGap;
        break;
      case "confettiGrays":
        borderStyle = (BorderStyle) 115;
        break;
      case "confettiOutline":
        borderStyle = (BorderStyle) 116;
        break;
      case "confettiStreamers":
        borderStyle = BorderStyle.ThinThickMediumGap;
        break;
      case "confettiWhite":
        borderStyle = (BorderStyle) 117;
        break;
      case "cornerTriangles":
        borderStyle = (BorderStyle) 141;
        break;
      case "couponCutoutDashes":
        borderStyle = (BorderStyle) 163;
        break;
      case "couponCutoutDots":
        borderStyle = (BorderStyle) 164;
        break;
      case "crazyMaze":
        borderStyle = (BorderStyle) 100;
        break;
      case "creaturesButterfly":
        borderStyle = (BorderStyle) 32 /*0x20*/;
        break;
      case "creaturesFish":
        borderStyle = (BorderStyle) 34;
        break;
      case "creaturesInsects":
        borderStyle = (BorderStyle) 142;
        break;
      case "creaturesLadyBug":
        borderStyle = (BorderStyle) 33;
        break;
      case "crossStitch":
        borderStyle = (BorderStyle) 138;
        break;
      case "cup":
        borderStyle = (BorderStyle) 67;
        break;
      case "decoArch":
        borderStyle = (BorderStyle) 89;
        break;
      case "decoArchColor":
        borderStyle = (BorderStyle) 50;
        break;
      case "decoBlocks":
        borderStyle = (BorderStyle) 90;
        break;
      case "diamondsGray":
        borderStyle = (BorderStyle) 88;
        break;
      case "doubleD":
        borderStyle = (BorderStyle) 55;
        break;
      case "doubleDiamonds":
        borderStyle = (BorderStyle) 127 /*0x7F*/;
        break;
      case "earth1":
        borderStyle = BorderStyle.DashSmallGap;
        break;
      case "earth2":
        borderStyle = BorderStyle.DoubleWave;
        break;
      case "eclipsingSquares1":
        borderStyle = (BorderStyle) 101;
        break;
      case "eclipsingSquares2":
        borderStyle = (BorderStyle) 86;
        break;
      case "eggsBlack":
        borderStyle = (BorderStyle) 66;
        break;
      case "fans":
        borderStyle = (BorderStyle) 51;
        break;
      case "film":
        borderStyle = (BorderStyle) 52;
        break;
      case "firecrackers":
        borderStyle = BorderStyle.ThinThinSmallGap | BorderStyle.ThickThickThinMediumGap;
        break;
      case "flowersBlockPrint":
        borderStyle = (BorderStyle) 49;
        break;
      case "flowersDaisies":
        borderStyle = (BorderStyle) 48 /*0x30*/;
        break;
      case "flowersModern1":
        borderStyle = (BorderStyle) 45;
        break;
      case "flowersModern2":
        borderStyle = (BorderStyle) 44;
        break;
      case "flowersPansy":
        borderStyle = (BorderStyle) 43;
        break;
      case "flowersRedRose":
        borderStyle = (BorderStyle) 39;
        break;
      case "flowersRoses":
        borderStyle = (BorderStyle) 38;
        break;
      case "flowersTeacup":
        borderStyle = (BorderStyle) 103;
        break;
      case "flowersTiny":
        borderStyle = (BorderStyle) 42;
        break;
      case "gems":
        borderStyle = (BorderStyle) 139;
        break;
      case "gingerbreadMan":
        borderStyle = (BorderStyle) 69;
        break;
      case "gradient":
        borderStyle = (BorderStyle) 122;
        break;
      case "handmade1":
        borderStyle = (BorderStyle) 159;
        break;
      case "handmade2":
        borderStyle = (BorderStyle) 160 /*0xA0*/;
        break;
      case "heartBalloon":
        borderStyle = BorderStyle.ThickThickThinMediumGap;
        break;
      case "heartGray":
        borderStyle = (BorderStyle) 68;
        break;
      case "hearts":
        borderStyle = BorderStyle.ThickThinMediumGap;
        break;
      case "heebieJeebies":
        borderStyle = (BorderStyle) 120;
        break;
      case "holly":
        borderStyle = (BorderStyle) 41;
        break;
      case "houseFunky":
        borderStyle = (BorderStyle) 73;
        break;
      case "hypnotic":
        borderStyle = (BorderStyle) 87;
        break;
      case "iceCreamCones":
        borderStyle = BorderStyle.Hairline;
        break;
      case "lightBulb":
        borderStyle = (BorderStyle) 121;
        break;
      case "lightning1":
        borderStyle = (BorderStyle) 53;
        break;
      case "lightning2":
        borderStyle = (BorderStyle) 119;
        break;
      case "mapleLeaf":
        borderStyle = (BorderStyle) 81;
        break;
      case "mapleMuffins":
        borderStyle = BorderStyle.Thick;
        break;
      case "mapPins":
        borderStyle = BorderStyle.ThinThickMediumGap | BorderStyle.ThickThickThinMediumGap;
        break;
      case "marquee":
        borderStyle = (BorderStyle) 146;
        break;
      case "marqueeToothed":
        borderStyle = (BorderStyle) 131;
        break;
      case "moons":
        borderStyle = (BorderStyle) 125;
        break;
      case "mosaic":
        borderStyle = (BorderStyle) 118;
        break;
      case "musicNotes":
        borderStyle = (BorderStyle) 79;
        break;
      case "northwest":
        borderStyle = (BorderStyle) 104;
        break;
      case "ovals":
        borderStyle = (BorderStyle) 126;
        break;
      case "packages":
        borderStyle = BorderStyle.Outset;
        break;
      case "palmsBlack":
        borderStyle = (BorderStyle) 80 /*0x50*/;
        break;
      case "palmsColor":
        borderStyle = BorderStyle.Triple;
        break;
      case "paperClips":
        borderStyle = (BorderStyle) 82;
        break;
      case "papyrus":
        borderStyle = (BorderStyle) 92;
        break;
      case "partyFavor":
        borderStyle = BorderStyle.ThinThickThinSmallGap;
        break;
      case "partyGlass":
        borderStyle = BorderStyle.DashLargeGap;
        break;
      case "pencils":
        borderStyle = BorderStyle.Engrave3D;
        break;
      case "people":
        borderStyle = (BorderStyle) 84;
        break;
      case "peopleHats":
        borderStyle = BorderStyle.DashDotStroker;
        break;
      case "peopleWaving":
        borderStyle = (BorderStyle) 85;
        break;
      case "poinsettias":
        borderStyle = (BorderStyle) 40;
        break;
      case "postageStamp":
        borderStyle = (BorderStyle) 135;
        break;
      case "pumpkin1":
        borderStyle = (BorderStyle) 65;
        break;
      case "pushPinNote1":
        borderStyle = (BorderStyle) 63 /*0x3F*/;
        break;
      case "pushPinNote2":
        borderStyle = (BorderStyle) 64 /*0x40*/;
        break;
      case "pyramids":
        borderStyle = (BorderStyle) 113;
        break;
      case "pyramidsAbove":
        borderStyle = (BorderStyle) 114;
        break;
      case "quadrants":
        borderStyle = (BorderStyle) 60;
        break;
      case "rings":
        borderStyle = BorderStyle.ThinThickThinSmallGap | BorderStyle.ThickThickThinMediumGap;
        break;
      case "safari":
        borderStyle = (BorderStyle) 98;
        break;
      case "sawtooth":
        borderStyle = (BorderStyle) 133;
        break;
      case "sawtoothGray":
        borderStyle = (BorderStyle) 134;
        break;
      case "scaredCat":
        borderStyle = (BorderStyle) 36;
        break;
      case "seattle":
        borderStyle = (BorderStyle) 78;
        break;
      case "shadowedSquares":
        borderStyle = (BorderStyle) 57;
        break;
      case "sharksTeeth":
        borderStyle = (BorderStyle) 132;
        break;
      case "shorebirdTracks":
        borderStyle = (BorderStyle) 83;
        break;
      case "skyrocket":
        borderStyle = (BorderStyle) 77;
        break;
      case "snowflakeFancy":
        borderStyle = (BorderStyle) 76;
        break;
      case "snowflakes":
        borderStyle = (BorderStyle) 75;
        break;
      case "sombrero":
        borderStyle = BorderStyle.Emboss3D;
        break;
      case "southwest":
        borderStyle = (BorderStyle) 105;
        break;
      case "stars":
        borderStyle = BorderStyle.ThinThickThinLargeGap;
        break;
      case "stars3D":
        borderStyle = BorderStyle.ThinThickLargeGap;
        break;
      case "starsBlack":
        borderStyle = (BorderStyle) 74;
        break;
      case "starsShadowed":
        borderStyle = BorderStyle.ThickThinLargeGap;
        break;
      case "starsTop":
        borderStyle = (BorderStyle) 157;
        break;
      case "sun":
        borderStyle = BorderStyle.Wave;
        break;
      case "swirligig":
        borderStyle = (BorderStyle) 62;
        break;
      case "tornPaper":
        borderStyle = (BorderStyle) 161;
        break;
      case "tornPaperBlack":
        borderStyle = (BorderStyle) 162;
        break;
      case "trees":
        borderStyle = BorderStyle.DotDotDash;
        break;
      case "triangleParty":
        borderStyle = (BorderStyle) 123;
        break;
      case "triangles":
        borderStyle = (BorderStyle) 129;
        break;
      case "tribal1":
        borderStyle = (BorderStyle) 130;
        break;
      case "tribal2":
        borderStyle = (BorderStyle) 109;
        break;
      case "tribal3":
        borderStyle = (BorderStyle) 108;
        break;
      case "tribal4":
        borderStyle = (BorderStyle) 107;
        break;
      case "tribal5":
        borderStyle = (BorderStyle) 110;
        break;
      case "tribal6":
        borderStyle = (BorderStyle) 106;
        break;
      case "twistedLines2":
        borderStyle = (BorderStyle) 124;
        break;
      case "vine":
        borderStyle = (BorderStyle) 47;
        break;
      case "waveline":
        borderStyle = (BorderStyle) 59;
        break;
      case "weavingAngles":
        borderStyle = (BorderStyle) 96 /*0x60*/;
        break;
      case "weavingBraid":
        borderStyle = (BorderStyle) 94;
        break;
      case "weavingRibbon":
        borderStyle = (BorderStyle) 95;
        break;
      case "weavingStrips":
        borderStyle = (BorderStyle) 136;
        break;
      case "whiteFlowers":
        borderStyle = (BorderStyle) 46;
        break;
      case "woodwork":
        borderStyle = (BorderStyle) 93;
        break;
      case "xIllusions":
        borderStyle = (BorderStyle) 111;
        break;
      case "zanyTriangles":
        borderStyle = (BorderStyle) 112 /*0x70*/;
        break;
      case "zigZag":
        borderStyle = (BorderStyle) 137;
        break;
      case "zigZagStitch":
        borderStyle = (BorderStyle) 143;
        break;
      case "none":
        borderStyle = BorderStyle.None;
        border.HasNoneStyle = true;
        break;
    }
    return borderStyle;
  }

  private int GetBorderMultiplier(Border border)
  {
    FormatBase parentFormat = border.ParentFormat;
    if (parentFormat is WCharacterFormat)
      return 20;
    if (parentFormat is Borders)
      parentFormat = parentFormat.ParentFormat;
    return parentFormat == null || parentFormat is WParagraphFormat ? 20 : 8;
  }

  private void ParseRunShading(XmlReader reader, WCharacterFormat charFormat)
  {
    string attribute1 = reader.GetAttribute("fill", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    string attribute3 = reader.GetAttribute("color", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      charFormat.TextureStyle = this.ParseTexture(attribute2);
    if (!string.IsNullOrEmpty(attribute1))
      charFormat.TextBackgroundColor = !(attribute1 == "auto") ? this.GetColorValue(attribute1) : Color.Empty;
    if (string.IsNullOrEmpty(attribute3))
      return;
    if (attribute3 == "auto")
      charFormat.ForeColor = Color.Empty;
    else
      charFormat.ForeColor = this.GetColorValue(attribute3);
  }

  private TextureStyle ParseTexture(string textureStyle)
  {
    switch (textureStyle)
    {
      case "pct5":
        return TextureStyle.Texture5Percent;
      case "pct10":
        return TextureStyle.Texture10Percent;
      case "pct12":
        return TextureStyle.Texture12Pt5Percent;
      case "pct15":
        return TextureStyle.Texture15Percent;
      case "pct20":
        return TextureStyle.Texture20Percent;
      case "pct25":
        return TextureStyle.Texture25Percent;
      case "pct30":
        return TextureStyle.Texture30Percent;
      case "pct35":
        return TextureStyle.Texture35Percent;
      case "pct37":
        return TextureStyle.Texture37Pt5Percent;
      case "pct40":
        return TextureStyle.Texture40Percent;
      case "pct45":
        return TextureStyle.Texture45Percent;
      case "pct50":
        return TextureStyle.Texture50Percent;
      case "pct55":
        return TextureStyle.Texture55Percent;
      case "pct60":
        return TextureStyle.Texture60Percent;
      case "pct62":
        return TextureStyle.Texture62Pt5Percent;
      case "pct65":
        return TextureStyle.Texture65Percent;
      case "pct70":
        return TextureStyle.Texture70Percent;
      case "pct75":
        return TextureStyle.Texture75Percent;
      case "pct80":
        return TextureStyle.Texture80Percent;
      case "pct85":
        return TextureStyle.Texture85Percent;
      case "pct87":
        return TextureStyle.Texture87Pt5Percent;
      case "pct90":
        return TextureStyle.Texture90Percent;
      case "pct95":
        return TextureStyle.Texture95Percent;
      case "thinHorzCross":
        return TextureStyle.TextureCross;
      case "horzCross":
        return TextureStyle.TextureDarkCross;
      case "diagCross":
        return TextureStyle.TextureDarkDiagonalCross;
      case "reverseDiagStripe":
        return TextureStyle.TextureDarkDiagonalDown;
      case "diagStripe":
        return TextureStyle.TextureDarkDiagonalUp;
      case "horzStripe":
        return TextureStyle.TextureDarkHorizontal;
      case "vertStripe":
        return TextureStyle.TextureDarkVertical;
      case "thinDiagCross":
        return TextureStyle.TextureDiagonalCross;
      case "thinReverseDiagStripe":
        return TextureStyle.TextureDiagonalDown;
      case "thinDiagStripe":
        return TextureStyle.TextureDiagonalUp;
      case "thinHorzStripe":
        return TextureStyle.TextureHorizontal;
      case "solid":
        return TextureStyle.TextureSolid;
      case "thinVertStripe":
        return TextureStyle.TextureVertical;
      case "nil":
        return TextureStyle.TextureNil;
      default:
        return TextureStyle.TextureNone;
    }
  }

  private TextureStyle Parse2003Texture(string textureStyle)
  {
    switch (textureStyle)
    {
      case "pct-5":
        return TextureStyle.Texture5Percent;
      case "pct-10":
        return TextureStyle.Texture10Percent;
      case "pct-12":
        return TextureStyle.Texture12Pt5Percent;
      case "pct-15":
        return TextureStyle.Texture15Percent;
      case "pct-20":
        return TextureStyle.Texture20Percent;
      case "pct-25":
        return TextureStyle.Texture25Percent;
      case "pct-30":
        return TextureStyle.Texture30Percent;
      case "pct-35":
        return TextureStyle.Texture35Percent;
      case "pct-37":
        return TextureStyle.Texture37Pt5Percent;
      case "pct-40":
        return TextureStyle.Texture40Percent;
      case "pct-45":
        return TextureStyle.Texture45Percent;
      case "pct-50":
        return TextureStyle.Texture50Percent;
      case "pct-55":
        return TextureStyle.Texture55Percent;
      case "pct-60":
        return TextureStyle.Texture60Percent;
      case "pct-62":
        return TextureStyle.Texture62Pt5Percent;
      case "pct-65":
        return TextureStyle.Texture65Percent;
      case "pct-70":
        return TextureStyle.Texture70Percent;
      case "pct-75":
        return TextureStyle.Texture75Percent;
      case "pct-80":
        return TextureStyle.Texture80Percent;
      case "pct-85":
        return TextureStyle.Texture85Percent;
      case "pct-87":
        return TextureStyle.Texture87Pt5Percent;
      case "pct-90":
        return TextureStyle.Texture90Percent;
      case "pct-95":
        return TextureStyle.Texture95Percent;
      case "thin-horz-cross":
        return TextureStyle.TextureCross;
      case "horz-cross":
        return TextureStyle.TextureDarkCross;
      case "diag-cross":
        return TextureStyle.TextureDarkDiagonalCross;
      case "reverse-diag-stripe":
        return TextureStyle.TextureDarkDiagonalDown;
      case "diag-stripe":
        return TextureStyle.TextureDarkDiagonalUp;
      case "horz-stripe":
        return TextureStyle.TextureDarkHorizontal;
      case "vert-stripe":
        return TextureStyle.TextureDarkVertical;
      case "thin-diag-cross":
        return TextureStyle.TextureDiagonalCross;
      case "thin-reverse-diag-stripe":
        return TextureStyle.TextureDiagonalDown;
      case "thin-diag-stripe":
        return TextureStyle.TextureDiagonalUp;
      case "thin-horz-stripe":
        return TextureStyle.TextureHorizontal;
      case "solid":
        return TextureStyle.TextureSolid;
      case "thin-vert-stripe":
        return TextureStyle.TextureVertical;
      case "nil":
        return TextureStyle.TextureNil;
      default:
        return TextureStyle.TextureNone;
    }
  }

  private void ParseVertAlign(XmlReader reader, WCharacterFormat charFormat)
  {
    switch (reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
    {
      case "subscript":
        charFormat.SubSuperScript = SubSuperScript.SubScript;
        break;
      case "superscript":
        charFormat.SubSuperScript = SubSuperScript.SuperScript;
        break;
      case "baseline":
        charFormat.SubSuperScript = SubSuperScript.None;
        break;
    }
  }

  private void ParseEmphasis(XmlReader reader, WCharacterFormat charFormat)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "circle":
        charFormat.EmphasisType = EmphasisType.Circle;
        break;
      case "comma":
        charFormat.EmphasisType = EmphasisType.Comma;
        break;
      case "dot":
        charFormat.EmphasisType = EmphasisType.Dot;
        break;
      case "underDot":
        charFormat.EmphasisType = EmphasisType.UnderDot;
        break;
      default:
        charFormat.EmphasisType = EmphasisType.NoEmphasis;
        break;
    }
  }

  private void ParseTextEffect(XmlReader reader, WCharacterFormat charFormat)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "antsBlack":
        charFormat.TextEffect = TextEffect.MarchingBlackAnts;
        break;
      case "antsRed":
        charFormat.TextEffect = TextEffect.MarchingRedAnts;
        break;
      case "blinkBackground":
        charFormat.TextEffect = TextEffect.BlinkingBackground;
        break;
      case "lights":
        charFormat.TextEffect = TextEffect.LasVegasLights;
        break;
      case "shimmer":
        charFormat.TextEffect = TextEffect.Shimmer;
        break;
      case "sparkle":
        charFormat.TextEffect = TextEffect.SparkleText;
        break;
      default:
        charFormat.TextEffect = TextEffect.None;
        break;
    }
  }

  private void ParseUnderline(XmlReader reader, WCharacterFormat charFormat)
  {
    string attribute1 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute1 != null)
    {
      switch (attribute1)
      {
        case "single":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Single;
          break;
        case "words":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Words;
          break;
        case "double":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Double;
          break;
        case "dotted":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Dotted;
          break;
        case "thick":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Thick;
          break;
        case "dash":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Dash;
          break;
        case "dotDash":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DotDash;
          break;
        case "dotDotDash":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DotDotDash;
          break;
        case "wave":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Wavy;
          break;
        case "dashLong":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DashLong;
          break;
        case "dottedHeavy":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DottedHeavy;
          break;
        case "dashedHeavy":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DashHeavy;
          break;
        case "dashLongHeavy":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DashLongHeavy;
          break;
        case "dashDotHeavy":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DotDashHeavy;
          break;
        case "dashDotDotHeavy":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DotDotDashHeavy;
          break;
        case "wavyHeavy":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.WavyHeavy;
          break;
        case "wavyDouble":
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.WavyDouble;
          break;
        default:
          charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.None;
          break;
      }
    }
    string attribute2 = reader.GetAttribute("color", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute2 == null)
      return;
    charFormat.UnderlineColor = this.GetColorValue(attribute2);
  }

  private void Parse2003Underline(XmlReader reader, WCharacterFormat charFormat)
  {
    string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "single":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Single;
        break;
      case "words":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Words;
        break;
      case "double":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Double;
        break;
      case "dotted":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Dotted;
        break;
      case "thick":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Thick;
        break;
      case "dash":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Dash;
        break;
      case "dot-dash":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DotDash;
        break;
      case "dot-dot-dash":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DotDotDash;
        break;
      case "wave":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.Wavy;
        break;
      case "dash-long":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DashLong;
        break;
      case "dotted-heavy":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DottedHeavy;
        break;
      case "dashed-heavy":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DashHeavy;
        break;
      case "dash-long-heavy":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DashLongHeavy;
        break;
      case "dash-dot-heavy":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DotDashHeavy;
        break;
      case "dash-dot-dot-heavy":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.DotDotDashHeavy;
        break;
      case "wavy-heavy":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.WavyHeavy;
        break;
      case "wavy-double":
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.WavyDouble;
        break;
      default:
        charFormat.UnderlineStyle = Syncfusion.DocIO.DLS.UnderlineStyle.None;
        break;
    }
  }

  private void ParseFonts(XmlReader reader, WCharacterFormat charFormat)
  {
    int i = 0;
    for (int attributeCount = reader.AttributeCount; i < attributeCount; ++i)
    {
      reader.MoveToAttribute(i);
      switch (reader.LocalName)
      {
        case "ascii":
          string attribute1 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute1))
          {
            charFormat.FontNameAscii = attribute1;
            charFormat.FontName = attribute1;
            break;
          }
          break;
        case "hAnsi":
        case "h-ansi":
          string attribute2 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute2))
          {
            charFormat.FontNameNonFarEast = attribute2;
            break;
          }
          break;
        case "eastAsia":
        case "fareast":
          string attribute3 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute3))
          {
            charFormat.FontNameFarEast = attribute3;
            break;
          }
          break;
        case "hint":
          string attribute4 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute4))
          {
            switch (attribute4.ToLower())
            {
              case "cs":
                charFormat.IdctHint = FontHintType.CS;
                continue;
              case "eastasia":
              case "fareast":
                charFormat.IdctHint = FontHintType.EastAsia;
                continue;
              default:
                charFormat.IdctHint = FontHintType.Default;
                continue;
            }
          }
          else
            break;
        case "cs":
          string attribute5 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute5))
          {
            charFormat.FontNameBidi = attribute5;
            break;
          }
          break;
        case "asciiTheme":
          string attribute6 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute6))
          {
            charFormat.FontNameAscii = attribute6;
            switch (attribute6)
            {
              case "minorHAnsi":
                charFormat.FontName = this.m_minorFontName != null ? this.m_minorFontName : "Calibri";
                continue;
              case "majorHAnsi":
                charFormat.FontName = this.m_majorFontName != null ? this.m_majorFontName : "Cambria";
                continue;
              default:
                continue;
            }
          }
          else
            break;
        case "eastAsiaTheme":
          string attribute7 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute7))
          {
            charFormat.FontNameFarEast = attribute7;
            break;
          }
          break;
        case "hAnsiTheme":
          string attribute8 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute8))
          {
            charFormat.FontNameNonFarEast = attribute8;
            break;
          }
          break;
        case "cstheme":
          string attribute9 = reader.GetAttribute(i);
          if (!string.IsNullOrEmpty(attribute9))
          {
            charFormat.FontNameBidi = attribute9;
            break;
          }
          break;
      }
    }
  }

  private static bool IsEnumDefined(ref string value, string formattedValue)
  {
    if (!System.Enum.IsDefined(typeof (LocaleIDs), (object) formattedValue))
      return false;
    value = formattedValue;
    return true;
  }

  internal static bool IsEnumDefined(ref string value)
  {
    value = value.Replace('-', '_');
    if (System.Enum.IsDefined(typeof (LocaleIDs), (object) value))
      return true;
    string[] strArray = value.Split('_');
    if (strArray.Length == 2)
    {
      string formattedValue1 = $"{strArray[0].ToLower()}_{strArray[1].ToUpper()}";
      if (DocxParser.IsEnumDefined(ref value, formattedValue1))
        return true;
      string formattedValue2 = $"{strArray[0].ToLower()}_{DocxParser.FirstLetterToUpper(strArray[1])}";
      if (DocxParser.IsEnumDefined(ref value, formattedValue2))
        return true;
    }
    else if (strArray.Length == 3)
    {
      string formattedValue3 = $"{strArray[0].ToLower()}_{DocxParser.FirstLetterToUpper(strArray[1])}_{strArray[2].ToUpper()}";
      if (DocxParser.IsEnumDefined(ref value, formattedValue3))
        return true;
      string formattedValue4 = $"{strArray[0].ToLower()}_{strArray[1].ToLower()}_{strArray[2].ToUpper()}";
      if (DocxParser.IsEnumDefined(ref value, formattedValue4))
        return true;
      string formattedValue5 = $"{strArray[0].ToLower()}_{strArray[1].ToUpper()}_{strArray[2].ToLower()}";
      if (DocxParser.IsEnumDefined(ref value, formattedValue5))
        return true;
    }
    return false;
  }

  private static string FirstLetterToUpper(string str)
  {
    return str.Length > 1 ? char.ToUpper(str[0]).ToString() + str.Substring(1) : str;
  }

  private void ParseLanguage(XmlReader reader, WCharacterFormat charFormat)
  {
    string str = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(str))
    {
      if (this.IsWord2003ML)
        str = str.ToLower();
      if (DocxParser.IsEnumDefined(ref str))
      {
        charFormat.LocaleIdASCII = (short) (LocaleIDs) System.Enum.Parse(typeof (LocaleIDs), str.Replace('-', '_'));
      }
      else
      {
        short languageId = this.GetLanguageID(str);
        if (languageId != (short) 1033)
          charFormat.LocaleIdASCII = languageId;
      }
    }
    string name = this.IsWord2003ML ? "fareast" : "eastAsia";
    str = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(str))
    {
      if (this.IsWord2003ML)
        str = str.ToLower();
      if (System.Enum.IsDefined(typeof (LocaleIDs), (object) str.Replace('-', '_')))
      {
        charFormat.LocaleIdFarEast = (short) (LocaleIDs) System.Enum.Parse(typeof (LocaleIDs), str.Replace('-', '_'));
      }
      else
      {
        short languageId = this.GetLanguageID(str);
        if (languageId != (short) 1033)
          charFormat.LocaleIdFarEast = languageId;
      }
    }
    str = reader.GetAttribute("bidi", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(str))
      return;
    if (this.IsWord2003ML)
      str = str.ToLower();
    if (System.Enum.IsDefined(typeof (LocaleIDs), (object) str.Replace('-', '_')))
    {
      charFormat.LocaleIdBidi = (short) (LocaleIDs) System.Enum.Parse(typeof (LocaleIDs), str.Replace('-', '_'));
    }
    else
    {
      short languageId = this.GetLanguageID(str);
      if (languageId == (short) 1033)
        return;
      charFormat.LocaleIdBidi = languageId;
    }
  }

  private void ParseHighlight(XmlReader reader, WCharacterFormat charFormat)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute == null)
      return;
    if (attribute.ToLower() == "darkyellow")
      charFormat.HighlightColor = Color.Gold;
    else
      charFormat.HighlightColor = this.GetColorValue(attribute);
  }

  private void ParseParagraphFormat(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    if (reader.LocalName != "pPr" && reader.LocalName != "pPrChange")
      throw new XmlException("Paragraph properties");
    if (paragraphFormat == null)
      throw new ArgumentException("Paragraph format should not be null");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "pPr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "sectPr":
            if (paragraphFormat.OwnerBase is WParagraph && (paragraphFormat.OwnerBase as WParagraph).OwnerTextBody.Owner is BlockContentControl)
            {
              paragraphFormat.XmlProps.Add("sectPr", (Stream) this.ReadSingleNodeIntoStream(reader));
              this.IsSDTHasSectionBreak = true;
              flag = true;
              goto case "cnfStyle";
            }
            this.ParseSectionProperties(reader, (IEntity) this.m_doc.LastSection);
            this.m_doc.AddSection();
            goto case "cnfStyle";
          case "pStyle":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1))
            {
              string key = attribute1.Trim();
              if (paragraphFormat.OwnerBase is WParagraph && this.StyleNameId.ContainsKey(key) && this.m_doc.Styles.FindByName(this.StyleNameId[key], StyleType.ParagraphStyle) is IWParagraphStyle byName)
              {
                if (!paragraphFormat.IsFormattingChange)
                {
                  (paragraphFormat.OwnerBase as WParagraph).ApplyStyle(byName, false);
                  goto case "cnfStyle";
                }
                paragraphFormat.ParagraphStyleName = key;
                goto case "cnfStyle";
              }
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          case "framePr":
            this.ParseFrameProperties(reader, paragraphFormat);
            goto case "cnfStyle";
          case "rPr":
            if (paragraphFormat.OwnerBase is WParagraph)
            {
              WCharacterFormat breakCharacterFormat = (paragraphFormat.OwnerBase as WParagraph).BreakCharacterFormat;
              this.ParseCharacterFormat(reader, breakCharacterFormat, (ParagraphItemCollection) null);
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          case "tabs":
            this.ParseTabs(reader, paragraphFormat);
            goto case "cnfStyle";
          case "pageBreakBefore":
            paragraphFormat.PageBreakBefore = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "keepLines":
            paragraphFormat.Keep = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "outlineLvl":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute2))
            {
              float result = 0.0f;
              if (float.TryParse(attribute2, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result) && (double) result > -1.0)
              {
                paragraphFormat.OutlineLevel = (int) result < 0 || (int) result > 9 ? OutlineLevel.BodyText : (OutlineLevel) System.Enum.ToObject(typeof (OutlineLevel), (int) result);
                goto case "cnfStyle";
              }
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          case "keepNext":
            paragraphFormat.KeepFollow = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "jc":
            if (this.IsWord2003ML)
            {
              this.ParseParagraph2003Justification(reader, paragraphFormat);
              goto case "cnfStyle";
            }
            this.ParseParagraphJustification(reader, paragraphFormat);
            goto case "cnfStyle";
          case "ind":
            this.ParseIndentation(reader, paragraphFormat);
            goto case "cnfStyle";
          case "spacing":
            this.ParseSpacing(reader, paragraphFormat);
            goto case "cnfStyle";
          case "shd":
            this.ParseShading(reader, paragraphFormat);
            goto case "cnfStyle";
          case "bidi":
            paragraphFormat.Bidi = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "widowControl":
            paragraphFormat.WidowControl = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "wordWrap":
            paragraphFormat.WordWrap = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "autoSpaceDE":
            paragraphFormat.AutoSpaceDE = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "autoSpaceDN":
            paragraphFormat.AutoSpaceDN = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "adjustRightInd":
            paragraphFormat.AdjustRightIndent = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "pBdr":
            this.ParseBorders(reader, paragraphFormat.OwnerBase as IEntity, paragraphFormat.Borders);
            goto case "cnfStyle";
          case "listPr":
          case "numPr":
            this.ParseList(reader, (FormatBase) paragraphFormat);
            goto case "cnfStyle";
          case "contextualSpacing":
            paragraphFormat.ContextualSpacing = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "pPrChange":
            if (reader.AttributeCount > 0)
            {
              string attribute3 = reader.GetAttribute("author", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute3))
                paragraphFormat.FormatChangeAuthorName = attribute3;
              string attribute4 = reader.GetAttribute("date", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
              if (!string.IsNullOrEmpty(attribute4))
              {
                DateTime result = new DateTime();
                DateTime.TryParse(attribute4, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AdjustToUniversal, out result);
                paragraphFormat.FormatChangeDateTime = result;
              }
            }
            this.ParseChangeParagraphFormat(reader, paragraphFormat);
            this.m_doc.ParaFormatChangeRevision(paragraphFormat);
            goto case "cnfStyle";
          case "cnfStyle":
            if (!flag)
            {
              reader.Read();
              break;
            }
            break;
          case "mirrorIndents":
            paragraphFormat.MirrorIndents = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "suppressAutoHyphens":
            paragraphFormat.SuppressAutoHyphens = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "textAlignment":
            this.ParseParagraphTextAlignment(reader, paragraphFormat);
            goto case "cnfStyle";
          case "snapToGrid":
            paragraphFormat.SnapToGrid = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "suppressOverlap":
            paragraphFormat.SuppressOverlap = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "textboxTightWrap":
            this.ParseParagraphTextboxTightWrap(reader, paragraphFormat);
            goto case "cnfStyle";
          case "suppressLineNumbers":
            paragraphFormat.SuppressLineNumbers = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "kinsoku":
            paragraphFormat.Kinsoku = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "overflowPunct":
            paragraphFormat.OverflowPunctuation = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "topLinePunct":
            paragraphFormat.TopLinePunctuation = this.GetBooleanValue(reader);
            goto case "cnfStyle";
          case "bottom":
          case "top":
          case "left":
          case "right":
          case "between":
          case "bar":
            WParagraphFormat paragraphFormat1 = (paragraphFormat.OwnerBase as WParagraph).ParagraphFormat;
            Borders borders1;
            if (paragraphFormat1.IsFormattingChange)
            {
              Borders borders2 = new Borders();
              paragraphFormat1.SetPropertyValue(20, (object) borders2);
              borders1 = (Borders) paragraphFormat1.OldPropertiesHash[20];
            }
            else
              borders1 = paragraphFormat1.Borders;
            if (borders1 != null)
            {
              this.ParseBorderValue(reader, borders1);
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
          default:
            if (!this.IsWord2003ML && reader.LocalName != "pPr")
            {
              paragraphFormat.XmlProps.Add(reader.LocalName, (Stream) this.ReadSingleNodeIntoStream(reader));
              flag = true;
              goto case "cnfStyle";
            }
            goto case "cnfStyle";
        }
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseFrameProperties(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    this.ParseFramePos(reader, paragraphFormat);
    this.ParseFrameAnchor(reader, paragraphFormat);
    this.ParseFrameSize(reader, paragraphFormat);
  }

  private void ParseFrameSize(XmlReader reader, WParagraphFormat paraFormat)
  {
    string name = this.IsWord2003ML ? "h-rule" : "hRule";
    string attribute1 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
      paraFormat.SetFrameWidthValue(this.GetFloatValue(attribute1, "frameWidth"));
    string attribute2 = reader.GetAttribute("h", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    float result = 0.0f;
    if (!string.IsNullOrEmpty(attribute2))
      float.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    string attribute3 = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    switch (attribute3)
    {
      case "exact":
        paraFormat.FrameHeight = result / 20f;
        break;
      default:
        if ((double) result != 0.0)
        {
          paraFormat.FrameHeight = (float) ((int) (short) result | 32768 /*0x8000*/) / 20f;
          break;
        }
        if (attribute3 == "auto")
        {
          paraFormat.FrameHeight = 0.0f;
          break;
        }
        break;
    }
    string attribute4 = reader.GetAttribute("dropCap", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute4))
    {
      switch (attribute4)
      {
        case "margin":
          paraFormat.DropCap = DropCapType.Margin;
          break;
        case "drop":
          paraFormat.DropCap = DropCapType.DropCap;
          break;
        default:
          paraFormat.DropCap = DropCapType.None;
          break;
      }
    }
    int int32 = Convert.ToInt32(reader.GetAttribute("lines", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace));
    if (int32 > 0 && int32 < 11)
      paraFormat.DropCapLines = int32;
    else
      paraFormat.DropCapLines = 1;
  }

  private void ParseFrameAnchor(XmlReader reader, WParagraphFormat paraFormat)
  {
    string name1 = this.IsWord2003ML ? "hanchor" : "hAnchor";
    string name2 = this.IsWord2003ML ? "vanchor" : "vAnchor";
    string attribute1 = reader.GetAttribute(name1, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
    {
      switch (attribute1)
      {
        case "margin":
          paraFormat.FrameHorizontalPos = (byte) 1;
          break;
        case "page":
        case "column":
          paraFormat.FrameHorizontalPos = (byte) 2;
          break;
        case "text":
          paraFormat.FrameHorizontalPos = (byte) 0;
          break;
      }
    }
    string attribute2 = reader.GetAttribute(name2, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
    {
      switch (attribute2)
      {
        case "margin":
          paraFormat.FrameVerticalPos = (byte) 0;
          break;
        case "page":
          paraFormat.FrameVerticalPos = (byte) 1;
          break;
        case "text":
          paraFormat.FrameVerticalPos = (byte) 2;
          break;
        case "none":
          paraFormat.FrameVerticalPos = (byte) 3;
          break;
      }
    }
    string attribute3 = reader.GetAttribute("anchorLock", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute3))
      return;
    paraFormat.LockFrameAnchor = this.GetBoolValue(attribute3);
  }

  private void ParseFramePos(XmlReader reader, WParagraphFormat paraFormat)
  {
    string name1 = this.IsWord2003ML ? "x-align" : "xAlign";
    string name2 = this.IsWord2003ML ? "y-align" : "yAlign";
    string str1 = this.IsWord2003ML ? "vspace" : "vSpace";
    string str2 = this.IsWord2003ML ? "hspace" : "hSpace";
    string attribute1 = reader.GetAttribute(name1, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
    {
      switch (attribute1)
      {
        case "right":
          paraFormat.FrameX = -8f;
          break;
        case "center":
          paraFormat.FrameX = -4f;
          break;
        case "inside":
          paraFormat.FrameX = -12f;
          break;
        case "outside":
          paraFormat.FrameX = -16f;
          break;
        case "left":
          paraFormat.FrameX = 0.0f;
          break;
      }
    }
    string attribute2 = reader.GetAttribute("x", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      this.SetFramePositions(attribute2, true, paraFormat);
    string attribute3 = reader.GetAttribute(name2, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
    {
      switch (attribute3)
      {
        case "top":
          paraFormat.FrameY = -4f;
          break;
        case "bottom":
          paraFormat.FrameY = -12f;
          break;
        case "center":
          paraFormat.FrameY = -8f;
          break;
        case "inside":
          paraFormat.FrameY = -16f;
          break;
        case "outside":
          paraFormat.FrameY = -20f;
          break;
        case "inline":
          paraFormat.FrameY = 0.0f;
          break;
      }
    }
    string attribute4 = reader.GetAttribute("y", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute4))
      this.SetFramePositions(attribute4, false, paraFormat);
    string attribute5 = reader.GetAttribute("wrap", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute5))
    {
      switch (attribute5)
      {
        case "notBeside":
          paraFormat.WrapFrameAround = FrameWrapMode.NotBeside;
          break;
        case "around":
          paraFormat.WrapFrameAround = FrameWrapMode.Around;
          break;
        case "none":
          paraFormat.WrapFrameAround = FrameWrapMode.None;
          break;
        case "tight":
          paraFormat.WrapFrameAround = FrameWrapMode.Tight;
          break;
        case "through":
          paraFormat.WrapFrameAround = FrameWrapMode.Through;
          break;
        default:
          if (this.IsWord2003ML && attribute5 == "not-beside")
            paraFormat.WrapFrameAround = FrameWrapMode.NotBeside;
          paraFormat.WrapFrameAround = FrameWrapMode.Auto;
          break;
      }
    }
    string attribute6 = reader.GetAttribute(str2, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute6))
      paraFormat.SetFrameHorizontalDistanceFromTextValue(this.GetFloatValue(attribute6, str2));
    string attribute7 = reader.GetAttribute(str1, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute7))
      return;
    paraFormat.SetFrameVerticalDistanceFromTextValue(this.GetFloatValue(attribute7, str1));
  }

  private void SetFramePositions(string position, bool isXValue, WParagraphFormat paraFormat)
  {
    short result = 0;
    bool flag = false;
    if (short.TryParse(position, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
      flag = isXValue ? paraFormat.IsFrameXAlign((float) result) : paraFormat.IsFrameYAlign((float) result);
    if (flag)
    {
      if (isXValue)
        paraFormat.FrameX = (float) result;
      else
        paraFormat.FrameY = (float) result;
    }
    else
    {
      float floatValue = this.GetFloatValue(position, "x");
      if (isXValue ? paraFormat.IsFrameXAlign(floatValue) : paraFormat.IsFrameYAlign(floatValue))
        floatValue -= 0.05f;
      if (isXValue)
        paraFormat.SetFrameXValue(floatValue);
      else
        paraFormat.SetFrameYValue(floatValue);
    }
  }

  private void ParseTabs(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    if (reader.LocalName != "tabs")
      throw new XmlException("Tab collection");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "tabs")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "tab":
            Tab tab = paragraphFormat.Tabs.AddTab();
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute1) && attribute1 != "clear")
              tab.Justification = this.GetTabAlign(attribute1);
            string attribute2 = reader.GetAttribute("pos", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute2))
            {
              float num = this.GetFloatValue(attribute2, "pos");
              if ((double) num < -1584.05 || (double) num > 1584.05)
                num = 0.0f;
              if (attribute1 == "clear")
                tab.DeletePosition = num * 20f;
              else
                tab.Position = num;
            }
            string attribute3 = reader.GetAttribute("leader", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute3))
            {
              tab.TabLeader = this.GetTabLeader(attribute3);
              break;
            }
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private Syncfusion.DocIO.DLS.TabJustification GetTabAlign(string align)
  {
    switch (align.ToLower())
    {
      case "center":
        return Syncfusion.DocIO.DLS.TabJustification.Centered;
      case "end":
      case "right":
        return Syncfusion.DocIO.DLS.TabJustification.Right;
      case "decimal":
        return Syncfusion.DocIO.DLS.TabJustification.Decimal;
      case "bar":
        return Syncfusion.DocIO.DLS.TabJustification.Bar;
      case "num":
        return Syncfusion.DocIO.DLS.TabJustification.List;
      default:
        return Syncfusion.DocIO.DLS.TabJustification.Left;
    }
  }

  private Syncfusion.DocIO.DLS.TabLeader GetTabLeader(string leader)
  {
    switch (leader)
    {
      case "dot":
        return Syncfusion.DocIO.DLS.TabLeader.Dotted;
      case "hyphen":
        return Syncfusion.DocIO.DLS.TabLeader.Hyphenated;
      case "underscore":
        return Syncfusion.DocIO.DLS.TabLeader.Single;
      case "heavy":
        return Syncfusion.DocIO.DLS.TabLeader.Heavy;
      default:
        return Syncfusion.DocIO.DLS.TabLeader.NoLeader;
    }
  }

  private void ParseChangeParagraphFormat(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    paragraphFormat.IsChangedFormat = true;
    paragraphFormat.IsFormattingChange = true;
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    if (reader.LocalName == "pPrChange" && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.ParseParagraphFormat(reader, paragraphFormat);
    paragraphFormat.IsFormattingChange = false;
    if (paragraphFormat.OwnerBase is WParagraph)
    {
      (paragraphFormat.OwnerBase as WParagraph).ListFormat.IsFormattingChange = paragraphFormat.IsFormattingChange;
    }
    else
    {
      if (!(paragraphFormat.OwnerBase is WParagraphStyle))
        return;
      (paragraphFormat.OwnerBase as WParagraphStyle).ListFormat.IsFormattingChange = paragraphFormat.IsFormattingChange;
    }
  }

  private void CheckTrackChange(ParagraphItem item)
  {
    if (item.GetCharFormat() != null && item.GetCharFormat().HasKey(105))
      this.m_doc.CharFormatChangeRevision(item.GetCharFormat(), item);
    if (this.m_trackChangeType == RevisionType.None)
    {
      if (this.moveRevision == null)
        return;
      this.moveRevision.Range.Items.Add((object) item);
    }
    else
    {
      if (this.moveRevision != null && this.m_trackchangeRevisionDetails.Count == 0 && (this.m_trackChangeType == RevisionType.Insertions || this.m_trackChangeType == RevisionType.Deletions))
        this.moveRevision.Range.Items.Add((object) item);
      if (this.m_trackChangeType == RevisionType.Deletions)
      {
        item.SetDeleteRev(true, this.m_revAuthorName, this.m_revDateTime);
        this.m_doc.ParagraphItemRevision(item, RevisionType.Deletions, this.m_revAuthorName, this.m_revDateTime, this.m_name, false, this.moveRevision, this.contentRevision, this.m_trackchangeRevisionDetails);
      }
      else if (this.m_trackChangeType == RevisionType.Insertions)
      {
        item.SetInsertRev(true, this.m_revAuthorName, this.m_revDateTime);
        this.m_doc.ParagraphItemRevision(item, RevisionType.Insertions, this.m_revAuthorName, this.m_revDateTime, this.m_name, false, this.moveRevision, this.contentRevision, this.m_trackchangeRevisionDetails);
      }
      else if (this.m_trackChangeType == RevisionType.MoveFrom)
      {
        item.SetDeleteRev(true, this.m_revAuthorName, this.m_revDateTime);
        this.m_doc.ParagraphItemRevision(item, RevisionType.MoveFrom, this.m_revAuthorName, this.m_revDateTime, this.m_name, false, this.moveRevision, this.contentRevision, this.m_trackchangeRevisionDetails);
      }
      else
      {
        if (this.m_trackChangeType != RevisionType.MoveTo)
          return;
        item.SetInsertRev(true, this.m_revAuthorName, this.m_revDateTime);
        this.m_doc.ParagraphItemRevision(item, RevisionType.MoveTo, this.m_revAuthorName, this.m_revDateTime, this.m_name, false, this.moveRevision, this.contentRevision, this.m_trackchangeRevisionDetails);
      }
    }
  }

  private void CreateMoveRangeRevision(WParagraph para, RevisionType revisionType)
  {
    if (para != null && para.BreakCharacterFormat.Revisions.Count > 0)
    {
      foreach (Revision revision in para.BreakCharacterFormat.Revisions)
      {
        if (revision.RevisionType == revisionType && revision.Author == this.m_revAuthorName && this.m_doc.Revisions.InnerList.Contains((object) revision))
        {
          this.moveRevision = revision;
          revision.Name = this.m_name;
        }
        else
          this.moveRevision = this.m_doc.CreateNewRevision(revisionType, this.m_revAuthorName, this.m_revDateTime, this.m_name);
      }
    }
    else
      this.moveRevision = this.m_doc.CreateNewRevision(revisionType, this.m_revAuthorName, this.m_revDateTime, this.m_name);
  }

  private void UpdateInsDelRevision(
    XmlReader reader,
    ParagraphItemCollection paraItems,
    RevisionType revisionType,
    IOfficeMathRunElement mathParaItem,
    bool isParsingRun)
  {
    if (this.m_trackChangeType == RevisionType.Deletions)
      this.m_trackchangeRevisionDetails.Push(this.m_doc.CreateNewChildRevision(RevisionType.Deletions, this.m_revAuthorName, this.m_revDateTime, this.m_name));
    else if (this.m_trackChangeType == RevisionType.Insertions)
      this.m_trackchangeRevisionDetails.Push(this.m_doc.CreateNewChildRevision(RevisionType.Insertions, this.m_revAuthorName, this.m_revDateTime, this.m_name));
    else if (this.m_trackChangeType == RevisionType.MoveTo)
      this.m_trackchangeRevisionDetails.Push(this.m_doc.CreateNewChildRevision(RevisionType.MoveTo, this.m_revAuthorName, this.m_revDateTime, this.m_name));
    else if (this.m_trackChangeType == RevisionType.MoveFrom)
      this.m_trackchangeRevisionDetails.Push(this.m_doc.CreateNewChildRevision(RevisionType.MoveFrom, this.m_revAuthorName, this.m_revDateTime, this.m_name));
    this.UpdateRevAuthorInformation(reader, (WCharacterFormat) null);
    this.m_trackChangeType = revisionType;
    this.m_trackchangeStack.Push(this.m_trackChangeType);
    if (isParsingRun)
      this.ParseRun(reader, paraItems, mathParaItem, false, reader.NodeType, false);
    this.ParseParagraphItems(reader, paraItems, (string) null, mathParaItem, false);
    this.m_trackChangeType = RevisionType.None;
    int num = (int) this.m_trackchangeStack.Pop();
    if (this.m_trackchangeRevisionDetails.Count > 0)
    {
      this.m_revAuthorName = this.m_trackchangeRevisionDetails.Peek().Author;
      this.m_revDateTime = this.m_trackchangeRevisionDetails.Peek().Date;
      this.m_trackchangeRevisionDetails.Pop();
    }
    if (this.m_trackchangeStack.Count <= 0)
      return;
    this.m_trackChangeType = this.m_trackchangeStack.Peek();
  }

  private void ParseBorders(XmlReader reader, IEntity ent, Borders borders)
  {
    switch (ent)
    {
      case WTable _:
        if (this.IsTableChangeFormat)
        {
          borders = new Borders();
          (ent as WTable).DocxTableFormat.Format.SetPropertyValue(1, (object) borders);
          borders = (Borders) (ent as WTable).DocxTableFormat.Format.OldPropertiesHash[1];
          break;
        }
        borders = (ent as WTable).DocxTableFormat.Format.Borders;
        break;
      case WTableRow _:
        if (this.IsRowChangeFormat)
        {
          borders = new Borders();
          (ent as WTableRow).RowFormat.SetPropertyValue(1, (object) borders);
          borders = (Borders) (ent as WTableRow).RowFormat.OldPropertiesHash[1];
          break;
        }
        borders = (ent as WTableRow).RowFormat.Borders;
        break;
      case WTableCell _:
        if (this.IsCellChangeFormat)
        {
          borders = new Borders();
          (ent as WTableCell).CellFormat.SetPropertyValue(1, (object) borders);
          borders = (Borders) (ent as WTableCell).CellFormat.OldPropertiesHash[1];
          break;
        }
        borders = (ent as WTableCell).CellFormat.Borders;
        break;
      case WSection _:
        WPageSetup pageSetup = (ent as WSection).PageSetup;
        if ((ent as WSection).SectionFormat.IsFormattingChange)
          pageSetup.Borders.IsFormattingChange = true;
        if (pageSetup.IsFormattingChange)
        {
          borders = new Borders();
          pageSetup.SetPropertyValue(34, (object) borders);
          borders = (Borders) pageSetup.OldPropertiesHash[34];
          break;
        }
        borders = (ent as WSection).PageSetup.Borders;
        break;
      case WParagraph _:
        WParagraphFormat paragraphFormat = (ent as WParagraph).ParagraphFormat;
        if (paragraphFormat.IsFormattingChange)
        {
          borders = new Borders();
          paragraphFormat.SetPropertyValue(20, (object) borders);
          borders = (Borders) paragraphFormat.OldPropertiesHash[20];
          break;
        }
        borders = paragraphFormat.Borders;
        break;
    }
    if (borders == null)
      return;
    this.ParseBorder(reader, borders);
  }

  private void ParseBorder(XmlReader reader, Borders borders)
  {
    if (borders == null)
      throw new ArgumentException("Borders should not be null");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        this.ParseBorderValue(reader, borders);
        reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseBorderValue(XmlReader reader, Borders borders)
  {
    switch (reader.LocalName)
    {
      case "top":
        this.ParseBorder(reader, borders.Top);
        break;
      case "start":
      case "left":
        this.ParseBorder(reader, borders.Left);
        break;
      case "bottom":
        this.ParseBorder(reader, borders.Bottom);
        break;
      case "end":
      case "right":
        this.ParseBorder(reader, borders.Right);
        break;
      case "between":
      case "insideH":
        this.ParseBorder(reader, borders.Horizontal);
        break;
      case "bar":
      case "insideV":
        this.ParseBorder(reader, borders.Vertical);
        break;
      case "tl2br":
        this.ParseBorder(reader, borders.DiagonalDown);
        break;
      case "tr2bl":
        this.ParseBorder(reader, borders.DiagonalUp);
        break;
    }
  }

  private void ParseSpacing(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    if (reader.AttributeCount == 0)
      return;
    string str1 = this.IsWord2003ML ? "before-lines" : "beforeLines";
    string str2 = this.IsWord2003ML ? "after-lines" : "afterLines";
    string name1 = this.IsWord2003ML ? "before-autospacing" : "beforeAutospacing";
    string name2 = this.IsWord2003ML ? "after-autospacing" : "afterAutospacing";
    string attribute1 = reader.GetAttribute("before", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
      paragraphFormat.SetPropertyValue(8, (object) this.GetFloatValue(attribute1, "paraSpacing"));
    string attribute2 = reader.GetAttribute(str1, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      paragraphFormat.BeforeLines = this.GetFloatValue(attribute2, str1);
    string attribute3 = reader.GetAttribute(str2, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
      paragraphFormat.AfterLines = this.GetFloatValue(attribute3, str2);
    string attribute4 = reader.GetAttribute("after", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute4))
      paragraphFormat.SetPropertyValue(9, (object) this.GetFloatValue(attribute4, "paraSpacing"));
    string attribute5 = reader.GetAttribute(name1, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute5))
      paragraphFormat.SpaceBeforeAuto = this.GetBoolValue(attribute5);
    string attribute6 = reader.GetAttribute(name2, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute6))
      paragraphFormat.SpaceAfterAuto = this.GetBoolValue(attribute6);
    this.ParseLineSpacing(reader, paragraphFormat);
  }

  private void ParseLineSpacing(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    string name = this.IsWord2003ML ? "line-rule" : "lineRule";
    string attribute1 = reader.GetAttribute("line", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    float num = 0.0f;
    if (!string.IsNullOrEmpty(attribute1))
      num = this.GetFloatValue(attribute1, "line");
    if ((double) num != 0.0)
    {
      paragraphFormat.SetPropertyValue(52, (object) 0.0f);
      paragraphFormat.SetPropertyValue(52, (object) Math.Abs(num));
      string attribute2 = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
      if (attribute2 == null)
        return;
      switch (attribute2)
      {
        case "atLeast":
          paragraphFormat.LineSpacingRule = LineSpacingRule.AtLeast;
          break;
        case "exact":
          paragraphFormat.LineSpacingRule = LineSpacingRule.Exactly;
          break;
        default:
          if (this.IsWord2003ML && attribute2 == "at-least")
            paragraphFormat.LineSpacingRule = LineSpacingRule.AtLeast;
          paragraphFormat.LineSpacingRule = (double) num > 0.0 ? LineSpacingRule.Multiple : LineSpacingRule.Exactly;
          break;
      }
    }
    else
    {
      if (string.IsNullOrEmpty(attribute1))
        return;
      switch (reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace))
      {
        case "auto":
          paragraphFormat.SetPropertyValue(52, (object) 0.0f);
          paragraphFormat.LineSpacingRule = LineSpacingRule.Multiple;
          break;
        case "atLeast":
          paragraphFormat.SetPropertyValue(52, (object) 0.0f);
          paragraphFormat.LineSpacingRule = LineSpacingRule.AtLeast;
          break;
      }
    }
  }

  private void ParseIndentation(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    if (reader.AttributeCount == 0)
      return;
    string name1 = this.IsWord2003ML ? "first-line" : "firstLine";
    string name2 = this.IsWord2003ML ? "left-chars" : "leftChars";
    string name3 = this.IsWord2003ML ? "right-chars" : "rightChars";
    string name4 = this.IsWord2003ML ? "first-line-chars" : "firstLineChars";
    string name5 = this.IsWord2003ML ? "hanging-chars" : "hangingChars";
    string attribute1 = reader.GetAttribute("left", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
      paragraphFormat.SetPropertyValue(2, (object) this.GetFloatValue(attribute1, reader.LocalName));
    string attribute2 = reader.GetAttribute("right", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      paragraphFormat.SetPropertyValue(3, (object) this.GetFloatValue(attribute2, reader.LocalName));
    string attribute3 = reader.GetAttribute("start", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
      paragraphFormat.SetPropertyValue(2, (object) this.GetFloatValue(attribute3, reader.LocalName));
    string attribute4 = reader.GetAttribute("end", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute4))
      paragraphFormat.SetPropertyValue(3, (object) this.GetFloatValue(attribute4, reader.LocalName));
    string attribute5 = reader.GetAttribute(name1, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute5))
      paragraphFormat.SetPropertyValue(5, (object) this.GetFloatValue(attribute5, reader.LocalName));
    string attribute6 = reader.GetAttribute("hanging", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute6))
      paragraphFormat.SetPropertyValue(5, (object) (float) -(double) this.GetFloatValue(attribute6, reader.LocalName));
    string attribute7 = reader.GetAttribute(name2, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute7))
      paragraphFormat.LeftIndentChars = (float) ((double) this.GetFloatValue(attribute7, reader.LocalName) * 20.0 / 100.0);
    string attribute8 = reader.GetAttribute(name3, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute8))
      paragraphFormat.RightIndentChars = (float) ((double) this.GetFloatValue(attribute8, reader.LocalName) * 20.0 / 100.0);
    string attribute9 = reader.GetAttribute(name4, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute9))
      paragraphFormat.FirstLineIndentChars = (float) ((double) this.GetFloatValue(attribute9, reader.LocalName) * 20.0 / 100.0);
    string attribute10 = reader.GetAttribute(name5, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute10))
      return;
    paragraphFormat.FirstLineIndentChars = (float) -((double) this.GetFloatValue(attribute10, reader.LocalName) * 20.0 / 100.0);
  }

  private void ParseParagraph2003Justification(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
    if (string.IsNullOrEmpty(attribute))
      return;
    switch (attribute)
    {
      case "center":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Center;
        break;
      case "right":
      case "end":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Right;
        break;
      case "both":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Justify;
        break;
      case "distribute":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Distribute;
        break;
      case "medium-kashida":
        paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyMedium;
        break;
      case "high-kashida":
        paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyHigh;
        break;
      case "low-kashida":
        paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyLow;
        break;
      case "thai-distribute":
        paragraphFormat.LogicalJustification = HorizontalAlignment.ThaiJustify;
        break;
      case "list-tab":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Right | HorizontalAlignment.Distribute;
        break;
      default:
        paragraphFormat.LogicalJustification = HorizontalAlignment.Left;
        break;
    }
  }

  private void ParseParagraphJustification(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (string.IsNullOrEmpty(attribute))
      return;
    switch (attribute)
    {
      case "center":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Center;
        break;
      case "right":
      case "end":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Right;
        break;
      case "both":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Justify;
        break;
      case "distribute":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Distribute;
        break;
      case "mediumKashida":
        paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyMedium;
        break;
      case "numTab":
        paragraphFormat.LogicalJustification = HorizontalAlignment.Right | HorizontalAlignment.Distribute;
        break;
      case "highKashida":
        paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyHigh;
        break;
      case "lowKashida":
        paragraphFormat.LogicalJustification = HorizontalAlignment.JustifyLow;
        break;
      case "thaiDistribute":
        paragraphFormat.LogicalJustification = HorizontalAlignment.ThaiJustify;
        break;
      default:
        paragraphFormat.LogicalJustification = HorizontalAlignment.Left;
        break;
    }
  }

  private void ParseParagraphTextAlignment(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (string.IsNullOrEmpty(attribute))
      return;
    switch (attribute)
    {
      case "baseline":
        paragraphFormat.BaseLineAlignment = BaseLineAlignment.Baseline;
        break;
      case "bottom":
        paragraphFormat.BaseLineAlignment = BaseLineAlignment.Bottom;
        break;
      case "center":
        paragraphFormat.BaseLineAlignment = BaseLineAlignment.Center;
        break;
      case "top":
        paragraphFormat.BaseLineAlignment = BaseLineAlignment.Top;
        break;
      default:
        paragraphFormat.BaseLineAlignment = BaseLineAlignment.Auto;
        break;
    }
  }

  private void ParseParagraphTextboxTightWrap(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (string.IsNullOrEmpty(attribute))
      return;
    switch (attribute)
    {
      case "allLines":
        paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.AllLines;
        break;
      case "firstAndLastLine":
        paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.FirstAndLastLine;
        break;
      case "firstLineOnly":
        paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.FirstLineOnly;
        break;
      case "lastLineOnly":
        paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.LastLineOnly;
        break;
      default:
        paragraphFormat.TextboxTightWrap = TextboxTightWrapOptions.None;
        break;
    }
  }

  private void ParseShading(XmlReader reader, WParagraphFormat paragraphFormat)
  {
    string attribute1 = reader.GetAttribute("fill", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
      paragraphFormat.BackColor = !(attribute1 == "auto") ? this.GetColorValue(attribute1) : Color.Empty;
    string attribute2 = reader.GetAttribute("themeFill", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      paragraphFormat.BackGroundColor = !(attribute2 == "auto") ? this.GetThemeFillColor(attribute2) : Color.Empty;
    string attribute3 = reader.GetAttribute("color", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
      paragraphFormat.ForeColor = !(attribute3 == "auto") ? this.GetColorValue(attribute3) : Color.Empty;
    string attribute4 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute4))
      return;
    paragraphFormat.TextureStyle = this.ParseTexture(attribute4);
  }

  private Color GetThemeFillColor(string value)
  {
    Color themeFillColor = Color.Empty;
    if (!string.IsNullOrEmpty(value))
    {
      if (!this.m_doc.Themes.SchemeColor.ContainsKey(value))
      {
        switch (value)
        {
          case "tx1":
            value = "dk1";
            break;
          case "tx2":
            value = "dk2";
            break;
          case "bg1":
            value = "lt1";
            break;
          case "bg2":
            value = "lt2";
            break;
        }
      }
      if (this.m_doc.Themes.SchemeColor.ContainsKey(value))
        return this.m_doc.Themes.SchemeColor[value];
      switch (value)
      {
        case "accent1":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 79, 129, 189);
          break;
        case "accent2":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 192 /*0xC0*/, 80 /*0x50*/, 77);
          break;
        case "accent3":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 155, 187, 89);
          break;
        case "accent4":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 128 /*0x80*/, 100, 162);
          break;
        case "accent5":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 75, 172, 198);
          break;
        case "accent6":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 247, 150, 70);
          break;
        case "dk1":
        case "tx1":
        case "phClr":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 0, 0, 0);
          break;
        case "dk2":
        case "tx2":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 31 /*0x1F*/, 73, 125);
          break;
        case "folHlink":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 128 /*0x80*/, 0, 128 /*0x80*/);
          break;
        case "hlink":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 0, 0, (int) byte.MaxValue);
          break;
        case "bg1":
        case "lt1":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, (int) byte.MaxValue, (int) byte.MaxValue, (int) byte.MaxValue);
          break;
        case "bg2":
        case "lt2":
          themeFillColor = Color.FromArgb((int) byte.MaxValue, 238, 236, 225);
          break;
      }
    }
    return themeFillColor;
  }

  private void ParseSectionProperties(XmlReader reader, IEntity entity)
  {
    if (reader.LocalName != "sectPr")
      throw new XmlException("Section properties");
    if (entity == null)
      throw new ArgumentException("Section should not be null");
    (entity as WSection).PageSetup.InitializeDocxPageSetup();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != "sectPr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "footerReference":
          case "headerReference":
            DictionaryEntry docRelation = this.m_docRelations[reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships")];
            string attribute1 = reader.GetAttribute("type", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            bool isHeader1 = (string) docRelation.Key == (this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships/header" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header");
            string fileName = docRelation.Value.ToString();
            Part part = this.FindPart(this.GetPartName(ref fileName), fileName);
            this.m_currentFile = docRelation.Value.ToString() + ".rels";
            this.ParseHeaderFooter(this.m_doc.LastSection.HeadersFooters, part, attribute1, isHeader1);
            this.m_currentFile = "";
            break;
          case "type":
            string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (this.IsWord2003ML)
            {
              this.Parse2003SectionBreakType(entity as WSection, attribute2);
              break;
            }
            this.ParseSectionBreakType(entity as WSection, attribute2);
            break;
          case "pgSz":
            this.ParsePageSize(reader, entity as WSection);
            break;
          case "pgMar":
            this.ParsePageMargins(reader, entity as WSection);
            break;
          case "cols":
            this.ParseColumns(reader, entity as WSection);
            if (reader.LocalName != "cols")
            {
              flag = true;
              break;
            }
            break;
          case "titlePg":
            (entity as WSection).PageSetup.DifferentFirstPage = this.GetBooleanValue(reader);
            break;
          case "pgBorders":
            this.ParsePageBorders(reader, entity as WSection);
            break;
          case "docGrid":
            this.ParseGrid(reader, entity as WSection);
            break;
          case "vAlign":
            this.ParseVertAlign(reader, entity as WSection);
            break;
          case "lnNumType":
            this.m_doc.SetTriggerElement(ref this.m_doc.m_notSupportedElementFlag, 18);
            this.ParseLineNumbering(reader, entity as WSection);
            if ((double) (entity as WSection).PageSetup.LineNumberingDistanceFromText == 0.0)
            {
              (entity as WSection).PageSetup.LineNumberingDistanceFromText = 18f;
              break;
            }
            break;
          case "footnotePr":
            this.ParseFootnoteProp(reader, true, entity as WSection);
            break;
          case "endnotePr":
            this.ParseFootnoteProp(reader, false, entity as WSection);
            break;
          case "textDirection":
            this.ParseTextDirection(reader, (IEntity) (entity as WSection));
            break;
          case "rtlGutter":
            if (this.GetBooleanValue(reader))
            {
              (entity as WSection).PageSetup.Margins.Right += this.m_gutter;
              break;
            }
            break;
          case "pgNumType":
            this.ParsePageNumberType(reader, entity as WSection);
            break;
          case "bidi":
            (entity as WSection).PageSetup.Bidi = this.GetBooleanValue(reader);
            break;
          case "formProt":
            (entity as WSection).ProtectForm = this.GetBooleanValue(reader);
            break;
          case "paperSrc":
            string attribute3 = reader.GetAttribute("first", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            float result = float.MaxValue;
            if (!string.IsNullOrEmpty(attribute3))
              (entity as WSection).PageSetup.FirstPageTray = (PrinterPaperTray) Math.Floor(float.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (double) result : 0.0);
            string attribute4 = reader.GetAttribute("other", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (!string.IsNullOrEmpty(attribute4))
            {
              (entity as WSection).PageSetup.OtherPagesTray = (PrinterPaperTray) Math.Floor(float.TryParse(attribute4, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (double) result : 0.0);
              break;
            }
            break;
          case "sectPrChange":
            this.UpdateRevAuthorInformation(reader, (WCharacterFormat) null);
            this.ParseChangeSectionProperties(reader, entity as WSection);
            this.m_doc.SectionFormatChangeRevision(entity as WSection);
            break;
          default:
            if (this.IsWord2003ML)
            {
              switch (reader.LocalName)
              {
                case "hdr":
                case "ftr":
                  bool isHeader2 = reader.LocalName == "hdr";
                  string attribute5 = reader.GetAttribute("type", "http://schemas.microsoft.com/office/word/2003/wordml");
                  this.ParseHeaderFooter(this.m_doc.LastSection.HeadersFooters, reader, attribute5, isHeader2);
                  break;
                case "textFlow":
                  this.Parse2003TextDirection(reader, (IEntity) (entity as WSection));
                  break;
              }
            }
            else
              break;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseChangeSectionProperties(XmlReader reader, WSection section)
  {
    section.SectionFormat.IsFormattingChange = true;
    section.PageSetup.IsFormattingChange = true;
    section.PageSetup.PageNumbers.IsFormattingChange = true;
    section.PageSetup.Margins.IsFormattingChange = true;
    section.PageSetup.Borders.IsFormattingChange = true;
    section.Document.SetDefaultSectionFormatting(section);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    if (reader.LocalName == "sectPrChange" && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.ParseSectionProperties(reader, (IEntity) section);
    section.SectionFormat.FormatChangeAuthorName = this.m_revAuthorName;
    section.SectionFormat.FormatChangeDateTime = this.m_revDateTime;
    section.SectionFormat.IsFormattingChange = false;
    section.PageSetup.IsFormattingChange = false;
    section.PageSetup.PageNumbers.IsFormattingChange = false;
    section.PageSetup.Margins.IsFormattingChange = false;
    section.PageSetup.Borders.IsFormattingChange = false;
    section.SectionFormat.IsChangedFormat = true;
  }

  private void ParseHeaderFooter(
    WHeadersFooters headerfooter,
    XmlReader reader,
    string type,
    bool isHeader)
  {
    IEntity entity = (IEntity) null;
    switch (type)
    {
      case "odd":
        entity = !isHeader ? (IEntity) headerfooter.OddFooter : (IEntity) headerfooter.OddHeader;
        break;
      case "first":
        entity = !isHeader ? (IEntity) headerfooter.FirstPageFooter : (IEntity) headerfooter.FirstPageHeader;
        break;
      case "even":
        entity = !isHeader ? (IEntity) headerfooter.EvenFooter : (IEntity) headerfooter.EvenHeader;
        break;
    }
    if (entity == null)
      return;
    int content = (int) reader.MoveToContent();
    this.ParseBody(reader, entity, false, false, false);
  }

  private void ParseHeaderFooter(
    WHeadersFooters headerfooter,
    Part part,
    string type,
    bool isHeader)
  {
    IEntity entity = (IEntity) null;
    XmlReader reader = UtilityMethods.CreateReader(part.DataStream);
    this.m_doc.SetTriggerElement(ref this.m_doc.m_supportedElementFlag_1, isHeader ? 22 : 20);
    switch (type)
    {
      case "default":
        entity = !isHeader ? (IEntity) headerfooter.OddFooter : (IEntity) headerfooter.OddHeader;
        break;
      case "first":
        entity = !isHeader ? (IEntity) headerfooter.FirstPageFooter : (IEntity) headerfooter.FirstPageHeader;
        break;
      case "even":
        entity = !isHeader ? (IEntity) headerfooter.EvenFooter : (IEntity) headerfooter.EvenHeader;
        break;
    }
    if (entity == null)
      return;
    int content = (int) reader.MoveToContent();
    this.ParseBody(reader, entity, false, false, false);
  }

  private void ParseFootnoteProp(XmlReader reader, bool isFootnote, WSection section)
  {
    if (reader.IsEmptyElement)
      return;
    string localName1 = reader.LocalName;
    string localName2 = reader.LocalName;
    reader.Read();
    if (localName1 == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName2)
    {
      switch (reader.LocalName)
      {
        case "pos":
          string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
          if (!string.IsNullOrEmpty(attribute) && (this.IsWord2003ML ? (attribute == "beneath-text" ? 1 : 0) : (attribute == "beneathText" ? 1 : 0)) != 0)
          {
            section.PageSetup.FootnotePosition = FootnotePosition.PrintImmediatelyBeneathText;
            break;
          }
          break;
        case "numFmt":
          if (this.IsWord2003ML)
          {
            this.Parse2003FootnoteNumFormat(reader, isFootnote, section);
            break;
          }
          this.ParseFootnoteNumFormat(reader, isFootnote, section);
          break;
        case "numRestart":
          this.ParseFootnoteNumRestart(reader, isFootnote, section);
          break;
        case "numStart":
          this.ParseFootnoteNumberStart(reader, isFootnote, section);
          break;
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseFootnoteNumberStart(XmlReader reader, bool isFootnote, WSection section)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute == null)
      return;
    float result = 0.0f;
    if (isFootnote)
    {
      if (!float.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
        return;
      section.PageSetup.InitialFootnoteNumber = (int) result;
    }
    else
    {
      if (!float.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
        return;
      section.PageSetup.InitialEndnoteNumber = (int) result;
    }
  }

  private void Parse2003FootnoteNumFormat(XmlReader reader, bool isFootnote, WSection section)
  {
    string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "decimal":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
        break;
      case "lower-letter":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
        break;
      case "upper-letter":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
        break;
      case "lower-roman":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
        break;
      case "upper-roman":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
        break;
    }
  }

  private void ParseFootnoteNumFormat(XmlReader reader, bool isFootnote, WSection section)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "decimal":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
        break;
      case "lowerLetter":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
        break;
      case "upperLetter":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
        break;
      case "lowerRoman":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
        break;
      case "upperRoman":
        if (isFootnote)
        {
          section.PageSetup.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
          break;
        }
        section.PageSetup.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
        break;
    }
  }

  private void ParseFootnoteNumRestart(XmlReader reader, bool isFootnote, WSection section)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute == null)
      return;
    if ((this.IsWord2003ML ? (attribute == "each-page" ? 1 : 0) : (attribute == "eachPage" ? 1 : 0)) != 0)
    {
      section.PageSetup.RestartIndexForFootnotes = FootnoteRestartIndex.RestartForEachPage;
    }
    else
    {
      if ((this.IsWord2003ML ? (attribute == "each-sect" ? 1 : 0) : (attribute == "eachSect" ? 1 : 0)) == 0)
        return;
      if (isFootnote)
        section.PageSetup.RestartIndexForFootnotes = FootnoteRestartIndex.RestartForEachSection;
      else
        section.PageSetup.RestartIndexForEndnote = EndnoteRestartIndex.RestartForEachSection;
    }
  }

  private void ParseFootnoteProp(XmlReader reader, bool isFootnote)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    string str = localName;
    this.SkipWhitespaces(reader);
    while (reader.LocalName != str)
    {
      switch (reader.LocalName)
      {
        case "pos":
          string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
          if (!string.IsNullOrEmpty(attribute) && (this.IsWord2003ML ? (attribute == "beneath-text" ? 1 : 0) : (attribute == "beneathText" ? 1 : 0)) != 0)
          {
            this.m_doc.FootnotePosition = FootnotePosition.PrintImmediatelyBeneathText;
            break;
          }
          if (!isFootnote && !string.IsNullOrEmpty(attribute) && (this.IsWord2003ML ? (attribute == "sect-end" ? 1 : 0) : (attribute == "sectEnd" ? 1 : 0)) != 0)
          {
            this.m_doc.EndnotePosition = EndnotePosition.DisplayEndOfSection;
            break;
          }
          break;
        case "numFmt":
          if (this.IsWord2003ML)
          {
            this.Parse2003FootnoteNumFormat(reader, isFootnote);
            break;
          }
          this.ParseFootnoteNumFormat(reader, isFootnote);
          break;
        case "numRestart":
          this.ParseFootnoteNumRestart(reader, isFootnote);
          break;
        case "numStart":
          this.ParseFootnoteNumberStart(reader, isFootnote);
          break;
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParseFootnoteNumberStart(XmlReader reader, bool isFootnote)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute == null)
      return;
    float result = 0.0f;
    if (isFootnote)
    {
      if (!float.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
        return;
      this.m_doc.InitialFootnoteNumber = (int) result;
    }
    else
    {
      if (!float.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
        return;
      this.m_doc.InitialEndnoteNumber = (int) result;
    }
  }

  private void Parse2003FootnoteNumFormat(XmlReader reader, bool isFootnote)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "decimal":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
        break;
      case "lower-letter":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
        break;
      case "upper-letter":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
        break;
      case "lower-roman":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
        break;
      case "upper-roman":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
        break;
    }
  }

  private void ParseFootnoteNumFormat(XmlReader reader, bool isFootnote)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "decimal":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.Arabic;
        break;
      case "lowerLetter":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseLetter;
        break;
      case "upperLetter":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseLetter;
        break;
      case "lowerRoman":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.LowerCaseRoman;
        break;
      case "upperRoman":
        if (isFootnote)
        {
          this.m_doc.FootnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
          break;
        }
        this.m_doc.EndnoteNumberFormat = FootEndNoteNumberFormat.UpperCaseRoman;
        break;
    }
  }

  private void ParseFootnoteNumRestart(XmlReader reader, bool isFootnote)
  {
    switch (reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
    {
      case "eachPage":
        this.m_doc.RestartIndexForFootnotes = FootnoteRestartIndex.RestartForEachPage;
        break;
      case "eachSect":
        if (isFootnote)
        {
          this.m_doc.RestartIndexForFootnotes = FootnoteRestartIndex.RestartForEachSection;
          break;
        }
        this.m_doc.RestartIndexForEndnote = EndnoteRestartIndex.RestartForEachSection;
        break;
    }
  }

  private void Parse2003PageNumberStyle(WSection section, string numberType)
  {
    switch (numberType)
    {
      case "lower-roman":
        section.PageSetup.PageNumberStyle = PageNumberStyle.RomanLower;
        break;
      case "upper-roman":
        section.PageSetup.PageNumberStyle = PageNumberStyle.RomanUpper;
        break;
      case "upper-letter":
        section.PageSetup.PageNumberStyle = PageNumberStyle.LetterUpper;
        break;
      case "lower-letter":
        section.PageSetup.PageNumberStyle = PageNumberStyle.LetterLower;
        break;
      case "decimal":
        section.PageSetup.PageNumberStyle = PageNumberStyle.Arabic;
        break;
    }
  }

  private void Parse2003ChapterNumberSeparator(WSection section, string chapterNumberSeprator)
  {
    switch (chapterNumberSeprator)
    {
      case "colon":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Colon;
        break;
      case "hyphen":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Hyphen;
        break;
      case "period":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Period;
        break;
      case "em-dash":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.EmDash;
        break;
      case "en-dash":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.EnDash;
        break;
    }
  }

  private void ParseChapterNumberSeparator(WSection section, string chapterNumberSeprator)
  {
    if (section.SectionFormat.IsFormattingChange)
      section.PageSetup.PageNumbers.IsFormattingChange = true;
    switch (chapterNumberSeprator)
    {
      case "colon":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Colon;
        break;
      case "hyphen":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Hyphen;
        break;
      case "period":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.Period;
        break;
      case "emDash":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.EmDash;
        break;
      case "enDash":
        section.PageSetup.PageNumbers.ChapterPageSeparator = ChapterPageSeparatorType.EnDash;
        break;
    }
  }

  private void ParsePageNumberStyle(WSection section, string numberType)
  {
    if (section.SectionFormat.IsFormattingChange)
      section.PageSetup.PageNumbers.IsFormattingChange = true;
    switch (numberType)
    {
      case "decimal":
        section.PageSetup.PageNumberStyle = PageNumberStyle.Arabic;
        break;
      case "lowerRoman":
        section.PageSetup.PageNumberStyle = PageNumberStyle.RomanLower;
        break;
      case "upperRoman":
        section.PageSetup.PageNumberStyle = PageNumberStyle.RomanUpper;
        break;
      case "lowerLetter":
        section.PageSetup.PageNumberStyle = PageNumberStyle.LetterLower;
        break;
      case "upperLetter":
        section.PageSetup.PageNumberStyle = PageNumberStyle.LetterUpper;
        break;
    }
  }

  private void ParsePageNumberType(XmlReader reader, WSection section)
  {
    string attribute1 = reader.GetAttribute("fmt", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
    {
      if (this.IsWord2003ML)
        this.Parse2003PageNumberStyle(section, attribute1);
      else
        this.ParsePageNumberStyle(section, attribute1);
    }
    string attribute2 = reader.GetAttribute("start", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
    {
      section.PageSetup.RestartPageNumbering = true;
      section.PageSetup.PageStartingNumber = this.ParseIntegerValue(attribute2);
    }
    string name1 = this.IsWord2003ML ? "chap-style" : "chapStyle";
    string attribute3 = reader.GetAttribute(name1, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
      section.PageSetup.PageNumbers.HeadingLevelForChapter = (HeadingLevel) this.ParseIntegerValue(attribute3);
    string name2 = this.IsWord2003ML ? "chap-sep" : "chapSep";
    string attribute4 = reader.GetAttribute(name2, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute4))
      return;
    if (this.IsWord2003ML)
      this.Parse2003ChapterNumberSeparator(section, attribute4);
    else
      this.ParseChapterNumberSeparator(section, attribute4);
  }

  private void Parse2003TextDirection(XmlReader reader, IEntity ent)
  {
    string attribute = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "lr-tb":
        (ent as WSection).TextDirection = DocTextDirection.LeftToRight;
        break;
      case "tb-rl":
        (ent as WSection).TextDirection = DocTextDirection.TopToBottom;
        break;
      case "bt-lr":
        (ent as WSection).TextDirection = DocTextDirection.LeftToRightRotated;
        break;
      case "lr-tb-v":
        (ent as WSection).TextDirection = DocTextDirection.RightToLeft;
        break;
      case "tb-rl-v":
        (ent as WSection).TextDirection = DocTextDirection.RightToLeftRotated;
        break;
    }
  }

  private void ParseTextDirection(XmlReader reader, IEntity ent)
  {
    if (this.IsWord2003ML)
      return;
    string attribute = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (attribute == null)
      return;
    switch (attribute)
    {
      case "tb":
      case "lrTb":
        (ent as WSection).TextDirection = DocTextDirection.LeftToRight;
        break;
      case "rl":
      case "tbRl":
        (ent as WSection).TextDirection = DocTextDirection.TopToBottom;
        break;
      case "lr":
      case "btLr":
        (ent as WSection).TextDirection = DocTextDirection.LeftToRightRotated;
        break;
      case "tbV":
      case "lrTbV":
        (ent as WSection).TextDirection = DocTextDirection.RightToLeft;
        break;
      case "rlV":
      case "tbRlV":
        (ent as WSection).TextDirection = DocTextDirection.RightToLeftRotated;
        break;
    }
  }

  private void ParseLineNumbering(XmlReader reader, WSection section)
  {
    string name = this.IsWord2003ML ? "count-by" : "countBy";
    WPageSetup pageSetup = section.PageSetup;
    string attribute1 = reader.GetAttribute("distance", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (reader.AttributeCount == 1 && !string.IsNullOrEmpty(attribute1))
      return;
    if (reader.HasAttributes && pageSetup.LineNumberingMode == LineNumberingMode.None)
      pageSetup.LineNumberingMode = LineNumberingMode.RestartPage;
    float result = 0.0f;
    string attribute2 = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      pageSetup.SetPageSetupProperty("LineNumberingStep", (object) (float.TryParse(attribute2, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? (int) result : 0));
    string attribute3 = reader.GetAttribute("start", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3) && new Regex("^.*\\d+(\\.*\\d+)*$").IsMatch(attribute3))
    {
      int numericValue = (int) this.GetNumericValue(attribute3);
      pageSetup.SetPageSetupProperty("LineNumberingStartValue", (object) (numericValue != -1 ? numericValue + 1 : numericValue));
    }
    string attribute4 = reader.GetAttribute("distance", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute4))
      pageSetup.SetPageSetupProperty("LineNumberingDistanceFromText", (object) this.GetFloatValue(attribute4, "distance"));
    string attribute5 = reader.GetAttribute("restart", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute5))
      return;
    if (this.IsWord2003ML)
    {
      switch (attribute5)
      {
        case "new-page":
          pageSetup.SetPageSetupProperty("LineNumberingMode", (object) LineNumberingMode.RestartPage);
          break;
        case "new-section":
          pageSetup.SetPageSetupProperty("LineNumberingMode", (object) LineNumberingMode.RestartSection);
          break;
        case "continuous":
          pageSetup.SetPageSetupProperty("LineNumberingMode", (object) LineNumberingMode.Continuous);
          break;
      }
    }
    else
    {
      switch (attribute5)
      {
        case "newPage":
          pageSetup.SetPageSetupProperty("LineNumberingMode", (object) LineNumberingMode.RestartPage);
          break;
        case "newSection":
          pageSetup.SetPageSetupProperty("LineNumberingMode", (object) LineNumberingMode.RestartSection);
          break;
        case "continuous":
          pageSetup.SetPageSetupProperty("LineNumberingMode", (object) LineNumberingMode.Continuous);
          break;
      }
    }
  }

  private void ParseVertAlign(XmlReader reader, WSection section)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute))
      return;
    switch (attribute)
    {
      case "top":
        section.PageSetup.VerticalAlignment = PageAlignment.Top;
        break;
      case "center":
        section.PageSetup.VerticalAlignment = PageAlignment.Middle;
        break;
      case "both":
        section.PageSetup.VerticalAlignment = PageAlignment.Justified;
        break;
      case "bottom":
        section.PageSetup.VerticalAlignment = PageAlignment.Bottom;
        break;
    }
  }

  private void ParseGrid(XmlReader reader, WSection section)
  {
    string str = this.IsWord2003ML ? "line-pitch" : "linePitch";
    string attribute1 = reader.GetAttribute(str, this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (string.IsNullOrEmpty(attribute1))
      return;
    section.PageSetup.LinePitch = this.GetFloatValue(attribute1, str);
    string attribute2 = reader.GetAttribute("type", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
    if (string.IsNullOrEmpty(attribute2))
      return;
    if (this.IsWord2003ML)
    {
      switch (attribute2)
      {
        case "lines-and-chars":
          section.PageSetup.PitchType = GridPitchType.CharsAndLine;
          break;
        case "snap-to-chars":
          section.PageSetup.PitchType = GridPitchType.SnapToChars;
          break;
        case "lines":
          section.PageSetup.PitchType = GridPitchType.LinesOnly;
          break;
      }
    }
    else
    {
      switch (attribute2)
      {
        case "lines":
          section.PageSetup.PitchType = GridPitchType.LinesOnly;
          break;
        case "linesAndChars":
          section.PageSetup.PitchType = GridPitchType.CharsAndLine;
          break;
        case "snapToChars":
          section.PageSetup.PitchType = GridPitchType.SnapToChars;
          break;
      }
    }
  }

  private void ParsePageBorders(XmlReader reader, WSection section)
  {
    string name1 = this.IsWord2003ML ? "offset-from" : "offsetFrom";
    string name2 = this.IsWord2003ML ? "z-order" : "zOrder";
    string attribute1 = reader.GetAttribute(name1, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1))
      section.PageSetup.PageBorderOffsetFrom = attribute1 == "page" ? PageBorderOffsetFrom.PageEdge : PageBorderOffsetFrom.Text;
    if (reader.GetAttribute(name2, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace) == "back")
      section.PageSetup.IsFrontPageBorder = false;
    string attribute2 = reader.GetAttribute("display", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
    {
      if ((this.IsWord2003ML ? (attribute2 == "first-page" ? 1 : 0) : (attribute2 == "firstPage" ? 1 : 0)) != 0)
        section.PageSetup.PageBordersApplyType = PageBordersApplyType.FirstPage;
      else if ((this.IsWord2003ML ? (attribute2 == "not-first-page" ? 1 : 0) : (attribute2 == "notFirstPage" ? 1 : 0)) != 0)
        section.PageSetup.PageBordersApplyType = PageBordersApplyType.AllExceptFirstPage;
    }
    this.ParseBorders(reader, (IEntity) section, (Borders) null);
  }

  private void ParseColumns(XmlReader reader, WSection section)
  {
    string attribute1 = reader.GetAttribute("sep", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1) && attribute1 == "1")
      section.PageSetup.DrawLinesBetweenCols = true;
    int result1 = 1;
    string attribute2 = reader.GetAttribute("num", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      int.TryParse(attribute2, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result1);
    section.PageSetup.NumberOfColumns = result1;
    string attribute3 = reader.GetAttribute("space", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
    {
      float result2 = 0.0f;
      float.TryParse(attribute3, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2);
      section.PageSetup.ColumnSpace = result2;
    }
    Syncfusion.DocIO.DLS.ColumnCollection columnCollection = new Syncfusion.DocIO.DLS.ColumnCollection(section);
    if (section.SectionFormat.IsFormattingChange)
    {
      for (int index = 0; index < section.Columns.Count; ++index)
        columnCollection.Add(section.Columns[index]);
    }
    if (section.Columns.Count > 0)
      section.Columns.InnerList.Clear();
    if (!this.GetBooleanValue(reader))
    {
      section.Columns.OwnerSection.PageSetup.EqualColumnWidth = false;
      this.ParseColumn(reader, section, result1);
    }
    else
    {
      section.Columns.OwnerSection.PageSetup.EqualColumnWidth = true;
      this.ParseEqualColumns(reader, section, result1);
    }
    if (columnCollection.Count <= 0)
      return;
    section.SectionFormat.SectFormattingColumnCollection = new Syncfusion.DocIO.DLS.ColumnCollection(section);
    for (int index = 0; index < section.Columns.Count; ++index)
      section.SectionFormat.SectFormattingColumnCollection.Add(section.Columns[index]);
    if (section.Columns.Count > 0)
      section.Columns.InnerList.Clear();
    for (int index = 0; index < columnCollection.Count; ++index)
      section.Columns.Add(columnCollection[index]);
    columnCollection.Close();
  }

  private void ParseEqualColumns(XmlReader reader, WSection section, int num)
  {
    float num1 = section.PageSetup.PageSize.Width * 20f;
    float num2 = section.PageSetup.Margins.Left * 20f;
    float num3 = section.PageSetup.Margins.Right * 20f;
    float result = 0.0f;
    string attribute = reader.GetAttribute("space", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute))
    {
      if (this.IsStrict)
        result = this.ParseFloatValue(attribute);
      else
        float.TryParse(attribute, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    }
    float num4 = (float) ((double) num1 - (double) num2 - (double) num3 - (this.IsStrict ? (double) result * 20.0 : (double) result * (double) (num - 1))) / (float) num;
    for (int index = 0; index < num; ++index)
    {
      Syncfusion.DocIO.DLS.Column column = new Syncfusion.DocIO.DLS.Column((IWordDocument) this.m_doc);
      if (section.SectionFormat.IsFormattingChange)
        column.IsFormattingChange = true;
      column.Space = this.IsStrict ? result : result / 20f;
      column.Width = num4 / 20f;
      section.Columns.Add(column, true);
    }
  }

  private void ParseColumn(XmlReader reader, WSection section, int num)
  {
    string localName = reader.LocalName;
    reader.Read();
    this.SkipWhitespaces(reader);
    while (reader.LocalName != localName && reader.LocalName == "col")
    {
      switch (reader.LocalName)
      {
        case "col":
          Syncfusion.DocIO.DLS.Column column = new Syncfusion.DocIO.DLS.Column((IWordDocument) this.m_doc);
          if (section.SectionFormat.IsFormattingChange)
            column.IsFormattingChange = true;
          string attribute1 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
          string attribute2 = reader.GetAttribute("space", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
          if (!string.IsNullOrEmpty(attribute2))
          {
            float floatValue = this.GetFloatValue(attribute2, reader.LocalName);
            column.Space = (double) floatValue < 0.0 || (double) floatValue > 1584.0 ? 0.0f : floatValue;
          }
          if (!string.IsNullOrEmpty(attribute1))
          {
            float floatValue = this.GetFloatValue(attribute1, reader.LocalName);
            column.Width = (double) floatValue < 0.0 || (double) floatValue > 1584.0 ? 0.0f : floatValue;
          }
          if (section.Columns.Count < num)
          {
            section.Columns.Add(column, true);
            break;
          }
          break;
      }
      reader.Read();
      this.SkipWhitespaces(reader);
    }
  }

  private void ParsePageMargins(XmlReader reader, WSection section)
  {
    float marginValue1 = this.GetMarginValue(reader, "top");
    float marginValue2 = this.GetMarginValue(reader, "right");
    float marginValue3 = this.GetMarginValue(reader, "bottom");
    float marginValue4 = this.GetMarginValue(reader, "left");
    float marginValue5 = this.GetMarginValue(reader, "footer");
    float marginValue6 = this.GetMarginValue(reader, "header");
    float marginValue7 = this.GetMarginValue(reader, "gutter");
    if (section.SectionFormat.IsFormattingChange)
    {
      section.PageSetup.Margins = new MarginsF();
      section.PageSetup.Margins.SetOldPropertyHashMarginValues(marginValue4, marginValue1, marginValue2, marginValue3, marginValue7);
    }
    else
    {
      section.PageSetup.Margins = new MarginsF(marginValue4, marginValue1, marginValue2, marginValue3);
      section.PageSetup.Margins.Gutter = marginValue7;
    }
    if ((double) marginValue5 != -1.0)
      section.PageSetup.SetPageSetupProperty("FooterDistance", (object) marginValue5);
    if ((double) marginValue6 != -1.0)
      section.PageSetup.SetPageSetupProperty("HeaderDistance", (object) marginValue6);
    this.m_gutter = marginValue7;
  }

  private float GetMarginValue(XmlReader reader, string attributeName)
  {
    int num;
    switch (attributeName)
    {
      case "footer":
      case "header":
        num = 36;
        break;
      case "gutter":
        num = 0;
        break;
      default:
        num = 72;
        break;
    }
    float marginValue = (float) num;
    string attribute = reader.GetAttribute(attributeName, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute != null)
      marginValue = attribute.Trim(ControlChar.SpaceChar) == string.Empty ? 0.0f : this.GetFloatValue(attribute, "pgMar");
    return marginValue;
  }

  private void ParsePageSize(XmlReader reader, WSection section)
  {
    float height = 792f;
    float width = 612f;
    string attribute1 = reader.GetAttribute("h", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute1 != null)
      height = attribute1.Trim(ControlChar.SpaceChar) == string.Empty ? 0.0f : this.GetFloatValue(attribute1, "pgSz");
    string attribute2 = reader.GetAttribute("w", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (attribute2 != null)
      width = attribute2.Trim(ControlChar.SpaceChar) == string.Empty ? 0.0f : this.GetFloatValue(attribute2, "pgSz");
    section.PageSetup.PageSize = new SizeF(width, height);
    string attribute3 = reader.GetAttribute("orient", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    section.PageSetup.Orientation = attribute3 == "landscape" ? PageOrientation.Landscape : PageOrientation.Portrait;
  }

  private float GetPageSize(string value)
  {
    if (value.EndsWith("cm"))
      return this.GetNumericValue(value.Remove(value.IndexOf("cm"), 2)) * 0.39f;
    if (value.EndsWith("mm"))
      return this.GetNumericValue(value.Remove(value.IndexOf("mm"), 2)) * 0.039f;
    return value.EndsWith("pt") ? this.GetNumericValue(value.Remove(value.IndexOf("pt"), 2)) * 0.0139f : (float) Math.Floor((double) this.GetNumericValue(value) / 2.0);
  }

  private void ParseSectionBreakType(WSection section, string sectionBreakType)
  {
    switch (sectionBreakType)
    {
      case "nextColumn":
        section.BreakCode = SectionBreakCode.NewColumn;
        break;
      case "nextPage":
        section.BreakCode = SectionBreakCode.NewPage;
        break;
      case "evenPage":
        section.BreakCode = SectionBreakCode.EvenPage;
        break;
      case "oddPage":
        section.BreakCode = SectionBreakCode.Oddpage;
        break;
      default:
        section.BreakCode = SectionBreakCode.NoBreak;
        break;
    }
  }

  private void Parse2003SectionBreakType(WSection section, string sectionBreakType)
  {
    switch (sectionBreakType)
    {
      case "next-column":
        section.BreakCode = SectionBreakCode.NewColumn;
        break;
      case "next-page":
        section.BreakCode = SectionBreakCode.NewPage;
        break;
      case "even-page":
        section.BreakCode = SectionBreakCode.EvenPage;
        break;
      case "odd-page":
        section.BreakCode = SectionBreakCode.Oddpage;
        break;
      default:
        section.BreakCode = SectionBreakCode.NoBreak;
        break;
    }
  }

  private void ParseSettingsRelations(Stream stream)
  {
    stream.Position = 0L;
    this.ParseRelations(UtilityMethods.CreateReader(stream), this.SettingsRelations);
  }

  private void InitializeCompactSettings()
  {
    if (this.AppVersion == "Word2010" || this.AppVersion == "Word2013" || this.AppVersion == "WordLatest")
    {
      this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.overrideTableStyleFontSizeAndJustification] = false;
      this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.enableOpenTypeFeatures] = false;
      this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.doNotFlipMirrorIndents] = false;
    }
    if (this.AppVersion == "Word2010" || this.AppVersion == "Word2013" || this.AppVersion == "WordLatest")
      this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.differentiateMultirowTableHeader] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseIndentAsNumberingTabStop] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseNormalStyleForList] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.FELineBreak11] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.AllowSpaceOfSameStyleInTable] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WW11IndentRules] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAutofitConstrainedTables] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.AutofitLikeWW11] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.HangulWidthLikeWW11] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontVertAlignCellWithSp] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontBreakConstrainedForcedTables] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontVertAlignInTxbx] = false;
    this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.Word11KerningPairs] = false;
  }

  private void ParseSettings(Stream stream)
  {
    this.InitializeCompactSettings();
    XmlReader reader = UtilityMethods.CreateReader(stream);
    if (reader == null)
      throw new Exception("reader");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "settings")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != "settings")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "zoom":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute1))
            {
              switch (attribute1)
              {
                case "fullPage":
                  this.m_doc.ViewSetup.ZoomType = ZoomType.FullPage;
                  break;
                case "bestFit":
                  this.m_doc.ViewSetup.ZoomType = ZoomType.PageWidth;
                  break;
                case "textFit":
                  this.m_doc.ViewSetup.ZoomType = ZoomType.TextFit;
                  break;
                default:
                  this.m_doc.ViewSetup.ZoomType = ZoomType.None;
                  break;
              }
            }
            string attribute2 = reader.GetAttribute("percent", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute2))
            {
              int result = 0;
              int.TryParse(attribute2, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              this.m_doc.ViewSetup.SetZoomPercentValue(result);
              break;
            }
            break;
          case "gutterAtTop":
            this.m_doc.DOP.GutterAtTop = true;
            break;
          case "bordersDoNotSurroundHeader":
            this.m_doc.BordersSurroundHeader = false;
            break;
          case "bordersDoNotSurroundFooter":
            this.m_doc.BordersSurroundFooter = false;
            break;
          case "defaultTabStop":
            string str = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (str.Trim() == "NaN")
              str = "720";
            if (!string.IsNullOrEmpty(str))
            {
              this.m_doc.DefaultTabWidth = this.GetFloatValue(str, reader.LocalName);
              break;
            }
            break;
          case "mirrorMargins":
            this.m_doc.MultiplePage = MultiplePage.MirrorMargins;
            break;
          case "bookFoldPrinting":
            this.m_doc.MultiplePage = MultiplePage.BookFold;
            break;
          case "bookFoldRevPrinting":
            this.m_doc.MultiplePage = MultiplePage.ReverseBookFold;
            break;
          case "printTwoOnOne":
            this.m_doc.MultiplePage = MultiplePage.TwoPagesPerSheet;
            break;
          case "bookFoldPrintingSheets":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute3))
            {
              int result = 0;
              int.TryParse(attribute3, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              this.m_doc.SheetsPerBooklet = result;
              break;
            }
            break;
          case "proofState":
            if (reader.GetAttribute("spelling", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main") == "clean")
              this.m_doc.DOP.SpellAllDone = true;
            if (reader.GetAttribute("grammar", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main") == "clean")
            {
              this.m_doc.DOP.Dop97.GramAllDone = true;
              break;
            }
            break;
          case "displayBackgroundShape":
            this.m_doc.Settings.DisplayBackgrounds = true;
            break;
          case "doNotDisplayPageBoundaries":
            this.m_doc.DOP.Dop2000.NoMargPgvwSaved = true;
            break;
          case "trackRevisions":
            this.m_doc.TrackChanges = true;
            break;
          case "uiCompat97To2003":
            this.m_doc.Settings.SetCompatibilityModeValue(CompatibilityMode.Word2003);
            break;
          case "hdrShapeDefaults":
          case "rsids":
          case "clrSchemeMapping":
          case "shapeDefaults":
            reader.Skip();
            flag = true;
            break;
          case "themeFontLang":
            this.m_doc.Settings.ThemeFontLanguages = new WCharacterFormat((IWordDocument) this.m_doc);
            this.ParseLanguage(reader, this.m_doc.Settings.ThemeFontLanguages);
            break;
          case "footnotePr":
            this.ParseFootnoteProp(reader, true);
            break;
          case "endnotePr":
            this.ParseFootnoteProp(reader, false);
            break;
          case "evenAndOddHeaders":
            this.m_doc.DifferentOddAndEvenPages = this.GetBoolValue(reader, this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
          case "docVars":
            this.ParseVariables(reader);
            break;
          case "view":
            this.ParseViewType(reader);
            break;
          case "documentProtection":
            this.ParseProtectType(reader);
            break;
          case "compat":
            this.ParseCompatNode(reader);
            break;
          case "compatSetting":
            this.ParseCompatSettingNode(reader);
            break;
          case "autoHyphenation":
            this.m_doc.DOP.AutoHyphen = this.GetBooleanValue(reader);
            break;
          case "consecutiveHyphenLimit":
            string attribute4 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute4))
            {
              int result = 0;
              int.TryParse(attribute4, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              this.m_doc.DOP.ConsecHypLim = result;
              break;
            }
            break;
          case "hyphenationZone":
            string attribute5 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute5))
            {
              int result = 0;
              int.TryParse(attribute5, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              this.m_doc.DOP.DxaHotZ = result;
              break;
            }
            break;
          case "doNotHyphenateCaps":
            this.m_doc.DOP.HyphCapitals = !this.GetBooleanValue(reader);
            break;
          case "attachedTemplate":
            string attribute6 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            if (!string.IsNullOrEmpty(attribute6) && this.SettingsRelations.ContainsKey(attribute6))
            {
              this.m_doc.AssociatedStrings.AttachedTemplate = this.SettingsRelations[attribute6].Value.ToString().Replace("file:///", string.Empty);
              break;
            }
            break;
          case "doNotShadeFormData":
            this.m_doc.DOP.FormFieldShading = !this.GetBooleanValue(reader);
            break;
          case "linkStyles":
            this.m_doc.DOP.LinkStyles = this.GetBooleanValue(reader);
            break;
          case "mailMerge":
            this.ParseMailMergeSettings(reader);
            break;
          case "mathPr":
            MathMLParser mathMlParser = new MathMLParser();
            this.m_doc.Settings.MathProperties = new OfficeMathProperties();
            mathMlParser.ParseMathProperties(reader, this.m_doc.Settings.MathProperties);
            break;
          case "forceUpgrade":
            this.m_doc.Settings.SetCompatibilityModeValue(CompatibilityMode.Word2013);
            break;
          default:
            flag = this.ParseCompatibiltyOption(reader);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseMailMergeSettings(XmlReader reader)
  {
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != "mailMerge")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "mainDocumentType":
            this.ParseMailMergeSettingsMainDocumentType(reader);
            break;
          case "activeRecord":
            string attribute1 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            if (attribute1 != null)
            {
              this.m_doc.MailMerge.Settings.ActiveRecord = this.ParseIntegerValue(attribute1);
              break;
            }
            break;
          case "addressFieldName":
            this.m_doc.MailMerge.Settings.AddressFieldName = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            break;
          case "checkErrors":
            this.ParseMailMergeSettingsCheckErrors(reader);
            break;
          case "connectString":
            this.m_doc.MailMerge.Settings.ConnectString = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            break;
          case "dataSource":
            string attribute2 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            if (attribute2 != null)
            {
              this.m_doc.MailMerge.Settings.DataSource = this.SettingsRelations[attribute2].Value.ToString();
              break;
            }
            break;
          case "dataType":
            this.ParseMailMergeSettingsDataType(reader);
            break;
          case "destination":
            this.ParseMailMergeSettingsDestination(reader);
            break;
          case "doNotSuppressBlankLines":
            this.m_doc.MailMerge.Settings.DoNotSupressBlankLines = this.GetBooleanValue(reader);
            break;
          case "headerSource":
            string attribute3 = reader.GetAttribute("id", this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
            if (attribute3 != null)
            {
              this.m_doc.MailMerge.Settings.HeaderSource = this.SettingsRelations[attribute3].Value.ToString();
              break;
            }
            break;
          case "linkToQuery":
            this.m_doc.MailMerge.Settings.LinkToQuery = this.GetBooleanValue(reader);
            break;
          case "mailAsAttachment":
            this.m_doc.MailMerge.Settings.MailAsAttachment = this.GetBooleanValue(reader);
            break;
          case "mailSubject":
            this.m_doc.MailMerge.Settings.MailSubject = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            break;
          case "query":
            this.m_doc.MailMerge.Settings.Query = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
            break;
          case "viewMergedData":
            this.m_doc.MailMerge.Settings.ViewMergedData = this.GetBooleanValue(reader);
            break;
          case "odso":
            this.m_doc.MailMerge.Settings.ODSOSettings = (Stream) this.ReadSingleNodeIntoStream(reader);
            flag = true;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
    if (!this.m_doc.MailMerge.Settings.ViewMergedData || this.m_doc.MailMerge.Settings.HasKey(0))
      return;
    this.m_doc.MailMerge.Settings.ActiveRecord = 1;
  }

  private void ParseMailMergeSettingsCheckErrors(XmlReader reader)
  {
    switch (reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace))
    {
      case "1":
        this.m_doc.MailMerge.Settings.CheckErrors = MailMergeCheckErrors.Simulate;
        break;
      case "3":
        this.m_doc.MailMerge.Settings.CheckErrors = MailMergeCheckErrors.CollectErrors;
        break;
      default:
        this.m_doc.MailMerge.Settings.CheckErrors = MailMergeCheckErrors.PauseOnError;
        break;
    }
  }

  private void ParseMailMergeSettingsDestination(XmlReader reader)
  {
    switch (reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace))
    {
      case "printer":
        this.m_doc.MailMerge.Settings.Destination = MailMergeDestination.Printer;
        break;
      case "email":
        this.m_doc.MailMerge.Settings.Destination = MailMergeDestination.EMail;
        break;
      case "fax":
        this.m_doc.MailMerge.Settings.Destination = MailMergeDestination.Fax;
        break;
      default:
        this.m_doc.MailMerge.Settings.Destination = MailMergeDestination.NewDocument;
        break;
    }
  }

  private void ParseMailMergeSettingsDataType(XmlReader reader)
  {
    switch (reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace))
    {
      case "textFile":
        this.m_doc.MailMerge.Settings.DataType = MailMergeDataType.TextFile;
        break;
      case "database":
        this.m_doc.MailMerge.Settings.DataType = MailMergeDataType.Database;
        break;
      case "spreadsheet":
        this.m_doc.MailMerge.Settings.DataType = MailMergeDataType.Spreadsheet;
        break;
      case "query":
        this.m_doc.MailMerge.Settings.DataType = MailMergeDataType.Query;
        break;
      case "odbc":
        this.m_doc.MailMerge.Settings.DataType = MailMergeDataType.ODBC;
        break;
      default:
        this.m_doc.MailMerge.Settings.DataType = MailMergeDataType.Native;
        break;
    }
  }

  private void ParseMailMergeSettingsMainDocumentType(XmlReader reader)
  {
    switch (reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace))
    {
      case "catalog":
        this.m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.Catalog;
        break;
      case "envelopes":
        this.m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.Envelopes;
        break;
      case "mailingLabels":
        this.m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.MailingLabels;
        break;
      case "email":
        this.m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.EMail;
        break;
      case "fax":
        this.m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.Fax;
        break;
      default:
        this.m_doc.MailMerge.Settings.MainDocumentType = MailMergeMainDocumentType.FormLetters;
        break;
    }
  }

  private void ParseWebSettings(Stream stream)
  {
    XmlReader reader = UtilityMethods.CreateReader(stream);
    if (reader == null)
      throw new Exception("reader");
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "webSettings")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != "webSettings")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "optimizeForBrowser":
            this.m_doc.Settings.IsOptimizedForBrowser = this.GetBooleanValue(reader);
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseWord2003DocPr(XmlReader reader)
  {
    if (reader == null)
      throw new Exception(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "docPr")
      throw new XmlException("Unexpected xml tag " + reader.LocalName);
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != "docPr")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "view":
            this.ParseViewType(reader);
            break;
          case "zoom":
            string attribute1 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute1))
            {
              switch (attribute1)
              {
                case "full-page":
                  this.m_doc.ViewSetup.ZoomType = ZoomType.FullPage;
                  break;
                case "best-fit":
                  this.m_doc.ViewSetup.ZoomType = ZoomType.PageWidth;
                  break;
                case "text-fit":
                  this.m_doc.ViewSetup.ZoomType = ZoomType.TextFit;
                  break;
                default:
                  this.m_doc.ViewSetup.ZoomType = ZoomType.None;
                  break;
              }
            }
            string attribute2 = reader.GetAttribute("percent", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute2))
            {
              int result = 0;
              int.TryParse(attribute2, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              this.m_doc.ViewSetup.SetZoomPercentValue(result);
              break;
            }
            break;
          case "dontDisplayPageBoundaries":
            this.m_doc.DOP.Dop2000.NoMargPgvwSaved = true;
            break;
          case "displayBackgroundShape":
            this.m_doc.Settings.DisplayBackgrounds = true;
            break;
          case "mirrorMargins":
            this.m_doc.MultiplePage = MultiplePage.MirrorMargins;
            break;
          case "bookFoldPrinting":
            this.m_doc.MultiplePage = MultiplePage.BookFold;
            break;
          case "bookFoldRevPrinting":
            this.m_doc.MultiplePage = MultiplePage.ReverseBookFold;
            break;
          case "printTwoOnOne":
            this.m_doc.MultiplePage = MultiplePage.TwoPagesPerSheet;
            break;
          case "bookFoldPrintingSheets":
            string attribute3 = reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            if (!string.IsNullOrEmpty(attribute3))
            {
              int result = 0;
              int.TryParse(attribute3, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              this.m_doc.SheetsPerBooklet = result;
              break;
            }
            break;
          case "bordersDontSurroundHeader":
            this.m_doc.BordersSurroundHeader = false;
            break;
          case "bordersDontSurroundFooter":
            this.m_doc.BordersSurroundFooter = false;
            break;
          case "gutterAtTop":
            this.m_doc.DOP.GutterAtTop = true;
            break;
          case "proofState":
            if (reader.GetAttribute("spelling", "http://schemas.microsoft.com/office/word/2003/wordml") == "clean")
              this.m_doc.DOP.SpellAllDone = true;
            if (reader.GetAttribute("grammar", "http://schemas.microsoft.com/office/word/2003/wordml") == "clean")
            {
              this.m_doc.DOP.Dop97.GramAllDone = true;
              break;
            }
            break;
          case "attachedTemplate":
            string attribute4 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute4) && this.SettingsRelations.ContainsKey(attribute4))
            {
              this.m_doc.AssociatedStrings.AttachedTemplate = this.SettingsRelations[attribute4].Value.ToString().Replace("file:///", string.Empty);
              break;
            }
            break;
          case "linkStyles":
            this.m_doc.DOP.LinkStyles = this.GetBooleanValue(reader);
            break;
          case "trackRevisions":
            this.m_doc.TrackChanges = true;
            break;
          case "documentProtection":
            this.ParseProtectType(reader);
            break;
          case "defaultTabStop":
            string str = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (str.Trim() == "NaN")
              str = "720";
            if (!string.IsNullOrEmpty(str))
            {
              this.m_doc.DefaultTabWidth = this.GetFloatValue(str, reader.LocalName);
              break;
            }
            break;
          case "autoHyphenation":
            this.m_doc.DOP.AutoHyphen = this.GetBooleanValue(reader);
            break;
          case "consecutiveHyphenLimit":
            string attribute5 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute5))
            {
              int result = 0;
              int.TryParse(attribute5, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              this.m_doc.DOP.ConsecHypLim = result;
              break;
            }
            break;
          case "hyphenationZone":
            string attribute6 = reader.GetAttribute("val", "http://schemas.microsoft.com/office/word/2003/wordml");
            if (!string.IsNullOrEmpty(attribute6))
            {
              int result = 0;
              int.TryParse(attribute6, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result);
              this.m_doc.DOP.DxaHotZ = result;
              break;
            }
            break;
          case "doNotHyphenateCaps":
            this.m_doc.DOP.HyphCapitals = !this.GetBooleanValue(reader);
            break;
          case "evenAndOddHeaders":
            this.m_doc.DifferentOddAndEvenPages = this.GetBoolValue(reader, this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main");
            break;
          case "hdrShapeDefaults":
            reader.Skip();
            flag = true;
            break;
          case "compat":
            this.ParseWord2003CompatNode(reader);
            break;
          case "docVars":
            this.ParseVariables(reader);
            break;
          default:
            reader.Skip();
            flag = true;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private bool ParseCompatibiltyOption(XmlReader reader)
  {
    switch (reader.LocalName)
    {
      case "useSingleBorderforContiguousCells":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.OrigWordTableRules] = this.GetBooleanValue(reader);
        break;
      case "wpJustification":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WPJust] = this.GetBooleanValue(reader);
        break;
      case "noTabHangInd":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoTabForInd] = this.GetBooleanValue(reader);
        break;
      case "noLeading":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoExtLeading] = this.GetBooleanValue(reader);
        break;
      case "spaceForUL":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontMakeSpaceForUL] = !this.GetBooleanValue(reader);
        break;
      case "noColumnBalance":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoColumnBalance] = this.GetBooleanValue(reader);
        break;
      case "balanceSingleByteDoubleByteWidth":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DntBlnSbDbWid] = !this.GetBooleanValue(reader);
        break;
      case "noExtraLineSpacing":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExactOnTop] = this.GetBooleanValue(reader);
        break;
      case "doNotLeaveBackslashAlone":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.LeaveBackslashAlone] = !this.GetBooleanValue(reader);
        break;
      case "ulTrailSpace":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DntULTrlSpc] = !this.GetBooleanValue(reader);
        break;
      case "doNotExpandShiftReturn":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExpShRtn] = !this.GetBooleanValue(reader);
        break;
      case "spacingInWholePoints":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.TruncDxaExpand] = this.GetBooleanValue(reader);
        break;
      case "lineWrapLikeWord6":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.LineWrapLikeWord6] = this.GetBooleanValue(reader);
        break;
      case "printBodyTextBeforeHeader":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.PrintBodyBeforeHdr] = this.GetBooleanValue(reader);
        break;
      case "printColBlack":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.MapPrintTextColor] = this.GetBooleanValue(reader);
        break;
      case "wpSpaceWidth":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WPSpace] = this.GetBooleanValue(reader);
        break;
      case "showBreaksInFrames":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ShowBreaksInFrames] = this.GetBooleanValue(reader);
        break;
      case "subFontBySize":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SubOnSize] = this.GetBooleanValue(reader);
        break;
      case "suppressBottomSpacing":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExtraAfter] = this.GetBooleanValue(reader);
        break;
      case "suppressTopSpacing":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressTopSpacing] = this.GetBooleanValue(reader);
        break;
      case "suppressSpacingAtTopOfPage":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressTopSpacingMac5] = this.GetBooleanValue(reader);
        break;
      case "suppressTopSpacingWP":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.F2ptExtLeadingOnly] = this.GetBooleanValue(reader);
        break;
      case "suppressSpBfAfterPgBrk":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressSpBfAfterPgBrk] = this.GetBooleanValue(reader);
        break;
      case "swapBordersFacingPages":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SwapBordersFacingPgs] = this.GetBooleanValue(reader);
        break;
      case "convMailMergeEsc":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ConvMailMergeEsc] = this.GetBooleanValue(reader);
        break;
      case "truncateFontHeightsLikeWP6":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.TruncFontHeight] = this.GetBooleanValue(reader);
        break;
      case "mwSmallCaps":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.MWSmallCaps] = this.GetBooleanValue(reader);
        break;
      case "usePrinterMetrics":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.PrintMet] = this.GetBooleanValue(reader);
        break;
      case "doNotSuppressParagraphBorders":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WW6BorderRules] = this.GetBooleanValue(reader);
        break;
      case "wrapTrailSpaces":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WrapTrailSpaces] = this.GetBooleanValue(reader);
        break;
      case "footnoteLayoutLikeWW8":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.FtnLayoutLikeWW8] = this.GetBooleanValue(reader);
        break;
      case "shapeLayoutLikeWW8":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SpLayoutLikeWW8] = this.GetBooleanValue(reader);
        break;
      case "alignTablesRowByRow":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.AlignTablesRowByRow] = this.GetBooleanValue(reader);
        break;
      case "forgetLastTabAlignment":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ForgetLastTabAlign] = this.GetBooleanValue(reader);
        break;
      case "adjustLineHeightInTable":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAdjustLineHeightInTable] = !this.GetBooleanValue(reader);
        break;
      case "autoSpaceLikeWord95":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseAutospaceForFullWidthAlpha] = this.GetBooleanValue(reader);
        break;
      case "noSpaceRaiseLower":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoSpaceRaiseLower] = this.GetBooleanValue(reader);
        break;
      case "doNotUseHTMLParagraphAutoSpacing":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseHTMLParagraphAutoSpacing] = this.GetBooleanValue(reader);
        break;
      case "layoutRawTableWidth":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.LayoutRawTableWidth] = this.GetBooleanValue(reader);
        break;
      case "layoutTableRowsApart":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.LayoutTableRowsApart] = this.GetBooleanValue(reader);
        break;
      case "useWord97LineBreakRules":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseWord97LineBreakingRules] = this.GetBooleanValue(reader);
        break;
      case "doNotBreakWrappedTables":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontBreakWrappedTables] = this.GetBooleanValue(reader);
        break;
      case "doNotSnapToGridInCell":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontSnapToGridInCell] = this.GetBooleanValue(reader);
        break;
      case "selectFldWithFirstOrLastChar":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAllowFieldEndSelect] = this.GetBooleanValue(reader);
        break;
      case "applyBreakingRules":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ApplyBreakingRules] = this.GetBooleanValue(reader);
        break;
      case "doNotWrapTextWithPunct":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontWrapTextWithPunct] = this.GetBooleanValue(reader);
        break;
      case "doNotUseEastAsianBreakRules":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseAsianBreakRules] = this.GetBooleanValue(reader);
        break;
      case "useWord2002TableStyleRules":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseWord2002TableStyleRules] = this.GetBooleanValue(reader);
        break;
      case "growAutofit":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.GrowAutoFit] = this.GetBooleanValue(reader);
        break;
      case "useNormalStyleForList":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseNormalStyleForList] = this.GetBooleanValue(reader);
        break;
      case "doNotUseIndentAsNumberingTabStop":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseIndentAsNumberingTabStop] = this.GetBooleanValue(reader);
        break;
      case "useAltKinsokuLineBreakRules":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.FELineBreak11] = this.GetBooleanValue(reader);
        break;
      case "allowSpaceOfSameStyleInTable":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.AllowSpaceOfSameStyleInTable] = this.GetBooleanValue(reader);
        break;
      case "doNotSuppressIndentation":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WW11IndentRules] = this.GetBooleanValue(reader);
        break;
      case "doNotAutofitConstrainedTables":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAutofitConstrainedTables] = this.GetBooleanValue(reader);
        break;
      case "autofitToFirstFixedWidthCell":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.AutofitLikeWW11] = this.GetBooleanValue(reader);
        break;
      case "underlineTabInNumList":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UnderlineTabInNumList] = this.GetBooleanValue(reader);
        break;
      case "displayHangulFixedWidth":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.HangulWidthLikeWW11] = this.GetBooleanValue(reader);
        break;
      case "splitPgBreakAndParaMark":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SplitPgBreakAndParaMark] = this.GetBooleanValue(reader);
        break;
      case "doNotVertAlignCellWithSp":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontVertAlignCellWithSp] = this.GetBooleanValue(reader);
        break;
      case "doNotBreakConstrainedForcedTable":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontBreakConstrainedForcedTables] = this.GetBooleanValue(reader);
        break;
      case "doNotVertAlignInTxbx":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontVertAlignInTxbx] = this.GetBooleanValue(reader);
        break;
      case "useAnsiKerningPairs":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.Word11KerningPairs] = this.GetBooleanValue(reader);
        break;
      case "cachedColBalance":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.CachedColBalance] = this.GetBooleanValue(reader);
        break;
      case "compatSetting":
        this.ParseCompatSettingNode(reader);
        break;
      default:
        this.m_doc.DocxProps.Add((Stream) this.ReadSingleNodeIntoStream(reader));
        return true;
    }
    return false;
  }

  private void ParseCompatNode(XmlReader reader)
  {
    if (reader == null)
      throw new Exception(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "compat")
      throw new XmlException("Expected xml tag \"compat\"");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != "compat")
    {
      if (reader.NodeType == XmlNodeType.Element)
      {
        if (!this.ParseCompatibiltyOption(reader))
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseWord2003CompatNode(XmlReader reader)
  {
    if (reader == null)
      throw new Exception(nameof (reader));
    while (reader.NodeType != XmlNodeType.Element)
      reader.Read();
    if (reader.LocalName != "compat")
      throw new XmlException("Expected xml tag \"compat\"");
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != "compat")
    {
      bool flag = false;
      if (reader.NodeType == XmlNodeType.Element)
      {
        switch (reader.LocalName)
        {
          case "origWordTableRules":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.OrigWordTableRules] = this.GetBooleanValue(reader);
            break;
          case "wpJustification":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WPJust] = this.GetBooleanValue(reader);
            break;
          case "noTabHangInd":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoTabForInd] = this.GetBooleanValue(reader);
            break;
          case "noLeading":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoExtLeading] = this.GetBooleanValue(reader);
            break;
          case "spaceForUL":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontMakeSpaceForUL] = !this.GetBooleanValue(reader);
            break;
          case "noColumnBalance":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoColumnBalance] = this.GetBooleanValue(reader);
            break;
          case "balanceSingleByteDoubleByteWidth":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DntBlnSbDbWid] = !this.GetBooleanValue(reader);
            break;
          case "noExtraLineSpacing":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExactOnTop] = this.GetBooleanValue(reader);
            break;
          case "doNotLeaveBackslashAlone":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.LeaveBackslashAlone] = !this.GetBooleanValue(reader);
            break;
          case "ulTrailSpace":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DntULTrlSpc] = !this.GetBooleanValue(reader);
            break;
          case "doNotExpandShiftReturn":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExpShRtn] = !this.GetBooleanValue(reader);
            break;
          case "spacingInWholePoints":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.TruncDxaExpand] = this.GetBooleanValue(reader);
            break;
          case "lineWrapLikeWord6":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.LineWrapLikeWord6] = this.GetBooleanValue(reader);
            break;
          case "printBodyTextBeforeHeader":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.PrintBodyBeforeHdr] = this.GetBooleanValue(reader);
            break;
          case "printColBlack":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.MapPrintTextColor] = this.GetBooleanValue(reader);
            break;
          case "wpSpaceWidth":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WPSpace] = this.GetBooleanValue(reader);
            break;
          case "showBreaksInFrames":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ShowBreaksInFrames] = this.GetBooleanValue(reader);
            break;
          case "subFontBySize":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SubOnSize] = this.GetBooleanValue(reader);
            break;
          case "suppressBottomSpacing":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ExtraAfter] = this.GetBooleanValue(reader);
            break;
          case "suppressTopSpacing":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressTopSpacing] = this.GetBooleanValue(reader);
            break;
          case "suppressTopSpacingMac5":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressTopSpacingMac5] = this.GetBooleanValue(reader);
            break;
          case "suppressTopSpacingWP":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.F2ptExtLeadingOnly] = this.GetBooleanValue(reader);
            break;
          case "suppressSpBfAfterPgBrk":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SuppressSpBfAfterPgBrk] = this.GetBooleanValue(reader);
            break;
          case "swapBordersFacingPages":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SwapBordersFacingPgs] = this.GetBooleanValue(reader);
            break;
          case "convMailMergeEsc":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ConvMailMergeEsc] = this.GetBooleanValue(reader);
            break;
          case "truncateFontHeight":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.TruncFontHeight] = this.GetBooleanValue(reader);
            break;
          case "mwSmallCaps":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.MWSmallCaps] = this.GetBooleanValue(reader);
            break;
          case "usePrinterMetrics":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.PrintMet] = this.GetBooleanValue(reader);
            break;
          case "ww6BorderRules":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WW6BorderRules] = this.GetBooleanValue(reader);
            break;
          case "wrapTrailSpaces":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.WrapTrailSpaces] = this.GetBooleanValue(reader);
            break;
          case "footnoteLayoutLikeWW8":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.FtnLayoutLikeWW8] = this.GetBooleanValue(reader);
            break;
          case "shapeLayoutLikeWW8":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.SpLayoutLikeWW8] = this.GetBooleanValue(reader);
            break;
          case "alignTablesRowByRow":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.AlignTablesRowByRow] = this.GetBooleanValue(reader);
            break;
          case "forgetLastTabAlignment":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ForgetLastTabAlign] = this.GetBooleanValue(reader);
            break;
          case "adjustLineHeightInTable":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAdjustLineHeightInTable] = !this.GetBooleanValue(reader);
            break;
          case "autoSpaceLikeWord95":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseAutospaceForFullWidthAlpha] = this.GetBooleanValue(reader);
            break;
          case "noSpaceRaiseLower":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.NoSpaceRaiseLower] = this.GetBooleanValue(reader);
            break;
          case "doNotUseHTMLParagraphAutoSpacing":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseHTMLParagraphAutoSpacing] = this.GetBooleanValue(reader);
            break;
          case "layoutRawTableWidth":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.LayoutRawTableWidth] = this.GetBooleanValue(reader);
            break;
          case "layoutTableRowsApart":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.LayoutTableRowsApart] = this.GetBooleanValue(reader);
            break;
          case "useWord97LineBreakRules":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseWord97LineBreakingRules] = this.GetBooleanValue(reader);
            break;
          case "breakWrappedTables":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontBreakWrappedTables] = !this.GetBooleanValue(reader);
            break;
          case "snapToGridInCell":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontSnapToGridInCell] = !this.GetBooleanValue(reader);
            break;
          case "dontAllowFieldEndSelect":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontAllowFieldEndSelect] = this.GetBooleanValue(reader);
            break;
          case "applyBreakingRules":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.ApplyBreakingRules] = this.GetBooleanValue(reader);
            break;
          case "wrapTextWithPunct":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontWrapTextWithPunct] = !this.GetBooleanValue(reader);
            break;
          case "useAsianBreakRules":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.DontUseAsianBreakRules] = !this.GetBooleanValue(reader);
            break;
          case "useWord2002TableStyleRules":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.UseWord2002TableStyleRules] = this.GetBooleanValue(reader);
            break;
          case "dontGrowAutofit":
            this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.GrowAutoFit] = !this.GetBooleanValue(reader);
            break;
          default:
            reader.Skip();
            flag = true;
            break;
        }
        if (!flag)
          reader.Read();
      }
      else
        reader.Read();
    }
  }

  private void ParseCompatSettingNode(XmlReader reader)
  {
    switch (reader.GetAttribute("name", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
    {
      case "compatibilityMode":
        this.m_doc.Settings.SetCompatibilityModeValue(this.GetCompatibilityMode(reader));
        break;
      case "overrideTableStyleFontSizeAndJustification":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.overrideTableStyleFontSizeAndJustification] = this.GetBooleanValue(reader);
        break;
      case "enableOpenTypeFeatures":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.enableOpenTypeFeatures] = this.GetBooleanValue(reader);
        break;
      case "doNotFlipMirrorIndents":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.doNotFlipMirrorIndents] = this.GetBooleanValue(reader);
        break;
      case "differentiateMultirowTableHeader":
        this.m_doc.Settings.CompatibilityOptions[CompatibilityOption.differentiateMultirowTableHeader] = this.GetBooleanValue(reader);
        break;
    }
  }

  private void ParseVariables(XmlReader reader)
  {
    if (reader.IsEmptyElement)
      return;
    string localName = reader.LocalName;
    reader.Read();
    if (localName == reader.LocalName && reader.NodeType == XmlNodeType.EndElement)
      return;
    while (reader.LocalName != "docVars")
    {
      string attribute1 = reader.GetAttribute("name", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
      string attribute2 = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
      if (!string.IsNullOrEmpty(attribute1) && !string.IsNullOrEmpty(attribute2))
        this.m_doc.Variables.Items.Add(attribute1, this.ParseString(attribute2));
      reader.Read();
    }
  }

  private string ParseString(string text)
  {
    StringBuilder stringBuilder = new StringBuilder(text);
    int num1;
    for (int startIndex1 = 0; startIndex1 < text.Length; startIndex1 = num1)
    {
      int num2 = text.IndexOf("_x", startIndex1);
      if (num2 != -1)
      {
        int startIndex2 = num2 + 2;
        num1 = text.IndexOf("_", startIndex2);
        if (num1 != -1)
        {
          if (num1 - startIndex2 == 4)
          {
            string s = text.Substring(startIndex2, 4);
            int result;
            if (int.TryParse(s, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture, out result))
              stringBuilder.Replace($"_x{s}_", char.ConvertFromUtf32(result));
          }
        }
        else
          break;
      }
      else
        break;
    }
    return stringBuilder.ToString();
  }

  private void ParseProtectType(XmlReader reader)
  {
    this.m_doc.RestrictFormatting = this.GetBoolValue(reader.GetAttribute("formatting", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace));
    switch (reader.GetAttribute("edit", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace))
    {
      case "comments":
        this.m_doc.ProtectionType = ProtectionType.AllowOnlyComments;
        break;
      case "forms":
        this.m_doc.ProtectionType = ProtectionType.AllowOnlyFormFields;
        break;
      case "trackedChanges":
      case "tracked-changes":
        this.m_doc.ProtectionType = ProtectionType.AllowOnlyRevisions;
        break;
      case "readOnly":
      case "read-only":
        this.m_doc.ProtectionType = ProtectionType.AllowOnlyReading;
        break;
    }
    string attribute1 = reader.GetAttribute("enforcement", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute1) && !(this.m_doc.Enforcement = this.GetBoolValue(attribute1)))
    {
      switch (this.m_doc.ProtectionType)
      {
        case ProtectionType.AllowOnlyRevisions:
          this.m_doc.DOP.LockRev = false;
          break;
        case ProtectionType.AllowOnlyComments:
          this.m_doc.DOP.LockAtn = false;
          break;
        case ProtectionType.AllowOnlyFormFields:
          this.m_doc.DOP.ProtEnabled = false;
          break;
        case ProtectionType.AllowOnlyReading:
          this.m_doc.DOP.LockAtn = false;
          this.m_doc.DOP.Dop2003.TreatLockAtnAsReadOnly = false;
          break;
      }
    }
    string attribute2 = reader.GetAttribute("hash", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute2))
      this.m_doc.Settings.HashValue = attribute2;
    string attribute3 = reader.GetAttribute("salt", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute3))
      this.m_doc.Settings.SaltValue = attribute3;
    string attribute4 = reader.GetAttribute("cryptProviderType", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute4))
      this.m_doc.Settings.CryptProviderTypeValue = attribute4;
    string attribute5 = reader.GetAttribute("cryptAlgorithmClass", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute5))
      this.m_doc.Settings.CryptAlgorithmClassValue = attribute5;
    string attribute6 = reader.GetAttribute("cryptAlgorithmType", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute6))
      this.m_doc.Settings.CryptAlgorithmTypeValue = attribute6;
    string attribute7 = reader.GetAttribute("cryptAlgorithmSid", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (!string.IsNullOrEmpty(attribute7))
      this.m_doc.Settings.CryptAlgorithmSidValue = attribute7;
    string attribute8 = reader.GetAttribute("cryptSpinCount", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute8))
      return;
    this.m_doc.Settings.CryptSpinCountValue = attribute8;
  }

  private void ParseViewType(XmlReader reader)
  {
    string attribute = reader.GetAttribute("val", this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
    if (string.IsNullOrEmpty(attribute))
      return;
    switch (attribute)
    {
      case "web":
        this.m_doc.ViewSetup.DocumentViewType = DocumentViewType.WebLayout;
        break;
      case "outline":
        this.m_doc.ViewSetup.DocumentViewType = DocumentViewType.OutlineLayout;
        break;
    }
  }

  private void AddItem(ParagraphItem item, ParagraphItemCollection paragraphItems)
  {
    paragraphItems.Add((IEntity) item);
  }

  private void AddToParagraph(ParagraphItem item, ParagraphItemCollection paragraphItems)
  {
    this.AddItem(item, paragraphItems);
    this.UpdateCommentItems(item);
    if (!(item is WOleObject))
      return;
    this.AddOleObject(item as WOleObject, paragraphItems);
  }

  private void AddOleObject(WOleObject oleObject, ParagraphItemCollection paragraphItems)
  {
    oleObject.AddFieldCodeText();
    WField field = oleObject.Field;
    WFieldMark wfieldMark1 = new WFieldMark((IWordDocument) this.m_doc);
    wfieldMark1.Type = FieldMarkType.FieldSeparator;
    this.AddToParagraph((ParagraphItem) wfieldMark1, paragraphItems);
    field.FieldSeparator = wfieldMark1;
    this.AddToParagraph((ParagraphItem) oleObject.OlePicture, paragraphItems);
    WFieldMark wfieldMark2 = new WFieldMark((IWordDocument) this.m_doc);
    wfieldMark2.Type = FieldMarkType.FieldEnd;
    this.AddToParagraph((ParagraphItem) wfieldMark2, paragraphItems);
    field.FieldEnd = wfieldMark2;
  }

  private string GetImageName(
    string imageId,
    bool isHeaderFooter,
    bool isPicBullet,
    ref bool isImageRelation)
  {
    Dictionary<string, DictionaryEntry> dictionary = !isHeaderFooter ? (!isPicBullet ? (!this.StartsWithExt(this.m_currentFile, "comments") ? (!this.StartsWithExt(this.m_currentFile, "diagrams") ? (string.IsNullOrEmpty(this.m_currentFile) ? this.m_docRelations : this.GetFileRelations(this.m_currentFile)) : this.GetDiagramFileRelations(this.m_currentFile) ?? this.m_docRelations) : this.GetFileRelations("comments.xml.rels")) : this.GetFileRelations("numbering.xml.rels")) : this.GetFileRelations(this.m_currentFile);
    DictionaryEntry dictionaryEntry = new DictionaryEntry();
    if (dictionary != null && dictionary.ContainsKey(imageId))
      dictionaryEntry = dictionary[imageId];
    if (dictionaryEntry.Key != null && dictionaryEntry.Key.ToString() != (this.IsStrict ? "http://purl.oclc.org/ooxml/officeDocument/relationships/image" : "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"))
      isImageRelation = false;
    return dictionaryEntry.Value == null ? string.Empty : dictionaryEntry.Value.ToString();
  }

  private void LoadImage(WPicture picture, string id, bool isHeaderFooter, bool isPicBullet)
  {
    bool isImageRelation = true;
    string imageName = this.GetImageName(id, isHeaderFooter, isPicBullet, ref isImageRelation);
    if (!isImageRelation)
      return;
    picture.OPictureHRef = imageName;
    if (this.ImageIds.ContainsKey(imageName))
    {
      picture.LoadImage(this.m_doc.Images[this.ImageIds[imageName]]);
      if (picture.ImageRecord == null)
        return;
      ++picture.ImageRecord.OccurenceCount;
    }
    else
    {
      byte[] imageBytes = this.GetImageBytes(imageName);
      if (imageBytes != null && imageBytes.Length > 0)
      {
        picture.LoadImage(imageBytes);
        if (picture.ImageRecord != null)
          this.ImageIds.Add(imageName, picture.ImageRecord.ImageId);
      }
      if (imageBytes != null)
        return;
      Image image = this.DownloadImage(imageName);
      if (id != null && this.m_isExternalHyperlink != null && this.m_docRelations.ContainsKey(id) && this.IsExternalHyperlink.ContainsKey(id) && this.IsExternalHyperlink[id])
        picture.ExternalLink = imageName;
      if (image != null)
        picture.LoadImage(image);
      int num = imageName.LastIndexOf('/');
      string str = imageName.Substring(num + 1, imageName.Length - (num + 1));
      if (image != null || !(str.ToLower() == "null"))
        return;
      Image defaultImage = picture.GetDefaultImage();
      picture.LoadImage(defaultImage);
    }
  }

  private byte[] GetImageBytes(string imageName)
  {
    string partName = this.GetPartName(ref imageName);
    Part part = this.FindPart(partName, imageName);
    byte[] imageBytes = (byte[]) null;
    if (part != null)
    {
      imageBytes = this.GetBytesFrom(part);
      this.ClearParsedImage(imageName, partName);
    }
    return imageBytes;
  }

  private Image GetLinkedImageBytes(string imageId, bool isHeaderFooter, bool isPicBullet)
  {
    Dictionary<string, DictionaryEntry> dictionary = !isHeaderFooter ? (!isPicBullet ? this.m_docRelations : this.GetFileRelations("numbering.xml.rels")) : this.GetFileRelations(this.m_currentFile);
    DictionaryEntry dictionaryEntry = new DictionaryEntry();
    if (dictionary.ContainsKey(imageId))
      dictionaryEntry = dictionary[imageId];
    return dictionaryEntry.Value == null ? (Image) null : this.DownloadImage(dictionaryEntry.Value.ToString());
  }

  private byte[] GetBytesFrom(Part part)
  {
    if (part == null)
      return (byte[]) null;
    int length = (int) part.DataStream.Length;
    byte[] buffer = new byte[length];
    part.DataStream.Position = 0L;
    part.DataStream.Read(buffer, 0, length);
    return buffer;
  }

  private string GetPartName(ref string fileName)
  {
    if (this.StartsWithExt(fileName, "..") && string.IsNullOrEmpty(this.m_currentFile))
      fileName = fileName.Remove(0, 2);
    if (fileName.IndexOf('\\') != -1)
      fileName = fileName.Replace('\\', '/');
    if (fileName.Contains("media") && !this.StartsWithExt(fileName, "/"))
      fileName = fileName.Remove(0, fileName.IndexOf("media"));
    int num = fileName.LastIndexOf('/');
    string partName = string.Empty;
    if (num > 0 && fileName.Substring(num + 1, fileName.Length - (num + 1)).Length > 0)
      partName = fileName.Remove(num + 1);
    else if (this.StartsWithExt(fileName, "/"))
      fileName = fileName.Remove(0, 1);
    if (!string.IsNullOrEmpty(partName))
      fileName = fileName.Replace(partName, (string) null);
    if (this.StartsWithExt(partName, "/"))
      partName = partName.Remove(0, 1);
    else if (!this.StartsWithExt(partName, "word/"))
      partName = "word/" + partName;
    return partName;
  }

  private Part FindPart(string partContainer, string partName)
  {
    partName = partName.Replace(partContainer, string.Empty);
    PartContainer partContainer1 = this.m_doc.DocxPackage.FindPartContainer(partContainer);
    return partContainer1.XmlParts.ContainsKey(partName) ? partContainer1.XmlParts[partName] : (Part) null;
  }

  private Dictionary<string, DictionaryEntry> GetFileRelations(string name)
  {
    string str = this.GetPartName(ref name);
    if (!string.IsNullOrEmpty(str))
      str = str.Replace("word/", (string) null);
    name = str + name;
    if (this.HFRelations.ContainsKey(name))
      return this.HFRelations[name];
    PartContainer partContainer = this.m_doc.DocxPackage.FindPartContainer("word/");
    if (!partContainer.Relations.ContainsKey("word/_rels/" + name) || partContainer.Relations["word/_rels/" + name].DataStream == null)
      return (Dictionary<string, DictionaryEntry>) null;
    Relations relation = partContainer.Relations["word/_rels/" + name];
    relation.DataStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(relation.DataStream);
    Dictionary<string, DictionaryEntry> relations = new Dictionary<string, DictionaryEntry>();
    this.ParseRelations(reader, relations);
    this.HFRelations.Add(name, relations);
    return this.HFRelations[name];
  }

  private Dictionary<string, DictionaryEntry> GetDiagramFileRelations(string name)
  {
    string str = this.GetPartName(ref name);
    if (!string.IsNullOrEmpty(str))
      str = str.Replace("word/diagrams/", (string) null);
    name = str + name;
    if (this.HFRelations.ContainsKey(name))
      return this.HFRelations[name];
    PartContainer partContainer = this.m_doc.DocxPackage.FindPartContainer("word/diagrams/");
    if (!partContainer.Relations.ContainsKey("word/diagrams/_rels/" + name) || partContainer.Relations["word/diagrams/_rels/" + name].DataStream == null)
      return (Dictionary<string, DictionaryEntry>) null;
    Relations relation = partContainer.Relations["word/diagrams/_rels/" + name];
    relation.DataStream.Position = 0L;
    XmlReader reader = UtilityMethods.CreateReader(relation.DataStream);
    Dictionary<string, DictionaryEntry> relations = new Dictionary<string, DictionaryEntry>();
    this.ParseRelations(reader, relations);
    this.HFRelations.Add(name, relations);
    return this.HFRelations[name];
  }

  private float ParseFloatVal(string value)
  {
    if (this.StartsWithExt(value, "."))
      value = "0" + value;
    float result = 0.0f;
    if (value.EndsWith("in"))
    {
      float.TryParse(value.Replace("in", string.Empty), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
      return (float) UnitsConvertor.Instance.ConvertUnits((double) result, PrintUnits.Inch, PrintUnits.Point);
    }
    try
    {
      return Convert.ToSingle(value, (IFormatProvider) CultureInfo.InvariantCulture);
    }
    catch (Exception ex)
    {
    }
    float.TryParse(value, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    return result;
  }

  private bool GetBooleanValue(XmlReader reader)
  {
    bool booleanValue = true;
    if (reader.AttributeCount > 0)
    {
      string name = reader.LocalName == "cols" ? "equalWidth" : "val";
      string attribute = reader.GetAttribute(name, this.IsStrict ? this.m_strictNameSpace : this.m_nameSpace);
      if (attribute == "0" || attribute == "false" || attribute == "off")
        booleanValue = false;
    }
    return booleanValue;
  }

  private CompatibilityMode GetCompatibilityMode(XmlReader reader)
  {
    CompatibilityMode compatibilityMode = CompatibilityMode.Word2007;
    if (reader.AttributeCount > 0)
    {
      switch (reader.GetAttribute("val", this.IsStrict ? "http://purl.oclc.org/ooxml/wordprocessingml/main" : "http://schemas.openxmlformats.org/wordprocessingml/2006/main"))
      {
        case "11":
          compatibilityMode = CompatibilityMode.Word2003;
          break;
        case "12":
          compatibilityMode = CompatibilityMode.Word2007;
          break;
        case "14":
          compatibilityMode = CompatibilityMode.Word2010;
          break;
        case "15":
          compatibilityMode = CompatibilityMode.Word2013;
          break;
      }
    }
    return compatibilityMode;
  }

  private bool GetBooleanValue(XmlReader reader, string nameSpace)
  {
    bool booleanValue = true;
    if (reader.AttributeCount > 0)
    {
      string attribute = reader.GetAttribute("val", nameSpace);
      if (attribute == "0" || attribute == "false" || attribute == "off")
        booleanValue = false;
    }
    return booleanValue;
  }

  private string GetReaderElementValue(XmlReader reader)
  {
    if (!reader.IsEmptyElement)
    {
      string localName = reader.LocalName;
      reader.Read();
      if (!(localName == reader.LocalName) || reader.NodeType != XmlNodeType.EndElement)
      {
        string empty;
        if (reader.NodeType != XmlNodeType.EndElement)
        {
          empty = reader.Value;
          reader.Skip();
        }
        else
          empty = string.Empty;
        reader.Skip();
        return empty;
      }
      reader.Read();
      return string.Empty;
    }
    reader.Read();
    return string.Empty;
  }

  private Color GetColorValue(string color)
  {
    if (color == null || color == "auto")
      return Color.Empty;
    if (this.StartsWithExt(color, "fill darken") || this.StartsWithExt(color, "fill lighten"))
      return this.GetGradientColor(color);
    Color colorValue = this.GetHexColor(color);
    if (colorValue == Color.Empty)
      colorValue = this.GetHtmlColor(color);
    return colorValue;
  }

  private Color GetGradientColor(string color)
  {
    int startIndex = color.IndexOf("(") + 1;
    int num = color.IndexOf(")");
    if (startIndex == -1 || num == -1)
      return Color.White;
    int result = 0;
    int.TryParse(color.Substring(startIndex, num - startIndex), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result);
    int blue;
    int green;
    int red;
    if (this.StartsWithExt(color, "fill darken"))
    {
      green = blue = result;
      red = 0;
    }
    else
    {
      green = blue = (int) byte.MaxValue;
      red = (int) byte.MaxValue - result;
    }
    return Color.FromArgb(red, green, blue);
  }

  private Color GetHexColor(string color)
  {
    color = color.Replace("#", string.Empty);
    if (color.Length == 3)
    {
      color = color.Insert(0, color[0].ToString());
      color = color.Insert(2, color[2].ToString());
      color = color.Insert(4, color[4].ToString());
    }
    else if (color.Length < 6)
    {
      int num = 6 - color.Length;
      for (int index = 0; index < num; ++index)
        color = color.Insert(0, "0");
    }
    for (int index = 0; index < 6; ++index)
    {
      char ch = color[index];
      if ((ch < '0' || ch > '9') && (ch < 'A' || ch > 'F') && (ch < 'a' || ch > 'f'))
        return Color.Empty;
    }
    string s1 = color.Substring(0, 2);
    string s2 = color.Substring(2, 2);
    string s3 = color.Substring(4, 2);
    return Color.FromArgb(int.Parse(s1, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture), int.Parse(s2, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture), int.Parse(s3, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture));
  }

  private Color GetHtmlColor(string color)
  {
    int startIndex = color.IndexOf("[");
    if (startIndex != -1)
    {
      color = color.Remove(startIndex, color.Length - startIndex);
      color = color.Trim();
    }
    try
    {
      return ColorTranslator.FromHtml(color);
    }
    catch
    {
    }
    return Color.Empty;
  }

  private float GetFloatValue(XmlReader reader, string attrName, string attrNS)
  {
    if (attrName == null || attrName.Length == 0)
      throw new ArgumentException("Attribute name must not be null or empty");
    string s = attrNS != null ? reader.GetAttribute(attrName, attrNS) : reader.GetAttribute(attrName);
    if (string.IsNullOrEmpty(s))
      return float.MaxValue;
    return attrName == "beforeLines" || attrName == "afterLines" ? (float) (short) float.Parse(s, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture) / 100f : float.Parse(s, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture) / 20f;
  }

  private MemoryStream ReadSingleNodeIntoStream(XmlReader reader)
  {
    MemoryStream data = new MemoryStream();
    XmlWriter writer = UtilityMethods.CreateWriter((Stream) data, Encoding.UTF8);
    writer.WriteNode(reader, false);
    writer.Flush();
    return data;
  }

  private void SkipWhitespaces(XmlReader reader)
  {
    if (reader.NodeType == XmlNodeType.Element)
      return;
    while (reader.NodeType == XmlNodeType.Whitespace)
      reader.Read();
  }

  internal void Close()
  {
    if (this.m_reader != null)
    {
      this.m_reader.Close();
      this.m_reader = (XmlReader) null;
    }
    this.m_doc = (WordDocument) null;
    if (this.m_linkStyleNames != null)
    {
      this.m_linkStyleNames.Clear();
      this.m_linkStyleNames = (Dictionary<string, string>) null;
    }
    if (this.m_baseStyleNames != null)
    {
      this.m_baseStyleNames.Clear();
      this.m_baseStyleNames = (Dictionary<string, string>) null;
    }
    if (this.m_chartRelations != null)
    {
      this.m_chartRelations.Clear();
      this.m_chartRelations = (Dictionary<string, DictionaryEntry>) null;
    }
    if (this.m_docRelations != null)
    {
      this.m_docRelations.Clear();
      this.m_docRelations = (Dictionary<string, DictionaryEntry>) null;
    }
    if (this.m_fontTableRelations != null)
    {
      this.m_fontTableRelations.Clear();
      this.m_fontTableRelations = (Dictionary<string, DictionaryEntry>) null;
    }
    if (this.m_settingsRelations != null)
    {
      this.m_settingsRelations.Clear();
      this.m_settingsRelations = (Dictionary<string, DictionaryEntry>) null;
    }
    if (this.m_isExternalHyperlink != null)
    {
      this.m_isExternalHyperlink.Clear();
      this.m_isExternalHyperlink = (Dictionary<string, bool>) null;
    }
    if (this.m_bookmarkNames != null)
    {
      this.m_bookmarkNames.Clear();
      this.m_bookmarkNames = (List<DocxParser.BookmarkInfo>) null;
    }
    if (this.m_hfRelations != null)
    {
      foreach (Dictionary<string, DictionaryEntry> dictionary in this.m_hfRelations.Values)
        dictionary.Clear();
      this.m_hfRelations.Clear();
      this.m_hfRelations = (Dictionary<string, Dictionary<string, DictionaryEntry>>) null;
    }
    if (this.m_pictureBullet != null)
    {
      this.m_pictureBullet.Clear();
      this.m_pictureBullet = (Dictionary<string, WPicture>) null;
    }
    if (this.m_abstractListStyles != null)
    {
      this.m_abstractListStyles.Clear();
      this.m_abstractListStyles = (Dictionary<string, string>) null;
    }
    if (this.m_overrideListStyles != null)
    {
      this.m_overrideListStyles.Clear();
      this.m_overrideListStyles = (Dictionary<string, string>) null;
    }
    if (this.m_currentRunFormat != null)
      this.m_currentRunFormat = (WCharacterFormat) null;
    if (this.m_footnote != null)
    {
      this.m_footnote.Clear();
      this.m_footnote = (List<DictionaryEntry>) null;
    }
    if (this.m_endnote != null)
    {
      this.m_endnote.Clear();
      this.m_endnote = (List<DictionaryEntry>) null;
    }
    if (this.m_fieldStack != null)
    {
      this.m_fieldStack.Clear();
      this.m_fieldStack = (Stack<WField>) null;
    }
    if (this.m_bookMarkCollection != null)
    {
      this.m_bookMarkCollection.Clear();
      this.m_bookMarkCollection = (List<Entity>) null;
    }
    if (this.m_editableRangeCollection != null)
    {
      this.m_editableRangeCollection.Clear();
      this.m_editableRangeCollection = (List<Entity>) null;
    }
    if (this.m_breakCollection != null)
    {
      this.m_breakCollection.Clear();
      this.m_breakCollection = (List<Entity>) null;
    }
    this.m_postCommMark = (WCommentMark) null;
    if (this.m_comments != null)
    {
      this.m_comments.Clear();
      this.m_comments = (Dictionary<string, WComment>) null;
    }
    if (this.m_commentsEx != null)
    {
      this.m_commentsEx.Clear();
      this.m_commentsEx = (List<WCommentExtended>) null;
    }
    if (this.m_commStack != null)
    {
      this.m_commStack.Clear();
      this.m_commStack = (Stack<WComment>) null;
    }
    if (this.m_imageIds != null)
    {
      this.m_imageIds.Clear();
      this.m_imageIds = (Dictionary<string, int>) null;
    }
    if (this.m_svgDataDict != null)
    {
      this.m_svgDataDict.Clear();
      this.m_svgDataDict = (Dictionary<string, byte[]>) null;
    }
    if (this.m_fontFamilyRecords != null)
    {
      this.m_fontFamilyRecords.Clear();
      this.m_fontFamilyRecords = (List<FontFamilyNameRecord>) null;
    }
    if (this.m_autoShapeHelper != null)
    {
      this.m_autoShapeHelper.Close();
      this.m_autoShapeHelper = (AutoShapeHelper) null;
    }
    if (this.m_trackchangeStack != null)
    {
      this.m_trackchangeStack.Clear();
      this.m_trackchangeStack = (Stack<RevisionType>) null;
    }
    if (this.m_trackchangeRevisionDetails != null)
    {
      this.m_trackchangeRevisionDetails.Clear();
      this.m_trackchangeRevisionDetails = (Stack<Revision>) null;
    }
    if (this.m_blockControls != null)
    {
      this.m_blockControls.Clear();
      this.m_blockControls = (List<BlockContentControl>) null;
    }
    if (this.m_inlineControls != null)
    {
      this.m_inlineControls.Clear();
      this.m_inlineControls = (List<InlineContentControl>) null;
    }
    if (this.m_cellControls == null)
      return;
    this.m_cellControls.Clear();
    this.m_cellControls = (List<WTableCell>) null;
  }

  internal bool StartsWithExt(string text, string value) => text.StartsWithExt(value);

  private struct BookmarkInfo
  {
    internal string bookmarkId;
    internal string bookmarName;
  }

  private enum GraphicDataContentType
  {
    None,
    Shape,
    Picture,
    Chart,
    Group,
  }
}
