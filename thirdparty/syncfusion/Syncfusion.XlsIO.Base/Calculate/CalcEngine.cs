// Decompiled with JetBrains decompiler
// Type: Syncfusion.Calculate.CalcEngine
// Assembly: Syncfusion.XlsIO.Base, Version=19.3460.0.57, Culture=neutral, PublicKeyToken=3d67ed1f87d44c89
// MVID: 92616603-9632-451A-8DB0-51A3184E0997
// Assembly location: C:\Program Files\PDFgear\Syncfusion.XlsIO.Base.dll

using Syncfusion.XlsIO;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.Net;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;
using System.Xml.XPath;

#nullable disable
namespace Syncfusion.Calculate;

public class CalcEngine : IDisposable
{
  private const double PI = 3.1415926535897931;
  private const char BMARKER = '\u0092';
  public const double machineepsilon = 5E-16;
  public const double maxrealnumber = 1E+300;
  public const double minrealnumber = 1E-300;
  private const char CHAR_divide = '/';
  private const string STRING_empty = "";
  private const string STRING_fixedreference = "$";
  private const string STRING_greatereq = ">=";
  private const string STRING_lesseq = "<=";
  private const string STRING_noequal = "<>";
  private const char sheetToken = '!';
  private const char TOKEN_EM = 'v';
  private const char TOKEN_EP = 't';
  private const char TOKEN_multiply = 'm';
  private const char TOKEN_divide = 'd';
  private const char TOKEN_add = 'a';
  private const char TOKEN_subtract = 's';
  private const char CHAR_add = '+';
  private const char CHAR_subtract = '-';
  private const char TOKEN_less = 'l';
  private const char CHAR_less = '<';
  private const char CHAR_lesseq = 'f';
  private const char TOKEN_greater = 'g';
  private const char TOKEN_greatereq = 'j';
  private const char TOKEN_equal = 'e';
  private const char CHAR_equal = '=';
  private const char TOKEN_lesseq = 'k';
  private const char CHAR_greatereq = 'h';
  private const char TOKEN_noequal = 'o';
  private const char CHAR_noequal = 'p';
  private const char TOKEN_and = 'c';
  private const char CHAR_multiply = '*';
  private const char CHAR_greater = '>';
  private const char CHAR_ANDop = '\u008C';
  private const char CHAR_ELSEop = '\u0090';
  private const char CHAR_IFop = '\u008E';
  private const char CHAR_NOTop = '\u0091';
  private const char TOKEN_ANDop = '\u0085';
  private const char TOKEN_ELSEop = '\u0089';
  private const char TOKEN_IFop = '\u0087';
  private const char CHAR_ORop = '\u008B';
  private const char CHAR_THENop = '\u008F';
  private const char CHAR_XORop = '\u008D';
  private const string TABLE_ROW = "[#THIS ROW]";
  private const string TABLE_HEADERS = "[#Headers]";
  private const string TABLE_TOTALS = "[#Totals]";
  private const string TABLE_DATA = "[#Data]";
  private const string TABLE_ALL = "[#All]";
  private const double OADate1904 = 1462.0;
  private const char TOKEN_NOTop = '\u008A';
  private const char TOKEN_or = '~';
  private const char TOKEN_ORop = '\u0084';
  private const char TOKEN_THENop = '\u0088';
  private const char TOKEN_XORop = '\u0086';
  private ArrayList weekEndType;
  private char MarkerParseChar = '\u0085';
  private bool isInteriorFunction;
  private char CHARTIC = "'"[0];
  private bool multiTick;
  private bool rethrowExceptions;
  private bool useDatesInCalcs;
  private List<string> nativeFormats;
  private ArrayList sortedSheetNames;
  private LookupCachingMode enableLookupTableCaching;
  private Dictionary<string, CalcEngine.LookUps> lookupTables;
  private ArrayList formulaErrorStrings;
  private static string[] charTable = new string[27]
  {
    string.Empty,
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z"
  };
  private static int[] factorialTable = new int[13]
  {
    1,
    1,
    2,
    6,
    24,
    120,
    720,
    5040,
    40320,
    362880,
    3628800,
    39916800,
    479001600
  };
  private Random rand;
  private static double[] gammaAs = new double[5]
  {
    0.918938533204673,
    0.000595238095238,
    0.000793650793651,
    1.0 / 360.0,
    1.0 / 12.0
  };
  private static int gauss_n = 16 /*0x10*/;
  private static double[] gauss_x = new double[16 /*0x10*/]
  {
    0.04830766569,
    0.14447196158,
    0.23928736225,
    0.33186860228,
    0.42135127613,
    0.50689990893,
    0.58771575724,
    0.66304426693,
    0.73218211874,
    0.79448379597,
    0.84936761373,
    0.89632115577,
    0.93490607594,
    0.96476225559,
    0.98561151155,
    0.99726386185
  };
  private static double[] gauss_w = new double[16 /*0x10*/]
  {
    0.09654008851,
    0.09563872008,
    0.09384439908,
    0.0911738787,
    0.087652093,
    0.08331192423,
    0.07819389579,
    0.07234579411,
    0.06582222278,
    0.05868409348,
    0.05099805926,
    0.04283589802,
    0.03427386291,
    0.02539206531,
    0.01627439473,
    0.00701861001
  };
  internal bool IgnoreSubtotal;
  internal int hitCount;
  private string download;
  private Hashtable _formulaInfoTable;
  private ArrayList breakedFormulaCells = new ArrayList();
  private ArrayList tempBreakedFormulaCells = new ArrayList();
  private ArrayList processedCells = new ArrayList();
  private Hashtable dependentFormulaCells;
  private bool _isDisposed;
  private char[] BRACEDELIMETER = new char[1]{ ',' };
  private string BRACERIGHTnLEFT = ")(";
  private bool useFormulaValues;
  private bool getValueFromArgPreserveLeadingZeros;
  private bool ignoreCellValue;
  private int calcID;
  private int columnMaxCount = -1;
  private int rowMaxCount = -1;
  public bool IgnoreValueChanged;
  private bool inAPull;
  private bool useDependencies;
  private bool checkDanglingStack;
  private bool inHandleIterations;
  private bool inRecalculateRange;
  private bool isRangeOperand;
  private bool forceRefreshCall;
  private bool preserveFormula;
  private string validFunctionNameChars = "_";
  internal string cell = string.Empty;
  [ThreadStatic]
  private static char formulaChar = '=';
  internal int reservedWord_AND = 1;
  internal int reservedWord_IF = 3;
  internal int reservedWord_ELSE = 5;
  internal int reservedWord_NOT = 6;
  internal int reservedWord_OR;
  internal int reservedWord_THEN = 4;
  internal int reservedWord_XOR = 2;
  private string validPrecedingChars;
  private Hashtable variableNamesToTokens;
  private Hashtable variableTokensToNames;
  private Hashtable dependentCells;
  public double ACC = 4.0;
  public double BIGNO = 10000000000.0;
  public double BIGNI = 1E-10;
  private Hashtable refreshedCells;
  private Hashtable libraryFunctions;
  internal char[] tokens;
  internal static int sheetID = -1;
  private char CHAR_and = 'i';
  private char CHAR_or = 'w';
  private ArrayList circCheckList = new ArrayList();
  private ArrayList errorStrings;
  private int computedValueLevel;
  private int dependencyLevel;
  private int maximumRecursiveCalls = 100;
  private string BRACELEFT = "{";
  private string BRACERIGHT = "}";
  private string STRING_and = "&";
  private string STRING_E = "E";
  private string STRING_EM = "E-";
  private string STRING_EP = "E+";
  private string TRUEVALUESTR = "TRUE";
  private string FALSEVALUESTR = "FALSE";
  private string STRING_or = "^";
  private string TIC = "\"";
  private char RIGHTBRACKET = '\u0083';
  private char LEFTBRACKET = '\u0082';
  private char CHAR_EP = 'x';
  private char CHAR_EM = 'r';
  private char UNIQUESTRINGMARKER = '\u007F';
  private char MarkerChar = '`';
  private int computeFunctionLevel;
  private DateTime dateTime1900 = new DateTime(1900, 1, 1, 0, 0, 0);
  internal ICalcData grid;
  private bool exteriorFormula;
  private string activeFunctionName = string.Empty;
  private bool rethrowLibraryComputationExceptions;
  private bool isIndexInteriorFormula;
  private bool lockDependencies;
  private bool exceptionThrown;
  private bool currentRowNotationEnabled = true;
  private bool calculationsSuspended;
  private bool allowShortCircuitIFs;
  private bool supportLogicalOperators;
  private bool useNoAmpersandQuotes;
  private bool treatStringsAsZero = true;
  internal bool matchType;
  private bool alwaysComputeDuringRefresh = true;
  private bool ensureIFCallDuringShortCircuit;
  private bool supportRangeOperands = true;
  private bool throwCircularException;
  private bool ignoreBracet;
  private bool findRangeIfIntersect;
  private double ABSOLUTEZERO = 1E-20;
  private string BMARKER2 = '\u0092'.ToString() + '\u0092'.ToString();
  [ThreadStatic]
  private static GridSheetFamilyItem defaultFamilyItem = (GridSheetFamilyItem) null;
  [ThreadStatic]
  internal static Hashtable modelToSheetID = (Hashtable) null;
  [ThreadStatic]
  internal static Hashtable sheetFamiliesList = (Hashtable) null;
  [ThreadStatic]
  private static int sheetFamilyID = 0;
  [ThreadStatic]
  private static char parseArgumentSeparator = ',';
  [ThreadStatic]
  private static char parseDecimalSeparator = '.';
  [ThreadStatic]
  private static char parseDateTimeSeparator = '/';
  private int iterationMaxCount;
  private double dateTime1900Double;
  private double iterationMaxTolerance = 0.001;
  internal int iterations_dont_converge = 27;
  private Hashtable iterationValues;
  private Exception libraryComputationException;
  private bool supportsSheetRanges = true;
  private char tempSheetPlaceHolder = '\u0085';
  [ThreadStatic]
  internal static int TokenCount = 0;
  private string markers = "()+-*/=><.,!";
  [ThreadStatic]
  private static int maxStackDepth = 50;
  private char[] logicalOperators = new char[5]
  {
    'a',
    's',
    'm',
    'd',
    'c'
  };
  private Hashtable namedRanges;
  private string[] reservedWordOperators;
  private string IFMarker = "qIF" + (object) '\u0082';
  internal bool UseDate1904;
  private bool isAreaCalculation;
  public static bool Treat1900AsLeapYear = true;
  internal bool errorFormula;
  private bool excelLikeComputations;
  internal bool IsArrayFormula;
  internal ArrayParser ArrayParser;
  internal LinearRegression LinearRegression;
  private static bool isParseArgumentSeparator = false;
  private static bool isParseDecimalSeparatorChanged = false;
  internal int operators_cannot_start_an_expression;
  internal int cannot_parse = 1;
  internal int bad_library = 2;
  internal int invalid_char_in_front_of = 3;
  internal int number_contains_2_decimal_points = 4;
  internal int expression_cannot_end_with_an_operator = 5;
  internal int invalid_characters_following_an_operator = 6;
  internal int invalid_char_in_number = 7;
  internal int mismatched_parentheses = 8;
  internal int unknown_formula_name = 9;
  internal int requires_a_single_argument = 10;
  internal int requires_3_args = 11;
  internal int invalid_Math_argument = 12;
  internal int requires_2_args = 13;
  internal int bad_index = 14;
  internal int Name_error = 14;
  internal int too_complex = 15;
  internal int circular_reference_ = 16 /*0x10*/;
  internal int missing_formula = 17;
  internal int improper_formula = 18;
  internal int invalid_expression = 19;
  internal int cell_empty = 20;
  internal int bad_formula = 21;
  internal int empty_expression = 22;
  internal int virtual_mode_required = 23;
  internal int mismatched_tics = 24;
  internal int wrong_number_arguments = 25;
  internal int invalid_arguments = 26;
  public int already_registered = 28;
  internal int calculation_overflow = 29;
  internal int missing_sheet = 30;
  public string[] FormulaErrorStrings = new string[31 /*0x1F*/]
  {
    "binary operators cannot start an expression",
    "cannot parse",
    "bad library",
    "invalid char in front of",
    "number contains 2 decimal points",
    "expression cannot end with an operator",
    "invalid characters following an operator",
    "invalid character in number",
    "mismatched parentheses",
    "unknown formula name",
    "requires a single argument",
    "requires 3 arguments",
    "invalid Math argument",
    "requires 2 arguments",
    "#NAME?",
    "too complex",
    "circular reference: ",
    "missing formula",
    "improper formula",
    "invalid expression",
    "cell empty",
    "bad formula",
    "empty expression",
    "",
    "mismatched string quotes",
    "wrong number of arguments",
    "invalid arguments",
    "iterations do not converge",
    "Control named '{0}' is already registered",
    "Calculation overflow",
    "Missing sheet"
  };
  private bool isDoubleQuotes;
  private bool isErrorString;
  private bool isCriteriaIsNumber;
  private Hashtable namedRangesNonScoped;
  internal bool findNamedRange;
  private Hashtable scopedRangeStrings = new Hashtable();

  public string ComputeDate(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double result1 = 0.0;
    double result2 = 0.0;
    int d = 0;
    for (int index = 0; index < length; ++index)
    {
      string empty = string.Empty;
      strArray[index] = this.GetValueFromArg(strArray[index]);
      string date = !double.TryParse(strArray[index].Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out double _) ? this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Numbers) : strArray[index];
      if (this.ErrorStrings.Contains((object) date))
        return date;
    }
    bool result3;
    strArray[0] = bool.TryParse(strArray[0], out result3) ? Convert.ToInt16(result3).ToString() : (!string.IsNullOrEmpty(strArray[0]) || !this.TreatStringsAsZero ? strArray[0] : "0");
    strArray[1] = bool.TryParse(strArray[1], out result3) ? Convert.ToInt16(result3).ToString() : (!string.IsNullOrEmpty(strArray[1]) || !this.TreatStringsAsZero ? strArray[1] : "0");
    strArray[2] = bool.TryParse(strArray[2], out result3) ? Convert.ToInt16(result3).ToString() : (!string.IsNullOrEmpty(strArray[2]) || !this.TreatStringsAsZero ? strArray[2] : "0");
    double result4;
    if (double.TryParse(strArray[0].Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[1].Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[2].Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2))
      d = this.GetSerialDateFromDate((int) result4, (int) result1, (int) result2);
    if (d == -1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[4].ToString();
    }
    return this.computedValueLevel <= 1 && this.ExcelLikeComputations ? DateTime.FromOADate((double) d).ToShortDateString() : d.ToString();
  }

  public string ComputeDatevalue(string argList)
  {
    argList = argList.Replace(this.TIC, string.Empty);
    double result1 = 0.0;
    DateTime result2;
    try
    {
      if (!double.TryParse(argList, NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result1))
      {
        if (DateTime.TryParse(argList, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result2))
          goto label_7;
      }
      result2 = result1 <= 0.0 ? DateTime.Parse(this.ComputedValue(argList).Replace(this.TIC, string.Empty)) : DateTime.FromOADate(result1);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
label_7:
    int num = 1 + (result2 - this.dateTime1900).Days;
    if (CalcEngine.Treat1900AsLeapYear && num > 59)
      ++num;
    return num.ToString();
  }

  public string ComputeDay(string argList)
  {
    DateTime result1;
    double num;
    if (DateTime.TryParse(this.GetValueFromArg(argList).Replace(this.TIC, string.Empty), out result1))
    {
      num = (double) result1.Day;
    }
    else
    {
      double result2;
      if (!double.TryParse(this.GetValueFromArg(argList), NumberStyles.Any, (IFormatProvider) null, out result2))
        return this.FormulaErrorStrings[this.invalid_arguments];
      num = result2 >= 1.0 ? (double) this.GetDateFromSerialDate((int) result2).Day : 0.0;
    }
    return num.ToString();
  }

  public string ComputeDays360(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 2:
      case 3:
        string days360 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Date);
        if (this.ErrorStrings.Contains((object) days360))
          return days360;
        string valueFromArg1 = this.GetValueFromArg(strArray[0]);
        string valueFromArg2 = this.GetValueFromArg(strArray[1]);
        bool result1;
        string s1 = bool.TryParse(valueFromArg1, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg1;
        string s2 = bool.TryParse(valueFromArg2, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg2;
        double result2;
        bool flag1 = double.TryParse(s1, out result2);
        double result3;
        bool flag2 = double.TryParse(s2, out result3);
        if (flag1 && result2 == 0.0 || flag2 && result3 == 0.0)
          return (result2 - result3).ToString();
        DateTime result4 = this.dateTime1900;
        DateTime result5 = this.dateTime1900;
        double result6;
        bool flag3 = double.TryParse(s1, NumberStyles.Any, (IFormatProvider) null, out result6) || DateTime.TryParse(this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty), (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result4);
        double result7;
        bool flag4 = double.TryParse(s2, NumberStyles.Any, (IFormatProvider) null, out result7) || DateTime.TryParse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty), (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result5);
        bool flag5 = length == 3 && (strArray[2] == this.TRUEVALUESTR || strArray[2] == this.FALSEVALUESTR);
        if (!flag3 || !flag4 || length != 2 && !flag5)
          return this.FormulaErrorStrings[this.invalid_arguments];
        DateTime dateTime1 = result6 > 0.0 ? this.GetDateFromSerialDate((int) result6) : result4;
        DateTime dateTime2 = result7 > 0.0 ? this.GetDateFromSerialDate((int) result7) : result5;
        bool flag6 = false;
        if (dateTime1.Day == 31 /*0x1F*/)
          dateTime1 = dateTime1.AddDays(-1.0);
        if (dateTime2.Day == 31 /*0x1F*/ && !flag5 && dateTime1.Day < 30)
          dateTime2 = dateTime2.AddDays(1.0);
        else if (dateTime2.Day == 31 /*0x1F*/)
          dateTime2 = flag5 && strArray[2] == this.TRUEVALUESTR || length == 2 ? dateTime2.AddDays(-1.0) : dateTime2.AddDays(1.0);
        if (dateTime2 < dateTime1)
        {
          flag6 = true;
          DateTime dateTime3 = dateTime1;
          dateTime1 = dateTime2;
          dateTime2 = dateTime3;
        }
        int num = dateTime2.Day - dateTime1.Day + 30 * (dateTime2.Month - dateTime1.Month) + 360 * (dateTime2.Year - dateTime1.Year);
        if (flag6)
          num = -num;
        return num.ToString();
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  public string ComputeYearFrac(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    List<DateTime> dateTimeList = new List<DateTime>();
    double num1 = 0.0;
    if (length != 2 && length > 3)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str1 = this.GetValueFromArg(strArray[0]);
    string str2 = this.GetValueFromArg(strArray[1]);
    string s = length == 3 ? this.GetValueFromArg(strArray[2]).Replace(this.TIC, "") : "0";
    DateTime result1 = this.dateTime1900;
    DateTime result2 = this.dateTime1900;
    double result3 = -1.0;
    double result4 = -1.0;
    double result5;
    if (!double.TryParse(str1, NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result3) && !DateTime.TryParse(str1.Replace(this.TIC, string.Empty), (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result1) || !DateTime.TryParse(str2.Replace(this.TIC, string.Empty), (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result2) && !double.TryParse(str2, NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result4) || !double.TryParse(s, NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result5))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    if (result5 > 4.0 && result5 < 0.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    if (result3 > 0.0)
    {
      result1 = this.GetDateFromSerialDate((int) result3);
      str1 = result1.ToShortDateString();
    }
    if (result4 > 0.0)
    {
      result2 = this.GetDateFromSerialDate((int) result4);
      str2 = result2.ToShortDateString();
    }
    double num2 = double.Parse(this.ComputeDatevalue(str2)) - double.Parse(this.ComputeDatevalue(str1));
    if (num2 < 0.0)
    {
      result1 = DateTime.Parse(str2);
      result2 = DateTime.Parse(str1);
    }
    double year1 = (double) result1.Year;
    double month1 = (double) result1.Month;
    double num3 = (double) result1.Day;
    double year2 = (double) result2.Year;
    double month2 = (double) result2.Month;
    double num4 = (double) result2.Day;
    double num5 = (double) DateTime.DaysInMonth(result1.Year, result1.Month);
    double num6 = (double) DateTime.DaysInMonth(result2.Year, result2.Month);
    switch (s)
    {
      case "0":
        if (num3 == 31.0 && num4 == 31.0)
        {
          num3 = 30.0;
          num4 = 30.0;
        }
        else if (num3 == 31.0)
          num3 = 30.0;
        else if (num3 == 30.0 && num4 == 31.0)
          num4 = 30.0;
        else if (month1 == 1.0 && month2 == 1.0 && num5 == num3 && num6 == num4)
        {
          num3 = 30.0;
          num4 = 30.0;
        }
        else if (month1 == 1.0 && num5 == num3)
          num3 = 30.0;
        num1 = (num4 + month2 * 30.0 + year2 * 360.0 - (num3 + month1 * 30.0 + year1 * 360.0)) / 360.0;
        break;
      case "1":
        double num7 = 366.0;
        if (year1 == year2 || year1 + 1.0 == year2 && (month1 > month2 || month1 == month2 && num3 >= num4))
        {
          if (year1 == year2 && DateTime.IsLeapYear(int.Parse(year1.ToString())))
            num7 = 366.0;
          else if (this.Daysfeb29(result1, result2) || month2 == 1.0 && num4 == 29.0)
            num7 = 366.0;
          num1 = num2 / num7;
          break;
        }
        double num8 = year2 - year1 + 1.0;
        double num9 = 0.0;
        if (num8 < 4.0)
        {
          for (int index = 0; (double) index <= num8; ++index)
          {
            if (this.IsLeap(year1 + (double) index))
            {
              num9 = 1.0;
              break;
            }
          }
        }
        else
          num9 = Math.Floor(num8 / 4.0) + (this.IsLeap(year1) || this.IsLeap(year2) ? 1.0 : 0.0);
        double num10 = 365.0 + num9 / num8;
        num1 = num2 / num10;
        break;
      case "2":
        num1 = num2 / 360.0;
        break;
      case "3":
        num1 = num2 / 365.0;
        break;
      case "4":
        if (num3 == 31.0)
          num3 = 30.0;
        if (num4 == 31.0)
          num4 = 30.0;
        num1 = (num4 + month2 * 30.0 + year2 * 360.0 - (num3 + month1 * 30.0 + year1 * 360.0)) / 360.0;
        break;
    }
    return num1.ToString();
  }

  private bool IsLeap(double year)
  {
    return year % 4.0 == 0.0 && year % 100.0 != 0.0 || year % 400.0 == 0.0;
  }

  public string ComputeDays(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string days = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Date);
    if (this.ErrorStrings.Contains((object) days))
      return days;
    string valueFromArg1 = this.GetValueFromArg(strArray[0]);
    bool result1;
    string str1 = bool.TryParse(valueFromArg1, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg1;
    string valueFromArg2 = this.GetValueFromArg(strArray[1]);
    string str2 = bool.TryParse(valueFromArg2, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg2;
    if (str1.StartsWith(this.TIC) && string.IsNullOrEmpty(str1.Replace(this.TIC, string.Empty)) || str2.StartsWith(this.TIC) && string.IsNullOrEmpty(str2.Replace(this.TIC, string.Empty)))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[5].ToString());
      return this.ErrorStrings[1].ToString();
    }
    string str3 = string.IsNullOrEmpty(str1.Replace(this.TIC, string.Empty)) ? DateTime.Parse("1899-12-31").ToShortDateString() : str1.Replace(this.TIC, string.Empty);
    string str4 = string.IsNullOrEmpty(str2.Replace(this.TIC, string.Empty)) ? DateTime.Parse("1899-12-31").ToShortDateString() : str2.Replace(this.TIC, string.Empty);
    double result2 = 0.0;
    double result3 = 0.0;
    if ((double.TryParse(str3.Replace(this.TIC, string.Empty), out result2) || DateTime.TryParse(str3.Replace(this.TIC, string.Empty), (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out DateTime _)) && (double.TryParse(str4.Replace(this.TIC, string.Empty), out result3) || DateTime.TryParse(str4.Replace(this.TIC, string.Empty), (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out DateTime _)))
    {
      if (result2 < 0.0 || result3 < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("invalid expression");
        return this.ErrorStrings[4].ToString();
      }
      if (result2 >= 1.0 && result3 >= 1.0)
      {
        double num = result2 - result3;
        return Math.Round(num - 0.4999999999 * (double) Math.Sign(num)).ToString();
      }
      if (result2 > 0.0)
        str3 = DateTime.FromOADate(result2 < 59.0 ? result2 + 1.0 : result2).ToShortDateString();
      if (result3 > 0.0)
        str4 = DateTime.FromOADate(result3 < 59.0 ? result3 + 1.0 : result3).ToShortDateString();
      if (result2 > 0.0 && result2 < 1.0)
        str3 = DateTime.FromOADate(result2).ToShortDateString();
      if (result3 > 0.0 && result3 < 1.0)
        str4 = DateTime.FromOADate(result3).ToShortDateString();
      strArray[0] = this.GetValueFromArg(strArray[0]);
      strArray[1] = this.GetValueFromArg(strArray[1]);
      strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
      strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
      double result4;
      bool flag1 = double.TryParse(strArray[0], out result4);
      double result5;
      bool flag2 = double.TryParse(strArray[1], out result5);
      return flag1 && result4 == 0.0 || flag2 && result5 == 0.0 ? (result4 - result5).ToString() : (int.Parse(this.ComputeDatevalue(str3.Replace(this.TIC, string.Empty))) - int.Parse(this.ComputeDatevalue(str4.Replace(this.TIC, string.Empty)))).ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[5].ToString());
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeEDate(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string s = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    int result1 = 0;
    DateTime result2;
    if (DateTime.TryParse(s, out result2))
    {
      if (!int.TryParse(str, out result1))
      {
        if (int.TryParse(this.ComputeDatevalue(str), out result1))
          goto label_17;
      }
      else
        goto label_17;
    }
    try
    {
      DateTime now = DateTime.Now;
      double d = double.Parse(s);
      int months = int.Parse(str);
      if (months < 0 && (double) months < d && d <= 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
        return this.ErrorStrings[4].ToString();
      }
      if (d != 0.0)
      {
        DateTime dateTime1900 = this.dateTime1900;
        result2 = DateTime.FromOADate(d).AddMonths(months);
      }
      else
      {
        DateTime dateTime = now.AddMonths(months);
        return this.ComputeDays(now.ToShortDateString() + (object) CalcEngine.ParseArgumentSeparator + dateTime.ToShortDateString());
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula] + ex.Message);
      return this.ErrorStrings[1].ToString();
    }
label_17:
    result2 = result2.AddMonths(result1);
    return this.ExcelLikeComputations ? result2.ToShortDateString() : ((int) result2.ToOADate()).ToString();
  }

  public string ComputeEOMonth(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string eoMonth = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Date);
    if (this.ErrorStrings.Contains((object) eoMonth))
      return eoMonth;
    string s = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (this.ErrorStrings.Contains((object) s))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return s;
    }
    double result1 = 0.0;
    DateTime result2;
    if (double.TryParse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, ""), out result1))
    {
      if (DateTime.TryParse(s, out result2))
        goto label_34;
    }
    try
    {
      DateTime now = DateTime.Now;
      int result3 = 0;
      result2 = this.dateTime1900;
      double result4 = 0.0;
      if (!int.TryParse(s, out result3))
      {
        if (result3 == 0 && double.TryParse(s, out result4))
        {
          if (result4 >= 1.0)
            result2 = DateTime.FromOADate(result4);
          if (result1 < result4 && result4 <= 0.0 || result4 + result1 < 0.0)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
            return this.ErrorStrings[4].ToString();
          }
        }
        result1 = double.Parse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, ""));
      }
      else
      {
        if (result3 >= 1)
          result2 = DateTime.FromOADate((double) result3);
        result1 = double.Parse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, ""));
      }
      if (result3 >= 0)
      {
        if (result3 <= 0)
        {
          if (result1 < (double) result3)
          {
            if (result4 != 0.0)
              goto label_34;
          }
          else
            goto label_34;
        }
        else
          goto label_34;
      }
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[4].ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula] + ex.Message);
      return this.ErrorStrings[1].ToString();
    }
label_34:
    DateTime dt = result2.AddMonths((int) result1);
    int num = DateTime.DaysInMonth(dt.Year, dt.Month);
    dt = DateTime.Parse($"{dt.Year.ToString()}/{dt.Month.ToString()}/{num.ToString()}");
    return this.ExcelLikeComputations ? dt.ToShortDateString() : this.GetSerialDateTimeFromDate(dt).ToString();
  }

  public string ComputeWeeknum(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length > 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (str.Equals("invalid expression"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    DateTime dateTime1 = this.dateTime1900;
    DateTime result1;
    if (!DateTime.TryParse(str, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result1))
    {
      try
      {
        result1 = DateTime.FromOADate(double.Parse(str));
        str = result1.ToShortDateString();
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula] + ex.Message);
        return this.ErrorStrings[4].ToString();
      }
    }
    ArrayList arrayList = new ArrayList();
    arrayList.AddRange((ICollection) new string[22]
    {
      "",
      "0",
      "1",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "0",
      "",
      "",
      "",
      "1"
    });
    int result2 = 0;
    if (length != 2 || !int.TryParse(this.GetValueFromArg(strArray[1]), out result2))
      result2 = 1;
    if (result2 == 21)
      return this.ComputeISOWeeknum(this.TIC + str + this.TIC);
    int num = int.Parse(arrayList[result2].ToString());
    dateTime1 = new DateTime(result1.Year, 1, 1);
    int day = dateTime1.Day;
    TimeSpan timeSpan = new TimeSpan(day < num ? num - day + 1 : day - num, 0, 0, 0);
    DateTime dateTime2 = dateTime1.Subtract(timeSpan);
    return (Math.Floor((double.Parse(this.ComputeDatevalue(str)) - double.Parse(this.ComputeDatevalue(dateTime2.ToShortDateString()))) / 7.0) + 1.0 + (double) num).ToString();
  }

  public string ComputeISOWeeknum(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    bool exactDateTime = this.TryParseExactDateTime(valueFromArg.Replace(this.TIC, string.Empty), out DateTime _);
    if (valueFromArg.Contains(":") && exactDateTime)
      strArray[0] = "0";
    if (valueFromArg.StartsWith(this.TIC) && string.IsNullOrEmpty(valueFromArg.Replace(this.TIC, string.Empty)))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    if (string.IsNullOrEmpty(valueFromArg))
      argList = this.ComputeDatevalue(new DateTime(1990, 12, 28).ToShortDateString());
    if (exactDateTime && (argList.Contains(":") || !this.IsCellReference(this.GetValueFromArg(strArray[0])) && this.GetValueFromArg(strArray[0]).Contains(":")))
      argList = "0";
    string s = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    DateTime dateTime1 = this.dateTime1900;
    DateTime result;
    if (!DateTime.TryParse(s, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result))
    {
      try
      {
        result = DateTime.FromOADate(double.Parse(s));
        result.ToShortDateString();
      }
      catch
      {
        this.ExceptionThrown = true;
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Bad Cell reference");
        return this.ErrorStrings[1].ToString();
      }
    }
    int num1 = 0;
    int num2 = 0;
    ArrayList arrayList = new ArrayList();
    arrayList.AddRange((ICollection) new string[7]
    {
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    });
    dateTime1 = new DateTime(result.Year, 1, 1);
    string str1 = dateTime1.DayOfWeek.ToString();
    if (arrayList.Contains((object) str1))
      num1 = arrayList.IndexOf((object) str1) + 1;
    double num3;
    if (result.Month == 1 && num1 > 4 && result.Day < 4)
    {
      DateTime dateTime2 = new DateTime(result.Year - 1, 1, 1);
      double num4 = Math.Abs((new DateTime(result.Year, 1, 1) - dateTime2).TotalDays + (double) (7 - num1));
      string str2 = dateTime2.DayOfWeek.ToString();
      if (arrayList.Contains((object) str2))
        num2 = arrayList.IndexOf((object) str2) + 1;
      num3 = num2 > 4 ? Math.Floor(num4 / 7.0) : Math.Floor(num4 / 7.0) + 1.0;
    }
    else if (result.Month == 1 && num1 <= 4 && result.Day <= 4)
    {
      DateTime dateTime3 = new DateTime(result.Year, 1, 1);
      num3 = Math.Floor(Math.Abs((result - dateTime3).TotalDays + (double) (num1 - 1) + 7.0) / 7.0);
    }
    else
    {
      if (result.Month == 12 && result.Day > 28 && num1 <= 3)
        return 1.ToString();
      DateTime dateTime4 = new DateTime(result.Year, 1, 1);
      double num5 = Math.Abs((result - dateTime4).TotalDays);
      if (num1 <= 4)
        num5 += (double) (num1 - 1);
      else if (num1 > 4)
        num5 -= (double) (7 - num1);
      num3 = Math.Floor(num5 / 7.0) + 1.0;
    }
    return num3.ToString();
  }

  public string ComputeWorkDay(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    DateTime dateTime = new DateTime();
    if (length != 2 && length > 3)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double result = 0.0;
    string argList1;
    if (length == 3)
      argList1 = $"{strArray[0]}{(object) CalcEngine.ParseArgumentSeparator}{strArray[1]}{(object) CalcEngine.ParseArgumentSeparator}1{(object) CalcEngine.ParseArgumentSeparator}{strArray[2]}";
    else
      argList1 = $"{strArray[0]}{(object) CalcEngine.ParseArgumentSeparator}{strArray[1]}{(object) CalcEngine.ParseArgumentSeparator}1";
    string workDayintl = this.ComputeWorkDayintl(argList1);
    if (this.ErrorStrings.Contains((object) workDayintl))
      return workDayintl;
    if (double.TryParse(workDayintl, out result))
      return DateTime.FromOADate(result).ToShortDateString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeNetworkDays(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    List<DateTime> dateTimeList = new List<DateTime>();
    if (length != 2 && length != 3)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    DateTime result1;
    if (!DateTime.TryParse(str1, out result1))
    {
      double result2 = 0.0;
      if (double.TryParse(str1, NumberStyles.Any, (IFormatProvider) null, out result2))
      {
        result1 = DateTime.FromOADate(result2);
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[1].ToString());
        return this.ErrorStrings[1].ToString();
      }
    }
    DateTime result3;
    if (!DateTime.TryParse(str2, out result3))
    {
      double result4 = 0.0;
      if (double.TryParse(str2, NumberStyles.Any, (IFormatProvider) null, out result4))
      {
        result3 = DateTime.FromOADate(result4);
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[1].ToString());
        return this.ErrorStrings[1].ToString();
      }
    }
    if (length == 3)
    {
      string range = strArray[2];
      this.AdjustRangeArg(ref range);
      if (range.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(range))
        {
          string s;
          try
          {
            s = this.GetValueFromArg(cellsFromArg).Replace(this.TIC, string.Empty);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
          DateTime result5;
          if (s != string.Empty && DateTime.TryParse(s, out result5) && !dateTimeList.Contains(result5) && result5.CompareTo(result1) != -1 && result5.CompareTo(result3) != 1 && result5.DayOfWeek != DayOfWeek.Sunday && result5.DayOfWeek != DayOfWeek.Saturday)
            dateTimeList.Add(result5);
        }
      }
      else
      {
        string str3;
        try
        {
          str3 = this.GetValueFromArg(range).Replace(this.TIC, string.Empty);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        DateTime result6;
        if (str3.Length > 0 && DateTime.TryParse(strArray[2].Replace(this.TIC, string.Empty), out result6) && !dateTimeList.Contains(result6) && result6.CompareTo(result1) != -1 && result6.CompareTo(result3) != 1 && result6.DayOfWeek != DayOfWeek.Sunday && result6.DayOfWeek != DayOfWeek.Saturday)
          dateTimeList.Add(result6);
      }
    }
    int num1 = int.Parse(this.ComputeDatevalue(str2)) - int.Parse(this.ComputeDatevalue(str1));
    int dayOfWeek1 = (int) result1.DayOfWeek;
    int dayOfWeek2 = (int) result3.DayOfWeek;
    if (result3.DayOfWeek == DayOfWeek.Saturday)
    {
      --dayOfWeek2;
      --num1;
    }
    int num2 = dayOfWeek1 - 1;
    int num3 = 7 - dayOfWeek2;
    int num4 = num1 + num2 + num3;
    int num5 = num4 / 7 * 2;
    return (num4 - num2 - num3 - num5 + 1 - dateTimeList.Count).ToString();
  }

  public string ComputeNetworkDaysintl(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    List<DateTime> dateTimeList = new List<DateTime>();
    if (length != 2 && length > 4)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    DateTime result1;
    DateTime result2;
    if (!DateTime.TryParse(str1, out result1) || !DateTime.TryParse(str2, out result2))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    if (length == 4)
    {
      string range = strArray[3];
      this.AdjustRangeArg(ref range);
      if (range.IndexOf(':') <= -1)
      {
        if (range.IndexOf(',') <= -1)
        {
          string str3;
          try
          {
            str3 = this.GetValueFromArg(range).Replace(this.TIC, string.Empty);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
          DateTime result3;
          if (str3.Length > 0 && DateTime.TryParse(range, out result3) && !dateTimeList.Contains(result3) && result3.CompareTo(result1) != -1 && result3.CompareTo(result2) != 1 && result3.DayOfWeek != DayOfWeek.Sunday && result3.DayOfWeek != DayOfWeek.Saturday)
          {
            dateTimeList.Add(result3);
            goto label_27;
          }
          goto label_27;
        }
      }
      foreach (string cellsFromArg in this.GetCellsFromArgs(range))
      {
        string s;
        try
        {
          s = this.GetValueFromArg(cellsFromArg).Replace(this.TIC, string.Empty);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        DateTime result4;
        if (s != string.Empty && DateTime.TryParse(s, out result4) && !dateTimeList.Contains(result4) && result4.CompareTo(result1) != -1 && result4.CompareTo(result2) != 1 && result4.DayOfWeek != DayOfWeek.Sunday && result4.DayOfWeek != DayOfWeek.Saturday)
          dateTimeList.Add(result4);
      }
    }
label_27:
    int result5 = 0;
    if (length <= 2 || !int.TryParse(strArray[2], out result5))
    {
      result5 = 1;
      ArrayList arrayList = new ArrayList();
      arrayList.AddRange((ICollection) this.SplitArguments(this.WeekEndType[result5].ToString(), ','));
      int num1 = int.Parse(this.ComputeDatevalue(str2)) - int.Parse(this.ComputeDatevalue(str1)) + 1;
      int num2 = num1;
      int num3 = 1;
      DateTime dateTime = result1;
      for (; num3 <= num1; ++num3)
      {
        int dayOfWeek = (int) dateTime.DayOfWeek;
        if (arrayList.IndexOf((object) dayOfWeek.ToString()) >= 0)
          --num2;
        else if (dateTimeList.IndexOf(dateTime) >= 0)
          --num2;
        dateTime = dateTime.AddDays(1.0);
      }
      return num2.ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeWorkDayintl(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    List<DateTime> dateTimeList = new List<DateTime>();
    if (length > 4 || length < 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string s1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    double result1 = 0.0;
    double result2 = 0.0;
    DateTime result3;
    if (DateTime.TryParse(s1, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result3) || double.TryParse(s1, out result2))
    {
      if (double.TryParse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty), out result1))
      {
        try
        {
          if (result2 > 0.0)
            result3 = DateTime.FromOADate(result2);
          DateTime.FromOADate(result1);
          double num = result2 + result1;
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
        int num1 = (int) result1;
        if (length == 4)
        {
          string range = strArray[3];
          this.AdjustRangeArg(ref range);
          if (range.IndexOf(':') <= -1)
          {
            if (range.IndexOf(',') <= -1)
            {
              string s2;
              try
              {
                double result4 = 0.0;
                s2 = this.GetValueFromArg(range).Replace(this.TIC, string.Empty);
                if (!double.TryParse(range, out result4))
                {
                  if (!DateTime.TryParse(range, out DateTime _))
                    return this.ErrorStrings[1].ToString();
                }
              }
              catch (Exception ex)
              {
                this.ExceptionThrown = true;
                if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                  throw this.LibraryComputationException;
                return this.ErrorStrings[4].ToString();
              }
              DateTime result5;
              if (s2.Length > 0 && DateTime.TryParse(s2, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result5) && !dateTimeList.Contains(result5) && result5.CompareTo(result3) != -1)
              {
                dateTimeList.Add(result5);
                goto label_40;
              }
              goto label_40;
            }
          }
          foreach (string cellsFromArg in this.GetCellsFromArgs(range))
          {
            string s3;
            try
            {
              s3 = this.GetValueFromArg(cellsFromArg).Replace(this.TIC, string.Empty);
            }
            catch (Exception ex)
            {
              this.ExceptionThrown = true;
              if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                throw this.LibraryComputationException;
              return this.ErrorStrings[4].ToString();
            }
            DateTime result6;
            if (s3 != string.Empty && DateTime.TryParse(s3, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result6) && !dateTimeList.Contains(result6) && result6.CompareTo(result3) != -1)
              dateTimeList.Add(result6);
          }
        }
label_40:
        int result7 = -1;
        if (length <= 2 || !int.TryParse(strArray[2], out result7))
          result7 = 1;
        if (result7 == 0)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
        ArrayList arrayList = new ArrayList();
        arrayList.AddRange((ICollection) this.SplitArguments(this.WeekEndType[result7].ToString(), ','));
        int num2 = 0;
        DateTime dateTime = result3;
        if (num1 < 0)
        {
          while (num2 > num1)
          {
            dateTime = dateTime.AddDays(-1.0);
            int dayOfWeek = (int) dateTime.DayOfWeek;
            if (arrayList.IndexOf((object) dayOfWeek.ToString()) < 0 && dateTimeList.IndexOf(dateTime) < 0)
              --num2;
          }
        }
        else
        {
          while (num2 < num1)
          {
            dateTime = dateTime.AddDays(1.0);
            int dayOfWeek = (int) dateTime.DayOfWeek;
            if (arrayList.IndexOf((object) dayOfWeek.ToString()) < 0 && dateTimeList.IndexOf(dateTime) < 0)
              ++num2;
          }
        }
        return this.ComputeDatevalue(dateTime.ToShortDateString());
      }
    }
    if (strArray[0].Replace(this.TIC, string.Empty).Equals(string.Empty))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[0].ToString());
      return this.ErrorStrings[0].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[1].ToString());
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeHour(string argList)
  {
    DateTime dateTime = DateTime.Now;
    if (this.SplitArgsPreservingQuotedCommas(argList).Length != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string hour = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Date);
    if (this.ErrorStrings.Contains((object) hour))
      return hour;
    argList = this.GetValueFromArg(argList);
    if (argList.IndexOf(this.TIC) > -1)
      argList = argList.Replace(this.TIC, string.Empty);
    DateTime result1 = new DateTime();
    if (DateTime.TryParse(argList, out result1))
    {
      dateTime = DateTime.Parse(argList);
    }
    else
    {
      double result2;
      if (double.TryParse(argList, NumberStyles.Any, (IFormatProvider) null, out result2))
        dateTime = DateTime.FromOADate(result2);
    }
    return dateTime.Hour.ToString();
  }

  public string ComputeMinute(string argList)
  {
    if (this.SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string minute = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) minute))
      return minute;
    argList = this.GetValueFromArg(argList);
    DateTime result1 = new DateTime();
    double result2 = 0.0;
    if (!DateTime.TryParse(this.StripTics0(argList), out result1) && !double.TryParse(argList, out result2))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    DateTime dateTime = DateTime.Now;
    if (argList.IndexOf(this.TIC) > -1)
      argList = argList.Replace(this.TIC, string.Empty);
    if (DateTime.TryParse(argList, out result1))
    {
      dateTime = DateTime.Parse(argList);
    }
    else
    {
      double result3;
      if (double.TryParse(argList, NumberStyles.Any, (IFormatProvider) null, out result3))
        dateTime = DateTime.FromOADate(result3);
    }
    return dateTime.Minute.ToString();
  }

  public string ComputeSecond(string argList)
  {
    DateTime dateTime = DateTime.Now;
    if (this.SplitArgsPreservingQuotedCommas(argList).Length != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string second = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Date);
    if (this.ErrorStrings.Contains((object) second))
      return second;
    argList = this.GetValueFromArg(argList);
    if (argList.IndexOf(this.TIC) > -1)
      argList = argList.Replace(this.TIC, string.Empty);
    DateTime result1 = new DateTime();
    if (DateTime.TryParse(argList, out result1))
    {
      dateTime = DateTime.Parse(argList);
    }
    else
    {
      double result2;
      if (double.TryParse(argList, NumberStyles.Any, (IFormatProvider) null, out result2))
        dateTime = DateTime.FromOADate(result2);
    }
    return dateTime.Second.ToString();
  }

  public string ComputeMonth(string argList)
  {
    if (this.SplitArgsPreservingQuotedCommas(argList).Length != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string month = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Date);
    if (this.ErrorStrings.Contains((object) month))
      return month;
    DateTime result1;
    double num;
    if (DateTime.TryParse(this.GetValueFromArg(argList).Replace(this.TIC, string.Empty), out result1))
    {
      num = (double) result1.Month;
    }
    else
    {
      double result2;
      if (!double.TryParse(this.GetValueFromArg(argList), NumberStyles.Any, (IFormatProvider) null, out result2))
        return this.FormulaErrorStrings[this.invalid_arguments];
      num = result2 >= 1.0 ? (double) this.GetDateFromSerialDate((int) result2).Month : 1.0;
    }
    return num.ToString();
  }

  public string ComputeNow(string argList)
  {
    if (!string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("No argument required for this formula");
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    DateTime now = DateTime.Now;
    return this.ExcelLikeComputations ? now.ToString() : now.ToOADate().ToString();
  }

  public string ComputeToday(string argList)
  {
    if (!string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("No argument required for this formula");
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    DateTime now = DateTime.Now;
    if (this.ExcelLikeComputations)
    {
      DateTime result;
      if (DateTime.TryParse($"{now.Year.ToString()}/{now.Month.ToString()}/{now.Day.ToString()}", out result))
        return result.ToShortDateString();
    }
    return this.computedValueLevel > 1 ? this.GetSerialDateTimeFromDate(now.Date).ToString() : this.GetSerialDateFromDate(now.Year, now.Month, now.Day).ToString();
  }

  public string ComputeTime(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string time = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) time))
      return time;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      TimeSpan timeSpan = new TimeSpan((int) result2, (int) result3, (int) result4);
      num = ((double) timeSpan.Hours + ((double) timeSpan.Minutes + (double) timeSpan.Seconds / 60.0) / 60.0) / 24.0;
      if (this.ExcelLikeComputations)
        return timeSpan.ToString();
    }
    return num.ToString("0.0########");
  }

  public string ComputeTimevalue(string argList)
  {
    DateTime result1 = DateTime.Now;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string timevalue = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) timevalue))
      return timevalue;
    string str = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    double num;
    try
    {
      string s = str.Replace(this.TIC, string.Empty);
      if (!DateTime.TryParse(s, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result1))
      {
        double result2 = 0.0;
        double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result2);
        result1 = DateTime.FromOADate(result2);
      }
      num = ((double) result1.Hour + ((double) result1.Minute + (double) result1.Second / 60.0) / 60.0) / 24.0;
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    return num.ToString("0.0###########");
  }

  public string ComputeWeekday(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 1:
      case 2:
        if (!string.IsNullOrEmpty(argList))
        {
          string weekday1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Date);
          if (this.ErrorStrings.Contains((object) weekday1))
            return weekday1;
          if (strArray.Length == 2)
          {
            string weekday2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
            if (this.ErrorStrings.Contains((object) weekday2))
              return weekday2;
          }
          double result1 = 1.0;
          double num1 = 0.0;
          DateTime result2;
          double num2;
          if (DateTime.TryParse(this.GetValueFromArg(strArray[0]), out result2) && (length == 1 || double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Any, (IFormatProvider) null, out result1)))
          {
            num2 = (double) result2.DayOfWeek;
          }
          else
          {
            double result3;
            if (!double.TryParse(this.GetValueFromArg(strArray[0]), NumberStyles.Any, (IFormatProvider) null, out result3) || length != 1 && !double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Any, (IFormatProvider) null, out result1))
              return num1.ToString();
            num2 = (double) this.GetDateFromSerialDate((int) result3).DayOfWeek;
          }
          if (result1 == 1.0)
          {
            ++num2;
          }
          else
          {
            if (num2 == 0.0)
              num2 = 7.0;
            if (result1 == 3.0)
              --num2;
          }
          return num2.ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeYear(string argList)
  {
    string valueFromArg = this.GetValueFromArg(argList);
    if (this.SplitArgsPreservingQuotedCommas(argList).Length != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string year = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Date);
    if (this.ErrorStrings.Contains((object) year))
      return year;
    DateTime result1;
    double num;
    if (DateTime.TryParse(valueFromArg.Replace(this.TIC, string.Empty), out result1))
    {
      num = (double) result1.Year;
    }
    else
    {
      double result2;
      if (!double.TryParse(this.GetValueFromArg(argList), NumberStyles.Any, (IFormatProvider) null, out result2))
        return this.FormulaErrorStrings[this.invalid_arguments];
      if (result2 < 1.0)
      {
        num = 1900.0;
      }
      else
      {
        result1 = this.GetDateFromSerialDate((int) result2);
        num = (double) result1.Year;
      }
    }
    return num.ToString();
  }

  public string ComputeDatedIF(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    string datedIf1 = string.Empty;
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.requires_3_args];
    }
    for (int index = 0; index < length; ++index)
    {
      string empty = string.Empty;
      string datedIf2 = index > 1 ? this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Text) : this.FormulaErrorStringCheck(strArray[index].Replace(this.TIC, string.Empty), CalcEngine.FormulaArgumentType.Date);
      if (this.ErrorStrings.Contains((object) datedIf2))
        return datedIf2;
    }
    if (length == 3)
    {
      strArray[0] = this.GetValueFromArg(strArray[0]);
      strArray[1] = this.GetValueFromArg(strArray[1]);
      strArray[2] = strArray[2].Replace(this.TIC, string.Empty);
      DateTime result1 = this.dateTime1900;
      DateTime result2 = this.dateTime1900;
      double result3;
      if (double.TryParse(strArray[0], out result3))
        result1 = DateTime.FromOADate(double.Parse(strArray[0]));
      else
        DateTime.TryParse(strArray[0].Replace(this.TIC, string.Empty), (IFormatProvider) null, DateTimeStyles.None, out result1);
      if (double.TryParse(strArray[1], out double _))
        result2 = DateTime.FromOADate(double.Parse(strArray[1]));
      else
        DateTime.TryParse(strArray[1].Replace(this.TIC, string.Empty), (IFormatProvider) null, DateTimeStyles.None, out result2);
      if (!double.TryParse(strArray[0], out result3) && !strArray[0].StartsWith(this.TIC))
        strArray[0] = this.TIC + result1.ToShortDateString().ToString() + this.TIC;
      if (!double.TryParse(strArray[1], out result3) && !strArray[1].StartsWith(this.TIC))
        strArray[1] = this.TIC + result2.ToShortDateString().ToString() + this.TIC;
      if (result1 > result2 && !result1.ToShortDateString().Equals(result2.ToShortDateString()))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (strArray[2].ToUpper().Equals("Y"))
      {
        double num = (double) (result2.Year - result1.Year);
        if (result1.Month == result2.Month && result2.Day < result1.Day || result2.Month < result1.Month)
          --num;
        datedIf1 = num.ToString();
      }
      else if (strArray[2].ToUpper().Equals("M"))
      {
        string days = this.ComputeDays(strArray[1] + (object) CalcEngine.parseArgumentSeparator + strArray[0]);
        int num = DateTime.DaysInMonth(result1.Year, result1.Month);
        datedIf1 = (int.Parse(days) / num).ToString();
      }
      else if (strArray[2].ToUpper().Equals("D"))
        datedIf1 = this.ComputeDays(strArray[1] + (object) CalcEngine.parseArgumentSeparator + strArray[0]);
      else if (strArray[2].ToUpper().Equals("YM"))
      {
        string days = this.ComputeDays($"{this.TIC}{(object) result2.Month}/{(object) result2.Day}/{(object) result1.Year}{this.TIC}" + (object) CalcEngine.parseArgumentSeparator + strArray[0]);
        int num = DateTime.DaysInMonth(result1.Year, result1.Month);
        datedIf1 = (int.Parse(days) / num).ToString();
      }
      else if (strArray[2].ToUpper().Equals("MD"))
        datedIf1 = (result2.Day - result1.Day).ToString();
      else if (strArray[2].ToUpper().Equals("YD"))
      {
        datedIf1 = this.ComputeDays($"{this.TIC}{(object) result2.Month}/{(object) result2.Day}/{(object) result1.Year}{this.TIC}" + (object) CalcEngine.parseArgumentSeparator + strArray[0]);
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    return datedIf1;
  }

  private bool Daysfeb29(DateTime sDate, DateTime eDate)
  {
    DateTime dateTime1 = new DateTime(sDate.Year, 2, 1);
    DateTime dateTime2 = new DateTime(eDate.Year, 2, 1);
    int num1 = int.Parse(this.ComputeDatevalue(sDate.ToShortDateString())) - int.Parse(this.ComputeDatevalue(dateTime1.ToShortDateString()));
    int num2 = int.Parse(this.ComputeDatevalue(eDate.ToShortDateString())) - int.Parse(this.ComputeDatevalue(dateTime1.ToShortDateString()));
    int num3 = int.Parse(this.ComputeDatevalue(sDate.ToShortDateString())) - int.Parse(this.ComputeDatevalue(dateTime2.ToShortDateString()));
    int num4 = int.Parse(this.ComputeDatevalue(eDate.ToShortDateString())) - int.Parse(this.ComputeDatevalue(dateTime2.ToShortDateString()));
    return DateTime.IsLeapYear(sDate.Year) && num1 < 0 && num2 >= 0 || DateTime.IsLeapYear(eDate.Year) && num3 < 0 && num4 >= 0;
  }

  private int GetSerialDateFromDate(int y, int m, int d)
  {
    if (y < 1900)
      y += 1900;
    bool flag = false;
    while (!flag)
    {
      while (m > 12)
      {
        m -= 12;
        ++y;
      }
      for (; m < 1 && y > 1900; --y)
        m += 12;
      if (y < 1900 || m < 1 && y <= 1900)
        return -1;
      flag = true;
      int day = new DateTime(y, m, 1).AddMonths(1).AddDays(-1.0).Day;
      while (d > day)
      {
        d -= day;
        ++m;
        if (m > 12)
        {
          m -= 12;
          ++y;
        }
        day = new DateTime(y, m, 1).AddMonths(1).AddDays(-1.0).Day;
        flag = false;
      }
      for (; d < 1; d = new DateTime(y, m + 1, 1).AddHours(-1.0).Day + d)
        --m;
    }
    int serialDateFromDate = 1 + (new DateTime(y, m, d, 0, 0, 0) - this.dateTime1900).Days;
    if (CalcEngine.Treat1900AsLeapYear && serialDateFromDate > 59)
      ++serialDateFromDate;
    return serialDateFromDate;
  }

  internal double GetSerialDateTimeFromDate(DateTime dt)
  {
    double num = dt.ToOADate() - this.dateTime1900Double;
    double dateTimeFromDate = 1.0 + dt.ToOADate() - this.dateTime1900Double;
    if (CalcEngine.Treat1900AsLeapYear && dateTimeFromDate > 59.0)
      ++dateTimeFromDate;
    if (this.UseDate1904)
      dateTimeFromDate -= 1462.0;
    return dateTimeFromDate;
  }

  private DateTime GetDateFromSerialDate(int days)
  {
    --days;
    if (CalcEngine.Treat1900AsLeapYear && days > 59)
      --days;
    return this.dateTime1900.AddDays((double) days);
  }

  public ArrayList WeekEndType
  {
    get
    {
      if (this.weekEndType == null)
      {
        this.weekEndType = new ArrayList();
        this.weekEndType.AddRange((ICollection) new string[18]
        {
          "",
          "6,0",
          "0,1",
          "1,2",
          "2,3",
          "3,4",
          "4,5",
          "5,6",
          "",
          "",
          "",
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6"
        });
      }
      return this.weekEndType;
    }
  }

  public string BaseToBase(string argList, int from, int to)
  {
    argList = argList.Replace(this.TIC, string.Empty);
    return Convert.ToString(Convert.ToInt64(argList, from), to);
  }

  public string ComputeDec2Bin(string argList)
  {
    int totalWidth = 0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    string str2 = strArray.Length > 1 ? this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty) : "10";
    string s = strArray.Length <= 1 || string.IsNullOrEmpty(strArray[0]) || !string.IsNullOrEmpty(strArray[1]) || strArray[1].Contains(this.TIC) ? str2 : "10";
    string dec2Bin1 = string.Empty;
    if (string.IsNullOrEmpty(argList) || strArray.Length > 2 || strArray.Length < 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double result1;
    if (double.TryParse(s, out result1) && result1 < 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[4].ToString();
    }
    string dec2Bin2 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) dec2Bin2))
      return dec2Bin2;
    if (double.TryParse(str1, out double _))
    {
      if (double.TryParse(s.Replace(this.TIC, string.Empty), out result1))
        goto label_18;
    }
    if (!string.IsNullOrEmpty(str1))
    {
      if (string.IsNullOrEmpty(str1))
      {
        if (!string.IsNullOrEmpty(s.Replace(this.TIC, string.Empty)))
          goto label_18;
      }
      else
        goto label_18;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
    return this.ErrorStrings[0].ToString();
label_18:
    try
    {
      if (strArray.Length > 1 && !string.IsNullOrEmpty(strArray[1]))
        totalWidth = int.Parse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty));
      if (double.Parse(str1) < -512.0 || double.Parse(str1) > 511.0)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("Value should be in between -512 and 512");
        return this.ErrorStrings[4].ToString();
      }
      dec2Bin1 = this.BaseToBase(str1, 10, 2);
      double result2;
      if (double.TryParse(str1, out result2) && result2 < 0.0)
        dec2Bin1 = dec2Bin1.Substring(dec2Bin1.Length - 10);
      if (strArray.Length > 1)
      {
        if (totalWidth > 10 || !string.IsNullOrEmpty(strArray[1]) && totalWidth < dec2Bin1.Length && dec2Bin1.Length != 10)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
          return this.ErrorStrings[4].ToString();
        }
        if (totalWidth <= 10)
          dec2Bin1 = dec2Bin1.PadLeft(totalWidth, '0');
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
    }
    return dec2Bin1;
  }

  public string ComputeDec2Oct(string argList)
  {
    int totalWidth = 0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string dec2Oct1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    string str = strArray.Length > 1 ? this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty) : "10";
    string s = strArray.Length <= 1 || string.IsNullOrEmpty(strArray[0]) || !string.IsNullOrEmpty(strArray[1]) || strArray[1].Contains(this.TIC) ? str : "10";
    if (string.IsNullOrEmpty(argList) || strArray.Length > 2 || strArray.Length < 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (this.ErrorStrings.Contains((object) dec2Oct1))
      return dec2Oct1;
    if (this.ErrorStrings.Contains((object) s))
      return s;
    double result1;
    if (double.TryParse(s, out result1) && result1 < 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[4].ToString();
    }
    string dec2Oct2 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) dec2Oct2))
      return dec2Oct2;
    if ((!double.TryParse(dec2Oct1, out double _) || !double.TryParse(s, out result1)) && (string.IsNullOrEmpty(dec2Oct1) || string.IsNullOrEmpty(dec2Oct1) && string.IsNullOrEmpty(s.Replace(this.TIC, string.Empty))))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[0].ToString();
    }
    string dec2Oct3 = string.Empty;
    if (strArray.Length > 1)
    {
      if (!string.IsNullOrEmpty(strArray[1]))
        totalWidth = int.Parse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty));
    }
    try
    {
      if (this.ComputeIsNumber(dec2Oct1) != this.TRUEVALUESTR || double.Parse(dec2Oct1) < -536870912.0 || double.Parse(dec2Oct1) > 536870911.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Input value should be in between -536870912 and 536870911");
        return this.ErrorStrings[4].ToString();
      }
      dec2Oct3 = this.BaseToBase(dec2Oct1, 10, 8);
      double result2;
      if (double.TryParse(dec2Oct1, out result2) && result2 < 0.0)
        dec2Oct3 = dec2Oct3.Substring(dec2Oct3.Length - 10);
      if (strArray.Length > 1)
      {
        if (totalWidth > 10 || !string.IsNullOrEmpty(strArray[1]) && totalWidth < dec2Oct3.Length && dec2Oct3.Length != 10)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
          return this.ErrorStrings[4].ToString();
        }
        if (totalWidth <= 10)
          dec2Oct3 = dec2Oct3.PadLeft(totalWidth, '0');
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
    }
    return dec2Oct3;
  }

  public string ComputeDec2Hex(string argList)
  {
    int totalWidth = 0;
    int result1 = 0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string dec2Hex1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    string str1 = strArray.Length > 1 ? this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty) : "10";
    string s = strArray.Length <= 1 || string.IsNullOrEmpty(strArray[0]) || !string.IsNullOrEmpty(strArray[1]) || strArray[1].Contains(this.TIC) ? str1 : "10";
    if (string.IsNullOrEmpty(argList) || strArray.Length > 2 || strArray.Length < 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (this.ErrorStrings.Contains((object) dec2Hex1))
      return dec2Hex1;
    if (this.ErrorStrings.Contains((object) s))
      return s;
    double result2;
    if (double.TryParse(s, out result2) && result2 < 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[4].ToString();
    }
    string dec2Hex2 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) dec2Hex2))
      return dec2Hex2;
    if ((!double.TryParse(dec2Hex1, out double _) || !double.TryParse(s.Replace(this.TIC, string.Empty), out result2)) && (string.IsNullOrEmpty(dec2Hex1) || string.IsNullOrEmpty(dec2Hex1) && string.IsNullOrEmpty(s.Replace(this.TIC, string.Empty))))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[0].ToString();
    }
    if (!int.TryParse(dec2Hex1, out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Number should not be < -549,755,813,888 or Number > 549,755,813,887");
      return this.ErrorStrings[4].ToString();
    }
    string str2 = string.Empty;
    if (strArray.Length > 1)
    {
      if (!string.IsNullOrEmpty(strArray[1]))
        totalWidth = int.Parse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty));
    }
    try
    {
      if (this.ComputeIsNumber(dec2Hex1) != this.TRUEVALUESTR || int.Parse(dec2Hex1) < -536870912 /*0xE0000000*/ || int.Parse(dec2Hex1) > 536870911 /*0x1FFFFFFF*/)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Input value should be in between -536870912 and 536870911");
        str2 = this.ErrorStrings[4].ToString();
      }
      else
      {
        str2 = this.BaseToBase(dec2Hex1, 10, 16 /*0x10*/);
        double result3;
        if (double.TryParse(dec2Hex1, out result3) && result3 < 0.0)
          str2 = str2.Substring(str2.Length - 10);
        if (strArray.Length > 1)
        {
          if (totalWidth > 10 || !string.IsNullOrEmpty(strArray[1]) && totalWidth < str2.Length && str2.Length != 10)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
            return this.ErrorStrings[4].ToString();
          }
          if (totalWidth <= 10)
            str2 = str2.PadLeft(totalWidth, '0');
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
    }
    return str2.ToUpper();
  }

  public string ComputeBin2Oct(string argList)
  {
    int totalWidth = 0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    string empty = string.Empty;
    if (strArray.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument should be less than or equal to 2");
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string bin2Oct1 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) bin2Oct1))
      return bin2Oct1;
    string bin2Oct2;
    try
    {
      bool result;
      if (bool.TryParse(str1, out result) || strArray.Length > 1 && bool.TryParse(this.GetValueFromArg(strArray[1]), out result))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Parameter is not valid");
        return this.ErrorStrings[1].ToString();
      }
      if (double.Parse(str1) < 0.0 || strArray.Length > 1 && double.Parse(this.GetValueFromArg(strArray[1])) < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (strArray.Length > 1)
        totalWidth = int.Parse(strArray[1]);
      if (str1.Length == 10 && str1.Substring(0, 1) == "1")
      {
        int startIndex = 10;
        string str2 = "";
        for (int index1 = 0; index1 < 3; ++index1)
        {
          startIndex -= 3;
          int num1 = int.Parse(this.BaseToBase(str1.Substring(startIndex, 3), 2, 8));
          int num2 = 0;
          for (int index2 = num1; index2 > 0; index2 /= 10)
            num2 += index2 % 10;
          str2 = num2.ToString() + str2;
        }
        return "7777777" + str2;
      }
      if (str1.Length > 10)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Parameter is not valid");
        bin2Oct2 = this.ErrorStrings[4].ToString();
      }
      else
      {
        bin2Oct2 = this.BaseToBase(str1, 2, 8);
        if (strArray.Length > 1)
        {
          if (totalWidth >= bin2Oct2.Length && totalWidth <= 10)
          {
            bin2Oct2 = bin2Oct2.PadLeft(totalWidth, '0');
          }
          else
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException("Parameter is not valid");
            bin2Oct2 = this.ErrorStrings[4].ToString();
          }
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" ? this.ErrorStrings[0].ToString() : this.ErrorStrings[4].ToString();
    }
    return bin2Oct2;
  }

  public string ComputeBin2Dec(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Number of Arguments is wrong");
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string bin2Dec = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) bin2Dec))
      return bin2Dec;
    string args = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    try
    {
      if (args == "")
        args = "0";
      string str = Convert.ToInt32(args, 2).ToString();
      return args.Length == 10 && args.Substring(0, 1) == "1" ? (Convert.ToInt32(args.Substring(1), 2) - 512 /*0x0200*/).ToString() : str;
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      if (this.ComputeIsText(args) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return args == "" ? "0" : this.ErrorStrings[4].ToString();
    }
  }

  public string ComputeBin2Hex(string argList)
  {
    double totalWidth = 0.0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string valueFromArg = this.GetValueFromArg(this.StripTics0(strArray[0]));
    string str1 = string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg;
    string empty = string.Empty;
    if (strArray.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string bin2Hex = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) bin2Hex))
      return bin2Hex;
    string str2;
    try
    {
      bool result;
      if (bool.TryParse(str1, out result) || strArray.Length > 1 && bool.TryParse(this.GetValueFromArg(strArray[1]), out result))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Parameter is not valid");
        return this.ErrorStrings[1].ToString();
      }
      if (double.Parse(str1) < 0.0 || strArray.Length > 1 && double.Parse(this.GetValueFromArg(strArray[1])) < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (strArray.Length > 1)
        totalWidth = double.Parse(this.GetValueFromArg(strArray[1]));
      if (str1 == "1111111111")
        return str1.Replace('1', 'F');
      if (str1.Length == 10 && str1.Substring(0, 1) == "1")
        return (1073741312 + int.Parse(Convert.ToString(Convert.ToInt32(str1, 2), 8))).ToString();
      if (str1.Length > 10)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Parameter is not valid");
        str2 = this.ErrorStrings[4].ToString();
      }
      else if (double.Parse(str1) < -1.0 || totalWidth < -1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Parameter is not valid");
        str2 = this.ErrorStrings[4].ToString();
      }
      else
      {
        str2 = this.BaseToBase(str1, 2, 16 /*0x10*/);
        if (strArray.Length > 1)
        {
          if (totalWidth >= (double) str2.Length && totalWidth <= 10.0)
          {
            str2 = str2.PadLeft((int) totalWidth, '0');
          }
          else
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException("Parameter is not valid");
            str2 = this.ErrorStrings[4].ToString();
          }
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" ? "0" : this.ErrorStrings[4].ToString();
    }
    return str2.ToUpper();
  }

  public string ComputeHex2Bin(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (argList.Equals(CalcEngine.ParseArgumentSeparator.ToString()))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[0].ToString());
      return this.ErrorStrings[0].ToString();
    }
    if (strArray.Length == 2)
    {
      string hex2Bin = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) hex2Bin))
        return hex2Bin;
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    string str = strArray.Length == 2 ? this.GetValueFromArg(strArray[1]) : "1";
    string s1 = string.IsNullOrEmpty(str) ? "1" : str;
    double result1 = 0.0;
    if (double.TryParse(s1, out result1) && (result1 < 0.0 || result1 > 10.0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    bool result2;
    if (bool.TryParse(this.GetValueFromArg(strArray[0]), out result2) || strArray.Length == 2 && bool.TryParse(this.GetValueFromArg(strArray[1]), out result2))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    if (!valueFromArg.Equals(string.Empty))
    {
      if (!valueFromArg.StartsWith(this.TIC) && !this.IsCellReference(valueFromArg) && !double.TryParse(valueFromArg, out double _))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[5].ToString());
        return this.ErrorStrings[5].ToString();
      }
    }
    else if (this.IsCellReference(strArray[0]) && valueFromArg.Equals(string.Empty))
      return "0";
    if (valueFromArg.StartsWith(this.TIC) && string.IsNullOrEmpty(valueFromArg.Replace(this.TIC, string.Empty)))
      return "0";
    if (s1.StartsWith(this.TIC) && !double.TryParse(s1.Replace(this.TIC, string.Empty), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    if (!double.TryParse(s1.Replace(this.TIC, string.Empty), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[5].ToString());
      return this.ErrorStrings[5].ToString();
    }
    int totalWidth = (int) result1;
    if (totalWidth < 0 || valueFromArg.StartsWith("-"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    string empty = string.Empty;
    string s2;
    try
    {
      s2 = this.BaseToBase(valueFromArg, 16 /*0x10*/, 2);
      if (valueFromArg.Replace(this.TIC, string.Empty) == "FFFFFFFFFF")
        return valueFromArg.Replace('F', '1').Replace(this.TIC, string.Empty);
      if (s2.Length > 10 || totalWidth > 10 || totalWidth < s2.Length && totalWidth != 0 && strArray.Length > 1 || totalWidth == 0 && strArray.Length > 1)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (totalWidth >= s2.Length)
        s2 = s2.PadLeft(totalWidth, '0');
      else if (totalWidth != 0 && strArray.Length > 1)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      double result3;
      if (double.TryParse(s2, out result3))
      {
        if (result3 > 536870911.0)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid" + ex.Message);
      return this.ErrorStrings[4].ToString();
    }
    return s2;
  }

  public string ComputeHex2Oct(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (strArray.Length == 1 && strArray[0].Contains(CalcEngine.parseArgumentSeparator.ToString()) && !double.TryParse(strArray[0].Replace(this.TIC, string.Empty), out double _))
      return this.ErrorStrings[4].ToString();
    if (argList.Equals(CalcEngine.ParseArgumentSeparator.ToString()))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[0].ToString());
      return this.ErrorStrings[0].ToString();
    }
    if (strArray.Length == 2)
    {
      string hex2Oct = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) hex2Oct))
        return hex2Oct;
    }
    string str1 = this.GetValueFromArg(strArray[0]);
    string str2 = strArray.Length == 2 ? this.GetValueFromArg(strArray[1]) : "0";
    double result1 = 0.0;
    if (!str1.Equals(string.Empty) && !str1.StartsWith(this.TIC) && !this.IsCellReference(str1) && !double.TryParse(str1, out double _))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[5].ToString());
      return this.ErrorStrings[5].ToString();
    }
    bool result2;
    if (bool.TryParse(this.GetValueFromArg(strArray[0]), out result2) || strArray.Length == 2 && bool.TryParse(this.GetValueFromArg(strArray[1]), out result2))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    if (str1.StartsWith(this.TIC) && string.IsNullOrEmpty(str1.Replace(this.TIC, string.Empty)))
      return "0";
    if (str1.Contains(CalcEngine.ParseArgumentSeparator.ToString()))
    {
      int num = str1.IndexOf(CalcEngine.ParseArgumentSeparator);
      str1 = str1.Replace(this.TIC, string.Empty).Substring(0, num - 1);
    }
    string empty = string.Empty;
    if (!double.TryParse(str2.Replace(this.TIC, string.Empty), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    int totalWidth = (int) result1;
    if (totalWidth < 0 || str1.StartsWith("-"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    if (strArray.Length > 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new Exception("Parameter is not valid");
      return this.FormulaErrorStrings[25];
    }
    if (strArray.Length > 1)
      totalWidth = int.Parse(this.StripTics0(strArray[1]));
    string hex2Oct1;
    try
    {
      str1 = str1.Replace(this.TIC, string.Empty);
      hex2Oct1 = this.BaseToBase(str1, 16 /*0x10*/, 8);
      double result3 = 0.0;
      string str3 = this.BaseToBase(str1, 16 /*0x10*/, 2);
      if (str3.Length > 10 && str3.Length % 4 == 0)
      {
        if (str3.StartsWith("1") && double.TryParse(this.BaseToBase(str1, 16 /*0x10*/, 10), out result3) && result3 < 1098974756864.0)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
        if (str3.StartsWith("0") && result3 > 536870911.0)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
      }
      else if (double.TryParse(this.BaseToBase(str1, 16 /*0x10*/, 10), out result3) && result3 > 536870911.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (hex2Oct1.Length > 10)
        hex2Oct1 = hex2Oct1.Substring(hex2Oct1.Length - 10);
      if (strArray.Length > 1)
      {
        if (totalWidth >= hex2Oct1.Length && totalWidth <= 10)
        {
          hex2Oct1 = hex2Oct1.PadLeft(totalWidth, '0');
        }
        else
        {
          if (this.rethrowLibraryComputationExceptions)
            throw new ArgumentException("The second parameter places should be less than or equal to 10");
          hex2Oct1 = this.ErrorStrings[4].ToString();
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.ComputeIsText(str1) == this.TRUEVALUESTR || !(str1 == "") ? this.ErrorStrings[4].ToString() : "0";
    }
    return hex2Oct1;
  }

  public string ComputeHex2Dec(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (string.IsNullOrEmpty(this.StripTics0(argList)))
      return "0";
    string hex2Dec1 = this.GetValueFromArg(strArray[0]);
    if (this.ErrorStrings.Contains((object) hex2Dec1))
      return hex2Dec1;
    double result = 0.0;
    double.TryParse(hex2Dec1, out result);
    if (result < 0.0 || hex2Dec1.Replace(this.TIC, string.Empty).Length > 10 || string.IsNullOrEmpty(this.StripTics0(argList).Trim()))
    {
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    if (hex2Dec1.Contains(CalcEngine.ParseArgumentSeparator.ToString()))
    {
      int num = hex2Dec1.IndexOf(CalcEngine.ParseArgumentSeparator);
      hex2Dec1 = hex2Dec1.Replace(this.TIC, string.Empty).Substring(0, num - 1);
    }
    string empty = string.Empty;
    string hex2Dec2;
    try
    {
      hex2Dec1 = hex2Dec1.Replace(this.TIC, string.Empty);
      if (strArray.Length > 1)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("Only a single argument has to be entered.");
        return this.FormulaErrorStrings[10].ToString();
      }
      hex2Dec2 = this.BaseToBase(hex2Dec1, 16 /*0x10*/, 10);
      if (hex2Dec1.Replace(this.TIC, string.Empty) == "FFFFFFFFFF")
        return "-1";
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      if (this.ComputeIsText(hex2Dec1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return hex2Dec1 == "" ? "0" : this.ErrorStrings[4].ToString();
    }
    return hex2Dec2;
  }

  public string ComputeOct2Bin(string argList)
  {
    int totalWidth = 0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    string empty = string.Empty;
    if (strArray.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.FormulaErrorStrings[25];
    }
    string oct2Bin1 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) oct2Bin1))
      return oct2Bin1;
    string oct2Bin2;
    try
    {
      bool result;
      if (bool.TryParse(str, out result) || strArray.Length > 1 && bool.TryParse(this.GetValueFromArg(strArray[1]), out result))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Parameter is not valid");
        return this.ErrorStrings[1].ToString();
      }
      if (double.Parse(str) < 0.0 || strArray.Length > 1 && double.Parse(this.GetValueFromArg(strArray[1])) < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (strArray.Length > 1)
        totalWidth = int.Parse(strArray[1]);
      oct2Bin2 = this.BaseToBase(str, 8, 2);
      if (strArray.Length > 1)
      {
        if (totalWidth >= oct2Bin2.Length && totalWidth <= 10)
        {
          oct2Bin2 = oct2Bin2.PadLeft(totalWidth, '0');
        }
        else
        {
          if (this.rethrowLibraryComputationExceptions)
            throw new ArgumentException("The second parameter places should be less than or equal to 10");
          oct2Bin2 = this.ErrorStrings[4].ToString();
        }
      }
      else if (oct2Bin2.Length > 10)
        oct2Bin2 = oct2Bin2.Substring(oct2Bin2.Length - 10, 10);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      if (this.ComputeIsText(str) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str == "" ? "0" : this.ErrorStrings[4].ToString();
    }
    return oct2Bin2;
  }

  public string ComputeOct2Hex(string argList)
  {
    int totalWidth = 0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.FormulaErrorStrings[25];
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    bool flag1 = strArray.Length == 2 && strArray[1].Contains("u");
    if (strArray[0].Contains("u") || flag1)
    {
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument value is less than zero");
      return this.ErrorStrings[4].ToString();
    }
    string oct2Hex = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) oct2Hex))
      return oct2Hex;
    bool flag2 = strArray.Length == 2 && this.ComputeIsNumber(strArray[1]) != this.TRUEVALUESTR;
    string empty = string.Empty;
    string str2;
    try
    {
      if (strArray.Length > 2)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Parameter is not valid");
        return this.FormulaErrorStrings[25];
      }
      if (strArray.Length > 1)
        totalWidth = int.Parse(strArray[1]);
      bool result;
      if (bool.TryParse(str1, out result) || strArray.Length > 1 && bool.TryParse(this.GetValueFromArg(strArray[1]), out result))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Parameter is not valid");
        return this.ErrorStrings[1].ToString();
      }
      if (str1.Length > 10)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("Total length should not exceed 10");
        return this.ErrorStrings[4].ToString();
      }
      str2 = empty = this.BaseToBase(str1, 8, 16 /*0x10*/);
      if (strArray.Length > 1)
      {
        if (totalWidth >= str2.Length && totalWidth <= 10)
        {
          str2 = str2.PadLeft(totalWidth, '0');
        }
        else
        {
          if (this.rethrowLibraryComputationExceptions)
            throw new ArgumentException("The second parameter places should be less than or equal to 10");
          return this.ErrorStrings[4].ToString();
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" ? this.ErrorStrings[0].ToString() : this.ErrorStrings[4].ToString();
    }
    return str2.ToUpper();
  }

  public string ComputeOct2Dec(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str = this.GetValueFromArg(strArray[0]);
    string oct2Dec1 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) oct2Dec1))
      return oct2Dec1;
    string empty = string.Empty;
    string oct2Dec2;
    try
    {
      str = str.Replace(this.TIC, string.Empty);
      if (strArray.Length > 1)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("Only a single argument has to be entered.");
        oct2Dec2 = this.formulaErrorStrings[10].ToString();
      }
      else if (str.Length > 10)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("Total length should not exceed 10");
        oct2Dec2 = this.ErrorStrings[4].ToString();
      }
      else
        oct2Dec2 = this.BaseToBase(str, 8, 10);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      if (this.ComputeIsText(str) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str == "" ? "0" : this.ErrorStrings[4].ToString();
    }
    return oct2Dec2;
  }

  public string ComputeReal(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Accepts a single Argument");
      return this.FormulaErrorStrings[10].ToString();
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    if (this.ErrorStrings.Contains((object) valueFromArg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return valueFromArg;
    }
    string args = valueFromArg.Replace(this.TIC, string.Empty).TrimEnd();
    if (args == "")
      return this.ErrorStrings[4].ToString();
    int length1 = args.IndexOf('+');
    int length2 = args.IndexOf('-');
    if (length1 == 0)
      length1 = args.IndexOf('+', 1);
    if (length2 == 0)
      length2 = args.IndexOf('-', 1);
    string str = args.Substring(args.Length - 1, 1);
    bool flag = str == "i" || str == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(args) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    if (args.ToUpper().Equals(this.TRUEVALUESTR) || args.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    if (length1 >= 0 || length2 >= 0)
    {
      if (!flag)
        return this.ErrorStrings[4].ToString();
      return length1 >= 0 ? (this.RethrowLibraryComputationExceptions ? (!(this.ComputeIsText(args.Substring(0, length1)) == this.TRUEVALUESTR) ? args.Substring(0, length1) : "Paramater is not valid") : (!(this.ComputeIsText(args.Substring(0, length1)) == this.TRUEVALUESTR) ? args.Substring(0, length1) : this.ErrorStrings[4].ToString())) : (this.RethrowParseExceptions ? (!(this.ComputeIsText(args.Substring(0, length2 - 1)) == this.TRUEVALUESTR) && !(this.ComputeIsText(args.Substring(length2 + 1, args.Length - length2 - 2)) == this.TRUEVALUESTR) ? args.Substring(0, length2) : "Paramater is not valid") : (!(this.ComputeIsText(args.Substring(0, length2 - 1)) == this.TRUEVALUESTR) && !(this.ComputeIsText(args.Substring(length2 + 1, args.Length - length2 - 2)) == this.TRUEVALUESTR) ? args.Substring(0, length2) : this.ErrorStrings[4].ToString()));
    }
    return flag ? (this.RethrowLibraryComputationExceptions ? (!(this.ComputeIsText(args.Substring(0, args.Length - 1)) == this.TRUEVALUESTR) ? "0" : "Paramater is not valid") : (!(this.ComputeIsText(args.Substring(0, args.Length - 1)) == this.TRUEVALUESTR) ? "0" : this.ErrorStrings[4].ToString())) : (this.RethrowLibraryComputationExceptions ? (!(this.ComputeIsText(args) == this.TRUEVALUESTR) ? args : "Paramater is not valid") : (!(this.ComputeIsText(args) == this.TRUEVALUESTR) ? args : this.ErrorStrings[4].ToString()));
  }

  public string ComputeImaginary(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Accepts a single Argument");
      return this.FormulaErrorStrings[10].ToString();
    }
    string imaginary = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    if (imaginary == "")
      return this.ErrorStrings[4].ToString();
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    string args = imaginary.Replace("+i", "+1i").Replace("-i", "-1i").Replace("+j", "+1j").Replace("-j", "-1j");
    if (args.ToUpper().Equals(this.TRUEVALUESTR) || args.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    int length = args.IndexOf('+');
    int num = args.IndexOf('-');
    if (length == 0)
      length = args.IndexOf('+', 1);
    if (num == 0)
      num = args.IndexOf('-', 1);
    string str1 = args.Substring(args.Length - 1, 1);
    bool flag = str1 == "i" || str1 == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(args) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    if (length >= 0 || num >= 0)
    {
      if (!flag)
        return this.ErrorStrings[4].ToString();
      return length >= 0 ? (this.RethrowLibraryComputationExceptions ? (!(this.ComputeIsText(args.Substring(0, length)) == this.TRUEVALUESTR) ? args.Substring(length + 1, args.Length - length - 2) : "Paramater is not valid") : (!(this.ComputeIsText(args.Substring(0, length)) == this.TRUEVALUESTR) ? args.Substring(length + 1, args.Length - length - 2) : this.ErrorStrings[4].ToString())) : (this.RethrowLibraryComputationExceptions ? (!(this.ComputeIsText(args.Substring(0, num - 1)) == this.TRUEVALUESTR) && !(this.ComputeIsText(args.Substring(num + 1, args.Length - num - 2)) == this.TRUEVALUESTR) ? "-" + args.Substring(num + 1, args.Length - num - 2) : "Paramater is not valid") : (!(this.ComputeIsText(args.Substring(0, num - 1)) == this.TRUEVALUESTR) && !(this.ComputeIsText(args.Substring(num + 1, args.Length - num - 2)) == this.TRUEVALUESTR) ? "-" + args.Substring(num + 1, args.Length - num - 2) : this.ErrorStrings[4].ToString()));
    }
    if (flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        return !(this.ComputeIsText(args.Substring(0, args.Length - 1)) == this.TRUEVALUESTR) ? args.Substring(0, args.Length - 1) : "Paramater is not valid";
      string str2 = this.ComputeIsText(args.Substring(0, args.Length - 1)) == this.TRUEVALUESTR ? this.ErrorStrings[4].ToString() : args.Substring(0, args.Length - 1);
      return str2 == "" ? "1" : str2;
    }
    return !(this.ComputeIsText(args) == this.TRUEVALUESTR) ? "0" : this.ErrorStrings[4].ToString();
  }

  public string ComputeImABS(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string imAbs = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.FormulaErrorStrings[25].ToString();
    }
    if (this.ErrorStrings.Contains((object) imAbs))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return imAbs;
    }
    if (imAbs == "")
      return this.ErrorStrings[4].ToString();
    if (imAbs.ToUpper().Equals(this.TRUEVALUESTR) || imAbs.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str = imAbs.Substring(imAbs.Length - 1, 1);
    bool flag = str == "i" || str == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(imAbs) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(imAbs);
    string imaginary = this.ComputeImaginary(imAbs);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      return Math.Sqrt(Math.Pow(double.Parse(real), 2.0) + Math.Pow(double.Parse(imaginary), 2.0)).ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(imAbs) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return imAbs == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[4].ToString();
    }
  }

  public string ComputeImProduct(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string empty = string.Empty;
    int index1 = 0;
    strArray[0] = this.GetValueFromArg(strArray[0]);
    string real1 = this.ComputeReal(strArray[0]);
    string imaginary1 = this.ComputeImaginary(strArray[0]);
    if (strArray.Length < 1)
      return this.ErrorStrings[5].ToString();
    string imProduct = strArray[0].Replace(this.TIC, string.Empty);
    if (imProduct == "")
      return this.ErrorStrings[4].ToString();
    if (strArray.Length == 1 && this.ComputeIsText(strArray[index1]) == this.FALSEVALUESTR)
      imProduct = strArray[index1];
    if (imProduct.ToUpper().Equals(this.TRUEVALUESTR) || imProduct.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str1 = imProduct.Substring(imProduct.Length - 1, 1);
    bool flag1 = str1 == "i" || str1 == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(imProduct) && !flag1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    for (int index2 = 1; index2 < strArray.Length; ++index2)
    {
      if (imProduct != string.Empty)
      {
        real1 = this.ComputeReal(imProduct);
        imaginary1 = this.ComputeImaginary(imProduct);
      }
      string real2 = this.ComputeReal(strArray[index2]);
      string imaginary2 = this.ComputeImaginary(strArray[index2]);
      if (strArray[index2].Contains(this.TIC))
        strArray[index2] = strArray[index2].Replace(this.TIC, string.Empty);
      if (strArray[index2] == "")
        return this.ErrorStrings[4].ToString();
      string str2 = strArray[index2].Substring(strArray[index2].Length - 1, 1);
      bool flag2 = str2 == "i" || str2 == "j";
      if (str1 != str2 && flag2 && flag1)
        return this.ErrorStrings[1].ToString();
      str1 = str2;
      flag1 = flag2;
      if (this.ErrorStrings.Contains((object) real1))
        return real1;
      if (this.ErrorStrings.Contains((object) imaginary1))
        return imaginary1;
      if (this.ErrorStrings.Contains((object) real2))
        return real2;
      if (this.ErrorStrings.Contains((object) imaginary2))
        return imaginary2;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      try
      {
        double num1 = double.Parse(real1);
        double num2 = double.Parse(imaginary1);
        double num3 = double.Parse(real2);
        double num4 = double.Parse(imaginary2);
        double num5 = num1 * num3 - num2 * num4;
        double num6 = num1 * num4 + num2 * num3;
        imProduct = this.ComputeComplex(num5.ToString() + (object) CalcEngine.ParseArgumentSeparator + num6.ToString());
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (!this.rethrowLibraryComputationExceptions)
          return this.FormulaErrorStrings[21].ToString();
        throw;
      }
    }
    return imProduct;
  }

  public string ComputeComplex(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length < 2 || strArray.Length > 3)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[13].ToString());
      return this.FormulaErrorStrings[13].ToString();
    }
    for (int index = 0; index < 2; ++index)
    {
      string complex = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) complex))
        return complex;
    }
    string complex1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str1 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    try
    {
      if (double.IsInfinity(double.Parse(complex1)) || double.IsInfinity(double.Parse(str1)) || double.IsNaN(double.Parse(complex1)) || double.IsNaN(double.Parse(str1)))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException();
        return this.ErrorStrings[4].ToString();
      }
      if (strArray.Length <= 3)
      {
        string str2;
        string str3 = ((strArray.Length != 3 ? "" : strArray[2]) == "" ? "i" : (str2 = strArray[2])).Replace(this.TIC, string.Empty);
        if (str3 != "i" && str3 != "j")
        {
          if (this.rethrowLibraryComputationExceptions)
            throw new ArgumentException("Suffix is not Appropriate");
          return this.ErrorStrings[1].ToString();
        }
        if (double.Parse(complex1) == 0.0 && double.Parse(str1) == 0.0)
          return "0";
        if (double.Parse(complex1) == 0.0)
          return double.Parse(str1) == 1.0 ? str3 : str1.ToString() + str3;
        if (double.Parse(str1) == 0.0)
          return complex1;
        string str4 = double.Parse(str1) > 0.0 ? "+" : "";
        return complex1 + str4 + (double.Parse(str1) == 1.0 ? str3 : str1 + str3);
      }
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("The number of Argument is wrong");
      return this.FormulaErrorStrings[21].ToString();
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(complex1) == this.TRUEVALUESTR || this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return complex1 == "" || str1 == "" ? this.ErrorStrings[0].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeImSum(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string imSum = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (imSum == "")
      return this.ErrorStrings[4].ToString();
    if (imSum.ToUpper().Equals(this.TRUEVALUESTR) || imSum.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str1 = imSum.Substring(imSum.Length - 1, 1);
    bool flag1 = str1 == "i" || str1 == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(imSum) && !flag1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    for (int index = 1; index < strArray.Length; ++index)
    {
      string real = this.ComputeReal(imSum);
      string imaginary = this.ComputeImaginary(imSum);
      string s1;
      string s2;
      if (strArray.Length > 1)
      {
        s1 = this.ComputeReal(strArray[index]);
        s2 = this.ComputeImaginary(strArray[index]);
        if (strArray[index].Contains(this.TIC))
          strArray[index] = strArray[index].Replace(this.TIC, string.Empty);
      }
      else
      {
        s1 = "0";
        s2 = "0";
      }
      if (this.ErrorStrings.Contains((object) real))
        return real;
      if (this.ErrorStrings.Contains((object) imaginary))
        return imaginary;
      if (this.ErrorStrings.Contains((object) s1))
        return s1;
      if (this.ErrorStrings.Contains((object) s2))
        return s2;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
      string str2 = strArray[index].Substring(strArray[index].Length - 1, 1);
      bool flag2 = str2 == "i" || str2 == "j";
      if (str2 != str1 && flag1 && flag2)
        return this.ErrorStrings[1].ToString();
      str1 = str2;
      flag1 = flag2;
      try
      {
        imSum = this.ComputeComplex((double.Parse(real) + double.Parse(s1)).ToString() + (object) CalcEngine.ParseArgumentSeparator + (double.Parse(imaginary) + double.Parse(s2)).ToString());
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("The Parameters are not correct");
        if (this.ComputeIsText(imSum) == this.TRUEVALUESTR)
          return this.ErrorStrings[5].ToString();
        return imSum == "" ? this.ErrorStrings[4].ToString() : this.ErrorStrings[1].ToString();
      }
    }
    return imSum;
  }

  public string ComputeImSub(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string imSub = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string argList1 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    if (imSub == "" || argList1 == "")
      return this.ErrorStrings[4].ToString();
    if (imSub.ToUpper().Equals(this.TRUEVALUESTR) || imSub.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str1 = imSub.Substring(imSub.Length - 1, 1);
    bool flag1 = str1 == "i" || str1 == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(imSub) && !flag1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    for (int index = 1; index < strArray.Length; ++index)
    {
      strArray[index] = strArray[index].Replace(this.TIC, string.Empty);
      string real1 = this.ComputeReal(imSub);
      string imaginary1 = this.ComputeImaginary(imSub);
      string real2 = this.ComputeReal(argList1);
      string imaginary2 = this.ComputeImaginary(argList1);
      string str2 = strArray[index].Substring(strArray[index].Length - 1, 1);
      bool flag2 = str2 == "i" || str2 == "j";
      if (str2 != str1 && flag1 && flag2)
        return this.ErrorStrings[1].ToString();
      if (this.ErrorStrings.Contains((object) real1))
        return real1;
      if (this.ErrorStrings.Contains((object) imaginary1))
        return imaginary1;
      if (this.ErrorStrings.Contains((object) real2))
        return real2;
      if (this.ErrorStrings.Contains((object) imaginary2))
        return imaginary2;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      try
      {
        imSub = this.ComputeComplex((double.Parse(real1) - double.Parse(real2)).ToString() + (object) CalcEngine.ParseArgumentSeparator + (double.Parse(imaginary1) - double.Parse(imaginary2)).ToString());
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions)
          throw;
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[21].ToString());
        return this.FormulaErrorStrings[21].ToString();
      }
    }
    return imSub;
  }

  public string ComputeImConjugate(string argList)
  {
    string str1 = string.Empty;
    bool flag = false;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Accepts a single Argument");
      return this.FormulaErrorStrings[10].ToString();
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    if (valueFromArg == "")
      return this.ErrorStrings[4].ToString();
    if (valueFromArg.ToUpper().Equals(this.TRUEVALUESTR) || valueFromArg.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = valueFromArg.Replace(this.TIC, "");
    if (str2.Length > 1)
    {
      string str3 = str2.Substring(valueFromArg.Length - 3);
      flag = str3 == "i" || str3 == "j";
      str1 = str3 == "i" || str3 == "j" ? str3 : "i";
    }
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(valueFromArg) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(valueFromArg);
    string imaginary = this.ComputeImaginary(valueFromArg);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      string argList1 = $"{double.Parse(real).ToString()}{(object) CalcEngine.ParseArgumentSeparator}-{double.Parse(imaginary).ToString()}{(object) CalcEngine.ParseArgumentSeparator}{str1}";
      return imaginary != "0" ? this.ComputeComplex(argList1) : valueFromArg;
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The parameter is not valid");
      return this.FormulaErrorStrings[21].ToString();
    }
  }

  public string ComputeImDiv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string args = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (args == "")
      return this.ErrorStrings[4].ToString();
    if (args.ToUpper().Equals(this.TRUEVALUESTR) || args.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str1 = args.Substring(args.Length - 1, 1);
    bool flag1 = str1 == "i" || str1 == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR)
    {
      if (!this.IsCellReference(args))
      {
        if (!flag1)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException("Argument is not valid");
          return this.ErrorStrings[4].ToString();
        }
      }
    }
    try
    {
      if (strArray.Length <= 1 || strArray.Length > 2)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Number of Arguments is incorrect");
        return this.FormulaErrorStrings[13].ToString();
      }
      string real1 = this.ComputeReal(strArray[0].Replace(this.TIC, ""));
      string imaginary1 = this.ComputeImaginary(strArray[0].Replace(this.TIC, ""));
      string argList1 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
      string str2 = argList1.Substring(argList1.Length - 1, 1);
      bool flag2 = str2 == "i" || str2 == "j";
      if (str2 != str1 && flag1 && flag2)
        return this.ErrorStrings[4].ToString();
      string real2 = this.ComputeReal(argList1);
      string imaginary2 = this.ComputeImaginary(argList1);
      if (this.ErrorStrings.Contains((object) real1))
        return real1;
      if (this.ErrorStrings.Contains((object) imaginary1))
        return imaginary1;
      if (this.ErrorStrings.Contains((object) real2))
        return real2;
      if (this.ErrorStrings.Contains((object) imaginary2))
        return imaginary2;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      if (real2 == "0" && imaginary2 == "0")
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("inumber2 is null");
        return this.ErrorStrings[4].ToString();
      }
      double num1 = double.Parse(real1);
      double num2 = double.Parse(imaginary1);
      double num3 = double.Parse(real2);
      double num4 = double.Parse(imaginary2);
      double num5 = num3 * num3 + num4 * num4;
      return this.ComputeComplex(((num1 * num3 + num2 * num4) / num5).ToString() + (object) CalcEngine.ParseArgumentSeparator + ((num2 * num3 - num1 * num4) / num5).ToString()).ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(args) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return args == "" ? this.ErrorStrings[4].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeImSqrt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("A single argument is alone needed");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      string s = Math.Sqrt((double.Parse(Math.Sqrt(double.Parse(real) * double.Parse(real) + double.Parse(imaginary) * double.Parse(imaginary)).ToString()) - double.Parse(real)) / 2.0).ToString();
      return this.ComputeComplex((double.Parse(imaginary) / (2.0 * double.Parse(s))).ToString() + (object) CalcEngine.ParseArgumentSeparator + s);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("The parameter is not valid");
        return this.ErrorStrings[5].ToString();
      }
      if (str1 == "" && this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The parameter is not valid");
      return this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeImArgument(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Only a single Argument is required");
      return this.FormulaErrorStrings[10].ToString();
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1, 1);
    bool flag = str2 == "i" || str2 == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    try
    {
      if (this.ErrorStrings.Contains((object) real))
        return real;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      if (this.ErrorStrings.Contains((object) imaginary))
        return imaginary;
      double num1 = double.Parse(real);
      double num2 = double.Parse(imaginary);
      if (num1 == 0.0 && num2 == 0.0)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("Paramater is not valid");
        return this.ErrorStrings[3].ToString();
      }
      if (num1 == 0.0 && num2 > 0.0)
        return (Math.PI / 2.0).ToString();
      if (num1 == 0.0 && num2 < 0.0)
        return (-1.0 * Math.PI / 2.0).ToString();
      if (num2 == 0.0 && num1 > 0.0)
        return "0";
      if (num2 == 0.0 && num1 < 0.0)
        return (-1.0 * Math.PI).ToString();
      if (num1 > 0.0)
        return Math.Atan(num2 / num1).ToString();
      return num1 < 0.0 && num2 >= 0.0 ? (Math.Atan(num2 / num1) + Math.PI).ToString() : (Math.Atan(num2 / num1) - Math.PI).ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (!this.rethrowLibraryComputationExceptions)
        return this.ErrorStrings[4].ToString();
      throw;
    }
  }

  public string ComputeIMSin(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
      return this.FormulaErrorStrings[10].ToString();
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      double num1 = double.Parse(real);
      double d = double.Parse(imaginary);
      double num2 = Math.Sin(num1) * (Math.Exp(d) + Math.Exp(-d)) / 2.0;
      double num3 = Math.Cos(num1) * (Math.Exp(d) - Math.Exp(-d)) / 2.0;
      return this.ComputeComplex(num2.ToString() + (object) CalcEngine.ParseArgumentSeparator + num3.ToString() + (object) CalcEngine.ParseArgumentSeparator + str3);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" ? this.ErrorStrings[4].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeImSinH(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
      return this.FormulaErrorStrings[10].ToString();
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      double d = double.Parse(real);
      double num1 = double.Parse(imaginary);
      double num2 = Math.Cos(num1) * ((Math.Exp(d) - Math.Exp(-d)) / 2.0);
      double num3 = Math.Sin(num1) * (Math.Exp(d) + Math.Exp(-d)) / 2.0;
      return this.ComputeComplex(num2.ToString() + (object) CalcEngine.ParseArgumentSeparator + num3.ToString());
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[1].ToString();
      if (str1 == "")
        return this.ErrorStrings[4].ToString();
      return double.Parse(str1) < 0.0 ? this.ErrorStrings[5].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeIMCSC(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Only a single Argument is needed");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      string imSin = this.ComputeIMSin(argList);
      return this.ErrorStrings.Contains((object) imSin) ? imSin : this.ComputeImDiv($"1{(object) CalcEngine.ParseArgumentSeparator}{imSin}");
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.FormulaErrorStrings[21].ToString();
    }
  }

  public string ComputeIMCos(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("A single argument is alone needed");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      double num1 = double.Parse(real);
      double d = double.Parse(imaginary);
      double num2 = Math.Cos(num1) * (Math.Exp(d) + Math.Exp(-d)) / 2.0;
      double num3 = -Math.Sin(num1) * (Math.Exp(d) - Math.Exp(-d)) / 2.0;
      return this.ComputeComplex(num2.ToString() + (object) CalcEngine.ParseArgumentSeparator + num3.ToString() + (object) CalcEngine.ParseArgumentSeparator + str3);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" ? this.ErrorStrings[4].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeIMSEC(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Only a single Argument has to he used");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    string imCos = this.ComputeIMCos(argList);
    return this.ErrorStrings.Contains((object) imCos) ? imCos : this.ComputeImDiv($"1{(object) CalcEngine.ParseArgumentSeparator}{imCos}");
  }

  public string ComputeIMTan(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Accepts a single Argument");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      string imSin = this.ComputeIMSin(argList);
      string imCos = this.ComputeIMCos(argList);
      if (this.ErrorStrings.Contains((object) imSin))
        return imSin;
      return this.ErrorStrings.Contains((object) imCos) ? imCos : this.ComputeImDiv(imSin + (object) CalcEngine.ParseArgumentSeparator + imCos);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeImCot(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string args = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1 || strArray.Length < 1)
      return this.FormulaErrorStrings[10].ToString();
    if (args == "")
      return this.ErrorStrings[4].ToString();
    if (args.ToUpper().Equals(this.TRUEVALUESTR) || args.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str1 = args.Substring(args.Length - 1);
    bool flag = str1 == "i" || str1 == "j";
    string str2 = str1 == "i" || str1 == "j" ? str1 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR)
    {
      if (!this.IsCellReference(args))
      {
        if (!flag)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException("Argument is not valid");
          return this.ErrorStrings[4].ToString();
        }
      }
    }
    try
    {
      string imCos = this.ComputeIMCos(argList);
      string imSin = this.ComputeIMSin(argList);
      if (this.ErrorStrings.Contains((object) imCos))
        return imCos;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      return this.ErrorStrings.Contains((object) imSin) ? imSin : this.ComputeImDiv(imCos + (object) CalcEngine.ParseArgumentSeparator + imSin);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[21].ToString());
      return this.FormulaErrorStrings[21].ToString();
    }
  }

  public string ComputeIMCSCH(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      string imSinH = this.ComputeImSinH(argList);
      return this.ErrorStrings.Contains((object) imSinH) ? imSinH : this.ComputeImDiv($"1{(object) CalcEngine.ParseArgumentSeparator}{imSinH}");
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || double.Parse(str1) >= 0.0 ? this.ErrorStrings[1].ToString() : this.ErrorStrings[4].ToString();
    }
  }

  public string ComputeImCosH(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("A single argument is alone needed");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR)
    {
      if (!this.IsCellReference(str1))
      {
        if (!flag)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException("Argument is not valid");
          return this.ErrorStrings[4].ToString();
        }
      }
    }
    try
    {
      string real = this.ComputeReal(str1);
      string imaginary = this.ComputeImaginary(str1);
      if (this.ErrorStrings.Contains((object) real))
        return real;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      if (this.ErrorStrings.Contains((object) imaginary))
        return imaginary;
      double d = double.Parse(real);
      double num1 = double.Parse(imaginary);
      double num2 = Math.Cos(num1) * (Math.Exp(d) + Math.Exp(-d)) / 2.0;
      double num3 = Math.Sin(num1) * (Math.Exp(d) - Math.Exp(-d)) / 2.0;
      return num2.ToString() == "Infinity" || num2.ToString() == "NaN" || num3.ToString() == "Infinity" || num3.ToString() == "NaN" ? this.ErrorStrings[4].ToString() : this.ComputeComplex(num2.ToString() + (object) CalcEngine.ParseArgumentSeparator + num3.ToString());
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[1].ToString();
      return str1 == "" ? this.ErrorStrings[4].ToString() : this.ErrorStrings[5].ToString();
    }
  }

  public string ComputeIMTanH(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      string imSinH = this.ComputeImSinH(argList);
      string imCosH = this.ComputeImCosH(argList);
      if (this.ErrorStrings.Contains((object) imSinH))
        return imSinH;
      return this.ErrorStrings.Contains((object) imCosH) ? imCosH : this.ComputeImDiv(imSinH + (object) CalcEngine.ParseArgumentSeparator + imCosH);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeIMCotH(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string args = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    if (strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (args == "")
      return this.ErrorStrings[4].ToString();
    try
    {
      string imSinH = this.ComputeImSinH(argList);
      string imCosH = this.ComputeImCosH(argList);
      if (this.ErrorStrings.Contains((object) imSinH))
        return imSinH;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      return this.ErrorStrings.Contains((object) imCosH) ? imCosH : this.ComputeImDiv(imCosH + (object) CalcEngine.ParseArgumentSeparator + imSinH);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(args) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return args == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeIMSecH(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    try
    {
      if (strArray.Length > 1)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("parameter is not valid");
        return this.FormulaErrorStrings[10].ToString();
      }
      if (str1 == "")
        return this.ErrorStrings[4].ToString();
      if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
        return this.ErrorStrings[1].ToString();
      string str2 = str1.Substring(str1.Length - 1);
      bool flag = str2 == "i" || str2 == "j";
      if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Argument is not valid");
        return this.ErrorStrings[4].ToString();
      }
      string real = this.ComputeReal(str1);
      string imaginary = this.ComputeImaginary(str1);
      if (this.ErrorStrings.Contains((object) real))
        return real;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      if (this.ErrorStrings.Contains((object) imaginary))
        return imaginary;
      string imCosH = this.ComputeImCosH(argList);
      return this.ErrorStrings.Contains((object) imCosH) ? imCosH : this.ComputeImDiv($"1{(object) CalcEngine.ParseArgumentSeparator}{imCosH}");
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeIMLOG10(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Only a single argument has to be entered");
      return this.FormulaErrorStrings[13].ToString();
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      double num1 = double.Parse(real);
      double num2 = double.Parse(imaginary);
      double num3 = Math.Log(Math.Sqrt(num1 * num1 + num2 * num2)) / Math.Log(10.0);
      double num4 = Math.Atan(num2 / num1) / Math.Log(10.0);
      return this.ComputeComplex(num3.ToString() + (object) CalcEngine.ParseArgumentSeparator + num4.ToString() + (object) CalcEngine.ParseArgumentSeparator + str3);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[5].ToString() + ": The parameter is not valid");
        return this.ErrorStrings[5].ToString();
      }
      if (str1 == "")
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[1].ToString() + ": The parameter is not valid");
        return this.ErrorStrings[1].ToString();
      }
      if (double.Parse(str1) < 0.0)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString() + ": The parameter is not valid");
        return this.ErrorStrings[4].ToString();
      }
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString() + ": The parameter is not valid");
      return this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeIMLOG2(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    if (strArray.Length > 1)
      return this.FormulaErrorStrings[10].ToString();
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      double num1 = double.Parse(real);
      double num2 = double.Parse(imaginary);
      double num3 = Math.Log(Math.Sqrt(num1 * num1 + num2 * num2)) / Math.Log(2.0);
      double num4 = Math.Atan(num2 / num1) / Math.Log(2.0);
      return this.ComputeComplex(num3.ToString() + (object) CalcEngine.ParseArgumentSeparator + num4.ToString() + (object) CalcEngine.ParseArgumentSeparator + str3);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || double.Parse(str1) >= 0.0 ? this.ErrorStrings[1].ToString() : this.ErrorStrings[4].ToString();
    }
  }

  public string ComputeIMLN(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Only a single argument has to be entered");
      return this.FormulaErrorStrings[13].ToString();
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      double num1 = double.Parse(real);
      double num2 = double.Parse(imaginary);
      double num3 = Math.Log(Math.Sqrt(num1 * num1 + num2 * num2));
      double num4 = Math.Atan(num2 / num1);
      return this.ComputeComplex(num3.ToString() + (object) CalcEngine.ParseArgumentSeparator + num4.ToString() + (object) CalcEngine.ParseArgumentSeparator + str3);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || double.Parse(str1) >= 0.0 ? this.ErrorStrings[1].ToString() : this.ErrorStrings[4].ToString();
    }
  }

  public string ComputeImEXP(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    int length = strArray.GetLength(0);
    if (string.IsNullOrEmpty(argList) || length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException("Wrong number of argument");
      return this.FormulaErrorStrings[25].ToString();
    }
    if (str1 == "")
      return this.ErrorStrings[4].ToString();
    if (this.IsCellReference(strArray[0]) && string.IsNullOrEmpty(str1))
      return "1";
    if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
      return this.ErrorStrings[1].ToString();
    string str2 = str1.Substring(str1.Length - 1);
    bool flag = str2 == "i" || str2 == "j";
    string str3 = str2 == "i" || str2 == "j" ? str2 : "i";
    if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    string real = this.ComputeReal(str1);
    string imaginary = this.ComputeImaginary(str1);
    if (this.ErrorStrings.Contains((object) real))
      return real;
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException("Paramater is not valid");
    if (this.ErrorStrings.Contains((object) imaginary))
      return imaginary;
    try
    {
      double d = double.Parse(real);
      double num1 = double.Parse(imaginary);
      double num2 = Math.Exp(d);
      double num3 = num2 * Math.Cos(num1);
      double num4 = num2 * Math.Sin(num1);
      return this.ComputeComplex(num3.ToString() + (object) CalcEngine.ParseArgumentSeparator + num4.ToString() + (object) CalcEngine.ParseArgumentSeparator + str3);
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      return str1.Contains(this.TIC) ? this.ErrorStrings[4].ToString() : this.ErrorStrings[5].ToString();
    }
  }

  public string ComputeImPower(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length == 2)
    {
      string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
      string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
      if (str1 == "")
        return this.ErrorStrings[4].ToString();
      if (str1.ToUpper().Equals(this.TRUEVALUESTR) || str1.ToUpper().Equals(this.FALSEVALUESTR))
        return this.ErrorStrings[1].ToString();
      string str3 = str1.Substring(str1.Length - 1);
      bool flag = str3 == "i" || str3 == "j";
      string str4 = str3 == "i" || str3 == "j" ? str3 : "i";
      if (this.ComputeIsText(this.GetValueFromArg(strArray[0])) == this.TRUEVALUESTR && !this.IsCellReference(str1) && !flag)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Argument is not valid");
        return this.ErrorStrings[4].ToString();
      }
      string real = this.ComputeReal(str1);
      string imaginary = this.ComputeImaginary(str1);
      if (this.ErrorStrings.Contains((object) real))
        return real;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Paramater is not valid");
      if (this.ErrorStrings.Contains((object) imaginary))
        return imaginary;
      try
      {
        double x1 = double.Parse(real);
        double y = double.Parse(imaginary);
        double x2 = Math.Sqrt(x1 * x1 + y * y);
        double num = Math.Atan2(y, x1);
        return this.ComputeComplex(this.ComputeRound((Math.Pow(x2, double.Parse(str2)) * double.Parse(this.ComputeCos((num * double.Parse(str2)).ToString()))).ToString()) + (object) CalcEngine.ParseArgumentSeparator + this.ComputeRound((Math.Pow(x2, double.Parse(str2)) * double.Parse(this.ComputeSin((num * double.Parse(str2)).ToString()))).ToString()) + (object) CalcEngine.ParseArgumentSeparator + str4);
      }
      catch
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("The Parameters are not correct");
        if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
          return this.ErrorStrings[5].ToString();
        return str1 == "" || str2 == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[1].ToString();
      }
    }
    else
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Number of parameters is not valid");
      return this.FormulaErrorStrings[this.wrong_number_arguments].ToString();
    }
  }

  public string ComputeImaginaryDifference(string argList) => this.ComputeImSub(argList);

  internal bool InvertMatrix(double[,] A, out double[,] invA)
  {
    bool flag = true;
    if (A.GetLength(0) != A.GetLength(1))
    {
      invA = A;
      return false;
    }
    int length = A.GetLength(0);
    double[,] numArray1 = (double[,]) A.Clone();
    double[,] numArray2 = new double[length, length];
    for (int index = 0; index < length; ++index)
      numArray2[index, index] = 1.0;
    for (int index1 = 0; index1 < length; ++index1)
    {
      int index2 = index1;
      double num1 = 0.0;
      int index3 = index2;
      for (int index4 = index2; index4 < length; ++index4)
      {
        double num2 = numArray1[index4, index2];
        if (num2 > num1)
        {
          num1 = num2;
          index3 = index4;
        }
      }
      if (index3 != index2)
      {
        for (int index5 = index2; index5 < length; ++index5)
        {
          double num3 = numArray1[index2, index5];
          numArray1[index2, index5] = numArray1[index3, index5];
          numArray1[index3, index5] = num3;
        }
        for (int index6 = 0; index6 < length; ++index6)
        {
          double num4 = numArray2[index2, index6];
          numArray2[index2, index6] = numArray2[index3, index6];
          numArray2[index3, index6] = num4;
        }
      }
      for (int index7 = index2 + 1; index7 < length; ++index7)
      {
        if (numArray1[index2, index2] == 0.0)
        {
          flag = false;
          numArray1[index2, index2] = 1E-60;
        }
        double num5 = numArray1[index7, index2] / numArray1[index2, index2];
        if (num5 != 0.0)
        {
          for (int index8 = index2; index8 < length; ++index8)
            numArray1[index7, index8] -= num5 * numArray1[index2, index8];
          for (int index9 = 0; index9 < length; ++index9)
            numArray2[index7, index9] -= num5 * numArray2[index2, index9];
        }
      }
    }
    for (int index10 = length - 1; index10 >= 0; --index10)
    {
      int index11 = index10;
      if (numArray1[index11, index11] == 0.0)
      {
        flag = false;
        numArray1[index11, index11] = 1E-60;
      }
      for (int index12 = index11 - 1; index12 >= 0; --index12)
      {
        double num = numArray1[index12, index11] / numArray1[index11, index11];
        numArray1[index12, index11] = 0.0;
        if (num != 0.0)
        {
          for (int index13 = 0; index13 < length; ++index13)
            numArray2[index12, index13] -= num * numArray2[index11, index13];
        }
      }
    }
    for (int index14 = 0; index14 < length; ++index14)
    {
      double num = numArray1[index14, index14];
      for (int index15 = 0; index15 < length; ++index15)
        numArray2[index14, index15] /= num;
    }
    invA = numArray2;
    return flag;
  }

  public string ComputeBitOr(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = (string) null;
    string str2 = (string) null;
    try
    {
      if (strArray.Length != 2)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("");
        return this.FormulaErrorStrings[13].ToString();
      }
      string bitOr = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) bitOr))
        return bitOr;
      str1 = this.GetValueFromArg(strArray[0]);
      str1 = string.IsNullOrEmpty(str1) ? "0" : str1;
      bool result;
      str1 = bool.TryParse(str1, out result) ? Convert.ToInt16(result).ToString() : str1;
      str1 = str1.Replace(this.TIC, "");
      str2 = this.GetValueFromArg(strArray[1]);
      str2 = string.IsNullOrEmpty(str2) ? "0" : str2;
      str2 = bool.TryParse(str2, out result) ? Convert.ToInt16(result).ToString() : str2;
      str2 = str2.Replace(this.TIC, "");
      return (int.Parse(str1) | int.Parse(str2)).ToString();
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || str2 == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeBitXor(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = (string) null;
    string str2 = (string) null;
    try
    {
      if (strArray.Length != 2)
      {
        if (this.rethrowLibraryComputationExceptions)
          throw new ArgumentException("Argument is not valid");
        return this.FormulaErrorStrings[13].ToString();
      }
      string bitXor = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) bitXor))
        return bitXor;
      str1 = this.GetValueFromArg(strArray[0]);
      str1 = string.IsNullOrEmpty(str1) ? "0" : str1;
      bool result;
      str1 = bool.TryParse(str1, out result) ? Convert.ToInt16(result).ToString() : str1;
      str1 = str1.Replace(this.TIC, "");
      str2 = this.GetValueFromArg(strArray[1]);
      str2 = string.IsNullOrEmpty(str2) ? "0" : str2;
      str2 = bool.TryParse(str2, out result) ? Convert.ToInt16(result).ToString() : str2;
      str2 = str2.Replace(this.TIC, "");
      long num1 = (long) int.Parse(str1);
      long num2 = (long) int.Parse(str2);
      if (num1 <= 281474976710655L /*0xFFFFFFFFFFFF*/ && num2 <= 281474976710655L /*0xFFFFFFFFFFFF*/ && num1 >= 0L && num2 >= 0L && Math.Floor(double.Parse(str1)) == (double) num1 && Math.Floor(double.Parse(str2)) == (double) num2)
        return (num1 ^ num2).ToString();
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      return this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR || str1 == "" || str2 == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeBitAnd(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = (string) null;
    string str2 = (string) null;
    try
    {
      if (strArray.Length != 2)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("The paramteter is not valid");
        return this.FormulaErrorStrings[13].ToString();
      }
      string bitAnd = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) bitAnd))
        return bitAnd;
      str1 = this.GetValueFromArg(strArray[0]);
      str1 = string.IsNullOrEmpty(str1) ? "0" : str1;
      bool result;
      str1 = bool.TryParse(str1, out result) ? Convert.ToInt16(result).ToString() : str1;
      str1 = str1.Replace(this.TIC, "");
      str2 = this.GetValueFromArg(strArray[1]);
      str2 = string.IsNullOrEmpty(str2) ? "0" : str2;
      str2 = bool.TryParse(str2, out result) ? Convert.ToInt16(result).ToString() : str2;
      str2 = str2.Replace(this.TIC, "");
      return (int.Parse(str1) & int.Parse(str2)).ToString();
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || str2 == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeBitLShift(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = (string) null;
    string str2 = (string) null;
    try
    {
      if (strArray.Length != 2)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Two Arguments are needed");
        return this.FormulaErrorStrings[13].ToString();
      }
      string bitLshift = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) bitLshift))
        return bitLshift;
      str1 = this.GetValueFromArg(strArray[0]);
      str1 = string.IsNullOrEmpty(str1) ? "0" : str1;
      bool result;
      str1 = bool.TryParse(str1, out result) ? Convert.ToInt16(result).ToString() : str1;
      str1 = str1.Replace(this.TIC, "");
      str2 = this.GetValueFromArg(strArray[1]);
      str2 = string.IsNullOrEmpty(str2) ? "0" : str2;
      str2 = bool.TryParse(str2, out result) ? Convert.ToInt16(result).ToString() : str2;
      str2 = str2.Replace(this.TIC, "");
      long num1 = long.Parse(str1);
      int num2 = int.Parse(str2);
      if (num1 <= 281474976710655L /*0xFFFFFFFFFFFF*/ && Math.Abs(num2) <= 53 && Math.Floor(double.Parse(str1)) == (double) num1 && num1 >= 0L)
        return (num2 >= 0 ? num1 << num2 : num1 >> -num2).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Argument is not valid");
      return this.ErrorStrings[4].ToString();
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || str2 == "" || double.Parse(str1) >= 0.0 && double.Parse(str2) >= 0.0 ? this.ErrorStrings[1].ToString() : this.ErrorStrings[4].ToString();
    }
  }

  public string ComputeBitRShift(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1 = (string) null;
    string str2 = (string) null;
    try
    {
      if (strArray.Length != 2)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Argument is not valid");
        return this.FormulaErrorStrings[13].ToString();
      }
      string bitRshift = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) bitRshift))
        return bitRshift;
      str1 = this.GetValueFromArg(strArray[0]);
      str1 = string.IsNullOrEmpty(str1) ? "0" : str1;
      bool result;
      str1 = bool.TryParse(str1, out result) ? Convert.ToInt16(result).ToString() : str1;
      str1 = str1.Replace(this.TIC, "");
      str2 = this.GetValueFromArg(strArray[1]);
      str2 = string.IsNullOrEmpty(str2) ? "0" : str2;
      str2 = bool.TryParse(str2, out result) ? Convert.ToInt16(result).ToString() : str2;
      str2 = str2.Replace(this.TIC, "");
      long num1 = long.Parse(str1);
      int num2 = int.Parse(str2);
      if (num1 <= 281474976710655L /*0xFFFFFFFFFFFF*/ && Math.Abs(num2) <= 53 && Math.Floor(double.Parse(str1)) == (double) num1 && num1 >= 0L)
        return (num2 >= 0 ? num1 >> num2 : num1 << -num2).ToString();
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Arguments are not valid");
      return this.ErrorStrings[4].ToString();
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || str2 == "" ? this.ErrorStrings[1].ToString() : this.ErrorStrings[4].ToString();
    }
  }

  public string ComputeErf(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string str1;
    string str2;
    if (strArray.Length == 2)
    {
      str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
      str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    }
    else if (strArray.Length == 1)
    {
      str1 = "0";
      str2 = this.GetValueFromArg(strArray[0]);
    }
    else
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Parameter is not valid");
      return this.FormulaErrorStrings[10].ToString();
    }
    if (strArray[0] == string.Empty || strArray.Length == 2 && strArray[1] == string.Empty)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[0].ToString();
    }
    string erf = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) erf))
      return erf;
    try
    {
      string erfPrecise = this.ComputeErfPrecise(str1);
      return (double.Parse(this.ComputeErfPrecise(str2)) - double.Parse(erfPrecise)).ToString();
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      if (str1 == string.Empty || str2 == string.Empty)
        return this.ErrorStrings[0].ToString();
      return double.Parse(str1) < 0.0 || double.Parse(str2) < 0.0 ? this.ErrorStrings[4].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeErfCPrecise(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (string.IsNullOrEmpty(argList) || strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments].ToString();
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    string erfCprecise = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) erfCprecise))
      return erfCprecise;
    bool result1;
    string argList1 = bool.TryParse(valueFromArg, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg;
    double result2 = 0.0;
    double.TryParse(argList1.Replace(this.TIC, string.Empty), out result2);
    double num1 = 0.254829592;
    double num2 = -0.284496736;
    double num3 = 1.421413741;
    double num4 = -1.453152027;
    double num5 = 1.061405429;
    double num6 = 0.3275911;
    if (result2 == 0.0)
      return "1";
    if (result2 < 0.0)
      return (1.0 - double.Parse(this.ComputeErfPrecise(argList1))).ToString();
    double num7 = 1.0 / (1.0 + num6 * result2);
    return (((((num5 * num7 + num4) * num7 + num3) * num7 + num2) * num7 + num1) * num7 * Math.Exp(-result2 * result2)).ToString();
  }

  public string ComputeErfPrecise(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string erfPrecise = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) erfPrecise))
      return erfPrecise;
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    bool result;
    string str = bool.TryParse(valueFromArg, out result) ? Convert.ToInt16(result).ToString() : valueFromArg;
    double num1 = 0.254829592;
    double num2 = -0.284496736;
    double num3 = 1.421413741;
    double num4 = -1.453152027;
    double num5 = 1.061405429;
    double num6 = 0.3275911;
    double num7 = double.Parse(str.Replace(this.TIC, string.Empty));
    int num8 = 1;
    if (num7 == 0.0)
      return "0";
    if (num7 < 0.0)
      num8 = -1;
    double num9 = Math.Abs(num7);
    double num10 = 1.0 / (1.0 + num6 * num9);
    double num11 = 1.0 - ((((num5 * num10 + num4) * num10 + num3) * num10 + num2) * num10 + num1) * num10 * Math.Exp(-num9 * num9);
    return ((double) num8 * num11).ToString();
  }

  public string ComputeBesselI(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string empty1 = string.Empty;
    string empty2 = string.Empty;
    if (strArray.Length > 2 || strArray.Length <= 1)
      return this.FormulaErrorStrings[13].ToString();
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    string besselI = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) besselI))
      return besselI;
    try
    {
      if (double.Parse(str1) == 0.0)
        return "0.0";
      if (double.Parse(str2) < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (double.Parse(str1) < 2.0 && double.Parse(str1) > 1.0)
      {
        double num1 = 2.0 / Math.Abs(double.Parse(str1));
        double num2 = 0.0;
        double num3 = 0.0;
        double num4 = 1.0;
        for (double num5 = Math.Round(2.0 * (double.Parse(str2) + Math.Sqrt(this.ACC * double.Parse(str2)))); num5 > 0.0; --num5)
        {
          double num6 = num3 + num5 * num1 * num4;
          num3 = num4;
          num4 = num6;
          if (Math.Abs(num4) > this.BIGNO)
          {
            num2 *= this.BIGNI;
            num4 *= this.BIGNI;
            num3 *= this.BIGNI;
          }
          string round1 = this.ComputeRound(num5.ToString());
          string round2 = this.ComputeRound(str2);
          if (int.Parse(round1) <= int.Parse(round2))
            num2 = num3;
        }
        double d = num2 * (CalcEngine.besseli0(double.Parse(str1)) / num4);
        return double.IsInfinity(d) || double.IsNaN(d) ? this.ErrorStrings[4].ToString() : (double.Parse(str1) >= 0.0 || int.Parse(str2) % 2 != 0 ? d : -d).ToString();
      }
      double num7 = 2.0 / Math.Abs(double.Parse(str1));
      double num8 = 0.0;
      double num9 = 0.0;
      double num10 = 1.0;
      for (double num11 = Math.Round(2.0 * (double.Parse(str2) + Math.Sqrt(this.ACC * double.Parse(str2)))); num11 > 0.0; --num11)
      {
        double num12 = num9 + num11 * num7 * num10;
        num9 = num10;
        num10 = num12;
        if (Math.Abs(num10) > this.BIGNO)
        {
          num8 *= this.BIGNI;
          num10 *= this.BIGNI;
          num9 *= this.BIGNI;
        }
        if (this.ComputeRound(num11.ToString()) == this.ComputeRound(str2))
          num8 = num9;
      }
      double d1 = num8 * (CalcEngine.besseli0(double.Parse(str1)) / num10);
      double num13 = d1;
      if (double.Parse(str1) < 0.9 && double.Parse(str1) > 0.0)
        return CalcEngine.besseli0(double.Parse(str1)).ToString();
      if (double.Parse(str1) < 0.0)
      {
        double num14;
        return (num14 = num13 * -1.0).ToString();
      }
      return double.IsInfinity(d1) || double.IsNaN(d1) ? this.ErrorStrings[4].ToString() : (double.Parse(str1) >= 0.0 || int.Parse(str2) % 2 != 0 ? d1 : -d1).ToString();
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || str2 == "" ? this.ErrorStrings[0].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public static double besseli0(double x)
  {
    double b0 = 0.0;
    double b1 = 0.0;
    double b2 = 0.0;
    if (x < 0.0)
      x = -x;
    if (x <= 8.0)
    {
      double x1 = x / 2.0 - 2.0;
      CalcEngine.besselmfirstcheb(-4.4153416464793395E-18, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 3.3307945188222384E-17, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -2.4312798465479549E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 1.7153912855551331E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -1.1685332877993451E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 7.6761854986049361E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -4.856446783111929E-13, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 2.95505266312964E-12, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -1.7268262914415559E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 9.675809035373237E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -5.1897956016352627E-10, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 2.6598237246823866E-09, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -1.300025009986248E-08, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 6.0469950225419186E-08, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -2.6707938539406119E-07, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 1.1173875391201037E-06, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -4.4167383584587505E-06, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 1.6448448070728896E-05, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -5.754195010082104E-05, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.00018850288509584165, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -0.00057637557453858236, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.0016394756169413357, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -0.0043243099950505759, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.010546460394594998, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -0.023737414805899471, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.049305284239670712, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -0.094901097048047639, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.17162090152220877, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -0.3046826723431984, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.67679527440947607, ref b0, ref b1, ref b2);
      double num = 0.5 * (b0 - b2);
      return Math.Exp(x) * num;
    }
    double x2 = 32.0 / x - 2.0;
    CalcEngine.besselmfirstcheb(-7.2331804878747538E-18, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, -4.8305044859441819E-18, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 4.46562142029676E-17, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 3.4612228676974612E-17, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, -2.8276239805165836E-16, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, -3.425485619677219E-16, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 1.7725601330565263E-15, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 3.8116806693526224E-15, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, -9.5548466988283073E-15, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, -4.1505693472872222E-14, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 1.54008621752141E-14, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 3.8527783827421426E-13, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 7.180124451383666E-13, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, -1.7941785315068062E-12, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, -1.3215811840447713E-11, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, -3.1499165279632416E-11, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 1.1889147107846439E-11, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 4.94060238822497E-10, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 3.3962320257083865E-09, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 2.266668990498178E-08, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 2.0489185894690638E-07, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 2.8913705208347567E-06, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 6.8897583469168245E-05, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 0.0033691164782556943, ref b0, ref b1, ref b2);
    CalcEngine.besselmnextcheb(x2, 0.80449041101410879, ref b0, ref b1, ref b2);
    double num1 = 0.5 * (b0 - b2);
    return Math.Exp(x) * num1 / Math.Sqrt(x);
  }

  public string ComputeBesselJ(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string empty1 = string.Empty;
    string empty2 = string.Empty;
    if (strArray.Length > 2 || strArray.Length <= 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    string besselJ = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) besselJ))
      return besselJ;
    double num1 = 40.0;
    double num2 = 10000000000.0;
    double num3 = 1E-10;
    try
    {
      if (double.Parse(str2) == 0.0)
        return CalcEngine.j0(str1).ToString();
      if (double.Parse(str2) == 1.0)
        return CalcEngine.j1(str1).ToString();
      if (double.Parse(str2) < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      double num4 = Math.Abs(double.Parse(str1));
      if (num4 == 0.0)
        return "0";
      double num5;
      if (double.Parse(str1) < 0.9 && double.Parse(str2) < 0.9)
      {
        double num6 = 2.0 / num4;
        num5 = CalcEngine.j0(num4.ToString());
      }
      else if (num4 > double.Parse(str2))
      {
        double num7 = 2.0 / num4;
        double num8 = CalcEngine.j0(num4.ToString());
        double num9 = CalcEngine.j1(num4.ToString());
        for (double num10 = 1.0; num10 < double.Parse(str2); ++num10)
        {
          double num11 = num10 * num7 * num9 - num8;
          num8 = num9;
          num9 = num11;
        }
        num5 = num9;
      }
      else if (double.Parse(str1) < 2.0 && double.Parse(str2) < 2.0)
      {
        double num12 = 2.0 / num4;
        double num13 = Math.Round(2.0 * (double.Parse(str2) + (double) ((int) Math.Sqrt(num1 * double.Parse(str2)) / 2)));
        bool flag = false;
        double num14;
        double num15 = num14 = 0.0;
        double num16 = num14;
        double num17 = num14;
        double num18 = 1.0;
        for (double num19 = num13; num19 > 0.0; --num19)
        {
          double num20 = num19 * num12 * num18 - num17;
          num17 = num18;
          num18 = num20;
          if (Math.Abs(num18) > num2)
          {
            num18 *= num3;
            num17 *= num3;
            num16 *= num3;
            num15 *= num3;
          }
          if (flag)
            num15 += num18;
          flag = !flag;
          string round1 = this.ComputeRound(num19.ToString());
          string round2 = this.ComputeRound(str2);
          if (int.Parse(round1) <= int.Parse(round2))
            num16 = num17;
        }
        double num21 = 2.0 * num15 - num18;
        num5 = num16 / num21;
      }
      else
      {
        double num22 = 2.0 / num4;
        double num23 = 2.0 * (double.Parse(str2) + (double) ((int) Math.Sqrt(num1 * double.Parse(str2)) / 2));
        bool flag = false;
        double num24;
        double num25 = num24 = 0.0;
        double num26 = num24;
        double num27 = num24;
        double num28 = 1.0;
        for (double num29 = num23; num29 > 0.0; --num29)
        {
          double num30 = num29 * num22 * num28 - num27;
          num27 = num28;
          num28 = num30;
          if (Math.Abs(num28) > num2)
          {
            num28 *= num3;
            num27 *= num3;
            num26 *= num3;
            num25 *= num3;
          }
          if (flag)
            num25 += num28;
          flag = !flag;
          if (this.ComputeRound(num29.ToString()) == this.ComputeRound(str2))
            num26 = num27;
        }
        double num31 = 2.0 * num25 - num28;
        num5 = num26 / num31;
      }
      return (double.Parse(str1) >= 0.0 || double.Parse(str2) % 2.0 != 1.0 ? num5 : -num5).ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str1 == "" || str2 == "" ? this.ErrorStrings[0].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public static double j1(string x)
  {
    double num1;
    if ((num1 = Math.Abs(double.Parse(x))) < 8.0)
    {
      double num2 = double.Parse(x) * double.Parse(x);
      return double.Parse(x) * (72362614232.0 + num2 * (num2 * (242396853.1 + num2 * (num2 * (15704.4826 + num2 * -30.16036606) - 2972611.439)) - 7895059235.0)) / (144725228442.0 + num2 * (2300535178.0 + num2 * (18583304.74 + num2 * (99447.43394 + num2 * (376.9991397 + num2 * 1.0)))));
    }
    double num3 = 8.0 / num1;
    double num4 = num1 - 2.356194491;
    double num5 = num3 * num3;
    double num6 = 1.0 + num5 * (0.00183105 + num5 * (num5 * (2.457520174E-06 + num5 * -2.40337019E-07) - 3.516396496E-05));
    double num7 = 3.0 / 64.0 + num5 * (num5 * (8.449199096E-06 + num5 * (num5 * 1.05787412E-07 - 8.8228987E-07)) - 0.0002002690873);
    double num8 = Math.Sqrt(0.636619772 / num1) * (Math.Cos(num4) * num6 - num3 * Math.Sin(num4) * num7);
    if (double.Parse(x) < 0.0)
      num8 = -num8;
    return num8;
  }

  public static double j0(string x)
  {
    double num1;
    if ((num1 = Math.Abs(double.Parse(x))) < 8.0)
    {
      double num2 = double.Parse(x) * double.Parse(x);
      return (57568490574.0 + num2 * (num2 * (651619640.7 + num2 * (num2 * (77392.33017 + num2 * -184.9052456) - 11214424.18)) - 13362590354.0)) / (57568490411.0 + num2 * (1029532985.0 + num2 * (9494680.718 + num2 * (59272.64853 + num2 * (267.8532712 + num2 * 1.0)))));
    }
    double num3 = 8.0 / num1;
    double num4 = num3 * num3;
    double num5 = num1 - 0.785398164;
    double num6 = 1.0 + num4 * (num4 * (2.734510407E-05 + num4 * (num4 * 2.093887211E-07 - 2.073370639E-06)) - 0.001098628627);
    double num7 = num4 * (0.0001430488765 + num4 * (num4 * (7.621095161E-07 - num4 * 9.34935152E-08) - 6.911147651E-06)) - 1.0 / 64.0;
    return Math.Sqrt(0.636619772 / num1) * (Math.Cos(num5) * num6 - num3 * Math.Sin(num5) * num7);
  }

  public string ComputeBesselY(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string empty1 = string.Empty;
    string empty2 = string.Empty;
    if (strArray.Length == 2)
      strArray[1].Contains("u");
    if (strArray.Length > 2 || strArray.Length <= 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    string besselY = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) besselY))
      return besselY;
    if (strArray.Length == 2)
    {
      int num1 = this.ComputeIsNumber(strArray[1]) != this.TRUEVALUESTR ? 1 : 0;
    }
    if (str1 == string.Empty && str2 == string.Empty)
    {
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Passed arguments contains invalid argument");
      return this.ErrorStrings[0].ToString();
    }
    string str3;
    string str4;
    if (strArray.Length == 2)
    {
      str3 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
      str4 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    }
    else
    {
      if (strArray.Length != 1)
        return this.FormulaErrorStrings[10].ToString();
      str3 = this.GetValueFromArg(strArray[0]);
      str4 = "0";
    }
    try
    {
      if (double.Parse(str3) < 0.0 || double.Parse(str4) < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (double.Parse(str3) == 0.0)
        return CalcEngine.y0(double.Parse(str3)).ToString();
      if (double.Parse(str4) == 1.0)
        return CalcEngine.y1(double.Parse(str3)).ToString();
      if (double.Parse(str3) < 2.0 && double.Parse(str3) > 1.0)
      {
        double num2 = 2.0 / double.Parse(str3);
        double num3 = CalcEngine.y1(double.Parse(str3));
        CalcEngine.y0(double.Parse(str3));
        return num3.ToString();
      }
      double num4 = 2.0 / double.Parse(str3);
      double num5 = CalcEngine.y1(double.Parse(str3));
      double num6 = CalcEngine.y0(double.Parse(str3));
      for (int index = 1; (double) index < double.Parse(str4); ++index)
      {
        double num7 = (double) index * num4 * num5 - num6;
        num6 = num5;
        num5 = num7;
      }
      return num5.ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str3) == this.TRUEVALUESTR || this.ComputeIsText(str4) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str3 == "" || str4 == "" ? this.ErrorStrings[0].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public static double y0(double x)
  {
    if (x < 8.0)
    {
      double num = x * x;
      return (num * (7062834065.0 + num * (num * (10879881.29 + num * (num * 228.4622733 - 86327.92757)) - 512359803.6)) - 2957821389.0) / (40076544269.0 + num * (745249964.8 + num * (7189466.438 + num * (47447.2647 + num * (226.1030244 + num * 1.0))))) + 0.636619772 * CalcEngine.j0(x.ToString()) * Math.Log(x);
    }
    double num1 = 8.0 / x;
    double num2 = num1 * num1;
    double num3 = x - 0.785398164;
    double num4 = 1.0 + num2 * (num2 * (2.734510407E-05 + num2 * (num2 * 2.093887211E-07 - 2.073370639E-06)) - 0.001098628627);
    double num5 = num2 * (0.0001430488765 + num2 * (num2 * (7.621095161E-07 + num2 * -9.34945152E-08) - 6.911147651E-06)) - 1.0 / 64.0;
    return Math.Sqrt(0.636619772 / x) * (Math.Sin(num3) * num4 + num1 * Math.Cos(num3) * num5);
  }

  public static double y1(double x)
  {
    if (x < 8.0)
    {
      double num = x * x;
      return x * (num * (1275274390000.0 + num * (num * (734926455.1 + num * (num * 8511.937935 - 4237922.726)) - 51534381390.0)) - 4900604943000.0) / (24995805700000.0 + num * (424441966400.0 + num * (3733650367.0 + num * (22459040.02 + num * (102042.605 + num * (354.9632885 + num)))))) + 0.636619772 * (CalcEngine.j1(x.ToString()) * Math.Log(x) - 1.0 / x);
    }
    double num1 = 8.0 / x;
    double num2 = num1 * num1;
    double num3 = x - 2.356194491;
    double num4 = 1.0 + num2 * (0.00183105 + num2 * (num2 * (2.457520174E-06 + num2 * -2.40337019E-07) - 3.516396496E-05));
    double num5 = 3.0 / 64.0 + num2 * (num2 * (8.449199096E-06 + num2 * (num2 * 1.05787412E-07 - 8.8228987E-07)) - 0.0002002690873);
    return Math.Sqrt(0.636619772 / x) * (Math.Sin(num3) * num4 + num1 * Math.Cos(num3) * num5);
  }

  public string ComputebesselK(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    string empty1 = string.Empty;
    string empty2 = string.Empty;
    if (strArray.Length == 2)
      strArray[1].Contains("u");
    if (strArray.Length > 2 || strArray.Length <= 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    string str3 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) str3))
      return str3;
    if (strArray.Length == 2)
    {
      int num1 = this.ComputeIsNumber(strArray[1]) != this.TRUEVALUESTR ? 1 : 0;
    }
    if (str1 == string.Empty && str2 == string.Empty)
    {
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("Passed arguments contains invalid argument");
      return this.ErrorStrings[0].ToString();
    }
    string str4;
    string str5;
    if (strArray.Length == 2)
    {
      str4 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
      str5 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    }
    else
    {
      if (strArray.Length != 1)
        return this.FormulaErrorStrings[10].ToString();
      str4 = this.GetValueFromArg(strArray[0]);
      str5 = "0";
    }
    double num2 = 0.0;
    double num3 = 0.0;
    double num4 = 0.57721566490153287;
    try
    {
      string s = double.Parse(str5) >= 0.0 ? str5 : "-" + str5.ToString();
      if (double.Parse(str4) < 0.0 || double.Parse(str5) < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (double.Parse(str4) <= 9.55)
      {
        double num5 = 0.0;
        double num6 = 0.25 * double.Parse(str4) * double.Parse(str4);
        double num7 = 1.0;
        double num8 = 0.0;
        double num9 = 1.0;
        double num10 = 2.0 / double.Parse(str4);
        if (double.Parse(s) > 0.0)
        {
          num8 = -num4;
          double num11 = 1.0;
          s = ((int) double.Parse(s)).ToString();
          for (int index = 1; (double) index <= double.Parse(s) - 1.0; ++index)
          {
            num8 += 1.0 / num11;
            ++num11;
            num7 *= num11;
          }
          num9 = num10;
          if (double.Parse(s) == 1.0)
          {
            num5 = 1.0 / double.Parse(str4);
          }
          else
          {
            double num12 = num7 / double.Parse(s);
            double num13 = 1.0;
            double num14 = num12;
            double num15 = -num6;
            double num16 = 1.0;
            for (int index = 1; (double) index <= double.Parse(s) - 1.0; ++index)
            {
              num12 /= double.Parse(s) - (double) index;
              num13 *= (double) index;
              num16 *= num15;
              double num17 = num12 * num16 / num13;
              num14 += num17;
              num9 *= num10;
            }
            double num18 = num14 * 0.5;
            num3 = Math.Abs(num18);
            num5 = num18 * num9;
          }
        }
        double num19 = 2.0 * Math.Log(0.5 * double.Parse(str4));
        double num20 = -num4;
        double num21;
        double num22;
        if (double.Parse(s) == 0.0)
        {
          num21 = num20;
          num22 = 1.0;
        }
        else
        {
          num21 = num8 + 1.0 / double.Parse(s);
          num22 = 1.0 / num7;
        }
        double num23 = (num20 + num21 - num19) * num22;
        double num24 = 1.0;
        do
        {
          num22 *= num6 / (num24 * (num24 + double.Parse(s)));
          num20 += 1.0 / num24;
          num21 += 1.0 / (num24 + double.Parse(s));
          num23 += (num20 + num21 - num19) * num22;
          ++num24;
        }
        while (Math.Abs(num22 / num23) > 5E-16);
        double num25 = 0.5 * num23 / num9;
        if (double.Parse(s) % 2.0 != 0.0)
          num25 = -num25;
        return (num5 + num25).ToString();
      }
      if (double.Parse(str4) > Math.Log(1E+300))
        return 0.0.ToString();
      double num26 = double.Parse(s);
      double num27 = 4.0 * num26 * num26;
      double num28 = 1.0;
      double num29 = 8.0 * double.Parse(str4);
      double num30 = 1.0;
      double num31 = 1.0;
      double num32 = num31;
      int num33 = 0;
      do
      {
        double num34 = num27 - num28 * num28;
        num31 = num31 * num34 / (num30 * num29);
        double num35 = Math.Abs(num31);
        if ((double) num33 < double.Parse(s) || num35 <= num2)
        {
          num2 = num35;
          num32 += num31;
          ++num30;
          num28 += 2.0;
          ++num33;
        }
        else
          break;
      }
      while (Math.Abs(num31 / num32) > 5E-16);
      return (Math.Exp(double.Parse("-" + str4)) * Math.Sqrt(Math.PI / (2.0 * double.Parse(str4))) * num32).ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str4) == this.TRUEVALUESTR || this.ComputeIsText(str5) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      return str4 == "" || str5 == "" ? this.ErrorStrings[0].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeConversion(string argList)
  {
    string s1 = (string) null;
    string s2 = (string) null;
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(argList);
    string s3 = this.GetValueFromArg(strArray1[0]).Replace(this.TIC, "");
    string valueFromArg1 = this.GetValueFromArg(strArray1[1]);
    string valueFromArg2 = this.GetValueFromArg(strArray1[2]);
    string str1 = valueFromArg1.Replace(this.TIC, "");
    string str2 = valueFromArg2.Replace(this.TIC, "");
    string[,] strArray2 = new string[165, 4]
    {
      {
        "a.u. of action",
        "Ä§",
        "action",
        "1.05457168181818e-34"
      },
      {
        "a.u. of charge",
        "e",
        "electric_charge",
        "1.60217653141414e-19"
      },
      {
        "a.u. of energy",
        "Eh",
        "energy",
        "4.35974417757576e-18"
      },
      {
        "a.u. of length",
        "aâ‚€",
        "length",
        "5.29177210818182e-11"
      },
      {
        "a.u. of mass",
        "mâ‚",
        "mass",
        "9.10938261616162e-31"
      },
      {
        "a.u. of time",
        "Ä§/Eh",
        "time",
        "2.41888432650516e-17"
      },
      {
        "admiralty knot",
        "admkn",
        "speed",
        "0.514773333"
      },
      {
        "ampere",
        "A",
        "electric_current",
        "1"
      },
      {
        "ampere per meter",
        "A/m",
        "magnetic_field_intensity",
        "1"
      },
      {
        "Ã¥ngstrÃ¶m",
        "Ã…",
        "length",
        "1e-10"
      },
      {
        "are",
        "ar",
        "area",
        "100"
      },
      {
        "astronomical unit",
        "ua",
        "length",
        "1.49597870691667e-11"
      },
      {
        "bar",
        "bar",
        "pressure",
        "100000"
      },
      {
        "barn",
        "b",
        "area",
        "1e-28"
      },
      {
        "becquerel",
        "Bq",
        "radioactivity",
        "1"
      },
      {
        "bit",
        "bit",
        "information",
        "1"
      },
      {
        "btu",
        "BTU",
        "energy",
        "1055.05585262"
      },
      {
        "byte",
        "byte",
        "information",
        "8"
      },
      {
        "candela",
        "cd",
        "luminous_intensity",
        "1"
      },
      {
        "candela per square metre",
        "cd/mÂ\u00B2",
        "luminance",
        "1"
      },
      {
        "coulomb",
        "C",
        "electric_charge",
        "1"
      },
      {
        "cubic Ã¥ngstrÃ¶m",
        "ang3",
        "volume",
        "1e-30"
      },
      {
        "cubic foot",
        "ft3",
        "volume",
        "0.028316846592"
      },
      {
        "cubic inch",
        "in3",
        "volume",
        "0.000016387064"
      },
      {
        "cubic light-year",
        "ly3",
        "volume",
        "8.46786664623715e-47"
      },
      {
        "cubic metre",
        "mÂ\u00B3",
        "volume",
        "1"
      },
      {
        "cubic mile",
        "mi3",
        "volume",
        "4168181825.44058"
      },
      {
        "cubic nautical mile",
        "Nmi3",
        "volume",
        "6352182208"
      },
      {
        "cubic Pica",
        "Pica3",
        "volume",
        "7.58660370370369e-8"
      },
      {
        "cubic yard",
        "yd3",
        "volume",
        "0.764554857984"
      },
      {
        "cup",
        "cup",
        "volume",
        "0.0002365882365"
      },
      {
        "dalton",
        "Da",
        "mass",
        "1.66053886282828e-27"
      },
      {
        "day",
        "d",
        "time",
        "86400"
      },
      {
        "degree",
        "Â°",
        "angle",
        "0.0174532925199433"
      },
      {
        "degrees Rankine",
        "Rank",
        "temperature",
        "0.555555555555556"
      },
      {
        "dyne",
        "dyn",
        "force",
        "0.00001"
      },
      {
        "electronvolt",
        "eV",
        "energy",
        "1.60217656514141"
      },
      {
        "ell",
        "ell",
        "length",
        "1.143"
      },
      {
        "erg",
        "erg",
        "energy",
        "1e-7"
      },
      {
        "farad",
        "F",
        "electric_capacitance",
        "1"
      },
      {
        "fluid ounce",
        "oz",
        "volume",
        "0.0000295735295625"
      },
      {
        "foot",
        "ft",
        "length",
        "0.3048"
      },
      {
        "foot-pound",
        "flb",
        "energy",
        "1.3558179483314"
      },
      {
        "gal",
        "Gal",
        "acceleration",
        "0.01"
      },
      {
        "gallon",
        "gal",
        "volume",
        "0.003785411784"
      },
      {
        "gauss",
        "G",
        "magnetic_flux_density",
        "1"
      },
      {
        "grain",
        "grain",
        "mass",
        "0.0000647989"
      },
      {
        "gram",
        "g",
        "mass",
        "0.001"
      },
      {
        "gray",
        "Gy",
        "absorbed_dose",
        "1"
      },
      {
        "gross registered ton",
        "GRT",
        "volume",
        "2.8316846592"
      },
      {
        "hectare",
        "ha",
        "area",
        "10000"
      },
      {
        "henry",
        "H",
        "inductance",
        "1"
      },
      {
        "hertz",
        "Hz",
        "frequency",
        "1"
      },
      {
        "horsepower",
        "HP",
        "power",
        "745.69987158227"
      },
      {
        "horsepower-hour",
        "HPh",
        "energy",
        "2684519.538"
      },
      {
        "hour",
        "h",
        "time",
        "3600"
      },
      {
        "imperial gallon (U.K.)",
        "uk_gal",
        "volume",
        "0.00454609"
      },
      {
        "imperial hundredweight",
        "lcwt",
        "mass",
        "50.802345"
      },
      {
        "imperial quart (U.K)",
        "uk_qt",
        "volume",
        "0.0011365225"
      },
      {
        "imperial ton",
        "brton",
        "mass",
        "1016.046909"
      },
      {
        "inch",
        "in",
        "length",
        "0.0254"
      },
      {
        "international acre",
        "uk_acre",
        "area",
        "4046.8564224"
      },
      {
        "IT calorie",
        "cal",
        "energy",
        "4.1868"
      },
      {
        "joule",
        "J",
        "energy",
        "1"
      },
      {
        "katal",
        "kat",
        "catalytic_activity",
        "1"
      },
      {
        "kelvin",
        "K",
        "temperature",
        "1"
      },
      {
        "kilogram",
        "kg",
        "mass",
        "1"
      },
      {
        "knot",
        "kn",
        "speed",
        "0.514444444444444"
      },
      {
        "light-year",
        "ly",
        "length",
        "9460730472580800"
      },
      {
        "litre",
        "L",
        "volume",
        "0.001"
      },
      {
        "lumen",
        "lm",
        "luminous_flux",
        "1"
      },
      {
        "lux",
        "lx",
        "illuminance",
        "1"
      },
      {
        "maxwell",
        "Mx",
        "magnetic_flux",
        "1e-18"
      },
      {
        "measurement ton",
        "MTON",
        "volume",
        "1.13267386368"
      },
      {
        "meter per hour",
        "m/h",
        "speed",
        "0.00027777777777778"
      },
      {
        "meter per second",
        "m/s",
        "speed",
        "1"
      },
      {
        "meter per second squared",
        "mâ‹…sâ\u0081»Â\u00B2",
        "acceleration",
        "1"
      },
      {
        "parsec",
        "pc",
        "length",
        "30856775814671900"
      },
      {
        "meter squared per second",
        "mÂ\u00B2/s",
        "kinematic_viscosity",
        "1"
      },
      {
        "metre",
        "m",
        "length",
        "1"
      },
      {
        "miles per hour",
        "mph",
        "speed",
        "0.44704"
      },
      {
        "millimetre of mercury",
        "mmHg",
        "pressure",
        "133.322"
      },
      {
        "minute",
        "â€\u00B2",
        "angle",
        "0.000290888208665722"
      },
      {
        "minute",
        "min",
        "time",
        "60"
      },
      {
        "modern teaspoon",
        "tspm",
        "volume",
        "0.000005"
      },
      {
        "mole",
        "mol",
        "amount_of_substance",
        "1"
      },
      {
        "morgen",
        "Morgen",
        "area",
        "2500"
      },
      {
        "n.u. of action",
        "Ä§",
        "action",
        "1.05457168181818e-34"
      },
      {
        "n.u. of mass",
        "mâ‚‘",
        "mass",
        "9.10938261616162e-31"
      },
      {
        "n.u. of speed",
        "câ‚€",
        "speed",
        "299792458"
      },
      {
        "n.u. of time",
        "Ä§/(meâ‹…câ‚€Â\u00B2)",
        "time",
        "1.28808866778687e-21"
      },
      {
        "nautical mile",
        "M",
        "length",
        "1852"
      },
      {
        "newton",
        "N",
        "force",
        "1"
      },
      {
        "Å“rsted",
        "Oe ",
        "magnetic_field_intensity",
        "79.5774715459477"
      },
      {
        "ohm",
        "Î©",
        "electric_resistance",
        "1"
      },
      {
        "ounce mass",
        "ozm",
        "mass",
        "0.028349523125"
      },
      {
        "pascal",
        "Pa",
        "pressure",
        "1"
      },
      {
        "pascal second",
        "Paâ‹…s",
        "dynamic_viscosity",
        "1"
      },
      {
        "pferdestÃ¤rke",
        "PS",
        "power",
        "735.49875"
      },
      {
        "phot",
        "ph",
        "illuminance",
        "0.0001"
      },
      {
        "pica (1/6 inch)",
        "pica",
        "length",
        "0.00035277777777778"
      },
      {
        "pica (1/72 inch)",
        "Pica",
        "length",
        "0.00423333333333333"
      },
      {
        "poise",
        "P",
        "dynamic_viscosity",
        "0.1"
      },
      {
        "pond",
        "pond",
        "force",
        "0.00980665"
      },
      {
        "pound force",
        "lbf",
        "force",
        "4.4482216152605"
      },
      {
        "pound mass",
        "lbm",
        "mass",
        "0.45359237"
      },
      {
        "quart",
        "qt",
        "volume",
        "0.000946352946"
      },
      {
        "radian",
        "rad",
        "angle",
        "1"
      },
      {
        "second",
        "â€\u00B3",
        "angle",
        "0.00000484813681109536"
      },
      {
        "second",
        "s",
        "time",
        "1"
      },
      {
        "short hundredweight",
        "cwt",
        "mass",
        "45.359237"
      },
      {
        "siemens",
        "S",
        "electrical_conductance",
        "1"
      },
      {
        "sievert",
        "Sv",
        "equivalent_dose",
        "1"
      },
      {
        "slug",
        "sg",
        "mass",
        "14.59390294"
      },
      {
        "square Ã¥ngstrÃ¶m",
        "ang2",
        "area",
        "1e-20"
      },
      {
        "square foot",
        "ft2",
        "area",
        "0.09290304"
      },
      {
        "square inch",
        "in2",
        "area",
        "0.00064516"
      },
      {
        "square light-year",
        "ly2",
        "area",
        "8.95054210748189e+31"
      },
      {
        "square meter",
        "mÂ\u00B2",
        "area",
        "1"
      },
      {
        "square mile",
        "mi2",
        "area",
        "2589988.110336"
      },
      {
        "square nautical mile",
        "Nmi2",
        "area",
        "3429904"
      },
      {
        "square Pica",
        "Pica2",
        "area",
        "0.00001792111111111"
      },
      {
        "square yard",
        "yd2",
        "area",
        "0.83612736"
      },
      {
        "statute mile",
        "mi",
        "length",
        "1609.344"
      },
      {
        "steradian",
        "sr",
        "solid_angle",
        "1"
      },
      {
        "stilb",
        "sb",
        "luminance",
        "0.0001"
      },
      {
        "stokes",
        "St",
        "kinematic_viscosity",
        "0.0001"
      },
      {
        "stone",
        "stone",
        "mass",
        "6.35029318"
      },
      {
        "tablespoon",
        "tbs",
        "volume",
        "0.0000147868"
      },
      {
        "teaspoon",
        "tsp",
        "volume",
        "0.00000492892"
      },
      {
        "tesla",
        "T",
        "magnetic_flux_density",
        "1"
      },
      {
        "thermodynamic calorie",
        "c",
        "energy",
        "4.184"
      },
      {
        "ton",
        "ton",
        "mass",
        "907.18474"
      },
      {
        "tonne",
        "t",
        "mass",
        "1000"
      },
      {
        "U.K. pint",
        "uk_pt",
        "volume",
        "0.00056826125"
      },
      {
        "U.S. bushel",
        "bushel",
        "volume",
        "0.03523907"
      },
      {
        "U.S. oil barrel",
        "barrel",
        "volume",
        "0.158987295"
      },
      {
        "U.S. pint",
        "pt",
        "volume",
        "0.000473176473"
      },
      {
        "U.S. survey mile",
        "survey_mi",
        "length",
        "1609.347219"
      },
      {
        "U.S. survey/statute acre",
        "us_acre",
        "area",
        "4046.87261"
      },
      {
        "volt",
        "V",
        "voltage",
        "1"
      },
      {
        "watt",
        "W",
        "power",
        "1"
      },
      {
        "watt-hour",
        "Wh",
        "energy",
        "3600"
      },
      {
        "weber",
        "Wb",
        "magnetic_flux",
        "1"
      },
      {
        "yard",
        "yd",
        "length",
        "0.9144"
      },
      {
        "year",
        "yr",
        "time",
        "31557600"
      },
      {
        "yotta",
        "Y",
        "Measurement",
        "1e+24"
      },
      {
        "zetta",
        "Z",
        "Measurement",
        "1e+21"
      },
      {
        "exa",
        "E",
        "Measurement",
        "1e+18"
      },
      {
        "peta",
        "P",
        "Measurement",
        "1e+15"
      },
      {
        "tera",
        "T",
        "Measurement",
        "1e+12"
      },
      {
        "giga",
        "G",
        "Measurement",
        "1e+09"
      },
      {
        "mega",
        "M",
        "Measurement",
        "1e+06"
      },
      {
        "kilo",
        "k",
        "Measurement",
        "1e+03"
      },
      {
        "hecto",
        "h",
        "Measurement",
        "1e+02"
      },
      {
        "dekao",
        "e",
        "Measurement",
        "1e+01"
      },
      {
        "deci",
        "d",
        "Measurement",
        "1e-01"
      },
      {
        "centi",
        "c",
        "Measurement",
        "1e-02"
      },
      {
        "micro",
        "u",
        "Measurement",
        "1e-06"
      },
      {
        "nano",
        "n",
        "Measurement",
        "1e-09"
      },
      {
        "pico",
        "p",
        "Measurement",
        "1e-12"
      },
      {
        "femto",
        "f",
        "Measurement",
        "1e-15"
      },
      {
        "atto",
        "a",
        "Measurement",
        "1e-18"
      },
      {
        "zepto",
        "z",
        "Measurement",
        "1e-21"
      },
      {
        "yocto",
        "y",
        "Measurement",
        "1e-24"
      }
    };
    for (int index = 0; index < 165; ++index)
    {
      if (strArray2[index, 1] == str1)
        s1 = strArray2[index, 3];
    }
    for (int index = 0; index < 165; ++index)
    {
      if (strArray2[index, 1] == str2)
        s2 = strArray2[index, 3];
    }
    if (s1 == null || s2 == null)
      return this.ErrorStrings[0].ToString();
    if (str1 == "F" && str2 == "C")
      return ((double.Parse(s3) - 32.0) * (5.0 / 9.0)).ToString();
    return str1 == "C" && str2 == "F" ? (double.Parse(s3) * 1.8 + 32.0).ToString() : (double.Parse(s3) * double.Parse(s1) / double.Parse(s2)).ToString();
  }

  private static void besselmfirstcheb(double c, ref double b0, ref double b1, ref double b2)
  {
    b0 = c;
    b1 = 0.0;
    b2 = 0.0;
  }

  private static void besselmnextcheb(
    double x,
    double c,
    ref double b0,
    ref double b1,
    ref double b2)
  {
    b2 = b1;
    b1 = b0;
    b0 = x * b1 - b2 + c;
  }

  private static void besselm1firstcheb(double c, ref double b0, ref double b1, ref double b2)
  {
    b0 = c;
    b1 = 0.0;
    b2 = 0.0;
  }

  private static void besselm1nextcheb(
    double x,
    double c,
    ref double b0,
    ref double b1,
    ref double b2)
  {
    b2 = b1;
    b1 = b0;
    b0 = x * b1 - b2 + c;
  }

  public bool UseDatesInCalculations
  {
    get => this.useDatesInCalcs;
    set => this.useDatesInCalcs = value;
  }

  public bool RethrowParseExceptions
  {
    get => this.rethrowExceptions;
    set => this.rethrowExceptions = value;
  }

  private List<string> NativeFormats
  {
    get
    {
      if (this.nativeFormats == null)
        this.nativeFormats = new List<string>()
        {
          "[DBNUM1]",
          "[DBNUM2]",
          "[DBNUM3]",
          "[DBNUM4]"
        };
      return this.nativeFormats;
    }
  }

  private ArrayList SortedSheetNames
  {
    get
    {
      GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
      if (this.sortedSheetNames == null && sheetFamilyItem != null && sheetFamilyItem.SheetNameToToken != null)
      {
        string[] c = new string[sheetFamilyItem.SheetNameToToken.Keys.Count];
        sheetFamilyItem.SheetNameToToken.Keys.CopyTo((Array) c, 0);
        this.sortedSheetNames = new ArrayList((ICollection) c);
        this.sortedSheetNames.Sort((IComparer) new CalcEngine.LenComparer());
      }
      return this.sortedSheetNames;
    }
  }

  private bool IsOptimizedMatchesEnabled()
  {
    return (this.enableLookupTableCaching & LookupCachingMode.OptimizeForMatches) != LookupCachingMode.None;
  }

  private bool IsVLookupCachingEnabled()
  {
    return (this.enableLookupTableCaching & LookupCachingMode.Both) != LookupCachingMode.None || (this.enableLookupTableCaching & LookupCachingMode.VLOOKUP) != LookupCachingMode.None;
  }

  private bool IsHLookupCachingEnabled()
  {
    return (this.enableLookupTableCaching & LookupCachingMode.Both) != LookupCachingMode.None || (this.enableLookupTableCaching & LookupCachingMode.HLOOKUP) != LookupCachingMode.None;
  }

  private bool IsLookupCachingEnabled()
  {
    return (this.enableLookupTableCaching & LookupCachingMode.Both) != LookupCachingMode.None || (this.enableLookupTableCaching & LookupCachingMode.VLOOKUP) != LookupCachingMode.None || (this.enableLookupTableCaching & LookupCachingMode.HLOOKUP) != LookupCachingMode.None;
  }

  public LookupCachingMode EnableLookupTableCaching
  {
    get => this.enableLookupTableCaching;
    set => this.enableLookupTableCaching = value;
  }

  public void LookupCachingClearAll()
  {
    if (this.lookupTables == null)
      this.lookupTables = new Dictionary<string, CalcEngine.LookUps>();
    this.lookupTables.Clear();
  }

  public void LookupCachingClearSheet(ICalcData grd)
  {
    if (this.lookupTables == null)
    {
      this.lookupTables = new Dictionary<string, CalcEngine.LookUps>();
    }
    else
    {
      string str = $"_{grd.GetHashCode()}";
      List<string> stringList = new List<string>();
      foreach (string key in this.lookupTables.Keys)
      {
        if (key.EndsWith(str))
          stringList.Add(key);
      }
      foreach (string key in stringList)
        this.lookupTables.Remove(key);
    }
  }

  private void MarkParseArgumentSeparatorInQuotes(ref string args)
  {
    if (args.IndexOf(CalcEngine.ParseArgumentSeparator) == -1)
      return;
    bool flag = false;
    StringBuilder stringBuilder = new StringBuilder(args.Length);
    for (int index = 0; index < args.Length; ++index)
    {
      if ((int) args[index] == (int) this.TIC[0])
      {
        flag = !flag;
        stringBuilder.Append(args[index]);
      }
      else if ((int) args[index] == (int) CalcEngine.ParseArgumentSeparator && flag)
        stringBuilder.Append(this.MarkerParseChar);
      else
        stringBuilder.Append(args[index]);
    }
    args = stringBuilder.ToString();
  }

  public void ReloadErrorStrings()
  {
    if (this.formulaErrorStrings == null)
      this.formulaErrorStrings = new ArrayList();
    this.formulaErrorStrings.Clear();
    this.formulaErrorStrings.AddRange((ICollection) this.FormulaErrorStrings);
  }

  private string GetSheetTokenFromReference(string r)
  {
    string tokenFromReference = string.Empty;
    if (r.Length > 2 && r[0] == '!')
    {
      int index = 1;
      string str = '!'.ToString();
      for (; index < r.Length && r[index] != '!'; ++index)
        str += (string) (object) r[index];
      tokenFromReference = str + (object) '!';
    }
    return tokenFromReference;
  }

  public int GetSheetID(ICalcData grd)
  {
    if (CalcEngine.modelToSheetID == null || CalcEngine.modelToSheetID[(object) this.grid] == null)
      return 0;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(grd);
    double result;
    return sheetFamilyItem != null && sheetFamilyItem.SheetNameToParentObject != null && sheetFamilyItem.SheetNameToParentObject.Count > 0 && double.TryParse((sheetFamilyItem.ParentObjectToToken[(object) grd] as string).Replace("!", string.Empty), NumberStyles.Any, (IFormatProvider) null, out result) ? (int) result : -1;
  }

  private double Determinant(double[,] a, int k)
  {
    double num1 = 1.0;
    int length = int.Parse(k.ToString());
    double[,] a1 = new double[length, length];
    if (k == 1)
      return a[0, 0];
    double num2 = 0.0;
    for (int index1 = 0; index1 < k; ++index1)
    {
      int index2 = 0;
      int index3 = 0;
      for (int index4 = 0; index4 < k; ++index4)
      {
        for (int index5 = 0; index5 < k; ++index5)
        {
          a1[index4, index5] = 0.0;
          if (index4 != 0 && index5 != index1)
          {
            a1[index2, index3] = a[index4, index5];
            if (index3 < k - 2)
            {
              ++index3;
            }
            else
            {
              index3 = 0;
              ++index2;
            }
          }
        }
      }
      num2 += num1 * (a[0, index1] * this.Determinant(a1, k - 1));
      num1 = -1.0 * num1;
    }
    return num2;
  }

  private double NormalProbabilityDensity(double x, double mean, double standardDeviation)
  {
    double num = (x - mean) / standardDeviation;
    return 0.398942280401433 * Math.Exp(-0.5 * num * num) / standardDeviation;
  }

  private bool Cofactor(double[,] num, int f, out double[,] inverse)
  {
    int length = int.Parse(f.ToString());
    double[,] a = new double[length, length];
    double[,] fac = new double[length, length];
    inverse = new double[length, length];
    for (int index1 = 0; index1 < f; ++index1)
    {
      for (int index2 = 0; index2 < f; ++index2)
      {
        int index3 = 0;
        int index4 = 0;
        for (int index5 = 0; index5 < f; ++index5)
        {
          for (int index6 = 0; index6 < f; ++index6)
          {
            if (index5 != index1 && index6 != index2)
            {
              a[index3, index4] = num[index5, index6];
              if (index4 < f - 2)
              {
                ++index4;
              }
              else
              {
                index4 = 0;
                ++index3;
              }
            }
          }
        }
        fac[index1, index2] = double.Parse(Math.Pow(-1.0, (double) (index1 + index2)).ToString()) * this.Determinant(a, f - 1);
      }
    }
    return this.Inverse(num, fac, f, out inverse);
  }

  private bool Inverse(double[,] num, double[,] fac, int r, out double[,] inverse)
  {
    int length = int.Parse(r.ToString());
    double[,] numArray = new double[length, length];
    inverse = new double[length, length];
    try
    {
      for (int index1 = 0; index1 < r; ++index1)
      {
        for (int index2 = 0; index2 < r; ++index2)
          numArray[index1, index2] = fac[index2, index1];
      }
      double num1 = this.Determinant(num, r);
      for (int index3 = 0; index3 < r; ++index3)
      {
        for (int index4 = 0; index4 < r; ++index4)
          inverse[index3, index4] = numArray[index3, index4] / num1;
      }
      return true;
    }
    catch
    {
      return false;
    }
  }

  private bool IsDate(object o, out DateTime date)
  {
    date = this.dateTime1900;
    return DateTime.TryParse(o.ToString(), (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out date) && date >= this.dateTime1900;
  }

  internal bool IsRange(string range)
  {
    bool flag1 = false;
    int length = range.IndexOf(':');
    double result1 = 0.0;
    double result2 = 0.0;
    if (length > 1 && length < range.Length - 2)
    {
      int index1 = length - 1;
      if (char.IsDigit(range[index1]))
      {
        bool flag2 = false;
        int index2 = index1 - 1;
        while (index2 > 0 && char.IsDigit(range[index2]))
          --index2;
        if (char.IsLetter(range[index2]))
        {
          int index3 = index2 - 1;
          while (index3 >= 0 && char.IsLetter(range[index3]))
            --index3;
          if (index3 > -1 && (int) range[index3] == (int) "$"[0])
            --index3;
          if (index3 < 0 || index3 == 0)
            flag2 = true;
          else if (range[index3] == '!')
          {
            int num1 = index3;
            int num2 = num1 - 1;
            if (num1 > 1 && (int) range[num2] == (int) this.CHARTIC)
              flag2 = range.Substring(0, num2 - 1).LastIndexOf(this.CHARTIC) == 0;
            else if (num2 > 0 && char.IsDigit(range[num2]))
              flag2 = !range.Substring(0, num2).Contains("[") || !range.Substring(0, num2).Contains("]") ? range.Substring(0, num2).LastIndexOf('!') == 0 : range.Substring(0, num2).LastIndexOf('!') == 3;
          }
        }
        if (flag2)
        {
          int index4 = length + 1;
          if (range[index4] == '!')
          {
            ++index4;
            while (index4 < range.Length && range[index4] != '!')
              ++index4;
            if (index4 < range.Length)
              ++index4;
          }
          if (index4 < range.Length - 6 && (int) range[index4] == (int) this.CHARTIC)
          {
            index4 = range.IndexOf('!', index4 + 1);
            if (index4 < range.Length - 2)
              ++index4;
          }
          if (index4 < range.Length - 2 && (int) range[index4] == (int) "$"[0])
            ++index4;
          if (char.IsLetter(range[index4]))
          {
            int index5 = index4 + 1;
            while (index5 < range.Length - 1 && char.IsLetter(range[index5]))
              ++index5;
            if (char.IsDigit(range[index5]))
            {
              int index6 = index5 + 1;
              while (index6 < range.Length && char.IsDigit(range[index6]))
                ++index6;
              flag1 = index6 == range.Length;
            }
          }
        }
      }
    }
    if (length >= 1 && length < range.Length - 1 && !flag1)
    {
      if (char.IsDigit(range[length - 1]))
      {
        int num = 0;
        if (range[num] == '!')
        {
          ++num;
          while (num < range.Length && range[num] != '!')
            ++num;
          if (num < range.Length)
            ++num;
          length -= num;
        }
        if (double.TryParse(range.Substring(num, length), out result1) && double.TryParse(range.Substring(range.IndexOf(":") + 1), out result2))
          return true;
      }
      else if (char.IsLetter(range[length - 1]))
      {
        int index7 = length - 1;
        bool flag3 = false;
        while (index7 >= 0 && char.IsLetter(range[index7]))
          --index7;
        if (index7 < 0)
          flag3 = true;
        else if (range[index7] == '!')
        {
          int num = index7 - 1;
          while (num >= 0 && num != 33)
            --num;
          if (num <= 0)
            flag3 = true;
        }
        if (flag3)
        {
          int index8 = length + 1;
          while (index8 <= range.Length - 1 && char.IsLetter(range[index8]))
            ++index8;
          flag1 = index8 == range.Length;
        }
      }
    }
    return flag1;
  }

  internal bool ISColumn(string range)
  {
    bool flag1 = false;
    string oldValue = this.SheetToken(range.Replace(this.TIC, string.Empty));
    if (!string.IsNullOrEmpty(oldValue))
      range = range.Replace(oldValue, string.Empty).Replace("$", string.Empty);
    int num = range.IndexOf(':');
    if (num > -1)
    {
      int index1 = num - 1;
      bool flag2 = false;
      while (index1 >= 0 && char.IsLetter(range[index1]))
        --index1;
      if (index1 < 0 || index1 == 0)
        flag2 = true;
      if (flag2)
      {
        int index2 = num + 1;
        if (char.IsLetter(range[index2]))
        {
          ++index2;
          while (index2 < range.Length - 1 && char.IsLetter(range[index2]))
            ++index2;
        }
        flag1 = index2 == range.Length;
      }
    }
    return flag1;
  }

  public double ChiSquaredProbabilityDensityFunction(double x, int k)
  {
    double num = CalcEngine.GammaFunction(0.5 * (double) k);
    return 1.0 / (Math.Pow(2.0, 0.5 * (double) k) * num) * Math.Pow(x, 0.5 * (double) k - 1.0) * Math.Exp(-0.5 * x);
  }

  private double StdevdotP(double[] range)
  {
    int length = range.GetLength(0);
    double num1 = 0.0;
    double num2 = 0.0;
    int num3 = 0;
    for (int index = 0; index < length; ++index)
      num1 += range[index];
    double num4 = num1 / (double) length;
    for (int index = 0; index < length; ++index)
    {
      num2 += Math.Pow(range[index] - num4, 2.0);
      ++num3;
    }
    return Math.Sqrt(num2 / (double) num3);
  }

  private double NormalCumulativeDistributionFunctionInverse(
    double p,
    double mean,
    double standardDeviation)
  {
    double num = this.StandardNormalCumulativeDistributionInverse(p);
    return standardDeviation * num + mean;
  }

  public double StandardNormalCumulativeDistributionInverse(double p)
  {
    if (p < 0.0 || p > 1.0)
      throw new ArgumentException("Probability must be between 0 and 1");
    if (p == 0.0)
      return double.NegativeInfinity;
    if (p == 1.0)
      return double.PositiveInfinity;
    if (p == 0.5)
      return 0.0;
    if (0.0 < p && p < 0.02425)
    {
      double num = Math.Sqrt(-2.0 * Math.Log(p));
      return (((((-0.0077848940024302926 * num - 0.32239645804113648) * num - 2.4007582771618381) * num - 2.5497325393437338) * num + 4.3746641414649678) * num + 2.9381639826987831) / ((((0.0077846957090414622 * num + 0.32246712907003983) * num + 2.445134137142996) * num + 3.7544086619074162) * num + 1.0);
    }
    if (0.02425 <= p && p <= 0.97575)
    {
      double num1 = p - 0.5;
      double num2 = num1 * num1;
      return (((((-39.696830286653757 * num2 + 220.9460984245205) * num2 - 275.92851044696869) * num2 + 138.357751867269) * num2 - 30.66479806614716) * num2 + 2.5066282774592392) * num1 / (((((-54.476098798224058 * num2 + 161.58583685804089) * num2 - 155.69897985988661) * num2 + 66.80131188771972) * num2 - 13.280681552885721) * num2 + 1.0);
    }
    double num3 = Math.Sqrt(-2.0 * Math.Log(1.0 - p));
    return -(((((-0.0077848940024302926 * num3 - 0.32239645804113648) * num3 - 2.4007582771618381) * num3 - 2.5497325393437338) * num3 + 4.3746641414649678) * num3 + 2.9381639826987831) / ((((0.0077846957090414622 * num3 + 0.32246712907003983) * num3 + 2.445134137142996) * num3 + 3.7544086619074162) * num3 + 1.0);
  }

  private double pearson(double[] x, double[] y, int n)
  {
    double num1 = 0.0;
    double num2 = 0.0;
    int num3 = n;
    for (int index = 0; index < n; ++index)
    {
      if (!x[index].Equals(double.NaN) && !y[index].Equals(double.NaN))
      {
        num1 += x[index];
        num2 += y[index];
      }
      else
        --num3;
    }
    double num4 = num1 / (double) num3;
    double num5 = num2 / (double) num3;
    double num6 = 0.0;
    double num7 = 0.0;
    double num8 = 0.0;
    for (int index = 0; index < n; ++index)
    {
      if (!x[index].Equals(double.NaN) && !y[index].Equals(double.NaN))
      {
        double num9 = x[index] - num4;
        double num10 = y[index] - num5;
        num6 += num9 * num10;
        num7 += num9 * num9;
        num8 += num10 * num10;
      }
    }
    return num6 / Math.Sqrt(num7 * num8);
  }

  public string ComputeNpv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length < 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    strArray[0] = this.GetValueFromArg(strArray[0]);
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    double result2;
    double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2);
    double num1 = 0.0;
    double num2 = 1.0;
    for (int index = 1; index < length; ++index)
    {
      string args = strArray[index];
      double result3;
      if (args.IndexOf(':') > -1)
      {
        if (args.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        foreach (string cellsFromArg in this.GetCellsFromArgs(args))
        {
          string npv = this.FormulaErrorStringCheck(cellsFromArg, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) npv))
            return npv;
          string valueFromArg = this.GetValueFromArg(cellsFromArg);
          if (double.TryParse(bool.TryParse(valueFromArg, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result3))
          {
            num2 *= 1.0 + result2;
            num1 += result3 / num2;
          }
        }
      }
      else
      {
        string npv = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
        if (this.ErrorStrings.Contains((object) npv))
          return npv;
        string valueFromArg = this.GetValueFromArg(args);
        if (double.TryParse(bool.TryParse(valueFromArg, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result3))
        {
          num2 *= 1.0 + result2;
          num1 += result3 / num2;
        }
      }
    }
    return num1.ToString();
  }

  public string ComputePmt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 3:
      case 4:
      case 5:
        if (!string.IsNullOrEmpty(argList))
        {
          string pmt = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) pmt))
            return pmt;
          double result1 = 0.0;
          double result2 = 0.0;
          double result3 = 0.0;
          double result4 = 0.0;
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index].Replace(this.TIC, string.Empty));
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result5;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result5) ? Convert.ToInt16(result5).ToString() : strArray[index];
          }
          double result6;
          if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result6) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result2) && (length == 3 || double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result3)) && (length <= 4 || double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result4)))
          {
            if (result1 == 0.0)
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
              return this.ErrorStrings[4].ToString();
            }
            double num1 = Math.Abs(result4) <= 0.5 ? 0.0 : 1.0;
            double num2;
            if (result6 == 0.0)
            {
              num2 = 1.0 * (result3 + result2) / ((1.0 + result6 * num1) * (1.0 - (result1 + 1.0)));
            }
            else
            {
              double num3 = Math.Pow(1.0 + result6, result1);
              num2 = result6 * (result3 + result2 * num3) / ((1.0 + result6 * num1) * (1.0 - num3));
            }
            return num2.ToString();
          }
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
          return this.FormulaErrorStrings[this.invalid_arguments];
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputePpmt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 4:
      case 5:
      case 6:
        if (!string.IsNullOrEmpty(argList))
        {
          string ppmt = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) ppmt))
            return ppmt;
          double result1 = 0.0;
          double result2 = 0.0;
          double result3 = 0.0;
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index]);
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result4;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result4) ? Convert.ToInt16(result4).ToString() : strArray[index];
          }
          double result5;
          double result6;
          if (!double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result5) || !double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out double _) || !double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result6) || !double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result1) || length != 4 && !double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result2) || length > 5 && !double.TryParse(strArray[5], NumberStyles.Any, (IFormatProvider) null, out result3))
            return this.FormulaErrorStrings[this.invalid_arguments];
          double num1 = Math.Abs(result3) <= 0.5 ? 0.0 : 1.0;
          double num2 = Math.Pow(1.0 + result5, result6);
          double num3 = result5 * (result2 + result1 * num2) / ((1.0 + result5 * num1) * (1.0 - num2));
          double result7 = 0.0;
          double.TryParse(this.ComputeIpmt(argList), NumberStyles.Any, (IFormatProvider) null, out result7);
          return (num3 - result7).ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputePv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 3:
      case 4:
      case 5:
        if (!string.IsNullOrEmpty(argList))
        {
          string pv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) pv))
            return pv;
          double result1 = 0.0;
          double result2 = 0.0;
          double result3 = 0.0;
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index]);
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result4;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result4) ? Convert.ToInt16(result4).ToString() : strArray[index];
          }
          double result5;
          double result6;
          if (!double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result5) || !double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result6) || !double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result1) || length != 3 && !double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result2) || length > 4 && !double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result3))
            return this.FormulaErrorStrings[this.invalid_arguments];
          if (strArray[1] == "0" || strArray[2] == "0")
            return "0";
          double num1 = Math.Abs(result3) <= 0.5 ? 0.0 : 1.0;
          double num2 = Math.Pow(1.0 + result5, result6);
          return ((result1 * (1.0 + result5 * num1) * (1.0 - num2) - result5 * result2) / (result5 * num2)).ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeEffect(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    switch (strArray.GetLength(0))
    {
      case 0:
      case 2:
        if (!string.IsNullOrEmpty(argList))
        {
          string effect = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) effect))
            return effect;
          string valueFromArg1 = this.GetValueFromArg(strArray[0]);
          string valueFromArg2 = this.GetValueFromArg(strArray[1]);
          string empty = string.Empty;
          double result1;
          if (double.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1) && this.IsCellReference(strArray[0]) && strArray[0].Contains(this.TIC) && result1 <= 0.0)
            empty = this.ErrorStrings[4].ToString();
          double result2;
          if (double.TryParse(valueFromArg2.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2) && (!this.IsCellReference(strArray[1]) || !strArray[1].Contains(this.TIC)) && result2 <= 0.0)
            empty = this.ErrorStrings[4].ToString();
          if (string.IsNullOrEmpty(empty))
            return Math.Round(Math.Pow(1.0 + result1 / result2, result2) - 1.0, 9).ToString();
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException("invalid expression");
          return empty;
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeRate(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 3:
      case 4:
      case 5:
      case 6:
        double result1 = 0.0;
        double result2 = 0.0;
        double result3 = 0.1;
        for (int index = 0; index < length; ++index)
          strArray[index] = this.GetValueFromArg(strArray[index]);
        double result4;
        double result5;
        double result6;
        if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result5) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result6) && (length == 3 || double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result1)) && (length <= 4 || double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result2)) && (length <= 5 || double.TryParse(strArray[5], NumberStyles.Any, (IFormatProvider) null, out result3)))
        {
          double num1 = Math.Abs(result2) <= 0.5 ? 0.0 : 1.0;
          int num2;
          for (num2 = 0; num2 < 20; ++num2)
          {
            double x = Math.Abs(result3 + 1.0);
            double num3 = Math.Pow(x, result4);
            double num4 = Math.Pow(x, result4 - 1.0);
            double num5 = result3 * (result1 + result6 * num3);
            double num6 = (1.0 + result3 * num1) * (1.0 - num3);
            double num7 = result1 + result6 * (num3 + result3 * result4 * num4);
            double num8 = (1.0 + result3 * num1) * -result4 * num4 + (1.0 - num3) * num1;
            double num9 = (num7 * num6 - num5 * num8) / (num6 * num6);
            double num10 = (result5 - num5 / num6) / num9;
            if (Math.Abs(num10) < 1E-07)
            {
              result3 += num10;
              break;
            }
            result3 += num10;
          }
          if (num2 < 20)
            return result3.ToString();
        }
        return this.FormulaErrorStrings[this.invalid_arguments];
      default:
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  public string ComputeSln(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.requires_3_args];
    }
    string sln = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) sln))
      return sln;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
      num = (result2 - result3) / result4;
    if (!(this.ComputeIsErr(num.ToString()) == this.TRUEVALUESTR))
      return num.ToString("C");
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputeSyd(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string syd = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) syd))
      return syd;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result) ? Convert.ToInt16(result).ToString() : strArray[index];
    }
    double result1;
    double result2;
    double result3;
    double result4;
    return double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result4) ? ((result1 - result2) * (result3 - result4 + 1.0) * 2.0 / (result3 * (result3 + 1.0))).ToString() : this.FormulaErrorStrings[this.invalid_arguments];
  }

  public string ComputeVdb(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 5:
      case 6:
      case 7:
        if (!string.IsNullOrEmpty(argList))
        {
          string vdb = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) vdb))
            return vdb;
          double result1 = 2.0;
          double result2 = 0.0;
          double num1 = 0.0;
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index]);
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result3;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result3) ? Convert.ToInt16(result3).ToString() : strArray[index];
          }
          double result4;
          double result5;
          double result6;
          double result7;
          double result8;
          if (!double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result4) || !double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result5) || !double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result6) || !double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result7) || !double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result8) || length != 5 && !double.TryParse(strArray[5], NumberStyles.Any, (IFormatProvider) null, out result1) || length > 6 && !double.TryParse(strArray[6], NumberStyles.Any, (IFormatProvider) null, out result2))
            return this.FormulaErrorStrings[this.invalid_arguments];
          double num2 = result1 / result6;
          double num3 = 0.0;
          double num4 = (result4 - result5) / result6;
          bool flag = Math.Abs(result2) > 0.5;
          int num5 = 0;
          while ((double) num5 < result8)
          {
            ++num5;
            double num6;
            if ((double) num5 == result6)
            {
              num6 = result4 - result5 - num3;
            }
            else
            {
              num6 = (result4 - num3) * num2;
              if (flag && num6 < num4)
                num6 = num4;
            }
            num3 += num6;
            if ((double) num5 > result7 && (double) num5 <= result8)
              num1 += num6;
            else if ((double) num5 - result8 < 0.99 && (double) num5 - result8 > 0.0)
              num1 += num6 * (result8 - (double) num5 + 1.0);
          }
          return num1.ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeDollarDe(string args)
  {
    string empty = string.Empty;
    NumberFormatInfo provider = (NumberFormatInfo) CultureInfo.CurrentCulture.NumberFormat.Clone();
    string s;
    try
    {
      string[] strArray1 = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray1.Length != 2 || string.IsNullOrEmpty(args))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      if (string.IsNullOrEmpty(strArray1[0]) || string.IsNullOrEmpty(strArray1[1]))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[0].ToString();
      }
      string str1 = strArray1[0];
      string str2 = "2";
      if (strArray1.GetLength(0) == 2)
        str2 = strArray1[1];
      string args1 = this.GetValueFromArg(str1);
      string str3 = this.GetValueFromArg(str2);
      string[] strArray2 = args1.Split(CalcEngine.parseDecimalSeparator);
      if (args1.Length == 0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      if (!this.IsCellReference(args1) && args1.Contains(this.TIC))
        args1 = args1.Replace(this.TIC, string.Empty);
      if (!this.IsCellReference(str3) && str3.Contains(this.TIC))
        str3 = str3.Replace(this.TIC, string.Empty);
      double.TryParse(strArray2[0], NumberStyles.Any, (IFormatProvider) null, out double _);
      double result;
      if (!double.TryParse(str3, NumberStyles.Any, (IFormatProvider) null, out result))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[1].ToString());
        return this.ErrorStrings[1].ToString();
      }
      if (result < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[3].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (result == 0.0 || this.ComputeRounddown(result.ToString()) == "0")
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[3].ToString());
        return this.ErrorStrings[3].ToString();
      }
      if (result > 0.0)
      {
        string[] strArray3 = this.SplitArguments(args1, CalcEngine.ParseDecimalSeparator);
        string[] strArray4 = this.SplitArguments(((result / 10.0 > 1.0 ? (strArray3.Length == 2 ? double.Parse($"0{CalcEngine.ParseDecimalSeparator.ToString()}{strArray3[1]}") * 100.0 : 0.0) : (strArray3.Length == 2 ? double.Parse($"0{CalcEngine.ParseDecimalSeparator.ToString()}{strArray3[1]}") * 10.0 : 0.0)) / result).ToString(), CalcEngine.ParseDecimalSeparator);
        int num = int.Parse(strArray3[0], NumberStyles.Any) + int.Parse(strArray4[0], NumberStyles.Any);
        s = strArray4.Length <= 1 ? num.ToString() : num.ToString() + CalcEngine.ParseDecimalSeparator.ToString() + (strArray4.Length == 2 ? strArray4[1] : string.Empty);
        if (double.Parse(s) > 0.0)
        {
          string[] strArray5 = s.ToString().Split(CalcEngine.parseDecimalSeparator);
          if (strArray5.Length > 1)
          {
            if (strArray5[1].Length > 0)
            {
              int length = strArray5[1].Length;
              provider.CurrencyDecimalDigits = length;
            }
          }
        }
        else
        {
          if (double.Parse(s) < 0.0)
            return string.Format((IFormatProvider) provider, "{0}", (object) args1);
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[3].ToString());
        return this.ErrorStrings[3].ToString();
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (!this.rethrowLibraryComputationExceptions)
        return ex.Message;
      throw;
    }
    return string.Format((IFormatProvider) provider, "{0}", (object) s);
  }

  public string ComputeDollarFr(string args)
  {
    NumberFormatInfo provider = (NumberFormatInfo) CultureInfo.CurrentCulture.NumberFormat.Clone();
    double num;
    try
    {
      string[] strArray1 = this.SplitArgsPreservingQuotedCommas(args);
      string str1 = strArray1[0];
      string str2 = "2";
      if (strArray1.GetLength(0) == 2)
        str2 = strArray1[1];
      if (strArray1.GetLength(0) >= 1 && string.IsNullOrEmpty(str1))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      if (string.IsNullOrEmpty(strArray1[0]) || string.IsNullOrEmpty(strArray1[1]))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[0].ToString();
      }
      string dollarFr = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) dollarFr))
        return dollarFr;
      string valueFromArg1 = this.GetValueFromArg(str1);
      string valueFromArg2 = this.GetValueFromArg(str2);
      valueFromArg1.Split(CalcEngine.parseDecimalSeparator);
      double result1;
      double.TryParse(this.StripTics0(valueFromArg1), NumberStyles.Any, (IFormatProvider) null, out result1);
      double result2;
      double.TryParse(this.StripTics0(valueFromArg2), NumberStyles.Any, (IFormatProvider) null, out result2);
      if (double.IsNaN(result1) || double.IsNaN(result2))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[1].ToString());
        return this.ErrorStrings[1].ToString();
      }
      if (result2 >= 0.0 && result2 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[3].ToString());
        return this.ErrorStrings[3].ToString();
      }
      if (result2 < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (result1 >= 0.0 && result1 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[3].ToString());
        return this.ErrorStrings[3].ToString();
      }
      num = (double) (int) result1 + result1 % 1.0 * Math.Pow(10.0, -Math.Ceiling(Math.Log(result2) / Math.Log(10.0))) * result2;
      string[] strArray2 = num.ToString().Split(CalcEngine.parseDecimalSeparator);
      if (strArray2.Length > 1)
      {
        if (strArray2[1].Length > 0)
        {
          int length = strArray2[1].Length;
          provider.CurrencyDecimalDigits = length;
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (!this.rethrowLibraryComputationExceptions)
        return ex.Message;
      throw;
    }
    return string.Format((IFormatProvider) provider, "{0}", (object) num);
  }

  public string ComputeDuration(string args)
  {
    string empty = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      double num1 = double.Parse(this.ComputeDays360(strArray[0] + (object) CalcEngine.ParseArgumentSeparator + strArray[1])) / 12.0;
      double num2 = num1 / 60.0;
      double num3 = double.Parse(this.GetValueFromArg(strArray[3]));
      double num4 = 100.0;
      double x = double.Parse(this.GetValueFromArg(strArray[2])) * 100.0;
      int y1 = 1;
      double num5 = 0.0;
      for (; (double) y1 <= num2; ++y1)
        num5 += Math.Pow(x, (double) y1) / Math.Pow(1.0 + num3, (double) y1);
      double y2 = num1 / 30.0;
      empty = (((num5 + x * 100.0 / Math.Pow(1.0 + num3, y2)) / (x * (1.0 - 1.0 / Math.Pow(1.0 + num3, y2) / num3 + num4 / Math.Pow(1.0 + num3, y2))) + x / 100.0) / 2.0 + x / 10.0).ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw;
    }
    return empty;
  }

  public string ComputeACCRINTM(string args)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    if (strArray.Length < 4 || strArray.Length > 5)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string valueFromArg1 = this.GetValueFromArg(strArray[0]);
    string valueFromArg2 = this.GetValueFromArg(strArray[1]);
    string valueFromArg3 = this.GetValueFromArg(strArray[2]);
    string valueFromArg4 = this.GetValueFromArg(strArray[3]);
    string str1 = strArray.Length == 5 ? this.GetValueFromArg(strArray[4]) : "0";
    DateTime result1 = this.dateTime1900;
    DateTime result2 = this.dateTime1900;
    double result3 = 0.0;
    double result4 = 0.0;
    double result5;
    if (!double.TryParse(str1.Replace(this.TIC, string.Empty), out result5))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    if (!double.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), out result3) && !DateTime.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), out result1) || !double.TryParse(valueFromArg2.Replace(this.TIC, string.Empty), out result4) && !DateTime.TryParse(valueFromArg2.Replace(this.TIC, string.Empty), out result2))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    if (result3 > 0.0)
      result1 = DateTime.FromOADate(result3);
    if (result4 > 0.0)
      result2 = DateTime.FromOADate(result4);
    double result6;
    if (valueFromArg4.Equals(string.Empty))
      result6 = 1000.0;
    else if (double.TryParse(valueFromArg4, out result6))
    {
      if (result6 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    else
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    double result7;
    if (double.TryParse(valueFromArg3, out result7))
    {
      if (result7 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      string str2 = this.TIC + result1.ToShortDateString() + this.TIC;
      string str3 = this.TIC + result2.ToShortDateString() + this.TIC;
      double result8;
      double result9;
      if (double.TryParse(str2.Replace(this.TIC, string.Empty), out result8) && double.TryParse(str3.Replace(this.TIC, string.Empty), out result9) && result8 >= result9)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      double num;
      switch ((int) result5)
      {
        case 0:
          num = double.Parse(this.ComputeDays360(str2 + CalcEngine.ParseArgumentSeparator.ToString() + str3 + CalcEngine.ParseArgumentSeparator.ToString() + this.TRUEVALUESTR)) / 360.0;
          break;
        case 1:
          num = double.Parse(this.ComputeDays360(str2 + CalcEngine.ParseArgumentSeparator.ToString() + str3)) / 365.0;
          break;
        case 2:
          num = double.Parse(this.ComputeDays(str3 + CalcEngine.ParseArgumentSeparator.ToString() + str2)) / 360.0;
          break;
        case 3:
          num = double.Parse(this.ComputeDays(str3 + CalcEngine.ParseArgumentSeparator.ToString() + str2)) / 365.0;
          break;
        case 4:
          num = double.Parse(this.ComputeDays360(str2 + CalcEngine.ParseArgumentSeparator.ToString() + str3)) / 360.0;
          break;
        default:
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
      }
      return (result7 * result6 * num).ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[4].ToString());
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeRRI(string args)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    if (strArray.Length != 3 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string rri = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) rri))
      return rri;
    string valueFromArg1 = this.GetValueFromArg(strArray[0]);
    string str1 = string.IsNullOrEmpty(valueFromArg1) ? "0" : valueFromArg1;
    bool result1;
    string s1 = bool.TryParse(str1, out result1) ? Convert.ToInt16(result1).ToString() : str1;
    string valueFromArg2 = this.GetValueFromArg(strArray[1]);
    string str2 = string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2;
    string s2 = bool.TryParse(str2, out result1) ? Convert.ToInt16(result1).ToString() : str2;
    string valueFromArg3 = this.GetValueFromArg(strArray[2]);
    string str3 = string.IsNullOrEmpty(valueFromArg3) ? "0" : valueFromArg3;
    string s3 = bool.TryParse(str3, out result1) ? Convert.ToInt16(result1).ToString() : str3;
    double result2;
    double result3;
    double result4;
    if (!double.TryParse(s1, out result2) || !double.TryParse(s2, out result3) || !double.TryParse(s3, out result4))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    if (result2 != 0.0 && result3 != 0.0)
      return (Math.Pow(result4 / result3, 1.0 / result2) - 1.0).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new Exception(this.ErrorStrings[4].ToString());
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeFvschedule(string args)
  {
    double num = 0.0;
    try
    {
      string[] strArray1 = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray1.Length > 2 || string.IsNullOrEmpty(args))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      string fvschedule1 = this.FormulaErrorStringCheck(strArray1[0], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) fvschedule1))
        return fvschedule1;
      string fvschedule2 = this.FormulaErrorStringCheck(strArray1[1], CalcEngine.FormulaArgumentType.Text);
      if (this.ErrorStrings.Contains((object) fvschedule2))
        return fvschedule2;
      string str1 = strArray1[0];
      string str2 = strArray1[1];
      string valueFromArg1 = this.GetValueFromArg(str1);
      string valueFromArg2 = this.GetValueFromArg(str2);
      if (string.IsNullOrEmpty(valueFromArg1) || string.IsNullOrEmpty(valueFromArg2))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[0].ToString();
      }
      double result1 = 0.0;
      double result2 = 0.0;
      double.TryParse(valueFromArg1, out result1);
      num = result1;
      string[] strArray2 = valueFromArg2.Replace(this.TIC, "").Split(CalcEngine.ParseArgumentSeparator);
      for (int index = 0; index < strArray2.Length; ++index)
      {
        if (string.IsNullOrEmpty(strArray2[index]))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        if (!double.TryParse(strArray2[index].ToString(), NumberStyles.Any, (IFormatProvider) null, out result2))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[5].ToString());
          return this.ErrorStrings[5].ToString();
        }
        result2 = double.Parse(strArray2[index]);
        num *= 1.0 + result2;
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw;
    }
    return num.ToString();
  }

  public string ComputeIntrate(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    List<DateTime> dateTimeList = new List<DateTime>();
    if (length > 5)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
    string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    string s1 = length == 5 ? this.GetValueFromArg(strArray[4]).Replace(this.TIC, "") : "0";
    string s2 = this.GetValueFromArg(strArray[2]).Replace(this.TIC, "");
    string s3 = this.GetValueFromArg(strArray[3]).Replace(this.TIC, "");
    int result1;
    double result2;
    double result3;
    if (!DateTime.TryParse(str1, out DateTime _) || !DateTime.TryParse(str2, out DateTime _) || !int.TryParse(s1, out result1) || !double.TryParse(s2, out result2) || !double.TryParse(s3, out result3))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double num1 = double.Parse(this.ComputeDatevalue(str2)) - double.Parse(this.ComputeDatevalue(str1));
    if (result1 > 4 && result1 < 0 && num1 < 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    double num2 = (result3 - result2) / (result2 * num1);
    double num3;
    switch (result1)
    {
      case 0:
        num3 = num2 * 360.0;
        break;
      case 1:
        num3 = num2 * 366.0;
        break;
      case 2:
        num3 = num2 * 360.0;
        break;
      case 3:
        num3 = num2 * 365.0;
        break;
      case 4:
        num3 = num2 * 360.0;
        break;
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
    }
    return num3.ToString();
  }

  public string ComputeDisc(string args)
  {
    string empty1 = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3 || strArray.Length > 5 || string.IsNullOrEmpty(args))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentNullException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.FormulaErrorStrings[this.invalid_arguments];
      }
      string s1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
      string s2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty);
      string valueFromArg1 = this.GetValueFromArg(strArray[2]);
      string valueFromArg2 = this.GetValueFromArg(strArray[3]);
      DateTime result1;
      DateTime result2 = result1 = this.dateTime1900;
      double result3 = 0.0;
      double result4 = 0.0;
      string empty2 = string.Empty;
      string str = strArray.Length <= 4 ? "0" : strArray[4];
      for (int index = 0; index <= 1; ++index)
      {
        string disc = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Date);
        if (this.ErrorStrings.Contains((object) disc))
          return disc;
      }
      for (int index = 2; index < strArray.Length; ++index)
      {
        if (index <= strArray.Length)
        {
          string disc = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) disc))
            return disc;
        }
      }
      if (string.IsNullOrEmpty(valueFromArg1) || string.IsNullOrEmpty(valueFromArg2))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[0].ToString();
      }
      if (DateTime.TryParse(s1, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result2) || double.TryParse(s1, out result3) && (DateTime.TryParse(s2, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result1) || double.TryParse(s2, out result4)))
      {
        if (result3 > 1.0)
          s1 = DateTime.FromOADate(result3).ToString();
        if (result4 > 1.0)
          s2 = DateTime.FromOADate(result4).ToString();
        string valueFromArg3 = this.GetValueFromArg(valueFromArg1);
        string valueFromArg4 = this.GetValueFromArg(valueFromArg2);
        string valueFromArg5 = this.GetValueFromArg(str);
        string s3 = string.IsNullOrEmpty(valueFromArg5) ? "0" : valueFromArg5;
        DateTime result5 = DateTime.Now;
        double result6 = 0.0;
        double result7 = 0.0;
        double result8;
        double result9;
        double result10;
        if (double.TryParse(valueFromArg3, out result8) && double.TryParse(valueFromArg4, out result9) && double.TryParse(s3, out result10) && (result8 < 0.0 || result8 == 0.0 || result9 < 0.0 || result9 == 0.0 || result10 < 0.0 || result10 > 4.0))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[4].ToString();
        }
        DateTime result11;
        if (!DateTime.TryParse(s1.Replace(this.TIC, string.Empty), out result11))
        {
          if (!double.TryParse(s1, out result6))
            goto label_66;
        }
        if (!DateTime.TryParse(s2.Replace(this.TIC, string.Empty), out result5))
        {
          if (!double.TryParse(s2, out result7))
            goto label_66;
        }
        if (result11.Year == 1 || result5.Year == 1)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[4].ToString();
        }
        if (result6 == 0.0)
          result6 = result11.ToOADate();
        if (result7 == 0.0)
          result7 = result5.ToOADate();
        if (result6 > result7 || result6 == result7)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
        if (result7 < 1.0 || result6 < 1.0)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
        double num = double.Parse(this.ComputeDays360(result6.ToString() + CalcEngine.ParseArgumentSeparator.ToString() + (object) result7)) + 1.0;
        switch (s3)
        {
          case "0":
            s3 = "360";
            break;
          case "1":
            s3 = "365";
            break;
          case "2":
            s3 = 360.ToString();
            break;
          case "3":
            s3 = 365.ToString();
            break;
          case "4":
            s3 = "30";
            break;
        }
        empty1 = ((double.Parse(valueFromArg4) - double.Parse(valueFromArg3)) / double.Parse(valueFromArg4) * (double.Parse(s3) / num)).ToString();
      }
      else
      {
        if (s1.StartsWith(this.TIC) || s2.StartsWith(this.TIC) || s1.Equals(string.Empty) || s2.Equals(string.Empty))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentNullException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
label_66:
    return empty1;
  }

  public string ComputeFv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 3:
      case 4:
      case 5:
        if (!string.IsNullOrEmpty(argList))
        {
          string fv1 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) fv1))
            return fv1;
          double result1 = 0.0;
          double result2 = 0.0;
          double result3 = 0.0;
          string valueFromArg1 = this.GetValueFromArg(strArray[0]);
          string valueFromArg2 = this.GetValueFromArg(strArray[1]);
          string valueFromArg3 = this.GetValueFromArg(strArray[2]);
          string str1 = length >= 4 ? this.GetValueFromArg(strArray[3]) : "0";
          string str2 = length == 5 ? this.GetValueFromArg(strArray[4]) : "0";
          string str3 = string.IsNullOrEmpty(valueFromArg1) ? "0" : valueFromArg1;
          string str4 = string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2;
          string str5 = string.IsNullOrEmpty(valueFromArg3) ? "0" : valueFromArg3;
          string str6 = string.IsNullOrEmpty(str1) ? "0" : str1;
          string str7 = string.IsNullOrEmpty(str2) ? "0" : str2;
          string fv2 = string.Empty;
          double result4;
          if (!double.TryParse(str3.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result4))
            fv2 = this.IsCellReference(strArray[0]) || strArray[0].Contains(this.TIC) ? this.ErrorStrings[1].ToString() : this.ErrorStrings[5].ToString();
          double result5;
          if (!double.TryParse(str4.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result5))
            fv2 = this.IsCellReference(strArray[1]) || strArray[1].Contains(this.TIC) ? this.ErrorStrings[1].ToString() : this.ErrorStrings[5].ToString();
          if (!double.TryParse(str5.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1))
            fv2 = this.IsCellReference(strArray[2]) || strArray[2].Contains(this.TIC) ? this.ErrorStrings[1].ToString() : this.ErrorStrings[5].ToString();
          if (!double.TryParse(str6.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2))
            fv2 = this.IsCellReference(strArray[3]) || strArray[3].Contains(this.TIC) ? this.ErrorStrings[1].ToString() : this.ErrorStrings[5].ToString();
          if (!double.TryParse(str7.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result3))
            fv2 = this.IsCellReference(strArray[4]) || strArray[4].Contains(this.TIC) ? this.ErrorStrings[1].ToString() : this.ErrorStrings[5].ToString();
          if (!string.IsNullOrEmpty(fv2))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException("invalid expression");
            return fv2;
          }
          result3 = Math.Abs(result3) > 0.5 ? 1.0 : 0.0;
          double num = Math.Pow(1.0 + result4, result5);
          double d1 = result1 * (1.0 + result4 * result3) * (1.0 - num) / result4 - result2 * num;
          double d2 = (1.0 - num) / result4;
          if (double.IsNaN(d1) && double.IsNaN(d2))
            d1 = 1.0 * (1.0 + result4 * result3) * (1.0 - num) / 1.0 - result2 * num;
          return d1.ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeIpmt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 4:
      case 5:
      case 6:
        if (!string.IsNullOrEmpty(argList))
        {
          string ipmt = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) ipmt))
            return ipmt;
          double result1 = 0.0;
          double result2 = 0.0;
          double result3 = 0.0;
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index]);
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result4;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result4) ? Convert.ToInt16(result4).ToString() : strArray[index];
          }
          double result5;
          double result6;
          double result7;
          if (!double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result5) || !double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result6) || !double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result7) || !double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result1) || length != 4 && !double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result2) || length > 5 && !double.TryParse(strArray[5], NumberStyles.Any, (IFormatProvider) null, out result3))
            return this.FormulaErrorStrings[this.invalid_arguments];
          double num1 = Math.Abs(result3) <= 0.5 ? 0.0 : 1.0;
          double num2 = Math.Pow(1.0 + result5, result7);
          double num3 = Math.Pow(1.0 + result5, result6);
          double num4 = result5 * (result2 + result1 * num2) / ((1.0 + result5 * num1) * (1.0 - num2));
          double num5 = num4 * (1.0 + result5 * num1) * (1.0 - num3) / result5 - result1 * num3;
          double num6 = Math.Pow(1.0 + result5, result6 - 1.0);
          double num7 = num4 * (1.0 + result5 * num1) * (1.0 - num6) / result5 - result1 * num6;
          return (num4 - num7 + num5).ToString();
        }
        break;
    }
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeIrr(string argList)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(argList);
    int length1 = strArray1.GetLength(0);
    int num1 = length1;
    if (length1 != 1 && length1 != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string irr1 = this.FormulaErrorStringCheck(strArray1[0], CalcEngine.FormulaArgumentType.None);
    if (this.ErrorStrings.Contains((object) irr1))
      return irr1;
    if (strArray1.Length == 2)
    {
      string irr2 = this.FormulaErrorStringCheck(strArray1[1], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) irr2))
        return irr2;
    }
    for (int index = 0; index < length1; ++index)
    {
      if (!this.IsCellReference(strArray1[index]) && (string.IsNullOrEmpty(this.GetValueFromArg(strArray1[index])) || bool.TryParse(this.GetValueFromArg(strArray1[index]), out bool _)))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[1].ToString();
      }
    }
    double result1 = 0.1;
    string args = strArray1[0];
    double num2 = 0.0;
    if (length1 == 2)
      double.TryParse(this.GetValueFromArg(strArray1[1]), NumberStyles.Any, (IFormatProvider) null, out result1);
    string[] strArray2 = !strArray1[0].Contains(":") ? this.SplitArgsPreservingQuotedCommas(strArray1[0].Replace(this.TIC, string.Empty)) : this.GetCellsFromArgs(args);
    int length2 = strArray2.GetLength(0);
    double[] numArray = new double[length2];
    int index1 = 0;
    bool flag1 = false;
    bool flag2 = false;
    foreach (string str in strArray2)
    {
      double result2;
      if (double.TryParse(this.GetValueFromArg(str), NumberStyles.Any, (IFormatProvider) null, out result2))
      {
        if (result2 > 0.0)
          flag1 = true;
        else if (result2 < 0.0)
          flag2 = true;
        numArray[index1] = result2;
        num2 += result2;
      }
      ++index1;
    }
    if (!flag1 && !flag2)
      return this.ErrorStrings[4].ToString();
    int num3 = 0;
    result1 = num2 >= 0.0 || num1 != 1 ? result1 : -0.9;
    for (; num3 < 20; ++num3)
    {
      double num4 = 0.0;
      double num5 = 0.0;
      double num6 = Math.Abs(result1 + 1.0);
      double num7 = num6;
      for (int index2 = 0; index2 < length2; ++index2)
      {
        num4 += numArray[index2] / num7;
        num7 *= num6;
        double num8 = (double) (index2 + 1) * numArray[index2] / num7;
        if (numArray[index2] == 0.0 && num5 < 0.0)
          num5 = num8;
        else
          num5 += num8;
      }
      double num9 = num4 / num5;
      if (Math.Abs(num9 / result1) < 1E-05)
      {
        result1 += num9;
        break;
      }
      result1 += num9;
    }
    if (num3 < 20)
      return result1.ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeXirr(string argList)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(argList);
    int length1 = strArray1.GetLength(0);
    switch (length1)
    {
      case 2:
      case 3:
        double result1 = 0.1;
        string args1 = strArray1[0];
        if (length1 == 3)
          double.TryParse(this.GetValueFromArg(strArray1[2]), NumberStyles.Any, (IFormatProvider) null, out result1);
        string[] strArray2 = args1.Contains(CalcEngine.ParseArgumentSeparator.ToString()) ? this.SplitArgsPreservingQuotedCommas(args1.Replace(this.TIC, string.Empty)) : this.GetCellsFromArgs(args1);
        int length2 = strArray2.GetLength(0);
        double[] numArray1 = new double[length2];
        int index1 = 0;
        int num1 = 0;
        int num2 = 0;
        foreach (string str in strArray2)
        {
          double result2;
          if (double.TryParse(this.GetValueFromArg(str.Replace("u", "-").Replace(this.TIC, string.Empty)), NumberStyles.Any, (IFormatProvider) null, out result2))
            numArray1[index1] = result2;
          if (result2 < 0.0)
            ++num2;
          else if (result2 > 0.0)
            ++num1;
          ++index1;
        }
        if (num1 == 0 || num2 == 0)
          return this.ErrorStrings[4].ToString();
        string args2 = strArray1[1];
        string[] strArray3;
        if (!strArray1[1].Contains(CalcEngine.ParseArgumentSeparator.ToString()) && this.IsCellReference(strArray1[1]))
          strArray3 = this.GetCellsFromArgs(args2);
        else
          strArray3 = strArray1[1].Split(CalcEngine.ParseArgumentSeparator);
        string[] strArray4 = strArray3;
        if (strArray4.GetLength(0) != length2)
          return this.ErrorStrings[4].ToString();
        int[] numArray2 = new int[length2];
        int index2 = 0;
        foreach (string str in strArray4)
        {
          string valueFromArg = this.GetValueFromArg(str);
          int result3;
          bool flag = int.TryParse(valueFromArg, out result3);
          DateTime result4;
          if (!flag && DateTime.TryParse(valueFromArg.Replace(this.TIC, string.Empty), out result4))
          {
            numArray2[index2] = (int) this.GetSerialDateTimeFromDate(result4);
          }
          else
          {
            if (!flag)
              return this.ErrorStrings[1].ToString();
            numArray2[index2] = result3;
          }
          if (numArray2[index2] < numArray2[0])
            return this.ErrorStrings[4].ToString();
          ++index2;
        }
        int num3;
        for (num3 = 0; num3 < 100; ++num3)
        {
          double num4 = 0.0;
          double num5 = 0.0;
          double x = result1 + 1.0;
          for (int index3 = 0; index3 < length2; ++index3)
          {
            double y = (double) (numArray2[0] - numArray2[index3]) / 365.0;
            double num6 = Math.Pow(x, y);
            num4 += numArray1[index3] * num6;
            num5 += numArray1[index3] * y * num6 / x;
          }
          double num7 = num4 / num5;
          result1 -= num7;
          if (Math.Abs(num7) < 1E-06)
            break;
        }
        return num3 >= 100 ? "#NUM!" : result1.ToString();
      default:
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  public string ComputeIspmt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string ispmt = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) ispmt))
      return ispmt;
    double result1 = 0.0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result2;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
    }
    double result3;
    double result4;
    double result5;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result5) && double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result1))
      num = -result3 * result1 * (result5 - result4) / result5;
    if (!(this.ComputeIsErr(num.ToString()) == this.TRUEVALUESTR))
      return num.ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputeMirr(string argList)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray1.GetLength(0) != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string mirr1 = this.FormulaErrorStringCheck(strArray1[0], CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) mirr1))
      return mirr1;
    for (int index = 1; index <= 2; ++index)
    {
      string mirr2 = this.FormulaErrorStringCheck(strArray1[index], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) mirr2))
        return mirr2;
    }
    double result1 = 0.1;
    double result2 = 0.1;
    double.TryParse(this.GetValueFromArg(strArray1[1]), NumberStyles.Any, (IFormatProvider) null, out result1);
    double.TryParse(this.GetValueFromArg(strArray1[2]), NumberStyles.Any, (IFormatProvider) null, out result2);
    string args = strArray1[0];
    string[] strArray2 = !strArray1[0].Contains(":") ? this.SplitArgsPreservingQuotedCommas(strArray1[0].Replace(this.TIC, string.Empty)) : this.GetCellsFromArgs(args);
    int length = strArray2.GetLength(0);
    double[] numArray = new double[length];
    int index1 = 0;
    foreach (string str in strArray2)
    {
      double result3;
      if (double.TryParse(this.GetValueFromArg(str), NumberStyles.Any, (IFormatProvider) null, out result3))
        numArray[index1] = result3;
      ++index1;
    }
    double num1 = 0.0;
    double num2 = 0.0;
    double num3 = 1.0;
    double num4 = 1.0 + result1;
    for (int index2 = 0; index2 < length; ++index2)
    {
      num3 *= 1.0 + result2;
      if (numArray[index2] > 0.0)
        num1 += numArray[index2] / num3;
      else
        num2 += numArray[index2] / num4;
      num4 *= 1.0 + result1;
    }
    return (Math.Round(100.0 * (Math.Pow(-num1 * num3 / (num2 * (1.0 + result1)), 1.0 / ((double) length - 1.0)) - 1.0)) / 100.0).ToString("0%");
  }

  public string ComputeNper(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 3:
      case 4:
      case 5:
        if (!string.IsNullOrEmpty(argList))
        {
          string nper = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) nper))
            return nper;
          double result1 = 0.0;
          double result2 = 0.0;
          double result3 = 0.0;
          double result4 = 0.0;
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index]);
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result5;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result5) ? Convert.ToInt16(result5).ToString() : strArray[index];
          }
          double result6;
          if (!double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result6) || !double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result1) || !double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result2) || length != 3 && !double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result3) || length > 4 && !double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result4))
            return this.FormulaErrorStrings[this.invalid_arguments];
          double num = Math.Abs(result4) <= 0.5 ? 0.0 : 1.0;
          return (Math.Log10((result1 * (1.0 + result6 * num) - result3 * result6) / (result1 * (1.0 + result6 * num) + result2 * result6)) / Math.Log10(1.0 + result6)).ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeDb(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 4:
      case 5:
        if (!string.IsNullOrEmpty(argList))
        {
          string db = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) db))
            return db;
          double result1 = 12.0;
          double num1 = 0.0;
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index]);
            strArray[index] = this.StripTics(strArray[index]);
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result2;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
          }
          double result3;
          double result4;
          double result5;
          double result6;
          if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && result3 >= 0.0 && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && result4 > 0.0 && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result5) && result5 > 0.0 && double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result6) && result6 > 0.0 && (length == 4 || double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result1)) && result1 > 0.0)
          {
            if (result5 < result6 && (result1 < 0.0 || result1 == 12.0))
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.ErrorStrings[4].ToString());
              return this.ErrorStrings[4].ToString();
            }
            double num2 = Math.Round(1.0 - Math.Pow(result4 / result3, 1.0 / result5), 3);
            double num3 = 0.0;
            for (int index = 1; (double) index <= result6; ++index)
            {
              num1 = index != 1 ? ((double) index <= result5 ? (result3 - num3) * num2 : (result3 - num3) * num2 * (12.0 - result1) / 12.0) : result3 * num2 * result1 / 12.0;
              if (this.ComputeIsErr(num1.ToString()) == this.TRUEVALUESTR)
                return "0";
              num3 += num1;
            }
            return num1.ToString();
          }
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeDdb(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 4:
      case 5:
        if (!string.IsNullOrEmpty(argList))
        {
          string ddb = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) ddb))
            return ddb;
          double result1 = 2.0;
          double num1 = 0.0;
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index]);
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result2;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
          }
          double result3;
          double result4;
          double result5;
          double result6;
          if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && result3 > 0.0 && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && result4 > 0.0 && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result5) && result5 > 0.0 && double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result6) && result6 > 0.0 && (length == 4 || double.TryParse(strArray[4], NumberStyles.Any, (IFormatProvider) null, out result1)) && result5 >= result6)
          {
            double num2 = result1 / result5;
            double num3 = 0.0;
            for (int index = 1; (double) index <= result6; ++index)
            {
              num1 = (double) index == result5 / 2.0 || result1 == 12.0 || result5 == 1.0 ? result3 - result4 - num3 : (result3 - num3) * num2;
              num3 += num1;
            }
            return num1.ToString();
          }
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[4].ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeCUMIPMT(string args)
  {
    double num1;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 5 || string.IsNullOrEmpty(args))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      string cumipmt = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) cumipmt))
        return cumipmt;
      string str1 = strArray[0];
      string str2 = strArray[1];
      string str3 = strArray[2];
      string str4 = strArray[3];
      string str5 = strArray[4];
      string str6 = strArray[5];
      string valueFromArg1 = this.GetValueFromArg(str1);
      string valueFromArg2 = this.GetValueFromArg(str2);
      string valueFromArg3 = this.GetValueFromArg(str3);
      string valueFromArg4 = this.GetValueFromArg(str4);
      string valueFromArg5 = this.GetValueFromArg(str5);
      string valueFromArg6 = this.GetValueFromArg(str6);
      double result1 = 0.0;
      double result2 = 0.0;
      double result3 = 0.0;
      double result4 = 0.0;
      double result5 = 0.0;
      double result6 = 0.0;
      if (!double.TryParse(valueFromArg1, out result1) || !double.TryParse(valueFromArg2, out result2) || !double.TryParse(valueFromArg3, out result3) || !double.TryParse(valueFromArg4, out result4) || !double.TryParse(valueFromArg5, out result5) || !double.TryParse(valueFromArg6, out result6))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.ErrorStrings[1].ToString());
        return this.ErrorStrings[1].ToString();
      }
      if (result1 <= 0.0 || result2 <= 0.0 || result3 <= 0.0 || result4 < 1.0 || result5 < 1.0 || result4 > result5 || result6 != 0.0 && result6 != 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (result4 < 1.0 || result5 < 1.0 || result4 > result5)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[1].ToString();
      }
      if (result6 != 0.0 && result6 != 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      double num2 = double.Parse(this.ComputePmt($"{result1},{result2},{result3},{0},{result6}"));
      double num3 = 0.0;
      if (result4 == 1.0 && result6 == 0.0)
      {
        num3 = -result3;
        ++result4;
      }
      for (int index = (int) result4; (double) index <= result5; ++index)
      {
        if (result6 == 1.0)
          num3 += double.Parse(this.ComputeFv($"{result1},{index - 2},{num2},{result3},{1}")) - num2;
        else
          num3 += double.Parse(this.ComputeFv($"{result1},{index - 1},{num2},{result3},{0}"));
      }
      num1 = num3 * result1;
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return num1.ToString();
  }

  public string ComputeACCRINT(string args)
  {
    double num1;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 5)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      string str1 = strArray[0];
      string str2 = strArray[1];
      string str3 = strArray[2];
      string str4 = strArray[3];
      string str5 = strArray[4];
      string str6 = strArray[5];
      string str7 = strArray.Length < 7 ? "0" : strArray[6];
      string str8 = strArray.Length < 8 ? "0" : strArray[7];
      string valueFromArg1 = this.GetValueFromArg(str1);
      string valueFromArg2 = this.GetValueFromArg(str2);
      string valueFromArg3 = this.GetValueFromArg(str3);
      string valueFromArg4 = this.GetValueFromArg(str4);
      string valueFromArg5 = this.GetValueFromArg(str5);
      string valueFromArg6 = this.GetValueFromArg(str6);
      string valueFromArg7 = this.GetValueFromArg(str7);
      this.GetValueFromArg(str8);
      double result1 = 0.0;
      double result2 = 0.0;
      double num2 = 0.277777777;
      DateTime result3 = new DateTime();
      DateTime result4 = new DateTime();
      DateTime result5 = new DateTime();
      double result6 = 0.0;
      double result7 = 0.0;
      double result8 = 0.0;
      if (!DateTime.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), out result3) && !double.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), out result6) || !double.TryParse(valueFromArg2.Replace(this.TIC, string.Empty), out result8) && !DateTime.TryParse(valueFromArg2.Replace(this.TIC, string.Empty), out result5) || !double.TryParse(valueFromArg3.Replace(this.TIC, string.Empty), out result7) && !DateTime.TryParse(valueFromArg3.Replace(this.TIC, string.Empty), out result4))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[1].ToString());
        return this.ErrorStrings[1].ToString();
      }
      double result9 = 0.0;
      double.TryParse(valueFromArg6, out result9);
      double.TryParse(valueFromArg4, out result1);
      double.TryParse(valueFromArg5, out result2);
      if (result6 > 0.0 || result7 > 0.0)
        result3 = this.GetDateFromSerialDate((int) result6);
      if (result7 > 0.0)
        result4 = this.GetDateFromSerialDate((int) result7);
      if (result8 > 0.0)
        result5 = this.GetDateFromSerialDate((int) result8);
      if (this.dateTime1900.Year > result3.Year || this.dateTime1900.Year > result4.Year || this.dateTime1900.Year > result5.Year)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      string str9 = this.TIC + result3.ToShortDateString() + this.TIC;
      string str10 = this.TIC + result4.ToShortDateString() + this.TIC;
      switch (valueFromArg7)
      {
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
          double num3 = double.Parse(this.ComputeYearFrac($"{str9},{str10},{valueFromArg7}"));
          double num4 = result2 * (result1 / (double) (int) result9) * num3 * (double) (int) result9;
          num1 = (int) result9 == 4 ? num4 + num2 : num4;
          break;
        default:
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return num1.ToString();
  }

  public string ComputeCUMPRINC(string args)
  {
    double num1 = 0.0;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 5 || string.IsNullOrEmpty(args))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      string cumprinc = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) cumprinc))
        return cumprinc;
      string str1 = strArray[0];
      string str2 = strArray[1];
      string str3 = strArray[2];
      string str4 = strArray[3];
      string str5 = strArray[4];
      string str6 = strArray[5];
      string valueFromArg1 = this.GetValueFromArg(str1);
      string valueFromArg2 = this.GetValueFromArg(str2);
      string valueFromArg3 = this.GetValueFromArg(str3);
      string valueFromArg4 = this.GetValueFromArg(str4);
      string valueFromArg5 = this.GetValueFromArg(str5);
      string valueFromArg6 = this.GetValueFromArg(str6);
      double result1 = 0.0;
      double result2 = 0.0;
      double result3 = 0.0;
      double result4 = 0.0;
      double result5 = 0.0;
      double result6 = 0.0;
      if (!double.TryParse(valueFromArg1, out result1) || !double.TryParse(valueFromArg2, out result2) || !double.TryParse(valueFromArg3, out result3) || !double.TryParse(valueFromArg4, out result4) || !double.TryParse(valueFromArg5, out result5) || !double.TryParse(valueFromArg6, out result6))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.ErrorStrings[1].ToString());
        return this.ErrorStrings[1].ToString();
      }
      if (result1 <= 0.0 || result2 <= 0.0 || result3 <= 0.0 || result4 < 1.0 || result4 > result2 || result5 < 1.0 || result5 > result2 || result4 > result5 || result6 != 0.0 && result6 != 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (result4 < 1.0 || result5 < 1.0 || result4 > result5)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[1].ToString();
      }
      if (result6 != 0.0 && result6 != 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      double num2 = double.Parse(this.ComputePmt($"{result1},{result2},{result3},{0},{result6}"));
      if (result4 == 1.0)
      {
        num1 = result6 != 0.0 ? num2 : num2 + result3 * result1;
        ++result4;
      }
      for (double num3 = result4; num3 <= result5; ++num3)
      {
        if (result6 > 0.0)
          num1 += num2 - (double.Parse(this.ComputeFv($"{result1},{num3 - 2.0},{num2},{result3},{1}")) - num2) * result1;
        else
          num1 += num2 - double.Parse(this.ComputeFv($"{result1},{num3 - 1.0},{num2},{result3},{0}")) * result1;
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return num1.ToString();
  }

  public string ComputeReceived(string args)
  {
    double num1;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 4)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      string str1 = strArray[0];
      string str2 = strArray[1];
      string str3 = strArray[2];
      string str4 = strArray[3];
      string str5 = strArray.Length > 4 ? strArray[4] : "0";
      string valueFromArg1 = this.GetValueFromArg(str1);
      string valueFromArg2 = this.GetValueFromArg(str2);
      string valueFromArg3 = this.GetValueFromArg(str3);
      string valueFromArg4 = this.GetValueFromArg(str4);
      string valueFromArg5 = this.GetValueFromArg(str5);
      double result1 = 0.0;
      double result2 = 0.0;
      int result3 = 0;
      DateTime result4;
      if (!DateTime.TryParse(valueFromArg1, out result4))
      {
        double result5 = 0.0;
        if (double.TryParse(valueFromArg1, NumberStyles.Any, (IFormatProvider) null, out result5))
        {
          result4 = DateTime.FromOADate(result5);
        }
        else
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
      }
      DateTime result6;
      if (!DateTime.TryParse(valueFromArg2, out result6))
      {
        double result7 = 0.0;
        if (double.TryParse(valueFromArg2, NumberStyles.Any, (IFormatProvider) null, out result7))
        {
          result6 = DateTime.FromOADate(result7);
        }
        else
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
      }
      if (!double.TryParse(valueFromArg3, out result1) || !double.TryParse(valueFromArg4, out result2) || result1 <= 0.0 || result2 <= 0.0 || result4 >= result6)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (!string.IsNullOrEmpty(valueFromArg5) && int.TryParse(valueFromArg5, out result3) && (result3 < 0 || result3 > 4))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      string str6 = this.TIC + result6.ToShortDateString() + this.TIC;
      string str7 = this.TIC + result4.ToShortDateString() + this.TIC;
      switch (result3)
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
          double num2 = double.Parse(this.ComputeYearFrac($"{str7},{str6},{result3}"));
          num1 = result1 / (1.0 - result2 * num2);
          break;
        default:
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return num1.ToString();
  }

  public string ComputeAddress(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    string empty = string.Empty;
    string valueFromArg1 = this.GetValueFromArg(strArray[0].Replace(this.TIC, string.Empty));
    string valueFromArg2 = this.GetValueFromArg(strArray[1].Replace(this.TIC, string.Empty));
    long num1 = long.Parse(valueFromArg1);
    long num2 = long.Parse(valueFromArg2);
    if (num1 < 1L || num2 < 1L)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    string str1 = length > 2 ? this.GetValueFromArg(strArray[2].Replace(this.TIC, string.Empty)) : "1";
    long num3 = num2;
    long num4 = num3 / 26L;
    long index1 = num3 % 26L == 0L ? num3 / num4 : num3 % 26L;
    long index2 = num3 % 26L == 0L ? num3 / 26L - 1L : num3 / 26L;
    char[] charArray = (empty + CalcEngine.charTable[index1] + CalcEngine.charTable[index2]).ToCharArray();
    Array.Reverse((Array) charArray);
    string str2 = new string(charArray);
    string address = '$'.ToString() + str2 + (object) '$' + valueFromArg1;
    if (length > 2)
    {
      switch (str1)
      {
        case "2":
          address = str2 + (object) '$' + valueFromArg1;
          break;
        case "3":
          address = '$'.ToString() + str2 + valueFromArg1;
          break;
        case "4":
          address = str2 + valueFromArg1;
          break;
      }
    }
    if (length > 3 && (this.GetValueFromArg(strArray[3].Replace(this.TIC, string.Empty)) == "FALSE" || this.GetValueFromArg(strArray[2].Replace(this.TIC, string.Empty)) == "0"))
    {
      switch (str1)
      {
        case "":
          address = $"R{(object) num1}C{(object) num2}";
          break;
        case "1":
          address = $"R{(object) num1}C{(object) num2}";
          break;
        case "2":
          address = $"R{(object) num1}C[{(object) num2}]";
          break;
        case "3":
          address = $"R[{(object) num1}]C{(object) num2}";
          break;
        case "4":
          address = $"R[{(object) num1}]C[{(object) num2}]";
          break;
      }
    }
    if (length > 4 && this.GetValueFromArg(strArray[3].Replace(this.TIC, string.Empty)) == string.Empty)
    {
      strArray[4] = this.GetValueFromArg(strArray[4]).Replace(this.TIC, string.Empty);
      address = $"{strArray[4]}!{address}";
    }
    return address;
  }

  public string ComputeCell(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (this.isIndexInteriorFormula)
      this.isIndexInteriorFormula = false;
    if (strArray.Length > 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string cell;
    if (strArray.Length == 2)
    {
      strArray[1] = strArray[1].Replace(this.TIC, string.Empty);
      string scopedRange = string.Empty;
      if (!this.IsCellReference(strArray[1]) && !this.TryGetNamedRange(strArray[1], out scopedRange))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.FormulaErrorStrings[this.invalid_arguments];
      }
      cell = strArray[1];
    }
    else
      cell = this.cell;
    string lower = strArray[0].Replace(this.TIC, string.Empty).ToLower();
    string str = "";
    switch (lower)
    {
      case "address":
        str = this.ComputeAddress(this.RowIndex(cell).ToString() + (object) CalcEngine.ParseArgumentSeparator + this.ColIndex(cell).ToString());
        break;
      case "col":
        str = this.ComputeColumn(cell);
        break;
      case "contents":
        str = this.GetValueFromArg(cell);
        break;
      case "filename":
        str = Process.GetCurrentProcess().MainModule.FileName;
        break;
      case "row":
        str = this.ComputeRow(cell);
        break;
      case "type":
        str = !(this.ComputeIsBlank(cell) == this.TRUEVALUESTR) ? (!(this.ComputeIsText(cell) == this.TRUEVALUESTR) ? "v" : "l") : "b";
        break;
    }
    return str.ToString();
  }

  public string ComputeInfo(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string lower = this.StripTics0(this.GetValueFromArg(strArray[0])).ToLower();
    string empty = string.Empty;
    switch (lower)
    {
      case "directory":
        return Environment.CurrentDirectory;
      case "numfile":
        return this.SortedSheetNames != null && CalcEngine.sheetFamiliesList.Count == 0 ? this.SortedSheetNames.Count.ToString() : "1";
      case "origin":
        return "$A: " + this.ComputeAddress(this.RowIndex(this.cell).ToString() + (object) CalcEngine.ParseArgumentSeparator + this.ColIndex(this.cell).ToString());
      case "osversion":
        return Environment.OSVersion.ToString();
      case "recalc":
        return this.alwaysComputeDuringRefresh ? "Automatic" : "Manual";
      case "release":
        return Assembly.GetExecutingAssembly().GetName().Version.ToString();
      case "system":
        switch (Environment.OSVersion.Platform)
        {
          case PlatformID.Unix:
            return "unix";
          case PlatformID.MacOSX:
            return "mac";
          default:
            return "pcdos";
        }
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeType(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    int num = 0;
    if (length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    if (string.IsNullOrEmpty(valueFromArg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    if (argList.IndexOf(CalcEngine.ParseArgumentSeparator) > -1)
      num = 64 /*0x40*/;
    else if (this.ComputeIsNumber(valueFromArg) == this.TRUEVALUESTR)
      num = 1;
    else if (this.ComputeIsLogical(valueFromArg) == this.TRUEVALUESTR)
      num = 4;
    else if (valueFromArg.Equals("invalid expression") || this.ErrorStrings.Contains((object) valueFromArg))
      num = 16 /*0x10*/;
    else if (this.ComputeIsText(valueFromArg) == this.TRUEVALUESTR)
      num = 2;
    return num.ToString();
  }

  public string ComputeIsFormula(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    string empty = string.Empty;
    if (length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str = strArray[0];
    if (!this.IsCellReference(strArray[0]))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    string scopedRange = string.Empty;
    if (this.TryGetNamedRange(str, out scopedRange) && scopedRange != string.Empty)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[1].ToString();
    }
    string fromParentObject = this.GetValueFromParentObject(str, false);
    return fromParentObject == string.Empty || fromParentObject[0] != '=' ? this.FALSEVALUESTR : this.TRUEVALUESTR;
  }

  private int matchCompare(object o1, object o2)
  {
    string s = o1.ToString();
    string str = o2.ToString();
    double result1;
    double result2;
    return double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(str, NumberStyles.Any, (IFormatProvider) null, out result2) ? result1.CompareTo(result2) : s.CompareTo(str);
  }

  public string ComputeHLookUp(string range)
  {
    bool flag1 = this.IsHLookupCachingEnabled();
    bool flag2 = this.IsOptimizedMatchesEnabled();
    if (flag1 && this.lookupTables == null)
      this.lookupTables = new Dictionary<string, CalcEngine.LookUps>();
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    string upper = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty).ToUpper();
    string formula = strArray[1].Replace("\"", string.Empty);
    string s = this.GetValueFromArg(strArray[2]).Replace("\"", string.Empty);
    double result1 = 0.0;
    if (!double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result1))
      return "#N/A";
    int num1 = (int) result1;
    bool flag3 = true;
    if (strArray.GetLength(0) == 4)
      flag3 = this.GetValueFromArg(strArray[3]) == this.TRUEVALUESTR;
    bool flag4 = flag3 && double.TryParse(upper, NumberStyles.Any, (IFormatProvider) null, out result1);
    int length = formula.IndexOf(":");
    if (length == -1)
    {
      formula = $"{formula}:{formula}";
      length = formula.IndexOf(":");
    }
    int num2 = formula.Substring(0, length).LastIndexOf('!');
    ICalcData grid = this.grid;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    if (num2 > -1)
    {
      if (formula.Contains("!") && formula.Contains("[") && formula.Contains("]"))
      {
        QueryExternalWorksheetEventArgs e = new QueryExternalWorksheetEventArgs(formula);
        this.QueryExternalWorksheet((object) this, e);
        if (e.IsWorksheetUpdated)
        {
          this.RegisterGridAsSheet(e.worksheetName, e.worksheet, CalcEngine.sheetFamilyID);
          this.grid = e.worksheet;
        }
        else
          this.grid = (ICalcData) sheetFamilyItem.TokenToParentObject[(object) formula.Substring(0, num2 + 1)];
      }
      else
        this.grid = (ICalcData) sheetFamilyItem.TokenToParentObject[(object) formula.Substring(0, num2 + 1)];
    }
    int row = this.RowIndex(formula.Substring(0, length));
    int num3 = this.RowIndex(formula.Substring(length + 1));
    int num4 = this.ColIndex(formula.Substring(0, length));
    int num5 = this.ColIndex(formula.Substring(length + 1));
    if (this.grid is ISheetData)
    {
      if (!(!row.Equals(-1) || num3.Equals(-1)).Equals(row.Equals(-1) || !num3.Equals(-1)))
        return this.ErrorStrings[5].ToString();
      if (row == -1)
        row = ((ISheetData) this.grid).GetFirstRow();
      if (num4 == -1)
        num4 = ((ISheetData) this.grid).GetFirstColumn();
      if (num3 == -1)
        ((ISheetData) this.grid).GetLastRow();
      if (num5 == -1)
        num5 = ((ISheetData) this.grid).GetLastColumn();
    }
    bool flag5 = false;
    string empty1 = string.Empty;
    List<string> stringList = (List<string>) null;
    Dictionary<string, int> dictionary = (Dictionary<string, int>) null;
    if (flag1)
    {
      string key = $"{row}_{num4}_{num5}_{this.grid.GetHashCode()}";
      if (!this.lookupTables.ContainsKey(key))
      {
        if (flag2)
          this.lookupTables.Add(key, new CalcEngine.LookUps()
          {
            MatchLookUpList = new Dictionary<string, int>(),
            LinearLookUpList = new List<string>()
          });
        else
          this.lookupTables.Add(key, new CalcEngine.LookUps()
          {
            LinearLookUpList = new List<string>()
          });
        flag5 = true;
      }
      stringList = this.lookupTables[key].LinearLookUpList;
      if (flag2)
        dictionary = this.lookupTables[key].MatchLookUpList;
    }
    string empty2 = string.Empty;
    int col1 = num4;
    string str1 = string.Empty;
    double result2 = 0.0;
    bool flag6 = true;
    bool flag7 = false;
    if (flag1 && flag2 && dictionary.ContainsKey(upper))
    {
      col1 = dictionary[upper];
      str1 = upper;
      flag7 = true;
    }
    else
    {
      for (int col2 = num4; col2 <= num5; ++col2)
      {
        if (!flag1 || col2 - num4 >= stringList.Count || flag5)
        {
          str1 = this.GetValueFromParentObject(this.grid, row, col2).ToString().ToUpper().Replace("\"", string.Empty);
          if (flag1)
          {
            stringList.Add(str1);
            if (flag2)
              dictionary.Add(str1, col2);
          }
        }
        else
          str1 = stringList[col2 - num4];
        if (str1 == upper || flag3 && (flag4 ? (!double.TryParse(str1, NumberStyles.Any, (IFormatProvider) null, out result2) ? 0 : (result2.CompareTo(result1) > 0 ? 1 : 0)) : (str1.CompareTo(upper) > 0 ? 1 : 0)) != 0)
        {
          if (str1 == upper)
          {
            col1 = col2;
            flag3 = true;
            flag7 = true;
          }
          if (flag5)
            flag6 = false;
          else
            break;
        }
        if (upper.Contains("*") || upper.Contains("?") || upper.Contains("~"))
        {
          bool flag8 = false;
          if (upper.Contains("~"))
            flag8 = str1.ToUpper().Equals(upper.Replace("~", string.Empty).Replace("**", "*"));
          else if (upper.Contains("*"))
          {
            string str2 = upper.Replace("*", string.Empty);
            if (upper.StartsWith("*") && upper.EndsWith("*"))
              flag8 = str1.ToUpper().Replace(this.TIC, string.Empty).Contains(str2.ToUpper());
            else if (upper.StartsWith("*"))
              flag8 = str1.ToUpper().Replace(this.TIC, string.Empty).EndsWith(str2.ToUpper());
            else if (upper.EndsWith("*"))
              flag8 = str1.ToUpper().Replace(this.TIC, string.Empty).StartsWith(str2.ToUpper());
          }
          else if (upper.Contains("?"))
            flag8 = str1.ToUpper().Length.Equals(upper.ToUpper().Length);
          if (flag8)
          {
            col1 = col2;
            flag3 = true;
            flag7 = true;
          }
          if (flag5)
            flag6 = false;
          else
            break;
        }
        if (flag6)
          col1 = col2;
        flag3 = flag5 = true;
      }
    }
    string hlookUp;
    if (flag3 || str1.Equals(upper))
    {
      if (!flag7 && !flag4)
      {
        this.grid = grid;
        return "#N/A";
      }
      hlookUp = this.GetValueFromParentObject(this.grid, num1 + row - 1, col1).ToString();
      if (hlookUp.Length > 0 && (int) hlookUp[0] == (int) CalcEngine.FormulaCharacter)
        hlookUp = this.Parse(hlookUp);
      result1 = 0.0;
      if (hlookUp.Length > 0 && (int) hlookUp[0] != (int) this.TIC[0] && !double.TryParse(hlookUp, NumberStyles.Any, (IFormatProvider) null, out result1))
        hlookUp = this.TIC + hlookUp + this.TIC;
    }
    else
      hlookUp = "#N/A";
    this.grid = grid;
    return hlookUp;
  }

  internal void SplitRange(string range, ref string rangeValue, ref string logicalValue)
  {
    int index = 0;
label_7:
    while (index < range.Length)
    {
      range = range.Replace('\u0092'.ToString(), string.Empty);
      while (index != range.Length && char.IsDigit(range[index]) | range[index] == ':' | range[index] == '!' | this.IsUpper(range[index]))
        rangeValue += (string) (object) range[index++];
      while (true)
      {
        if (index != range.Length && !this.IsUpper(range[index]) && range[index] == '"' | char.IsLetter(range[index]) | char.IsDigit(range[index]) | range[index] == ',' | range[index] == '~')
          logicalValue += (string) (object) range[index++];
        else
          goto label_7;
      }
    }
  }

  public string ComputeMatch(string arg)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(arg);
    if (this.IsArrayFormula && strArray1.Length > 3 && strArray1[1].IndexOfAny(this.logicalOperators) > -1)
    {
      int num1 = arg.IndexOf(CalcEngine.ParseArgumentSeparator);
      int num2 = arg.LastIndexOf(CalcEngine.ParseArgumentSeparator);
      string str1 = strArray1[0];
      if (string.IsNullOrEmpty(str1))
        return this.ErrorStrings[1].ToString();
      string valueFromArg = this.GetValueFromArg(strArray1[strArray1.Length - 1]);
      string str2 = arg.Substring(num1 + 1, num2 - str1.Length - 1);
      if (string.IsNullOrEmpty(valueFromArg) || valueFromArg == "0" || valueFromArg == "1" || valueFromArg == "-1")
      {
        if (str2.IndexOfAny(this.logicalOperators) > -1)
          arg = str1 + (object) CalcEngine.parseArgumentSeparator + str2.Replace(CalcEngine.parseArgumentSeparator, ';') + (object) ',' + valueFromArg;
      }
      else
        arg = str1 + (object) CalcEngine.parseArgumentSeparator + str2.Replace(CalcEngine.parseArgumentSeparator, ';') + valueFromArg.Replace(CalcEngine.parseArgumentSeparator, ';');
    }
    string[] strArray2 = this.SplitArgsPreservingQuotedCommas(arg);
    int length1 = strArray2.GetLength(0);
    switch (length1)
    {
      case 2:
      case 3:
        if (!string.IsNullOrEmpty(arg))
        {
          string match1 = this.FormulaErrorStringCheck(strArray2[0], CalcEngine.FormulaArgumentType.Text);
          if (this.ErrorStrings.Contains((object) match1))
            return match1;
          int num3 = 1;
          string empty1 = string.Empty;
          string empty2 = string.Empty;
          List<string> stringList = new List<string>();
          string[] strArray3 = (string[]) null;
          string[] strArray4 = strArray2[1].Split(';');
          if ((length1 == 2 || length1 == 3) && this.IsArrayFormula && strArray4[0].IndexOfAny(this.logicalOperators) > -1)
          {
            strArray3 = strArray4 == null || strArray4.Length <= 0 ? (string[]) null : new string[strArray4.Length];
            for (int index = 0; index < strArray4.Length; ++index)
            {
              this.SplitRange(strArray4[index], ref empty2, ref empty1);
              if (empty1 != string.Empty && strArray3 != null)
              {
                string str = this.GetValueFromArg(strArray4[index]).Replace(this.TIC, string.Empty);
                strArray3[index] = str;
              }
            }
          }
          string s = strArray2[1].Replace(this.TIC, string.Empty);
          int length2 = s.IndexOf(":");
          if (length1 == 3)
          {
            string match2 = this.FormulaErrorStringCheck(strArray2[2], CalcEngine.FormulaArgumentType.Numbers);
            if (this.ErrorStrings.Contains((object) match2))
              return match2;
            string str = this.GetValueFromArg(strArray2[2]).Replace(this.TIC, string.Empty);
            double result;
            num3 = double.TryParse(str, NumberStyles.Integer, (IFormatProvider) null, out result) ? (int) result : 1;
            if (str.Contains(this.TIC) && (str.Contains(this.TRUEVALUESTR) || str.Contains(this.FALSEVALUESTR)))
            {
              if (this.rethrowLibraryComputationExceptions)
                throw new ArgumentException("Passed arguments contains invalid argument");
              return this.ErrorStrings[1].ToString();
            }
            if (str == this.FALSEVALUESTR)
              num3 = 0;
            else if (str == this.TRUEVALUESTR)
              num3 = 1;
            else if (str.Contains(this.TIC) && this.ComputeIsText(str) == this.TRUEVALUESTR)
            {
              if (this.rethrowLibraryComputationExceptions)
                throw new ArgumentException("Passed arguments contains invalid argument");
              return this.ErrorStrings[1].ToString();
            }
          }
          string upper = this.GetValueFromArg(strArray2[0]).Replace(this.TIC, string.Empty).ToUpper();
          DateTime result1;
          if (upper != null && !double.TryParse(upper, out double _) && DateTime.TryParse(upper, (IFormatProvider) null, DateTimeStyles.None, out result1))
            upper = this.GetSerialDateTimeFromDate(result1).ToString();
          if (length2 > -1)
          {
            int num4 = this.RowIndex(s.Substring(0, length2));
            int num5 = this.RowIndex(s.Substring(length2 + 1));
            int num6 = this.ColIndex(s.Substring(0, length2));
            int num7 = this.ColIndex(s.Substring(length2 + 1));
            if (this.grid is ISheetData)
            {
              if (!(!num4.Equals(-1) || num5.Equals(-1)).Equals(num4.Equals(-1) || !num5.Equals(-1)))
                return this.ErrorStrings[5].ToString();
              if (num4 == -1)
                ((ISheetData) this.grid).GetFirstRow();
              if (num6 == -1)
                ((ISheetData) this.grid).GetFirstColumn();
              if (num5 == -1)
                ((ISheetData) this.grid).GetLastRow();
              if (num7 == -1)
                ((ISheetData) this.grid).GetLastColumn();
            }
          }
          if (this.IsArrayFormula && strArray3 == null || strArray3 != null && strArray3.Length == 0)
          {
            string empty3 = string.Empty;
            string args = string.Empty;
            s = strArray2[1].Replace('\u0092'.ToString(), string.Empty);
            string[] strArray5 = s.Split(new string[1]
            {
              this.TIC
            }, StringSplitOptions.RemoveEmptyEntries);
            if (strArray5.Length > 1)
            {
              int index1;
              for (int index2 = 0; index2 <= strArray5.Length - 1; index2 = index1 + 1)
              {
                string[] strArray6;
                if (args == string.Empty)
                  strArray6 = strArray5[index2++].Replace(this.TIC, string.Empty).Split(';');
                else
                  strArray6 = this.SplitArguments(args, ';');
                string str3 = string.Empty;
                string[] strArray7 = strArray5;
                int index3 = index2;
                index1 = index3 + 1;
                string[] strArray8 = strArray7[index3].Replace(this.TIC, string.Empty).Split(';');
                int num8 = Math.Max(strArray6.Length, strArray8.Length);
                int num9 = Math.Min(strArray6.Length, strArray8.Length);
                for (int index4 = 0; index4 <= num8 - 1; ++index4)
                {
                  string str4;
                  if (index4 < num9)
                    str4 = this.GetValueFromArg($"{'\u0092'.ToString()}n{strArray6[index4]}n{strArray8[index4]}{strArray5[index1]}{'\u0092'.ToString()}");
                  else
                    str4 = "#N/A";
                  str3 = $"{str3}{str4};";
                }
                args = str3.Remove(str3.Length - 1);
              }
              strArray3 = this.SplitArguments(args, ';');
            }
            else if (this.IsRange(this.StripTics(s)))
              strArray3 = this.GetCellsFromArgs(this.StripTics(s));
          }
          else if (this.IsRange(this.StripTics(s)) && (strArray3 == null || strArray3 != null && strArray3.Length == 0))
            strArray3 = this.GetCellsFromArgs(this.StripTics(s));
          if (strArray3 == null)
            strArray3 = this.SplitArguments(s.Replace(this.TIC, string.Empty));
          int num10 = 1;
          int num11 = 0;
          string o2 = string.Empty;
          string str5 = string.Empty;
          foreach (string str6 in strArray3)
          {
            if (this.IsCellReference(str6.Replace(this.TIC, string.Empty)))
            {
              str5 = this.GetValueFromArg(str6).Replace(this.TIC, string.Empty).ToUpper();
              DateTime result2;
              if (str5 != null && DateTime.TryParse(str5.Replace(this.TIC, string.Empty), (IFormatProvider) null, DateTimeStyles.None, out result2) && !double.TryParse(str5, NumberStyles.Any, (IFormatProvider) null, out double _))
                str5 = this.GetSerialDateTimeFromDate(result2).ToString();
            }
            else
              str5 = str6.Replace(this.TIC, string.Empty).ToUpper();
            if (o2 != string.Empty)
            {
              if (num3 == 1)
              {
                if (this.matchCompare((object) str5, (object) o2) < 0 && str5 == upper)
                {
                  --num10;
                  break;
                }
              }
              else if (num3 == -1 && this.matchCompare((object) str5, (object) o2) > 0)
              {
                num10 = -1;
                break;
              }
            }
            if (num3 != 0 && num3 != 1 || !(str5 == upper) || !this.matchType && (!this.IsArrayFormula || this.IsCellReference(str6.Replace(this.TIC, string.Empty))))
            {
              if (num3 == 1 && this.matchCompare((object) upper, (object) str5) < 0)
              {
                --num10;
                break;
              }
              if (num3 == -1 && this.matchCompare((object) upper, (object) str5) > 0)
              {
                --num10;
                break;
              }
              if (num3 == 1 && str5 == string.Empty)
                ++num11;
              else
                ++num10;
              if (o2 == string.Empty && str5 != string.Empty)
              {
                num10 += num11;
                num11 = 0;
              }
              o2 = str5;
            }
            else
              break;
          }
          if (num3 != 0 && num10 == strArray3.Length + 1)
            num10 = strArray3.Length;
          if (num3 == 1 && str5 != string.Empty && num11 > 0)
            num10 += num11;
          if (num3 == 1 && num10 + num11 == strArray3.Length + 1)
            --num10;
          return num10 > 0 && num10 <= strArray3.Length ? num10.ToString() : "#N/A";
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  private string GetResultRange(string lookupRange, string resultRange, ref bool isRangeModified)
  {
    string empty = string.Empty;
    int length1 = lookupRange.IndexOf(":");
    int num1 = this.RowIndex(lookupRange.Substring(0, length1));
    int num2 = this.RowIndex(lookupRange.Substring(length1 + 1));
    int num3 = this.ColIndex(lookupRange.Substring(0, length1));
    int num4 = this.ColIndex(lookupRange.Substring(length1 + 1));
    int num5;
    int col;
    if (num1 == num2)
    {
      num5 = this.RowIndex(resultRange);
      col = this.ColIndex(resultRange) + (num4 - num3);
    }
    else
    {
      if (num3 != num4)
        return resultRange;
      num5 = this.RowIndex(resultRange);
      col = this.ColIndex(resultRange) + (num2 - num1);
    }
    string alphaLabel = RangeInfo.GetAlphaLabel(col);
    string resultRange1;
    if (resultRange.IndexOf(':') > -1)
    {
      int length2 = resultRange.IndexOf(":");
      int num6 = this.RowIndex(resultRange.Substring(0, length2));
      resultRange1 = $"{resultRange.Substring(0, length2)}:{alphaLabel}{(object) num6}";
    }
    else
      resultRange1 = $"{resultRange}:{alphaLabel}{(object) num5}";
    isRangeModified = true;
    return resultRange1;
  }

  public string ComputeLookUp(string range)
  {
    bool isRangeModified = false;
    string empty1 = string.Empty;
    bool flag = this.IsLookupCachingEnabled();
    this.IsOptimizedMatchesEnabled();
    if (flag && this.lookupTables == null)
      this.lookupTables = new Dictionary<string, CalcEngine.LookUps>();
    string[] s = this.SplitArgsPreservingQuotedCommas(range);
    string str1 = this.GetValueFromArg(s[0]).Replace(this.TIC, string.Empty);
    int index1 = 0;
    string upper = str1.Replace(this.TIC, string.Empty).ToUpper();
    s[1] = s[1].Replace(this.TIC, string.Empty);
    if (s.Length == 3)
      s[2] = this.StripTics0(s[2]);
    string str2 = s[1].Replace("\"", string.Empty);
    this.GetValueFromArg(s[0]);
    List<string> cellValue = new List<string>();
    List<string> stringList = new List<string>();
    if (s.Length == 2)
    {
      string str3 = s[1];
      this.SplitArgsPreservingQuotedCommas(s[1]);
      if (s[1].Contains(";"))
      {
        string[] strArray1 = this.SplitArguments(s[1], ';');
        if (strArray1.Length == 1)
        {
          foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(strArray1[0].ToUpper()))
          {
            cellValue.Add(this.GetValueFromArg(preservingQuotedComma).ToUpper());
            stringList.Add(this.GetValueFromArg(preservingQuotedComma).ToUpper());
          }
        }
        else if (strArray1.Length == 2)
        {
          string[] strArray2 = this.SplitArgsPreservingQuotedCommas(strArray1[0].ToUpper());
          string[] strArray3 = this.SplitArgsPreservingQuotedCommas(strArray1[1].ToUpper());
          foreach (string str4 in strArray2)
            cellValue.Add(this.GetValueFromArg(str4).ToUpper());
          foreach (string str5 in strArray3)
            stringList.Add(this.GetValueFromArg(str5).ToUpper());
        }
        else
        {
          for (int index2 = 0; index2 < strArray1.Length; ++index2)
          {
            string[] strArray4 = this.SplitArgsPreservingQuotedCommas(strArray1[index2].ToUpper());
            cellValue.Add(this.GetValueFromArg(strArray4[0]).ToUpper());
            stringList.Add(this.GetValueFromArg(strArray4[1]).ToUpper());
          }
        }
        str3.IndexOf(CalcEngine.ParseArgumentSeparator);
      }
      else if (s[1].IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(s[1]))
        {
          cellValue.Add(this.GetValueFromArg(cellsFromArg).ToUpper());
          stringList.Add(this.GetValueFromArg(cellsFromArg).ToUpper());
        }
      }
      else
      {
        foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(s[1].ToUpper()))
        {
          cellValue.Add(this.GetValueFromArg(preservingQuotedComma).ToUpper());
          stringList.Add(this.GetValueFromArg(preservingQuotedComma).ToUpper());
        }
      }
    }
    else if (s.Length == 3)
    {
      if (str2.IndexOf(':') > -1)
      {
        int length = str2.IndexOf(':');
        int num1 = this.ColIndex(str2.Substring(0, length));
        int num2 = this.ColIndex(str2.Substring(length + 1, str2.Length - length - 1));
        index1 = num2 > num1 ? num2 - num1 + 1 : num1 - num2 + 1;
        foreach (string cellsFromArg in this.GetCellsFromArgs(str2))
        {
          try
          {
            cellValue.Add(this.GetValueFromArg(cellsFromArg));
          }
          catch
          {
            this.ExceptionThrown = true;
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.ErrorStrings[0].ToString());
            return this.ErrorStrings[0].ToString();
          }
        }
      }
      else
      {
        foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(s[1]))
        {
          try
          {
            cellValue.Add(this.GetValueFromArg(preservingQuotedComma));
          }
          catch
          {
            this.ExceptionThrown = true;
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.ErrorStrings[0].ToString());
            return this.ErrorStrings[0].ToString();
          }
        }
      }
    }
    string str6 = string.Empty;
    if (s.Length == 3)
      str6 = s[2];
    if (str2.IndexOf(':') > -1 && str6.IndexOf(':') == -1 || str6.IndexOfAny(this.tokens) == -1 && this.GetCellsFromArgs(s[1]).Length > this.GetCellsFromArgs(s[2]).Length)
      str6 = this.GetResultRange(str2, str6, ref isRangeModified);
    else
      isRangeModified = true;
    string lookUp;
    if (!str6.StartsWith(this.TIC) && !str6.EndsWith(this.TIC) && str6.Contains(":") && str6.IndexOfAny(this.tokens) > -1)
    {
      string str7 = string.Empty;
      string str8 = str6.Replace('\u0092'.ToString(), string.Empty);
      for (int index3 = 0; index3 <= str8.Length; ++index3)
      {
        string empty2 = string.Empty;
        string empty3 = string.Empty;
        if (index3 > 0)
          --index3;
        if (str8[index3].ToString().Contains("!"))
        {
          while (index3 != str8.Length && !char.IsLetter(str8[index3]))
            empty3 += (string) (object) str8[index3++];
        }
        while (index3 != str8.Length && str8[index3] != '!' && (!char.IsNumber(str8[index3]) || !char.IsLetter(str8[index3 + 1])))
          empty2 += (string) (object) str8[index3++];
        if (index3 != str8.Length && char.IsNumber(str8[index3]))
          empty2 += (string) (object) str8[index3++];
        str7 = empty2.IndexOf(':') <= -1 || empty2.StartsWith('!'.ToString()) ? this.ComputedValue(str7 + empty2) : $"{str7}n{this.GetResultVectorValue(empty3 + empty2, upper, ref isRangeModified, index1, s, cellValue)}";
        if (index3 != str8.Length && char.IsNumber(str8[index3 - 1]) && str8[index3].ToString().IndexOfAny(this.tokens) > -1)
          str7 = this.ComputedValue(str7 + (object) str8[index3++]);
      }
      lookUp = str7;
    }
    else
    {
      if (s.Length == 2)
      {
        int length = s[1].IndexOf(':');
        int num3 = this.ColIndex(s[1].Substring(0, length));
        int num4 = this.RowIndex(s[1].Substring(0, length));
        int col = this.ColIndex(s[1].Substring(length + 1, s[1].Length - length - 1));
        index1 = col > num3 ? col - num3 + 1 : num3 - col + 1;
        str6 = col <= num3 || !cellValue.Contains(upper) ? s[1] : $"{RangeInfo.GetAlphaLabel(col)}{num4.ToString()}:{s[1].Substring(length + 1, s[1].Length - length - 1)}";
      }
      lookUp = this.GetResultVectorValue(str6, upper, ref isRangeModified, index1, s, cellValue);
    }
    return lookUp;
  }

  private string GetResultVectorValue(
    string resultVal,
    string lookUp,
    ref bool isRangeModified,
    int index,
    string[] s,
    List<string> cellValue)
  {
    List<string> stringList = new List<string>();
    string empty = string.Empty;
    if (resultVal.IndexOf(':') > -1)
    {
      foreach (string cellsFromArg in this.GetCellsFromArgs(resultVal))
      {
        try
        {
          stringList.Add(this.GetValueFromArg(cellsFromArg));
        }
        catch
        {
          this.ExceptionThrown = true;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[0].ToString());
          return this.ErrorStrings[0].ToString();
        }
      }
    }
    else
    {
      foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(resultVal))
      {
        try
        {
          stringList.Add(this.GetValueFromArg(preservingQuotedComma));
        }
        catch
        {
          this.ExceptionThrown = true;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[0].ToString());
          return this.ErrorStrings[0].ToString();
        }
      }
    }
    if (!cellValue.Contains(lookUp))
    {
      string strB = cellValue[0];
      int num = 0;
      for (int index1 = 0; index1 < cellValue.Count; ++index1)
      {
        double result1 = 0.0;
        double result2 = 0.0;
        if (double.TryParse(lookUp, out result1))
        {
          if (double.TryParse(cellValue[index1], out result2) && result1 >= result2)
          {
            strB = cellValue[index1];
            ++num;
          }
        }
        else if (cellValue[index1].CompareTo(strB) == 1 && lookUp.CompareTo(cellValue[index1]) == 1 && strB.CompareTo(lookUp) == 1 || lookUp.CompareTo(cellValue[index1]) == 1)
        {
          if (cellValue[index1].CompareTo(strB) == 1 && lookUp.CompareTo(cellValue[index1]) == 1 && strB.CompareTo(lookUp) == 1 || lookUp.CompareTo(cellValue[index1]) == 1)
          {
            strB = cellValue[index1];
            ++num;
          }
        }
        else if (num != 0)
          break;
      }
      if (num == 0)
        return this.ErrorStrings[0].ToString();
      lookUp = strB;
    }
    int num1 = 0;
    int index2 = 0;
    string resultVectorValue;
    if (s.Length == 3 && s[2].IndexOf(':') > -1 || s.Length == 2 && cellValue.Count > stringList.Count && cellValue.Contains(lookUp))
    {
      for (int index3 = 0; index3 < cellValue.Count; ++index3)
      {
        if (cellValue[index3] == lookUp)
        {
          index2 = cellValue.IndexOf(lookUp);
          break;
        }
      }
      resultVectorValue = isRangeModified ? stringList[index2] : stringList[index2 / index];
    }
    else
    {
      for (int index4 = 0; index4 < cellValue.Count; ++index4)
      {
        if (cellValue[index4] == lookUp)
        {
          index = cellValue.IndexOf(lookUp);
          ++num1;
        }
        else if (num1 != 0)
          break;
      }
      resultVectorValue = stringList[index + num1 - 1];
    }
    isRangeModified = false;
    return resultVectorValue;
  }

  public string ComputeVLookUp(string range)
  {
    bool flag1 = this.IsVLookupCachingEnabled();
    bool flag2 = this.IsOptimizedMatchesEnabled();
    if (flag1 && this.lookupTables == null)
      this.lookupTables = new Dictionary<string, CalcEngine.LookUps>();
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    double result1 = 0.0;
    bool flag3 = double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1);
    string str1 = flag3 ? valueFromArg : valueFromArg.Replace(this.TIC, string.Empty).ToUpper();
    DateTime result2;
    if (str1 != null && !double.TryParse(str1.Replace(this.TIC, string.Empty), out double _) && DateTime.TryParse(str1, (IFormatProvider) null, DateTimeStyles.None, out result2))
      str1 = this.GetSerialDateTimeFromDate(result2).ToString();
    string formula = strArray[1].Replace("\"", string.Empty);
    if (formula == "#REF!")
      return formula;
    string str2 = this.GetValueFromArg(strArray[2]).Replace("\"", string.Empty);
    double result3 = 0.0;
    if (this.ComputeIsLogical(str2).Equals(this.TRUEVALUESTR))
      result3 = double.Parse(this.ComputeN(str2));
    else if (!double.TryParse(str2, NumberStyles.Any, (IFormatProvider) null, out result3) || str2 == "NaN")
      return "#N/A";
    if (result3 < 1.0)
      return this.ErrorStrings[1].ToString();
    int num1 = (int) result3;
    bool flag4 = true;
    bool flag5 = true;
    if (strArray.GetLength(0) == 4)
      flag4 = flag5 = this.GetValueFromArg(strArray[3]) == this.TRUEVALUESTR || this.GetValueFromArg(strArray[3].Replace(this.TIC, string.Empty)) == "1";
    bool flag6 = double.TryParse(str1.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result3);
    int length = formula.IndexOf(":");
    if (length == -1)
    {
      formula = $"{formula}:{formula}";
      length = formula.IndexOf(":");
    }
    int num2 = formula.Substring(0, length).LastIndexOf('!');
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    ICalcData grd = (ICalcData) null;
    if (num2 > -1)
    {
      if (formula.Contains("!") && formula.Contains("[") && formula.Contains("]"))
      {
        QueryExternalWorksheetEventArgs e = new QueryExternalWorksheetEventArgs(formula);
        this.QueryExternalWorksheet((object) this, e);
        if (e.IsWorksheetUpdated)
        {
          this.RegisterGridAsSheet(e.worksheetName, e.worksheet, CalcEngine.sheetFamilyID);
          grd = e.worksheet;
        }
        else
          grd = (ICalcData) sheetFamilyItem.TokenToParentObject[(object) formula.Substring(0, num2 + 1)];
      }
      else if (sheetFamilyItem.TokenToParentObject != null)
        grd = sheetFamilyItem.TokenToParentObject[(object) formula.Substring(0, num2 + 1)] as ICalcData;
    }
    int num3 = this.RowIndex(formula.Substring(0, length));
    int num4 = this.RowIndex(formula.Substring(length + 1));
    int col = this.ColIndex(formula.Substring(0, length));
    int num5 = this.ColIndex(formula.Substring(length + 1));
    if (this.grid is ISheetData || grd is ISheetData)
    {
      if (!(!num3.Equals(-1) || num4.Equals(-1)).Equals(num3.Equals(-1) || !num4.Equals(-1)))
        return this.ErrorStrings[5].ToString();
      if (num3 == -1)
        num3 = grd == null ? ((ISheetData) this.grid).GetFirstRow() : ((ISheetData) grd).GetFirstRow();
      if (col == -1)
        col = grd == null ? ((ISheetData) this.grid).GetFirstColumn() : ((ISheetData) grd).GetFirstColumn();
      if (num4 == -1)
        num4 = grd == null ? ((ISheetData) this.grid).GetLastRow() : ((ISheetData) grd).GetLastRow();
      if (num5 == -1)
      {
        int num6 = grd == null ? ((ISheetData) this.grid).GetLastColumn() : ((ISheetData) grd).GetLastColumn();
      }
    }
    bool flag7 = true;
    string empty1 = string.Empty;
    List<string> stringList1 = (List<string>) null;
    Dictionary<string, int> dictionary = (Dictionary<string, int>) null;
    if (flag1)
    {
      string key = $"{col}_{num3}_{num4}_{this.grid.GetHashCode()}";
      if (grd != null)
        key = $"{col}_{num3}_{num4}_{grd.GetHashCode()}";
      if (!this.lookupTables.ContainsKey(key))
      {
        if (flag2)
          this.lookupTables.Add(key, new CalcEngine.LookUps()
          {
            LinearLookUpList = new List<string>(),
            MatchLookUpList = new Dictionary<string, int>()
          });
        else
          this.lookupTables.Add(key, new CalcEngine.LookUps()
          {
            LinearLookUpList = new List<string>()
          });
        flag7 = true;
      }
      stringList1 = this.lookupTables[key].LinearLookUpList;
      if (flag2)
        dictionary = this.lookupTables[key].MatchLookUpList;
    }
    string empty2 = string.Empty;
    int row1 = num3;
    int num7 = 0;
    string str3 = string.Empty;
    double result4 = 0.0;
    bool flag8 = true;
    bool flag9 = false;
    List<string> stringList2 = new List<string>();
    if (flag1 && flag2 && dictionary.Count > 0)
    {
      if (dictionary.ContainsKey(str1))
      {
        row1 = dictionary[str1];
        str3 = str1;
        flag9 = true;
      }
    }
    else
    {
      for (int row2 = num3; row2 <= num4; ++row2)
      {
        if (flag1 && flag2)
        {
          str3 = grd == null ? this.GetValueFromParentObject(this.grid, row2, col).ToUpper().Replace("\"", string.Empty) : this.GetValueFromParentObject(grd, row2, col).ToUpper().Replace("\"", string.Empty);
          if (!stringList1.Contains(str3))
            stringList1.Add(str3);
          if (flag2 && !dictionary.ContainsKey(str3))
            dictionary.Add(str3, row2);
          if (row2 == num4 && dictionary.ContainsKey(str1) || flag4 && (flag6 ? (!double.TryParse(str3, NumberStyles.Any, (IFormatProvider) null, out result4) ? 0 : (result4.CompareTo(result3) > 0 ? 1 : 0)) : (str3.CompareTo(str1) > 0 ? 1 : 0)) != 0)
          {
            if (dictionary.ContainsKey(str1))
            {
              row1 = dictionary[str1];
              str3 = str1;
              flag9 = true;
            }
            else
              flag8 = false;
          }
          if (flag8 && !dictionary.ContainsKey(str1))
            row1 = row2;
        }
        else
        {
          if (!flag1 || row2 - num3 >= stringList1.Count || flag7)
          {
            string str4 = grd == null ? this.GetValueFromParentObject(this.grid, row2, col).ToString().ToUpper() : this.GetValueFromParentObject(grd, row2, col).ToString().ToUpper();
            str3 = flag3 ? str4 : str4.Replace("\"", string.Empty);
            DateTime result5;
            if (str3 != null && !double.TryParse(str3.Replace(this.TIC, string.Empty), out double _) && DateTime.TryParse(str3, (IFormatProvider) null, DateTimeStyles.None, out result5))
              str3 = this.GetSerialDateTimeFromDate(result5).ToString();
            if (!stringList2.Contains(str3))
              stringList2.Add(str3);
            if (flag1)
            {
              if (!stringList1.Contains(str3))
                stringList1.Add(str3);
              if (flag2 && !dictionary.ContainsKey(str3))
                dictionary.Add(str3, row2);
            }
          }
          else
            str3 = stringList1[row2 - num3];
          if (str3.Equals(str1) || flag4 && (flag6 ? (!double.TryParse(str3, NumberStyles.Any, (IFormatProvider) null, out result4) ? 0 : (result4.CompareTo(result3) > 0 ? 1 : 0)) : (str3.CompareTo(str1) > 0 ? 1 : 0)) != 0)
          {
            if (str3.ToUpper().Equals(str1))
            {
              if (!(str1 == string.Empty) || this.matchType)
              {
                row1 = row2;
                flag4 = true;
                flag9 = true;
                ++num7;
                if (strArray.GetLength(0) == 4 && strArray[3] == this.FALSEVALUESTR)
                  break;
              }
              else
                continue;
            }
            if (flag7)
              flag8 = false;
            else
              break;
          }
          if (str1.Contains("*") || str1.Contains("?") || str1.Contains("~"))
          {
            bool flag10 = false;
            if (str1.Contains("~"))
              flag10 = str3.ToUpper().Equals(str1.Replace("~", string.Empty).Replace("**", "*"));
            else if (str1.Contains("*"))
            {
              string str5 = str1.Replace("*", string.Empty);
              if (str1.StartsWith("*") && str1.EndsWith("*"))
                flag10 = str3.ToUpper().Replace(this.TIC, string.Empty).Contains(str5.ToUpper());
              else if (str1.StartsWith("*"))
                flag10 = str3.ToUpper().Replace(this.TIC, string.Empty).EndsWith(str5.ToUpper());
              else if (str1.EndsWith("*"))
                flag10 = str3.ToUpper().Replace(this.TIC, string.Empty).StartsWith(str5.ToUpper());
            }
            else if (str1.Contains("?"))
              flag10 = str3.ToUpper().Length.Equals(str1.ToUpper().Length);
            if (flag10)
            {
              row1 = row2;
              flag4 = true;
              flag9 = true;
              ++num7;
            }
            if (flag7)
              flag8 = false;
            else
              break;
          }
          if (flag8)
            row1 = row2;
          flag7 = num7 == 0;
          flag4 = true;
        }
      }
    }
    string vlookUp;
    if (flag4 || str3.Equals(str1))
    {
      if (stringList1 != null && stringList1.Count > 0)
      {
        if (!flag1)
          stringList1.Sort();
        stringList1[0] = stringList1[0] == string.Empty ? "0" : stringList1[0];
      }
      if (stringList2 != null && stringList2.Count > 0 && str1 != string.Empty)
      {
        if (!flag1)
          stringList2.Sort();
        stringList2[0] = stringList2[0] == string.Empty ? "0" : stringList2[0];
      }
      if (!flag9 && (!flag6 || flag6 && stringList2 != null && stringList2.Count > 0 && double.Parse(stringList2[0].ToString()) > double.Parse(str1)) || !flag9 && flag1 && flag6 && stringList1 != null && double.Parse(stringList1[0]) > double.Parse(str1) || !flag5 && !flag9)
        return "#N/A";
      vlookUp = grd == null ? this.GetValueFromParentObject(this.grid, row1, num1 + col - 1).ToString() : this.GetValueFromParentObject(grd, row1, num1 + col - 1).ToString();
      if (string.IsNullOrEmpty(vlookUp) && !this.GetValueFromParentObject(this.grid, row1, num1 + col - 1, false).ToUpper().StartsWith("=IF"))
        vlookUp = "0";
      if (vlookUp.Length > 0 && (int) vlookUp[0] == (int) CalcEngine.FormulaCharacter)
        vlookUp = this.ParseFormula(vlookUp);
      result3 = 0.0;
      if (vlookUp.Length > 0 && (int) vlookUp[0] != (int) this.TIC[0] && !double.TryParse(vlookUp, NumberStyles.Any, (IFormatProvider) null, out result3))
        vlookUp = this.TIC + vlookUp + this.TIC;
    }
    else
      vlookUp = "#N/A";
    return vlookUp;
  }

  public string ComputeLeft(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length1 = strArray.GetLength(0);
    if (length1 > 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string left1 = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.TextWithNumber);
    if (this.ErrorStrings.Contains((object) left1))
      return left1;
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    double result1 = 0.0;
    bool flag1 = double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1);
    bool flag2 = valueFromArg.StartsWith(this.TIC) && valueFromArg.EndsWith(this.TIC);
    string str1 = length1 == 2 ? this.GetValueFromArg(strArray[1].Replace(this.TIC, string.Empty)) : "1";
    string str2 = length1 != 2 || !string.IsNullOrEmpty(str1) ? str1 : "0";
    bool result2;
    string str3 = bool.TryParse(str2, out result2) ? Convert.ToInt16(result2).ToString() : str2;
    double result3;
    if (double.TryParse(str3, out result3) && result3 < 0.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    string s = this.ComputedValue(str3);
    string left2;
    if (int.Parse(s) == 0)
    {
      left2 = string.Empty;
    }
    else
    {
      int num = int.Parse(s) + (flag2 ? 1 : 0);
      int length2 = valueFromArg.Length >= num ? num : valueFromArg.Length;
      left2 = valueFromArg.Substring(0, length2);
      if (flag2 && !left2.EndsWith(this.TIC))
        left2 += this.TIC;
    }
    if (this.UseNoAmpersandQuotes && left2.Length > 1 && (int) left2[0] == (int) this.TIC[0] && (int) left2[left2.Length - 1] == (int) this.TIC[0] && !left2.Contains(this.TIC + this.TIC))
      left2 = left2.Substring(1, left2.Length - 2);
    if (left2.Contains(this.TIC + this.TIC))
      left2 = left2.Replace(this.TIC + this.TIC, this.TIC);
    if (flag1)
      left2 = this.TIC + left2.Replace(this.TIC, string.Empty) + this.TIC;
    return left2;
  }

  public string ComputeLen(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 1 && !this.IsArrayFormula)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string cellsFromArg1 = strArray[0];
    string str1 = "";
    if (this.IsArrayFormula)
    {
      string interiorFunction = this.ArrayParser.ComputeInteriorFunction(range, "LEN", this.computeFunctionLevel);
      if (interiorFunction != string.Empty)
        return interiorFunction;
      if (cellsFromArg1.IndexOf(':') > -1)
        cellsFromArg1 = this.GetCellsFromArgs(cellsFromArg1)[0];
    }
    if (cellsFromArg1.IndexOf(':') > -1 && cellsFromArg1.IndexOf(':') > 2)
    {
      foreach (string cellsFromArg2 in this.GetCellsFromArgs(cellsFromArg1))
      {
        string str2;
        try
        {
          str2 = this.GetValueFromArg(cellsFromArg2).Replace(this.TIC, string.Empty);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        bool flag = str2.StartsWith(this.TIC) && str2.EndsWith(this.TIC);
        str1 = $"{str1}{(object) (flag ? str2.Length - 2 : str2.Length)};";
      }
      return this.TIC + str1.Substring(0, str1.Length - 1) + this.TIC;
    }
    if (cellsFromArg1.StartsWith(this.TIC) && cellsFromArg1.EndsWith(this.TIC) && cellsFromArg1.IndexOf(";") > -1)
    {
      string str3 = cellsFromArg1.Replace(this.TIC, string.Empty);
      char[] chArray = new char[1]{ ';' };
      foreach (string str4 in str3.Split(chArray))
      {
        bool flag = str4.StartsWith(this.TIC) && str4.EndsWith(this.TIC);
        str1 = $"{str1}{(object) (flag ? str4.Length - 2 : str4.Length)};";
      }
      return this.TIC + str1.Substring(0, str1.Length - 1) + this.TIC;
    }
    string valueFromArg = this.GetValueFromArg(cellsFromArg1);
    return (valueFromArg.StartsWith(this.TIC) && valueFromArg.EndsWith(this.TIC) ? (double) (valueFromArg.Length - 2) : (double) valueFromArg.Length).ToString();
  }

  public string ComputeMid(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 3)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string valueFromArg1 = this.GetValueFromArg(strArray[0]);
    if (this.ErrorStrings.Contains((object) valueFromArg1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return valueFromArg1;
    }
    bool flag = valueFromArg1.StartsWith(this.TIC) && valueFromArg1.EndsWith(this.TIC);
    int length = int.Parse(this.GetValueFromArg(strArray[2]));
    if (strArray[1].IndexOf("#VALUE!") > -1)
      return "#VALUE!";
    string valueFromArg2 = this.GetValueFromArg(strArray[1]);
    int startIndex = int.Parse(valueFromArg2) + (flag ? 0 : -1);
    if (int.Parse(valueFromArg2) < 1 || (double) length < 0.0)
      return "#VALUE!";
    if (startIndex > valueFromArg1.Length)
      return "";
    string mid = startIndex + length <= valueFromArg1.Length ? valueFromArg1.Substring(startIndex, length) : valueFromArg1.Substring(startIndex);
    if (flag && !mid.StartsWith(this.TIC))
      mid = this.TIC + mid;
    if (flag && !mid.EndsWith(this.TIC))
      mid += this.TIC;
    return mid;
  }

  public string ComputeRight(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    if (length > 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string right1 = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.TextWithNumber);
    if (this.ErrorStrings.Contains((object) right1))
      return right1;
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    bool flag = valueFromArg.StartsWith(this.TIC) && valueFromArg.EndsWith(this.TIC);
    string str1 = length == 2 ? this.GetValueFromArg(strArray[1].Replace(this.TIC, string.Empty)) : "1";
    string str2 = length != 2 || !string.IsNullOrEmpty(str1) ? str1 : "0";
    bool result1;
    string str3 = bool.TryParse(str2, out result1) ? Convert.ToInt16(result1).ToString() : str2;
    double result2;
    if (double.TryParse(str3, out result2) && result2 < 0.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    string s = this.ComputedValue(str3);
    string right2;
    if (int.Parse(s) == 0)
    {
      right2 = string.Empty;
    }
    else
    {
      int num = int.Parse(s) + (flag ? 1 : 0);
      int startIndex = valueFromArg.Length >= num ? valueFromArg.Length - num : 0;
      right2 = valueFromArg.Substring(startIndex);
      if (flag && !right2.StartsWith(this.TIC))
        right2 = this.TIC + right2;
    }
    if (this.UseNoAmpersandQuotes && right2.Length > 1 && (int) right2[0] == (int) this.TIC[0] && (int) right2[right2.Length - 1] == (int) this.TIC[0] && !right2.Contains(this.TIC + this.TIC))
      right2 = right2.Substring(1, right2.Length - 2);
    return right2;
  }

  public bool IsSeparatorInTIC(string s)
  {
    int index = s.IndexOf(this.TIC) + 1;
    bool flag = true;
    for (; index > 0 && index < s.Length; ++index)
    {
      if ((int) s[index] == (int) CalcEngine.ParseArgumentSeparator && flag)
        return true;
      if ((int) s[index] == (int) this.TIC[0])
        flag = !flag;
    }
    return false;
  }

  public string[] GetStringArray(string s)
  {
    List<string> stringList = new List<string>();
    int startIndex = 0;
    bool flag = false;
    for (int index = 0; index < s.Length; ++index)
    {
      char ch = s[index];
      if ((int) ch == (int) this.TIC[0])
        flag = !flag;
      else if (!flag && (int) ch == (int) CalcEngine.ParseArgumentSeparator)
      {
        stringList.Add(s.Substring(startIndex, index - startIndex));
        startIndex = index + 1;
      }
    }
    stringList.Add(s.Substring(startIndex));
    string[] array = new string[stringList.Count];
    stringList.CopyTo(array);
    return array;
  }

  public string ComputeConcatenate(string range)
  {
    string empty = string.Empty;
    StringBuilder stringBuilder = new StringBuilder(this.TIC);
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.IsSeparatorInTIC(range) ? this.GetStringArray(range) : this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    foreach (string args in strArray)
    {
      string str = args;
      string valueFromArg = this.GetValueFromArg(args);
      bool.TryParse(valueFromArg, out bool _);
      if (this.ErrorStrings.Contains((object) valueFromArg))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return valueFromArg;
      }
      if (args.Contains(":") && this.IsCellReference(args))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[1].ToString();
      }
      if (args == string.Empty || (int) args[0] != (int) this.TIC[0])
        str = this.GetValueFromArg(args);
      if (stringBuilder.Length > 1 && (int) stringBuilder[stringBuilder.Length - 1] == (int) this.TIC[0])
        --stringBuilder.Length;
      if (str.Length > 0 && (int) str[0] == (int) this.TIC[0])
        stringBuilder.Append(str.Substring(1));
      else
        stringBuilder.Append(str);
    }
    if ((int) stringBuilder[stringBuilder.Length - 1] != (int) this.TIC[0])
      stringBuilder.Append(this.TIC);
    string str1 = stringBuilder.ToString();
    if (str1.IndexOf("#N/A") > -1)
      str1 = "#N/A";
    return this.excelLikeComputations ? str1.Substring(str1.IndexOf(this.TIC) + 1, str1.LastIndexOf(this.TIC) - 1) : str1;
  }

  public string ComputeIndirect(string args)
  {
    bool flag1 = false;
    if (args[args.Length - 1] == '\u0092')
    {
      args = this.GetValueFromArg(args);
      flag1 = true;
    }
    string scopedRange = string.Empty;
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(args);
    if (strArray1.Length == 0 || strArray1.Length > 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    strArray1[0] = strArray1[0].ToUpper();
    this.PutTokensForSheets(ref strArray1[0]);
    if (this.IsCellReference(strArray1[0].Replace(this.TIC, string.Empty)) && strArray1[0].Replace(this.TIC, string.Empty).StartsWith('!'.ToString()) || this.TryGetNamedRange(strArray1[0].ToUpper().Replace(this.TIC, string.Empty), out scopedRange))
      strArray1[0] = strArray1[0].Replace(this.TIC, string.Empty);
    string oldValue1 = this.SheetToken(strArray1[0].Replace(this.TIC, string.Empty));
    if (!string.IsNullOrEmpty(oldValue1))
      strArray1[0] = strArray1[0].Replace(oldValue1, string.Empty);
    if (strArray1.Length == 2 && strArray1[1] == this.FALSEVALUESTR)
    {
      bool flag2 = strArray1[0].StartsWith(this.TIC) && strArray1[0].EndsWith(this.TIC);
      string[] strArray2 = strArray1[0].ToUpper().Replace(this.TIC, string.Empty).Split(new char[1]
      {
        ':'
      }, StringSplitOptions.RemoveEmptyEntries);
      string[] strArray3 = strArray2[0].Split(new char[2]
      {
        'R',
        'C'
      }, StringSplitOptions.RemoveEmptyEntries);
      if (strArray2.Length > 2)
        return this.ErrorStrings[2].ToString();
      strArray1[0] = RangeInfo.GetAlphaLabel(Convert.ToInt32(strArray3[1])) + strArray3[0];
      if (strArray2.Length == 2)
      {
        string oldValue2 = this.SheetToken(strArray2[1]);
        if (!string.IsNullOrEmpty(oldValue2))
          strArray2[1] = strArray2[1].Replace(oldValue2, string.Empty);
        string[] strArray4 = strArray2[1].Split(new char[2]
        {
          'R',
          'C'
        }, StringSplitOptions.RemoveEmptyEntries);
        string[] strArray5;
        (strArray5 = strArray1)[0] = $"{strArray5[0]}:{RangeInfo.GetAlphaLabel(Convert.ToInt32(strArray4[1]))}{strArray4[0]}";
      }
      if (flag2)
        strArray1[0] = this.TIC + strArray1[0] + this.TIC;
    }
    string empty = string.Empty;
    string text;
    if (strArray1[0].StartsWith(this.TIC))
      text = oldValue1 + strArray1[0].Replace(this.TIC, string.Empty);
    else if (this.IsCellReference(strArray1[0]))
    {
      string args1 = !this.TryGetNamedRange(strArray1[0].ToUpper(), out scopedRange) ? this.GetValueFromArg(oldValue1 + strArray1[0]) : strArray1[0];
      if (string.IsNullOrEmpty(args1))
        args1 = "0";
      if (this.computedValueLevel > 1 && !this.TryGetNamedRange(args1.ToUpper(), out scopedRange))
      {
        this.isInteriorFunction = true;
        return oldValue1 + strArray1[0].Replace("$", string.Empty);
      }
      if (this.TryGetNamedRange(args1.ToUpper(), out scopedRange))
      {
        text = Convert.ToString(scopedRange).ToUpper().Replace("$", "");
        this.PutTokensForSheets(ref text);
        if (!text.StartsWith('!'.ToString()))
          text = oldValue1 + text;
      }
      else
      {
        if (this.IsCellReference(args1))
          return this.GetValueFromArg(args1);
        return flag1 ? args1 : this.ErrorStrings[2].ToString();
      }
    }
    else
      text = strArray1[0];
    if (!this.IsCellReference(text.Replace("$", "")))
    {
      if (!this.TryGetNamedRange(text.ToUpper(), out scopedRange))
        return this.ErrorStrings[2].ToString();
      text = Convert.ToString(scopedRange);
      this.PutTokensForSheets(ref text);
      if (!text.StartsWith('!'.ToString()))
        text = oldValue1 + text;
    }
    if (this.computedValueLevel > 1 && !text.StartsWith('!'.ToString()) || text.Contains(":") && (this.IsRange(text) || this.ISColumn(text)))
    {
      this.isInteriorFunction = true;
      return text.Replace("$", string.Empty);
    }
    string valueFromArg = this.GetValueFromArg(text.Replace("$", string.Empty));
    return this.treatStringsAsZero && string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg;
  }

  private string SubstituteText(
    string text,
    string old_Text,
    string new_Text,
    string instance_num)
  {
    if (instance_num.Equals(string.Empty))
    {
      text = text.Replace(old_Text, new_Text);
    }
    else
    {
      double result = 0.0;
      if (double.TryParse(instance_num, NumberStyles.Integer, (IFormatProvider) null, out result))
      {
        int num = (int) result;
        int length = -1;
        while (num > 0 && (length = text.IndexOf(old_Text, length + 1)) > -1)
          --num;
        if (num == 0)
          text = text.Substring(0, length) + new_Text + text.Substring(length + old_Text.Length);
      }
    }
    return text;
  }

  public string ComputeSubstitute(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.Length != 3 && strArray.Length != 4)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string str1 = string.Empty;
    string old_Text = this.StripTics0(this.GetValueFromArg(strArray[1]));
    string new_Text = this.StripTics0(this.GetValueFromArg(strArray[2]));
    string instance_num = strArray.Length == 4 ? this.GetValueFromArg(strArray[3]) : string.Empty;
    string str2;
    if (this.IsRange(strArray[0]))
    {
      foreach (string cellsFromArg in this.GetCellsFromArgs(strArray[0]))
      {
        string text = this.StripTics0(this.GetValueFromArg(cellsFromArg));
        str1 = $"{str1}{this.SubstituteText(text, old_Text, new_Text, instance_num)};";
      }
      str2 = str1.Substring(0, str1.Length - 1);
    }
    else
      str2 = this.SubstituteText(this.StripTics0(this.GetValueFromArg(strArray[0])), old_Text, new_Text, instance_num);
    return this.TIC + str2 + this.TIC;
  }

  public string ComputeText(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    string str1 = strArray[0];
    string str2 = strArray[1].Replace(this.TIC, string.Empty);
    DateTime result1 = this.dateTime1900;
    string s = this.GetValueFromArg(str1);
    if (string.IsNullOrEmpty(s) && str2.Length > 0)
    {
      if (str2.ToUpper().IndexOfAny(new char[5]
      {
        'M',
        'D',
        'Y',
        'S',
        'T'
      }) > -1)
        s = result1.ToString();
    }
    double result2;
    if (double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result2) && str2.Length > 0 && !this.NativeFormats.Contains(str2) && str2 != "0")
    {
      if (str2.ToUpper().IndexOfAny(new char[3]
      {
        'H',
        'S',
        'T'
      }) < 0)
      {
        if (str2.ToUpper().IndexOfAny(new char[3]
        {
          'D',
          'Y',
          'M'
        }) > -1)
          s = this.GetDateFromSerialDate((int) result2).ToString();
      }
    }
    if ((double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result2) || DateTime.TryParse(s.Replace(this.TIC, string.Empty), out result1)) && (!str2[0].Equals('[') || !this.NativeFormats.Contains(str2)))
    {
      if (str2.Length > 0)
      {
        if (str2.ToUpper().IndexOfAny(new char[5]
        {
          'M',
          'D',
          'Y',
          'S',
          'T'
        }) > -1)
        {
          char[] charArray = (str2.Equals("HH:MM") || str2.Equals("hh:mm") ? str2.Replace('h', 'H') : str2.Replace('Y', 'y').Replace('D', 'd').Replace('H', 'h').Replace('S', 's').Replace('m', 'M').Replace("AM/PM", "tt")).ToCharArray();
          bool flag1 = false;
          bool flag2 = false;
          int index1 = 0;
          int num1 = 0;
          int index2 = 0;
          int num2 = 0;
          foreach (char c in charArray)
          {
            if (c == 's' && charArray[index2] == 'M')
            {
              charArray[index2] = 'm';
              if (charArray[index2 - 1] == 'M')
                charArray[index2 - 1] = 'm';
            }
            if (char.IsLetter(c))
            {
              index2 = index1;
              if (c == 'M')
              {
                ++num1;
                ++num2;
              }
            }
            else if (num2 > 1)
              ++num2;
            if (c == 'M' && flag1)
            {
              charArray[index1] = 'm';
              flag2 = true;
            }
            if (c == 'h' || c == 'H')
              flag1 = true;
            else if (char.IsLetter(c) && c != 'M' && c != 'h' && !flag2)
            {
              flag1 = false;
              flag2 = false;
            }
            ++index1;
          }
          string format = new string(charArray);
          DateTime dateTime = DateTime.FromOADate(result2);
          if (result2 == 0.0)
            dateTime = result1;
          s = dateTime.ToString(format);
          goto label_31;
        }
      }
      s = string.Format($"{{0:{str2}}}", (object) result2);
    }
label_31:
    return this.TIC + s + this.TIC;
  }

  public string ComputeTextJoin(string range)
  {
    string empty = string.Empty;
    StringBuilder stringBuilder = new StringBuilder();
    string[] array = this.SplitArgsPreservingQuotedCommas(range);
    string str1 = this.GetValueFromArg(array[0]).Replace(this.TIC, string.Empty);
    string valueFromArg1 = this.GetValueFromArg(array[1]);
    foreach (string args in array)
    {
      int num1 = Array.IndexOf<string>(array, args, 0, array.Length);
      switch (num1)
      {
        case 0:
        case 1:
          continue;
        default:
          if (args.IndexOf(':') > -1)
          {
            string[] cellsFromArgs = this.GetCellsFromArgs(args);
            foreach (string str2 in cellsFromArgs)
            {
              try
              {
                int num2 = Array.IndexOf<string>(cellsFromArgs, str2, 0, cellsFromArgs.Length);
                string valueFromArg2 = this.GetValueFromArg(str2);
                if (this.ErrorStrings.Contains((object) valueFromArg2))
                {
                  if (this.RethrowLibraryComputationExceptions)
                    throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                  return valueFromArg2;
                }
                if (valueFromArg2.Length > 0 && valueFromArg2 != string.Empty && num2 != 0)
                  stringBuilder.Append(str1 + valueFromArg2);
                if (valueFromArg2.Length > 0 && valueFromArg2 != string.Empty && num2 == 0)
                  stringBuilder.Append(valueFromArg2);
                if (valueFromArg2.Length == 0)
                {
                  if (valueFromArg2 == string.Empty)
                  {
                    if (valueFromArg1 == this.FALSEVALUESTR)
                      stringBuilder.Append(str1 + valueFromArg2);
                  }
                }
              }
              catch (Exception ex)
              {
                this.ExceptionThrown = true;
                if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                  throw this.LibraryComputationException;
                return ex.Message;
              }
            }
            continue;
          }
          string valueFromArg3 = this.GetValueFromArg(args);
          bool.TryParse(valueFromArg3, out bool _);
          if (this.ErrorStrings.Contains((object) valueFromArg3))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return valueFromArg3;
          }
          if (valueFromArg3.Length == 0 && valueFromArg3 == string.Empty && valueFromArg1 == this.FALSEVALUESTR)
            stringBuilder.Append(str1 + valueFromArg3.Replace(this.TIC, string.Empty));
          if (valueFromArg3.Length > 0 && num1 != 2)
            stringBuilder.Append(str1 + valueFromArg3.Replace(this.TIC, string.Empty));
          if (valueFromArg3.Length > 0 && valueFromArg3 != string.Empty && num1 == 2)
          {
            stringBuilder.Append(valueFromArg3.Replace(this.TIC, string.Empty));
            continue;
          }
          continue;
      }
    }
    string str3 = stringBuilder.ToString();
    return str3.Length > (int) short.MaxValue ? this.ErrorStrings[1].ToString() : str3;
  }

  public string ComputeConcat(string range)
  {
    string empty = string.Empty;
    StringBuilder stringBuilder = new StringBuilder();
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    foreach (string str in strArray)
    {
      if (str.IndexOf(':') > -1 && this.IsRange(str))
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(str))
        {
          try
          {
            string valueFromArg = this.GetValueFromArg(cellsFromArg);
            if (this.ErrorStrings.Contains((object) valueFromArg))
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return valueFromArg;
            }
            if (valueFromArg.Length > 0 && (int) valueFromArg[0] == (int) this.TIC[0])
              stringBuilder.Append(valueFromArg.Substring(1, valueFromArg.Length - 2));
            else
              stringBuilder.Append(valueFromArg);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
        }
      }
      else
      {
        string valueFromArg = this.GetValueFromArg(str);
        bool.TryParse(valueFromArg, out bool _);
        if (this.ErrorStrings.Contains((object) valueFromArg))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return valueFromArg;
        }
        if (valueFromArg.Length > 0 && (int) valueFromArg[0] == (int) this.TIC[0])
          stringBuilder.Append(valueFromArg.Substring(1, valueFromArg.Length - 2));
        else
          stringBuilder.Append(valueFromArg);
      }
    }
    string str1 = stringBuilder.ToString();
    if (str1.Contains(this.TIC + this.TIC))
      str1 = str1.Replace(this.TIC + this.TIC, this.TIC);
    return str1.Length > (int) short.MaxValue ? this.ErrorStrings[1].ToString() : str1;
  }

  public string ComputeValue(string range)
  {
    string str1 = string.Empty;
    try
    {
      string[] strArray1 = this.SplitArgsPreservingQuotedCommas(range);
      if (strArray1.GetLength(0) > 0)
      {
        string str2 = strArray1[0];
        string[] strArray2 = this.IsRange(range) ? (string[]) null : new string[1];
        bool flag1 = false;
        bool flag2 = false;
        if (str2.Contains(this.TIC))
          flag1 = true;
        if (!string.IsNullOrEmpty(str2) && !this.IsCellReference(str2) && flag1)
        {
          DateTime result;
          if (double.TryParse(str2.Replace(this.TIC, string.Empty), out double _) || DateTime.TryParse(str2.Replace(this.TIC, string.Empty), (IFormatProvider) null, DateTimeStyles.None, out result) || this.TryParseExactDateTime(str2.Replace(this.TIC, string.Empty), out result))
          {
            str2 = strArray2[0] = str2.Replace(this.TIC, string.Empty);
            flag2 = true;
          }
        }
        else
        {
          if (string.IsNullOrEmpty(str2) && flag1)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.ErrorStrings[1].ToString());
            return this.ErrorStrings[1].ToString();
          }
          if (string.IsNullOrEmpty(str2) && !flag1)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
            return this.FormulaErrorStrings[this.invalid_arguments];
          }
          if (range.Contains(":"))
            strArray2 = this.GetCellsFromArgs(this.StripTics(str2.ToString()));
          else
            str2 = strArray2[0] = this.GetValueFromArg(str2);
        }
        foreach (string str3 in strArray2)
        {
          if (strArray2.Length > 1)
            str2 = this.GetValueFromArg(str3);
          if (str2.StartsWith("$"))
            str2 = str2.Replace("$", string.Empty);
          if (str2.StartsWith("%") || str2.EndsWith("%"))
          {
            str2 = str2.Replace("%", string.Empty);
            double result = 0.0;
            if (double.TryParse(str2, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result))
              str2 = (result / 100.0).ToString();
          }
          double result1 = 0.0;
          if (double.TryParse(str2, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
          {
            if (this.computedValueLevel > 1 && this.exteriorFormula)
            {
              str1 = !(str3 != strArray2[0]) ? result1.ToString() : $"{str1};{result1.ToString()}";
            }
            else
            {
              if (range.Contains(":"))
                return this.ComputedValue(range);
              str1 = result1.ToString();
            }
          }
          else
          {
            TimeSpan result2;
            if (TimeSpan.TryParse(str2, out result2))
            {
              if (flag2)
              {
                str1 = this.ComputeTimevalue(result2.ToString());
              }
              else
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
                return this.FormulaErrorStrings[this.invalid_arguments];
              }
            }
            else
            {
              DateTime dt;
              if (this.IsDate((object) str2, out dt))
                str1 = this.ComputeDatevalue(dt.ToString());
              else if (this.TryParseExactDateTime(str2.Replace(this.TIC, string.Empty), out dt))
                str1 = (this.GetSerialDateTimeFromDate(dt) - this.GetSerialDateTimeFromDate(DateTime.Today)).ToString();
              else if (string.IsNullOrEmpty(str2))
              {
                str1 = "0";
              }
              else
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.ErrorStrings[1].ToString());
                return this.ErrorStrings[1].ToString();
              }
            }
          }
        }
        if (this.exteriorFormula)
          this.exteriorFormula = false;
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (!this.RethrowLibraryComputationExceptions)
        return this.ErrorStrings[1].ToString();
      throw;
    }
    return str1.ToString();
  }

  public string ComputeMod(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (this.IsArrayFormula && strArray.Length > 2)
      strArray[1] = strArray[strArray.Length - 1];
    if ((strArray.Length != 2 || string.IsNullOrEmpty(range)) && !this.IsArrayFormula)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string mod = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) mod))
      return mod;
    string str1 = strArray[0];
    string str2 = strArray[1];
    string valueFromArg = this.GetValueFromArg(str1);
    string str3 = !string.IsNullOrEmpty(str2) ? this.GetValueFromArg(str2) : "0";
    bool result1;
    string str4 = bool.TryParse(valueFromArg, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg;
    bool result2;
    string str5 = bool.TryParse(str3, out result2) ? Convert.ToInt16(result2).ToString() : str3;
    double result3 = 0.0;
    double result4 = 0.0;
    double num = 0.0;
    if (double.TryParse(str4.Replace(this.TIC, string.Empty), out result3) && double.TryParse(str5.Replace(this.TIC, string.Empty), out result4))
    {
      num = result3 - result4 * Math.Floor(result3 / result4);
      if (this.ComputeIsErr(num.ToString()) == this.TRUEVALUESTR)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[3].ToString();
      }
    }
    return num.ToString();
  }

  public string ComputeTrunc(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    double result1 = 0.0;
    if (length > 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string trunc = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) trunc))
      return trunc;
    if (length == 2)
    {
      string valueFromArg = this.GetValueFromArg(strArray[1]);
      bool result2;
      double.TryParse(this.GetValueFromArg((bool.TryParse(valueFromArg, out result2) ? Convert.ToInt16(result2).ToString() : valueFromArg).Replace(this.TIC, string.Empty)), NumberStyles.Integer, (IFormatProvider) null, out result1);
    }
    range = this.GetValueFromArg(strArray[0]);
    bool result3;
    range = bool.TryParse(range, out result3) ? Convert.ToInt16(result3).ToString() : range;
    double result4;
    if (!double.TryParse(range.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result4) || result1 < 0.0)
      return "0";
    string format = result1 == 0.0 ? "F0" : "0." + new string('0', (int) result1);
    double num = Math.Pow(10.0, result1);
    return ((result4 < 0.0 ? -1.0 : 1.0) * Math.Floor(num * Math.Abs(result4)) / num).ToString(format);
  }

  private string PerformSumproductArithmetic(string range)
  {
    double num = 0.0;
    string[] strArray1 = range.Split(new string[1]
    {
      this.TIC
    }, StringSplitOptions.RemoveEmptyEntries);
    string empty1 = string.Empty;
    int index1 = -1;
    string empty2 = string.Empty;
    string str1 = string.Empty;
    if (strArray1.Length > 1)
    {
      foreach (string str2 in strArray1)
      {
        if (str2.Contains(";"))
          ++index1;
        else if (str2.IndexOfAny(this.tokens) > -1)
        {
          string[] strArray2;
          string[] strArray3;
          if (str1 != string.Empty)
          {
            strArray2 = str1.Replace(this.TIC, string.Empty).Split(';');
            strArray3 = strArray1[index1].Replace(this.TIC, string.Empty).Split(';');
          }
          else
          {
            strArray3 = strArray1[index1].Replace(this.TIC, string.Empty).Split(';');
            strArray2 = strArray1[index1 - 1].Replace(this.TIC, string.Empty).Split(';');
          }
          ++index1;
          string str3 = str2;
          if (strArray2.Length == strArray3.Length)
          {
            for (int index2 = 0; index2 <= strArray2.Length - 1; ++index2)
            {
              string valueFromArg = this.GetValueFromArg($"{'\u0092'.ToString()}n{strArray2[index2]}n{strArray3[index2]}{str3}{'\u0092'.ToString()}");
              str1 = $"{str1}{valueFromArg};";
            }
            str1 = str1.Substring(0, str1.Length - 1);
          }
          if (index1 == strArray1.Length - 1)
          {
            string str4 = str1.Replace(this.TIC, string.Empty);
            char[] chArray = new char[1]{ ';' };
            foreach (string s in str4.Split(chArray))
            {
              double result;
              if (double.TryParse(s, out result))
                num += result;
            }
          }
        }
      }
    }
    else if (strArray1.Length == 1 && strArray1[0].Contains(";") && strArray1[0].IndexOfAny(this.tokens) == -1)
    {
      string str5 = strArray1[0];
      char[] chArray = new char[1]{ ';' };
      foreach (string s in str5.Split(chArray))
      {
        double result;
        if (double.TryParse(s, out result))
          num += result;
      }
    }
    return num.ToString();
  }

  public string ComputeSumProduct(string range)
  {
    double num1 = 0.0;
    int count = 0;
    bool result1 = false;
    double[] vector = (double[]) null;
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()) && !range.Contains('!'.ToString()))
    {
      range = range.Replace('\u0092'.ToString(), string.Empty);
      return this.PerformSumproductArithmetic(range);
    }
    string[] collection;
    if (range.Contains(this.TIC) && range.StartsWith(this.TIC) | range.EndsWith(this.TIC))
    {
      collection = range.Split(new string[1]{ this.TIC }, StringSplitOptions.RemoveEmptyEntries);
      for (int index = 0; index < collection.Length; ++index)
      {
        if (collection[index] == CalcEngine.parseArgumentSeparator.ToString())
        {
          List<string> stringList = new List<string>((IEnumerable<string>) collection);
          stringList.Remove(collection[index]);
          collection = stringList.ToArray();
        }
        else if (collection[index].StartsWith(CalcEngine.parseArgumentSeparator.ToString()) && this.IsCellReference(collection[index].Replace(CalcEngine.parseArgumentSeparator.ToString(), string.Empty)))
          collection[index] = collection[index].Replace(CalcEngine.parseArgumentSeparator.ToString(), string.Empty);
      }
    }
    else
      collection = this.SplitArgsPreservingQuotedCommas(range);
    foreach (string str1 in collection)
    {
      string str2 = string.Empty;
      string empty = string.Empty;
      if (str1.IndexOf(':') > -1 && !this.IsCellReference(str1))
      {
        string str3 = str1.Replace('\u0092'.ToString(), string.Empty);
        string str4 = string.Empty;
        for (int index1 = 0; index1 <= str3.Length - 1; ++index1)
        {
          string args = string.Empty;
          string[] strArray1 = (string[]) null;
          string str5 = string.Empty;
          string str6 = string.Empty;
          while (index1 != str3.Length && ((char.IsDigit(str3[index1]) | str3[index1] == ':' | str3[index1] == '!' ? 1 : 0) | (index1 == 0 || !this.IsUpper(str3[index1]) ? 0 : (!char.IsDigit(str3[index1 - 1]) ? 1 : 0)) | (index1 != 0 ? 0 : (this.IsUpper(str3[index1]) ? 1 : 0))) != 0)
            args += (string) (object) str3[index1++];
          if (this.exteriorFormula && str3[index1] == '{')
          {
            int startIndex = index1 + 1;
            args = str3.Substring(startIndex, str3.IndexOf("}") - 1);
            index1 = startIndex + str3.IndexOf("}");
            strArray1 = args.Split(';');
            this.exteriorFormula = false;
          }
          if (index1 != str3.Length && str3[index1] == '"')
          {
            string str7 = str5;
            string str8 = str3;
            int index2 = index1;
            int index3 = index2 + 1;
            // ISSUE: variable of a boxed type
            __Boxed<char> local1 = (System.ValueType) str8[index2];
            string str9 = str7 + (object) local1;
            while (index3 != str3.Length && str3[index3] != '"')
              str9 += (string) (object) str3[index3++];
            string str10 = str9;
            string str11 = str3;
            int index4 = index3;
            index1 = index4 + 1;
            // ISSUE: variable of a boxed type
            __Boxed<char> local2 = (System.ValueType) str11[index4];
            str5 = str10 + (object) local2;
          }
          while (index1 != str3.Length && (this.IsUpper(str3[index1]) | char.IsDigit(str3[index1]) | str3[index1] == 'n' || (int) str3[index1] == (int) CalcEngine.parseDecimalSeparator || str3[index1].ToString().IndexOfAny(this.logicalOperators) > -1 && char.IsDigit(str3[index1 - 1])))
            str5 += (string) (object) str3[index1++];
          foreach (char token in this.tokens)
          {
            if (index1 != str3.Length && (int) str3[index1] == (int) token)
            {
              str5 += (string) (object) str3[index1];
              break;
            }
          }
          if (strArray1 == null)
            strArray1 = this.GetCellsFromArgs(args);
          if (args == string.Empty && str2 != string.Empty)
          {
            string[] strArray2 = this.SplitArgsPreservingQuotedCommas(str2);
            string[] strArray3 = strArray2[0].Replace(this.TIC, string.Empty).Split(';');
            string[] strArray4 = strArray2[1].Replace(this.TIC, string.Empty).Split(';');
            if (strArray3.Length == strArray4.Length)
            {
              for (int index5 = 0; index5 <= strArray3.Length - 1; ++index5)
              {
                if (index5 + 1 != strArray2.Length)
                  str6 = this.GetValueFromArg('\u0092'.ToString() + strArray3[index5] + strArray4[index5] + str5 + '\u0092'.ToString());
                str4 = $"{str4}{str6};";
              }
            }
            str2 = string.Empty;
          }
          else
          {
            for (int index6 = 0; index6 <= strArray1.Length - 1; ++index6)
            {
              string valueFromArg = this.GetValueFromArg('\u0092'.ToString() + strArray1[index6] + str5 + '\u0092'.ToString());
              str4 = $"{str4}{valueFromArg};";
            }
          }
          if (index1 == str3.Length - 1)
          {
            str2 = str4.Remove(str4.Length - 1);
          }
          else
          {
            string str12 = str4.Remove(str4.Length - 1);
            str2 = str2 + this.TIC + str12 + this.TIC + (object) CalcEngine.parseArgumentSeparator;
          }
          str4 = string.Empty;
        }
        this.performMultiplication(str2, ref result1, ref count, ref vector, ref empty);
        if (empty != string.Empty)
          return empty;
      }
      else if (!str1.StartsWith(this.TIC) && str1.IndexOf(':') > -1)
      {
        int length = str1.IndexOf(":");
        int num2 = this.RowIndex(str1.Substring(0, length));
        int num3 = this.RowIndex(str1.Substring(length + 1));
        if (!(!num2.Equals(-1) || num3.Equals(-1)).Equals(num2.Equals(-1) || !num3.Equals(-1)))
          return this.ErrorStrings[5].ToString();
        int num4 = this.ColIndex(str1.Substring(0, length));
        int num5 = this.ColIndex(str1.Substring(length + 1));
        if (this.grid is ISheetData)
        {
          if (num2 == -1 && this.grid is ISheetData)
            num2 = ((ISheetData) this.grid).GetFirstRow();
          if (num4 == -1 && this.grid is ISheetData)
            num4 = ((ISheetData) this.grid).GetFirstColumn();
          if (num3 == -1 && this.grid is ISheetData)
            num3 = ((ISheetData) this.grid).GetLastRow();
          if (num5 == -1 && this.grid is ISheetData)
            num5 = ((ISheetData) this.grid).GetLastColumn();
        }
        if (vector != null && count != (num3 - num2 + 1) * (num5 - num4 + 1))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        if (vector == null)
        {
          count = (num3 - num2 + 1) * (num5 - num4 + 1);
          vector = new double[count];
          for (int index = 0; index < count; ++index)
            vector[index] = 1.0;
        }
        GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
        string tokenFromReference = this.GetSheetTokenFromReference(str1);
        ICalcData grd = tokenFromReference == null || tokenFromReference == string.Empty ? this.grid : (ICalcData) sheetFamilyItem.TokenToParentObject[(object) tokenFromReference];
        int index7 = 0;
        for (int row = num2; row <= num3; ++row)
        {
          for (int col = num4; col <= num5; ++col)
          {
            double result2;
            vector[index7] = !double.TryParse(this.GetValueFromParentObject(grd, row, col).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2) ? (!bool.TryParse(this.GetValueFromParentObject(grd, row, col).Replace(this.TIC, string.Empty), out result1) ? 0.0 : vector[index7] * Convert.ToDouble(result1)) : vector[index7] * result2;
            ++index7;
          }
        }
      }
      else if (str1.Contains(CalcEngine.parseArgumentSeparator.ToString()) || str1.Contains(";") || str1.Contains("{"))
      {
        string r = str1.Replace('\u0092'.ToString(), string.Empty);
        if (this.exteriorFormula)
        {
          r = r.Replace("{", string.Empty).Replace("}", string.Empty);
          this.exteriorFormula = false;
        }
        this.performMultiplication(r, ref result1, ref count, ref vector, ref empty);
        if (empty != string.Empty)
          return empty;
      }
      else
      {
        string valueFromArg = this.GetValueFromArg(str1);
        double result3;
        if (double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), out result3))
        {
          num1 += result3;
        }
        else
        {
          if (this.ErrorStrings.Contains((object) valueFromArg))
            return valueFromArg;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
      }
    }
    for (int index = 0; index < count; ++index)
      num1 += vector[index];
    return num1.ToString();
  }

  internal void performMultiplication(
    string r,
    ref bool indexValue,
    ref int count,
    ref double[] vector,
    ref string errorString)
  {
    int index1 = 0;
    double result = 0.0;
    string[] strArray1;
    string[] strArray2;
    if (r.Contains(";"))
    {
      strArray1 = this.SplitArguments(r, ';');
      strArray2 = new string[strArray1.Length * this.SplitArgsPreservingQuotedCommas(strArray1[0]).Length];
    }
    else if (r.Contains(","))
    {
      strArray1 = this.SplitArguments(r, ',');
      strArray2 = new string[strArray1.Length * this.SplitArgsPreservingQuotedCommas(strArray1[0]).Length];
    }
    else
    {
      strArray1 = this.SplitArgsPreservingQuotedCommas(r);
      strArray2 = new string[strArray1.Length];
    }
    for (int index2 = 0; index2 < strArray1.Length; ++index2)
    {
      int index3 = 0;
      if (strArray1[index2].Contains(","))
      {
        for (string[] strArray3 = this.SplitArguments(strArray1[index2], ','); index3 != strArray3.Length; ++index3)
        {
          strArray2[index1] = strArray3[index3];
          ++index1;
        }
      }
      else
        strArray2[index2] = strArray1[index2];
    }
    string[] strArray4 = strArray2;
    if (vector != null && count != strArray4.Length)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      errorString = this.ErrorStrings[1].ToString();
    }
    else if (vector == null)
    {
      count = strArray4.Length;
      vector = new double[count];
      for (int index4 = 0; index4 < count; ++index4)
        vector[index4] = 1.0;
    }
    for (int index5 = 0; index5 < strArray4.Length; ++index5)
      vector[index5] = !double.TryParse(strArray4[index5], NumberStyles.Any, (IFormatProvider) null, out result) ? (!bool.TryParse(strArray4[index5], out indexValue) ? 0.0 : vector[index5] * Convert.ToDouble(indexValue)) : vector[index5] * result;
  }

  public string ComputeDollar(string args)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    if (strArray.Length > 2 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string dollar = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) dollar))
      return dollar;
    string str1 = strArray[0];
    string str2 = "2";
    if (strArray.GetLength(0) == 2)
      str2 = strArray[1];
    string valueFromArg1 = this.GetValueFromArg(str1);
    string str3 = string.IsNullOrEmpty(valueFromArg1) ? "0" : valueFromArg1;
    bool result1;
    string s1 = bool.TryParse(str3, out result1) ? Convert.ToInt16(result1).ToString() : str3;
    string valueFromArg2 = this.GetValueFromArg(str2);
    string str4 = string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2;
    string s2 = bool.TryParse(str4, out result1) ? Convert.ToInt16(result1).ToString() : str4;
    double result2;
    if (!double.TryParse(s1, NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[3].ToString());
      return this.ErrorStrings[5].ToString();
    }
    double result3;
    if (!double.TryParse(s2, NumberStyles.Any, (IFormatProvider) null, out result3))
      result3 = 2.0;
    NumberFormatInfo provider = (NumberFormatInfo) CultureInfo.CurrentCulture.NumberFormat.Clone();
    double num1;
    if (result3 > 0.0)
    {
      num1 = Math.Round(result2, (int) result3, MidpointRounding.AwayFromZero);
      provider.CurrencyDecimalDigits = (int) result3;
    }
    else
    {
      double num2 = Math.Pow(10.0, -result3);
      num1 = Math.Round(result2 / num2) * num2;
      provider.CurrencyDecimalDigits = 0;
    }
    return string.Format((IFormatProvider) provider, "{0:C}", (object) num1);
  }

  public string ComputeFixed(string args)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    string str1 = strArray[0];
    string str2 = "2";
    string str3 = "FALSE";
    int length = strArray.GetLength(0);
    if (length > 1)
      str2 = strArray[1];
    if (length > 2)
      str3 = strArray[2];
    string valueFromArg1 = this.GetValueFromArg(str1);
    string valueFromArg2 = this.GetValueFromArg(str2);
    string valueFromArg3 = this.GetValueFromArg(str3);
    double result1 = 0.0;
    double result2;
    double.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2);
    if (strArray.Length == 1 || strArray.Length > 1 && strArray[1] == string.Empty)
      result1 = 2.0;
    else if (!double.TryParse(valueFromArg2.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1) && result1 == 0.0)
      return this.ErrorStrings[1].ToString();
    double result3;
    bool flag;
    if (double.TryParse(valueFromArg3, NumberStyles.Any, (IFormatProvider) null, out result3))
      flag = result3 != 0.0;
    else if (valueFromArg3.ToUpper() == this.FALSEVALUESTR)
    {
      flag = false;
    }
    else
    {
      if (!(valueFromArg3.ToUpper() == this.TRUEVALUESTR))
        return "#NAME?";
      flag = true;
    }
    NumberFormatInfo provider = (NumberFormatInfo) CultureInfo.CurrentCulture.NumberFormat.Clone();
    double num1;
    if (result1 > 0.0)
    {
      num1 = Math.Round(result2, (int) result1, MidpointRounding.AwayFromZero);
      provider.NumberDecimalDigits = (int) result1;
    }
    else
    {
      double num2 = Math.Pow(10.0, -result1);
      num1 = Math.Round(result2 / num2) * num2;
      provider.NumberDecimalDigits = 0;
    }
    if (flag)
      provider.NumberGroupSeparator = string.Empty;
    return string.Format((IFormatProvider) provider, "{0:N}", (object) num1);
  }

  public string ComputeChoose(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray.Length < 2)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    int result;
    return !int.TryParse(this.GetValueFromArg(strArray[0]), out result) || result > strArray.Length - 1 || result < 1 ? "#VALUE!" : this.GetValueFromArg(strArray[result]);
  }

  public string ComputeLower(string args) => this.GetValueFromArg(args).ToLower();

  public string ComputeUpper(string args) => this.GetValueFromArg(args).ToUpper();

  public string ComputeT(string args)
  {
    int num = 0;
    string[] strArray = this.SplitArguments(args, CalcEngine.ParseArgumentSeparator);
    if (strArray.Length > 0)
    {
      foreach (string args1 in strArray)
      {
        ++num;
        if (args1.IndexOf(':') > -1)
        {
          --num;
          foreach (string cellsFromArg in this.GetCellsFromArgs(args1))
            ++num;
        }
      }
    }
    if (num > 1)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string valueFromArg = this.GetValueFromArg(args);
    string pattern = "[a-zA-Z0-9!#$%&'()*+,/:;<=>?@\\^_`{|}~-]";
    return this.ComputeIsNumber(args) == "TRUE" || this.ComputeIsLogical(args) == "TRUE" || this.UseDatesInCalculations && this.IsDate((object) valueFromArg, out DateTime _) || !Regex.IsMatch(valueFromArg, pattern) ? string.Empty : valueFromArg.Replace(this.TIC, string.Empty);
  }

  public string ComputeColumn(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    int length = strArray.GetLength(0);
    strArray[0] = strArray[0].Replace("\"", "");
    if (length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (string.IsNullOrEmpty(strArray[0]))
      return this.ColIndex(this.cell).ToString();
    string scopedRange = string.Empty;
    if (!this.IsCellReference(strArray[0]) && !this.TryGetNamedRange(strArray[0], out scopedRange))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    if (arg.IndexOf(':') > -1 && this.IsArrayFormula)
    {
      string interiorFunction = this.ArrayParser.ComputeInteriorFunction(arg, "COLUMN", this.computeFunctionLevel);
      if (!(interiorFunction == string.Empty))
        return interiorFunction;
      arg = this.GetCellsFromArgs(arg)[0];
    }
    if (arg.IndexOf(':') > -1)
      arg = this.GetCellsFromArgs(arg)[0];
    return this.ColIndex(arg).ToString();
  }

  public string ComputeRow(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    int length = strArray.GetLength(0);
    strArray[0] = strArray[0].Replace("\"", "");
    if (strArray[0].Contains(":") && this.exteriorFormula)
    {
      string str = string.Empty + "{";
      string[] cellsFromArgs = this.GetCellsFromArgs(strArray[0]);
      for (int index = 0; index < cellsFromArgs.Length; ++index)
        str = CalcEngine.parseArgumentSeparator == ',' ? str + this.ComputeRow(cellsFromArgs[index]) + (object) ';' : str + this.ComputeRow(cellsFromArgs[index]) + (object) ',';
      return '\u0092'.ToString() + (str.Remove(str.Length - 1) + "}") + (object) '\u0092';
    }
    if (length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (string.IsNullOrEmpty(strArray[0]))
      return this.RowIndex(this.cell).ToString();
    string scopedRange = string.Empty;
    if (!this.IsCellReference(strArray[0]) && !this.TryGetNamedRange(strArray[0], out scopedRange))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    if (arg.IndexOf(':') > -1 && this.IsArrayFormula)
    {
      string interiorFunction = this.ArrayParser.ComputeInteriorFunction(arg, "ROW", this.computeFunctionLevel);
      if (!(interiorFunction == string.Empty))
        return interiorFunction;
      arg = this.GetCellsFromArgs(arg)[0];
    }
    if (arg.IndexOf(':') > -1)
      arg = this.GetCellsFromArgs(arg.Replace(this.TIC, string.Empty))[0];
    return this.RowIndex(arg).ToString();
  }

  public string ComputeN(string args)
  {
    string empty = string.Empty;
    double result1 = 0.0;
    if (this.SplitArguments(args, CalcEngine.ParseArgumentSeparator).GetLength(0) != 1)
      return this.FormulaErrorStrings[this.requires_a_single_argument];
    string valueFromArg = this.GetValueFromArg(args);
    if (double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1))
      return result1.ToString();
    DateTime result2;
    if (DateTime.TryParse(valueFromArg, out result2))
      result1 = this.GetSerialDateTimeFromDate(result2);
    else if (valueFromArg.Equals(this.TRUEVALUESTR))
      result1 = 1.0;
    else if (valueFromArg.Equals(this.FALSEVALUESTR))
      result1 = 0.0;
    else if (this.ErrorStrings.Contains((object) valueFromArg) || this.formulaErrorStrings.Contains((object) valueFromArg))
      return valueFromArg;
    return result1.ToString();
  }

  private string ComputeNA(string args) => this.ComputeNA();

  public string ComputeNA() => "#N/A";

  public string ComputeErrorType(string args)
  {
    string empty = string.Empty;
    if (this.SplitArguments(args, CalcEngine.ParseArgumentSeparator).GetLength(0) != 1)
      return this.FormulaErrorStrings[this.requires_a_single_argument];
    string str = !this.IsCellReference(args) ? args : this.GetValueFromArg(args);
    if (str.Length > 1 && (int) str[0] == (int) this.TIC[0] && (int) str[str.Length - 1] == (int) this.TIC[0])
      return "#N/A";
    switch (str)
    {
      case "#NULL!":
        return "1";
      case "#DIV/0!":
        return "2";
      case "#VALUE!":
        return "3";
      case "#REF!":
        return "4";
      case "#NAME?":
        return "5";
      case "#NUM!":
        return "6";
      case "#N/A":
        return "7";
      case "#GETTING_DATA":
        return "8";
      default:
        return "#N/A";
    }
  }

  public string ComputeTrim(string args)
  {
    string trim = this.GetValueFromArg(args).Trim('"', ' ');
    for (int index = 0; trim.Length != index; trim = trim.Replace("  ", " "))
      index = trim.Length;
    return trim;
  }

  public string ComputeIsLogical(string args)
  {
    args = this.GetValueFromArg(args).ToUpper();
    return args.Equals(this.FALSEVALUESTR) || args.Equals(this.TRUEVALUESTR) ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeIsNA(string args)
  {
    if (this.ErrorStrings.IndexOf((object) args.ToUpper()) != -1)
      return args.ToUpper().Equals("#N/A") ? this.TRUEVALUESTR : this.FALSEVALUESTR;
    try
    {
      args = this.GetValueFromArg(args).ToUpper();
    }
    catch
    {
      return this.FALSEVALUESTR;
    }
    return args.StartsWith("#N/A") ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeIsErr(string range)
  {
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string upper = range.ToUpper();
    range = range.Length <= 0 || range.StartsWith("#") || upper.StartsWith("NAN") || upper.StartsWith("-NAN") || !(range != double.PositiveInfinity.ToString()) || !(range != double.NegativeInfinity.ToString()) ? range.ToUpper() : this.GetValueFromArg(range).ToUpper().Replace(this.TIC, string.Empty);
    return (range.StartsWith("NAN") || range.StartsWith("-NAN") || range.StartsWith("INFINITY") || range.StartsWith("-INFINITY") || range.StartsWith("#") || range.StartsWith("n#")) && !range.StartsWith("#N/A") || range.Equals(double.PositiveInfinity.ToString()) || range.Equals(double.NegativeInfinity.ToString()) ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeIsBlank(string args)
  {
    return this.GetValueFromArg(args).Equals(string.Empty) ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeIsText(string args)
  {
    bool flag = this.IsCellReference(args);
    string str = flag ? this.GetValueFromArg(args) : args;
    return (flag || str.StartsWith(this.TIC)) && str.Length > 0 && !double.TryParse(str.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out double _) ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeIsNonText(string args)
  {
    return this.ComputeIsText(args) == this.TRUEVALUESTR ? this.FALSEVALUESTR : this.TRUEVALUESTR;
  }

  public string ComputeIsError(string range)
  {
    if (this.SplitArgsPreservingQuotedCommas(range).Length > 1 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (range.Length > 0 && !range.StartsWith("#"))
      range = this.GetValueFromArg(range);
    range = range.ToUpper().Replace(this.TIC, string.Empty);
    return range.StartsWith(double.NaN.ToString().ToUpper()) || range.StartsWith("-" + double.NaN.ToString().ToUpper()) || range.StartsWith(double.PositiveInfinity.ToString().ToUpper()) || range.StartsWith(double.NegativeInfinity.ToString().ToUpper()) || range.StartsWith("#") || range.StartsWith("n#") ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeIsRef(string args)
  {
    string scopedRange = string.Empty;
    return this.SplitArgsPreservingQuotedCommas(args).Length != 1 ? this.FormulaErrorStrings[this.wrong_number_arguments] : ((this.TryGetNamedRange(args, out scopedRange) || this.IsCellReference(args)) && !args.StartsWith(this.TIC) && !args.EndsWith(this.TIC)).ToString().ToUpper();
  }

  public string ComputeAnd(string range)
  {
    bool flag = true;
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments].ToString();
    }
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    foreach (string args in strArray)
    {
      double result1;
      if (this.SplitArguments(args, ':').Length > 1)
      {
        if (this.IsCellReference(args.Replace(this.TIC, string.Empty)))
        {
          foreach (string cellsFromArg in this.GetCellsFromArgs(args))
          {
            string valueFromArg;
            try
            {
              valueFromArg = this.GetValueFromArg(cellsFromArg);
              if (this.ErrorStrings.Contains((object) valueFromArg))
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                return valueFromArg;
              }
            }
            catch (Exception ex)
            {
              this.ExceptionThrown = true;
              if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                throw new ArgumentException(this.ErrorStrings[4].ToString());
              return this.ErrorStrings[4].ToString();
            }
            flag = ((flag ? 1 : 0) & (valueFromArg.Equals(string.Empty) ? (bool.Parse(this.TRUEVALUESTR) ? 1 : 0) : (valueFromArg == this.TRUEVALUESTR ? 1 : (!double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1) ? 0 : (result1 != 0.0 ? 1 : 0))))) != 0;
            if (!flag)
              return this.FALSEVALUESTR;
          }
          continue;
        }
      }
      string valueFromArg1;
      bool result2;
      try
      {
        valueFromArg1 = this.GetValueFromArg(args);
        DateTime result3 = this.dateTime1900;
        if (valueFromArg1.StartsWith(this.TIC) && !bool.TryParse(args.Replace(this.TIC, string.Empty), out result2))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
        if (strArray.Length == 1 && string.IsNullOrEmpty(valueFromArg1))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        if (this.ErrorStrings.Contains((object) valueFromArg1))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return valueFromArg1;
        }
        if (DateTime.TryParse(valueFromArg1, out result3))
          return this.TRUEVALUESTR;
        if (!double.TryParse(valueFromArg1, out result1))
        {
          if (!valueFromArg1.Equals(string.Empty))
          {
            if (!bool.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), out result2))
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.ErrorStrings[1].ToString());
              return this.IsCellReference(args) ? this.ErrorStrings[1].ToString() : this.ErrorStrings[5].ToString();
            }
          }
        }
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      flag = ((flag ? 1 : 0) & (!bool.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), out result2) || !result2 ? (!double.TryParse(valueFromArg1, NumberStyles.Any, (IFormatProvider) null, out result1) ? 0 : (result1 != 0.0 ? 1 : 0)) : 1)) != 0;
      if (!flag)
        return this.FALSEVALUESTR;
    }
    return !flag ? this.FALSEVALUESTR : this.TRUEVALUESTR;
  }

  public string ComputeIFS(string args)
  {
    string empty = string.Empty;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    int length = strArray.GetLength(0);
    if (length % 2 != 0)
      throw new ArgumentException("You've entered too few arguments in this function");
    int index1;
    for (int index2 = 0; index2 < length; index2 = index1 + 1)
    {
      string s = this.GetValueFromArg(strArray[index2]).Replace(this.TIC, string.Empty);
      if (this.ErrorStrings.Contains((object) s))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return s;
      }
      double result = 0.0;
      if (!this.IsCellReference(strArray[0]) && !bool.TryParse(s.Replace(this.TIC, string.Empty), out bool _) && s.StartsWith(this.TIC) || this.IsCellReference(strArray[0]) && s.StartsWith(this.TIC) || !s.Replace(this.TIC, string.Empty).ToUpper().Equals(this.TRUEVALUESTR) && !s.Replace(this.TIC, string.Empty).ToUpper().Equals(this.FALSEVALUESTR) && !double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[1].ToString();
      }
      index1 = index2 + 1;
      if (s.Replace(this.TIC, string.Empty).ToUpper().Equals(this.TRUEVALUESTR) || double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result))
        return this.GetValueFromArg(strArray[index1]).Replace(this.TIC, string.Empty);
    }
    return this.ErrorStrings[0].ToString();
  }

  public string ComputeSwitch(string args)
  {
    int index1 = 0;
    string str1 = this.ErrorStrings[0].ToString();
    string empty = string.Empty;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    int length = strArray.GetLength(0);
    string str2 = this.GetValueFromArg(strArray[index1]).Replace(this.TIC, string.Empty);
    int index2;
    for (int index3 = 1; index3 < length; index3 = index2 + 1)
    {
      string str3 = this.GetValueFromArg(strArray[index3]).Replace(this.TIC, string.Empty);
      if (this.ErrorStrings.Contains((object) str3))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return str3;
      }
      if (!str2.Equals(str3) && index3 == length - 1 && length % 2 == 0)
        str1 = this.GetValueFromArg(strArray[index3]).Replace(this.TIC, string.Empty);
      index2 = index3 + 1;
      if (str2.Equals(str3))
        return this.GetValueFromArg(strArray[index2]).Replace(this.TIC, string.Empty);
    }
    return str1;
  }

  public string ComputeOr(string range)
  {
    bool flag = false;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    foreach (string args in strArray)
    {
      double result;
      if (args.IndexOf(':') > -1)
      {
        if (this.IsCellReference(args))
        {
          foreach (string cellsFromArg in this.GetCellsFromArgs(args))
          {
            string valueFromArg;
            try
            {
              valueFromArg = this.GetValueFromArg(cellsFromArg);
              if (this.ErrorStrings.Contains((object) valueFromArg))
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                return valueFromArg;
              }
            }
            catch (Exception ex)
            {
              this.ExceptionThrown = true;
              if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                throw this.LibraryComputationException;
              return ex.Message;
            }
            flag = ((flag ? 1 : 0) | (valueFromArg.Equals(this.TRUEVALUESTR) ? 1 : (!double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result) ? 0 : (result != 0.0 ? 1 : 0)))) != 0;
            if (flag)
              return this.TRUEVALUESTR;
          }
          continue;
        }
      }
      string valueFromArg1;
      try
      {
        valueFromArg1 = this.GetValueFromArg(args);
        if (this.ErrorStrings.Contains((object) valueFromArg1))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
        if (strArray.Length == 1 && string.IsNullOrEmpty(valueFromArg1))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        if (this.ErrorStrings.Contains((object) valueFromArg1))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return valueFromArg1;
        }
        if (DateTime.TryParse(valueFromArg1, out DateTime _))
          return this.TRUEVALUESTR;
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return ex.Message;
      }
      flag = ((flag ? 1 : 0) | (valueFromArg1.Replace(this.TIC, string.Empty).ToUpper().Equals(this.TRUEVALUESTR) ? 1 : (!double.TryParse(valueFromArg1, NumberStyles.Any, (IFormatProvider) null, out result) ? 0 : (result != 0.0 ? 1 : 0)))) != 0;
      if (flag)
        return this.TRUEVALUESTR;
    }
    return !flag ? this.FALSEVALUESTR : this.TRUEVALUESTR;
  }

  public string ComputeNot(string args)
  {
    string str = args;
    if (args.Length > 0)
    {
      if (!char.IsLetter(args[0]))
      {
        if (args.IndexOfAny(new char[2]
        {
          CalcEngine.ParseArgumentSeparator,
          ':'
        }) > -1)
          return this.FormulaErrorStrings[this.requires_a_single_argument];
      }
    }
    string s;
    try
    {
      s = this.GetValueFromArg(str);
      if (s.Equals(this.TRUEVALUESTR))
        s = this.FALSEVALUESTR;
      else if (s.Equals(this.FALSEVALUESTR))
      {
        s = this.TRUEVALUESTR;
      }
      else
      {
        double result;
        if (double.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result))
          s = Math.Abs(result) <= 1E-10 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
        throw this.LibraryComputationException;
      return ex.Message;
    }
    return s;
  }

  public string ComputeOffSet(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    int length1 = strArray.GetLength(0);
    switch (length1)
    {
      case 3:
      case 4:
      case 5:
        if (!string.IsNullOrEmpty(arg))
        {
          if (this.isIndexInteriorFormula && this.hitCount - 1 == this.computedValueLevel)
            this.isIndexInteriorFormula = false;
          for (int index = 1; index < length1; ++index)
          {
            if (index <= length1)
            {
              string offSet = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Numbers);
              if (this.ErrorStrings.Contains((object) offSet))
                return offSet;
            }
          }
          string str1 = strArray[0];
          string empty = string.Empty;
          int num1 = 0;
          int num2 = 0;
          double result1;
          if (!string.IsNullOrEmpty(strArray[1]))
            num1 = double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Integer, (IFormatProvider) null, out result1) ? (int) result1 : -1;
          if (!string.IsNullOrEmpty(strArray[2]))
            num2 = double.TryParse(this.GetValueFromArg(strArray[2]), NumberStyles.Integer, (IFormatProvider) null, out result1) ? (int) result1 : -1;
          int num3 = length1 >= 4 ? (double.TryParse(this.GetValueFromArg(strArray[3]), NumberStyles.Integer, (IFormatProvider) null, out result1) ? (int) result1 : 2) : -1;
          int num4 = length1 == 5 ? (double.TryParse(this.GetValueFromArg(strArray[4]), NumberStyles.Integer, (IFormatProvider) null, out result1) ? (int) result1 : 2) : -1;
          int num5 = num3 > 0 ? num3 - 1 : num3;
          int num6 = num4 > 0 ? num4 - 1 : num4;
          string oldValue = string.Empty;
          if (str1.Contains('!'.ToString()))
          {
            oldValue = this.ExternalBookToken(str1);
            if (!string.IsNullOrEmpty(oldValue))
              str1 = str1.Replace(oldValue, string.Empty);
          }
          if (str1.StartsWith(this.TIC) && this.IsCellReference(str1.Replace(this.TIC, string.Empty)))
            str1 = str1.Replace(this.TIC, string.Empty);
          int length2 = str1.IndexOf(":");
          bool flag1 = length2 == -1;
          if (flag1)
          {
            str1 = $"{str1}:{str1}";
            length2 = str1.IndexOf(":");
          }
          bool flag2 = ((flag1 ? 1 : 0) & (num6 > 0 ? 0 : (num5 <= 0 ? 1 : 0))) != 0;
          if (num6 == -1 && this.computedValueLevel == 1)
            flag2 = true;
          else if (num6 == -1 && num5 >= 0 && this.computedValueLevel > 1)
            ++num6;
          else if (num5 == -1 && num6 >= 0 && this.computedValueLevel > 1)
            ++num5;
          string tokenFromReference = this.GetSheetTokenFromReference(str1);
          int num7 = this.RowIndex(str1.Substring(0, length2)) + num1;
          int num8 = this.RowIndex(str1.Substring(length2 + 1)) + num1;
          if (!(!this.RowIndex(str1.Substring(0, length2)).Equals(-1) || this.RowIndex(str1.Substring(length2 + 1)).Equals(-1)).Equals(this.RowIndex(str1.Substring(0, length2)).Equals(-1) || !this.RowIndex(str1.Substring(length2 + 1)).Equals(-1)) || !this.IsCellReference(str1))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[5].ToString();
          }
          int col = this.ColIndex(str1.Substring(0, length2)) + num2;
          int num9 = this.ColIndex(str1.Substring(length2 + 1)) + num2;
          if (this.grid is ISheetData)
          {
            if (num7 == num1 - 1)
              num7 = ((ISheetData) this.grid).GetFirstRow() + num1;
            if (col == num2 - 1)
              col = ((ISheetData) this.grid).GetFirstColumn() + num2;
            if (num8 == num1 - 1)
            {
              int num10 = ((ISheetData) this.grid).GetLastRow() + num1;
            }
            if (num9 == num2 - 1)
              num9 = ((ISheetData) this.grid).GetLastColumn() + num2;
          }
          if (num7 <= 0 || col <= 0)
            return this.ErrorStrings[2].ToString();
          if ((num5 > 0 && num6 < 0 || num5 < 0 && num6 > 0) && !string.IsNullOrEmpty(this.cell))
            num7 = this.RowIndex(this.cell);
          if (num9 == int.Parse(this.ComputeColumn(str1)) - 1)
            flag2 = true;
          string str2;
          if (!flag2)
            str2 = string.Format("{4}{0}{1}:{2}{3}", (object) RangeInfo.GetAlphaLabel(col), (object) num7, (object) RangeInfo.GetAlphaLabel(col + num6), (object) (num7 + num5), (object) (oldValue + tokenFromReference));
          else
            str2 = this.ComputedValue(string.Format("{2}{0}{1}", (object) RangeInfo.GetAlphaLabel(col), (object) num7, (object) (oldValue + tokenFromReference)));
          string s = str2;
          DateTime result2;
          if (s != null && !double.TryParse(s.Replace(this.TIC, string.Empty), out double _) && DateTime.TryParse(s, out result2))
            return this.GetSerialDateTimeFromDate(result2).ToString();
          return string.IsNullOrEmpty(s) && this.TreatStringsAsZero ? "0" : s;
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeTrue(string empty) => this.TRUEVALUESTR;

  public string ComputeFalse(string empty) => this.FALSEVALUESTR;

  public string ComputeXor(string range)
  {
    bool flag = false;
    foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(range))
    {
      double result;
      if (preservingQuotedComma.IndexOf(':') > -1)
      {
        if (this.IsCellReference(preservingQuotedComma))
        {
          foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma))
          {
            string valueFromArg;
            try
            {
              valueFromArg = this.GetValueFromArg(cellsFromArg);
            }
            catch (Exception ex)
            {
              this.ExceptionThrown = true;
              if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                throw this.LibraryComputationException;
              return ex.Message;
            }
            flag = ((flag ? 1 : 0) ^ (valueFromArg == this.TRUEVALUESTR ? 1 : 0) ^ (!double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result) ? 0 : (result != 0.0 ? 1 : 0))) != 0;
          }
          continue;
        }
      }
      string valueFromArg1;
      try
      {
        valueFromArg1 = this.GetValueFromArg(preservingQuotedComma);
        if (this.ErrorStrings.Contains((object) valueFromArg1))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return valueFromArg1;
        }
        if (!valueFromArg1.Replace(this.TIC, string.Empty).ToUpper().Equals(this.TRUEVALUESTR))
        {
          if (!valueFromArg1.Replace(this.TIC, string.Empty).ToUpper().Equals(this.FALSEVALUESTR))
          {
            if (!double.TryParse(valueFromArg1, NumberStyles.Any, (IFormatProvider) null, out double _))
              return this.ErrorStrings[1].ToString();
          }
        }
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return ex.Message;
      }
      flag = ((flag ? 1 : 0) ^ (valueFromArg1.Replace(this.TIC, string.Empty).ToUpper().Equals(this.TRUEVALUESTR) ? 1 : 0) ^ (!double.TryParse(valueFromArg1, NumberStyles.Any, (IFormatProvider) null, out result) ? 0 : (result != 0.0 ? 1 : 0))) != 0;
    }
    return !flag ? this.FALSEVALUESTR : this.TRUEVALUESTR;
  }

  public string ComputeIfNA(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    string empty = string.Empty;
    string scopedRange = string.Empty;
    if (length != 2)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    double result;
    string ifNa;
    if (this.ComputeIsNA(strArray[0]).Equals(bool.TrueString.ToUpper()))
    {
      if (strArray[1].Equals(this.TRUEVALUESTR) || strArray[1].Equals(this.FALSEVALUESTR))
        return strArray[1];
      if (!strArray[1].Contains(this.TIC) && !this.IsCellReference(strArray[1]) && !double.TryParse(strArray[1], out result) && !this.TryGetNamedRange(strArray[1], out scopedRange))
        return this.ErrorStrings[5].ToString();
      ifNa = this.GetValueFromArg(strArray[1]);
    }
    else if (this.IsRange(strArray[0]))
    {
      ifNa = this.ErrorStrings[1].ToString();
    }
    else
    {
      if (!strArray[0].Contains(this.TIC) && !this.IsCellReference(strArray[0]) && !double.TryParse(strArray[0], out result) && !this.TryGetNamedRange(strArray[0], out scopedRange))
        return this.ErrorStrings[5].ToString();
      ifNa = this.GetValueFromArg(strArray[0]);
    }
    if (ifNa.StartsWith(this.TIC) && ifNa.EndsWith(this.TIC))
      ifNa = ifNa.Substring(1, ifNa.Length - 2);
    return ifNa;
  }

  public string ComputeAcos(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string acos = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) acos))
      return acos;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Acos)).ToString();
  }

  public string ComputeArabic(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray.Length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string upper = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "").ToUpper();
    if (!this.GetValueFromArg(strArray[0]).Contains(this.TIC) && string.IsNullOrEmpty(upper) || !this.IsCellReference(strArray[0]) && !strArray[0].Contains(this.TIC))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[5].ToString();
    }
    long num1 = 0;
    long num2 = 1000;
    for (int index = 1; index <= upper.Length; ++index)
    {
      long num3;
      switch (upper.Substring(index - 1, 1))
      {
        case "I":
          num3 = 1L;
          break;
        case "V":
          num3 = 5L;
          break;
        case "X":
          num3 = 10L;
          break;
        case "L":
          num3 = 50L;
          break;
        case "C":
          num3 = 100L;
          break;
        case "D":
          num3 = 500L;
          break;
        case "M":
          num3 = 1000L;
          break;
        default:
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
      }
      if (num3 > num2)
        num1 = num1 + num3 - 2L * num2;
      else
        num1 += num3;
      num2 = num3;
    }
    return num1.ToString();
  }

  public string ComputeAreas(string arg)
  {
    string scopedRange = string.Empty;
    if (arg.Contains(" "))
      arg = arg.Substring(0, arg.IndexOf(" "));
    if (!this.IsCellReference(arg) && !arg.Contains(")") && !this.TryGetNamedRange(arg, out scopedRange))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    string[] strArray1 = this.SplitArguments(arg, ')');
    if (strArray1.Length > 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string[] strArray2 = this.SplitArgsPreservingQuotedCommas(strArray1[0].Replace("(", string.Empty).Replace(")", string.Empty));
    for (int index = 0; index < strArray2.Length; ++index)
    {
      if (!this.IsCellReference(strArray2[index]) && !this.TryGetNamedRange(strArray2[index], out scopedRange))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.FormulaErrorStrings[this.invalid_arguments];
      }
    }
    return strArray2.Length.ToString();
  }

  public string ComputeAsin(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string asin = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) asin))
      return asin;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Asin));
  }

  public string ComputeAsinh(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string asinh = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) asinh))
      return asinh;
    args = this.GetValueFromArg(args);
    bool result1;
    args = bool.TryParse(args, out result1) ? Convert.ToInt16(result1).ToString() : args;
    double result2;
    if (double.TryParse(this.StripTics0(args), NumberStyles.Any, (IFormatProvider) null, out result2))
      return ((double) Math.Sign(result2) * Math.Log(Math.Abs(result2) + Math.Sqrt(result2 * result2 + 1.0))).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeAtan(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string atan = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) atan))
      return atan;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Atan)).ToString();
  }

  public string ComputeAtan2(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2)
      return this.FormulaErrorStrings[this.requires_2_args];
    double result1 = 0.0;
    string atan2_1 = this.GetValueFromArg(strArray[0]);
    string atan2_2 = this.GetValueFromArg(strArray[1]);
    bool result2;
    if (bool.TryParse(atan2_1, out result2))
      atan2_1 = Convert.ToInt32(result2).ToString();
    else if (atan2_1.Equals(string.Empty))
      atan2_1 = "0";
    bool result3;
    if (bool.TryParse(atan2_2, out result3))
      atan2_2 = Convert.ToInt32(result3).ToString();
    else if (atan2_2.Equals(string.Empty))
      atan2_2 = "0";
    if (this.ErrorStrings.Contains((object) atan2_1))
      return atan2_1;
    if (this.ErrorStrings.Contains((object) atan2_2))
      return atan2_2;
    double result4;
    if (!double.TryParse(atan2_1.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result4) || !double.TryParse(atan2_2.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
      return this.ErrorStrings[1].ToString();
    }
    if (result1 != 0.0 || result4 != 0.0)
      return Math.Atan2(result1, result4).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputeAtanh(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string atanh = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) atanh))
      return atanh;
    args = this.GetValueFromArg(args);
    bool result1;
    args = bool.TryParse(args, out result1) ? Convert.ToInt16(result1).ToString() : args;
    double result2;
    double num;
    if (double.TryParse(this.StripTics0(args), NumberStyles.Any, (IFormatProvider) null, out result2) && (num = Math.Abs(result2)) < 1.0)
      return (0.5 * (double) Math.Sign(result2) * Math.Log((1.0 + num) / (1.0 - num))).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeCeiling(string args)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    int length = strArray.GetLength(0);
    if (length != 2 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    strArray[0] = this.GetValueFromArg(strArray[0]);
    string str1 = length > 1 ? strArray[0] : "1";
    string str2 = string.IsNullOrEmpty(strArray[0]) ? "0" : str1;
    strArray[1] = this.GetValueFromArg(strArray[1]);
    string str3 = length <= 1 || strArray[1].Length == 0 ? "0" : strArray[1];
    string str4 = string.IsNullOrEmpty(strArray[1]) ? "0" : str3;
    bool result1 = false;
    bool result2 = false;
    string str5 = bool.TryParse(strArray[0].Replace(this.TIC, string.Empty), out result1) ? Convert.ToInt32(result1).ToString() : str2;
    string str6 = bool.TryParse(strArray[1].Replace(this.TIC, string.Empty), out result2) ? Convert.ToInt32(result2).ToString() : str4;
    double result3 = -1.0;
    double num = -1.0;
    double result4;
    if (double.TryParse(this.GetValueFromArg(str5), NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(this.GetValueFromArg(str6), NumberStyles.Any, (IFormatProvider) null, out result3))
    {
      if (result4 == 0.0 || result3 == 0.0 || result4 < 0.0 && this.ComputeRounddown(result4.ToString()) == "0" && result3 > 0.0)
        return "0";
      if (result4 > 0.0 && result3 < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.ErrorStrings[4].ToString();
      }
      num = Math.Floor(result4 / result3) * result3;
      if (result3 > 0.0)
      {
        while (num < result4)
          num += result3;
      }
      else
      {
        while (num > result4)
          num += result3;
      }
    }
    return num.ToString();
  }

  public string ComputeCeilingMath(string args)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    int length = strArray.GetLength(0);
    if (string.IsNullOrEmpty(args) || length > 3 || length < 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string ceilingMath = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) ceilingMath))
      return ceilingMath;
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    string str1 = length <= 1 || this.GetValueFromArg(strArray[1]).Length == 0 ? "1" : this.GetValueFromArg(strArray[1]).Replace(this.TIC, "");
    string str2 = length != 3 || this.GetValueFromArg(strArray[2]).Length == 0 ? "0" : this.GetValueFromArg(strArray[2]).Replace(this.TIC, "");
    double result1 = -1.0;
    double result2 = -1.0;
    double num = 0.0;
    bool result3 = false;
    bool result4 = false;
    bool result5 = false;
    string str3 = bool.TryParse(valueFromArg.Replace(this.TIC, string.Empty), out result3) ? Convert.ToInt32(result3).ToString() : valueFromArg;
    string str4 = bool.TryParse(str1.Replace(this.TIC, string.Empty), out result4) ? Convert.ToInt32(result4).ToString() : str1;
    string str5 = bool.TryParse(str2.Replace(this.TIC, string.Empty), out result5) ? Convert.ToInt32(result5).ToString() : str2;
    string empty = string.Empty;
    double result6;
    if (double.TryParse(str3.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result6) && double.TryParse(str4.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(str5.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result6 < 0.0 && result2 < 0.0)
        result1 = -1.0;
      if (strArray.Length < 2)
        return result6 > 0.0 ? this.ComputeRoundup(result6.ToString()) : this.ComputeRounddown(result6.ToString());
      if (result6 == 0.0 || result1 == 0.0)
        return "0";
      if (strArray.Length < 3)
        return double.Parse(this.ComputeCeiling(result6.ToString() + (object) CalcEngine.ParseArgumentSeparator + result1.ToString())).ToString();
      result6 = double.Parse(this.ComputeRoundup(result6.ToString()));
      num = double.Parse(this.ComputeRoundup((result6 / result1).ToString())) * result1;
      if (result6 < 0.0 && result6 % 2.0 != 0.0 && result2 == 0.0)
        num += result1;
    }
    return num.ToString();
  }

  public string ComputeColumns(string arg)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray1.Length != 1 || string.IsNullOrEmpty(arg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double result = -1.0;
    string scopedRange = string.Empty;
    if (double.TryParse(strArray1[0], out result))
      return "1";
    if (strArray1[0].Contains(this.TIC) && !strArray1[0].Contains(";") && !strArray1[0].Contains(CalcEngine.ParseArgumentSeparator.ToString()) || !this.IsCellReference(strArray1[0]) && !this.TryGetNamedRange(strArray1[0], out scopedRange) && !arg.Contains(";") && !arg.Contains(CalcEngine.ParseArgumentSeparator.ToString()))
    {
      strArray1[0] = this.GetValueFromArg(arg);
      if (this.ErrorStrings.Contains((object) strArray1[0]))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return strArray1[0];
      }
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    int num1 = 1;
    if (arg.IndexOf(':') > -1)
    {
      string[] cellsFromArgs = this.GetCellsFromArgs(arg);
      int num2 = this.ColIndex(cellsFromArgs[0].ToString());
      int num3 = this.ColIndex(cellsFromArgs[cellsFromArgs.Length - 1].ToString()) - num2 + 1;
      num1 = num3 > 0 ? num3 : 1;
    }
    else if (arg.IndexOf(';') > -1)
    {
      string[] strArray2 = this.SplitArguments(arg.Replace(this.TIC, ""), ';');
      for (int index = 1; index < strArray2.Length; ++index)
      {
        if (this.SplitArgsPreservingQuotedCommas(strArray2[index - 1]).Length != this.SplitArgsPreservingQuotedCommas(strArray2[1]).Length)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
          return this.FormulaErrorStrings[this.wrong_number_arguments];
        }
        num1 = this.SplitArgsPreservingQuotedCommas(strArray2[0]).Length;
      }
    }
    else
      num1 = this.SplitArgsPreservingQuotedCommas(strArray1[0].Replace(this.TIC, string.Empty)).Length;
    return num1.ToString();
  }

  public string ComputeCombin(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.requires_2_args]);
      return this.FormulaErrorStrings[this.requires_2_args];
    }
    strArray[0] = string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) ? "0" : strArray[0];
    strArray[1] = string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) ? "0" : strArray[1];
    if (strArray[0].Replace(this.TIC, string.Empty).Equals(string.Empty) || strArray[1].Replace(this.TIC, string.Empty).Equals(string.Empty))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    double result1;
    double result2;
    if (double.TryParse(this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      int k = (int) (result2 + 0.1);
      int n = (int) (result1 + 0.1);
      if (n >= k && k >= 0 && n >= 0 && result2 >= 0.0)
        return this.comb(k, n).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[4].ToString();
    }
    if ((strArray[0].StartsWith(this.TIC) || strArray[1].StartsWith(this.TIC)) && (!this.IsCellReference(strArray[0]) || !this.IsCellReference(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[5].ToString());
    return this.ErrorStrings[5].ToString();
  }

  public string ComputeCombinA(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (argList.Contains("u"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.errorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    if (length != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string combinA = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) combinA))
      return combinA;
    if (argList.Length > 15)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    strArray[0] = string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) ? "0" : strArray[0];
    strArray[1] = string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) ? "0" : strArray[1];
    int int32_1 = Convert.ToInt32(this.GetValueFromArg(strArray[0]));
    int int32_2 = Convert.ToInt32(this.GetValueFromArg(strArray[1]));
    return Convert.ToInt32(int32_1) != 0 || Convert.ToInt32(int32_2) != 0 ? this.ComputeCombin($"{(object) (int32_1 + int32_2 - 1)},{(object) (int32_1 - 1)}") : "1";
  }

  public string ComputeLog(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    string log = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) log))
      return log;
    string valueFromArg1 = this.GetValueFromArg(strArray[0]);
    bool result1;
    string s1 = bool.TryParse(valueFromArg1, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg1;
    double result2 = 10.0;
    double result3 = 10.0;
    if (length == 2)
    {
      string valueFromArg2 = this.GetValueFromArg(strArray[1]);
      if (string.IsNullOrEmpty(s1) || string.IsNullOrEmpty(valueFromArg2))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
        return this.ErrorStrings[4].ToString();
      }
      bool result4;
      string s2 = bool.TryParse(valueFromArg2, out result4) ? Convert.ToInt16(result4).ToString() : valueFromArg2;
      if (double.TryParse(this.GetValueFromArg(strArray[0]), NumberStyles.Any, (IFormatProvider) null, out result2) && result2 > 0.0 && (length == 1 || double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Any, (IFormatProvider) null, out result3)))
        return Math.Log(result2, result3).ToString();
      if (double.TryParse(s1, NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(s2, NumberStyles.Any, (IFormatProvider) null, out result3))
      {
        double num1 = Math.Log10(result2);
        double num2 = Math.Log10(result3);
        if (this.ComputeIsErr(num1.ToString()) == this.TRUEVALUESTR || this.ComputeIsErr(num2.ToString()) == this.TRUEVALUESTR)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[4].ToString();
        }
        if (!(this.ComputeIsErr((num1 / num2).ToString()) == this.TRUEVALUESTR))
          return (num1 / num2).ToString();
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[3].ToString();
      }
    }
    else if (double.TryParse(this.GetValueFromArg(strArray[0]), NumberStyles.Any, (IFormatProvider) null, out result2) && result2 > 0.0 && (length == 1 || double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Any, (IFormatProvider) null, out result3)))
      return Math.Log(result2, result3).ToString();
    return this.ComputeMath(argList, new CalcEngine.MathFunc(Math.Log10)).ToString();
  }

  public string ComputeLog10(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string log10 = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) log10))
      return log10;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Log10)).ToString();
  }

  public string ComputeExp(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string exp = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) exp))
      return exp;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    args = !string.IsNullOrEmpty(this.GetValueFromArg(args)) || !this.TreatStringsAsZero ? args : "0";
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Exp)).ToString();
  }

  public string ComputeSqrtpi(string args)
  {
    string empty = string.Empty;
    string sqrtpi = string.Empty;
    if (this.SplitArgsPreservingQuotedCommas(args).GetLength(0) > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (args.Length > 0 && !char.IsLetter(args[0]))
    {
      if (args.IndexOfAny(new char[2]
      {
        CalcEngine.ParseArgumentSeparator,
        ':'
      }) == -1)
      {
        double result;
        if (!double.TryParse(this.GetValueFromArg(args), NumberStyles.Any, (IFormatProvider) null, out result))
          return this.ErrorStrings[1].ToString();
        if (result < 0.0)
          return this.ErrorStrings[4].ToString();
        sqrtpi = this.ComputeSqrt((result * Math.PI).ToString());
        goto label_36;
      }
    }
    if (args.Length > 0 && (args[0] == '\u0092' || args[0] == 'u' || args[0] == 'n' || args.IndexOfAny(this.tokens) > -1))
    {
      args = args.Replace('{', '(');
      args = args.Replace('}', ')');
      string s;
      try
      {
        s = this.GetValueFromArg(args).Replace(this.TIC, string.Empty);
      }
      catch
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return this.FormulaErrorStrings[26];
      }
      double result;
      if (double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result) && result >= 0.0)
        sqrtpi = this.ComputeSqrt((result * Math.PI).ToString());
      else
        return this.ErrorStrings.Contains((object) s) ? s : this.ErrorStrings[4].ToString();
    }
    else
    {
      foreach (string cellsFromArg in this.GetCellsFromArgs(args))
      {
        string s;
        try
        {
          s = this.GetValueFromArg(cellsFromArg).Replace(this.TIC, string.Empty);
        }
        catch
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return this.FormulaErrorStrings[26];
        }
        if (s.Length > 0)
        {
          double result;
          if (double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result) && result >= 0.0)
          {
            sqrtpi = this.ComputeSqrt((result * Math.PI).ToString());
            break;
          }
          return this.ErrorStrings.Contains((object) s) ? s : this.ErrorStrings[4].ToString();
        }
      }
    }
label_36:
    return sqrtpi;
  }

  public string ComputeSqrt(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string sqrt = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) sqrt))
      return sqrt;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Sqrt)).ToString();
  }

  public string ComputeAbs(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string abs = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) abs))
      return abs;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Abs)).ToString();
  }

  public string ComputeCos(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string cos = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) cos))
      return cos;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Cos)).ToString();
  }

  public string ComputeAcosh(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string acosh = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) acosh))
      return acosh;
    args = this.GetValueFromArg(args);
    bool result1;
    args = bool.TryParse(args, out result1) ? Convert.ToInt16(result1).ToString() : args;
    double result2;
    double.TryParse(this.StripTics0(args), NumberStyles.Any, (IFormatProvider) null, out result2);
    if (result2 >= 1.0)
      return Math.Log(result2 + Math.Sqrt(result2 * result2 - 1.0)).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeRand(string args)
  {
    this.SplitArgsPreservingQuotedCommas(args);
    string rand = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.None);
    if (this.FormulaErrorStrings[this.invalid_arguments] == rand)
      return rand;
    if (this.rand == null)
      this.rand = new Random();
    return this.rand.NextDouble().ToString("0.0#############");
  }

  public string ComputeTan(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string tan = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) tan))
      return tan;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Tan)).ToString();
  }

  public string ComputeTanh(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string tanh = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) tanh))
      return tanh;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Tanh)).ToString();
  }

  private bool CheckCriteria(char op, string s, string criteria)
  {
    s = this.GetValueFromArg(s);
    return s.ToUpper().Replace(this.TIC, "") == criteria.ToUpper();
  }

  private bool CheckCriteria(char op, string s, double compare)
  {
    switch (op)
    {
      case 'e':
        s = this.GetValueFromArg(s);
        double result1;
        if (double.TryParse(s, out result1))
        {
          if (result1 == compare)
            return true;
          break;
        }
        DateTime result2;
        if (DateTime.TryParse(s, out result2))
        {
          result1 = this.GetSerialDateTimeFromDate(result2);
          if (result1 == compare)
            return true;
          break;
        }
        break;
      case 'g':
        s = this.GetValueFromArg(s);
        double result3;
        if (double.TryParse(s, out result3))
        {
          if (result3 > compare)
            return true;
          break;
        }
        DateTime result4;
        if (DateTime.TryParse(s, out result4))
        {
          result3 = this.GetSerialDateTimeFromDate(result4);
          if (result3 > compare)
            return true;
          break;
        }
        break;
      case 'j':
        s = this.GetValueFromArg(s);
        double result5;
        if (double.TryParse(s, out result5))
        {
          if (result5 >= compare)
            return true;
          break;
        }
        DateTime result6;
        if (DateTime.TryParse(s, out result6))
        {
          result5 = this.GetSerialDateTimeFromDate(result6);
          if (result5 >= compare)
            return true;
          break;
        }
        break;
      case 'k':
        s = this.GetValueFromArg(s);
        double result7;
        if (double.TryParse(s, out result7))
        {
          if (result7 <= compare)
            return true;
          break;
        }
        DateTime result8;
        if (DateTime.TryParse(s, out result8))
        {
          result7 = this.GetSerialDateTimeFromDate(result8);
          if (result7 <= compare)
            return true;
          break;
        }
        break;
      case 'l':
        s = this.GetValueFromArg(s);
        double result9;
        if (double.TryParse(s, out result9))
        {
          if (result9 < compare)
            return true;
          break;
        }
        DateTime result10;
        if (DateTime.TryParse(s, out result10))
        {
          result9 = this.GetSerialDateTimeFromDate(result10);
          if (result9 < compare)
            return true;
          break;
        }
        break;
      default:
        return false;
    }
    return false;
  }

  public string ComputeSumif(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length1 = strArray.GetLength(0);
    switch (length1)
    {
      case 2:
      case 3:
        string args1 = strArray[0];
        string valueFromArg1 = strArray[1];
        if (valueFromArg1.Length < 1)
          return "0";
        char op = 'e';
        if ((int) valueFromArg1[0] != (int) this.TIC[0] && "=><".IndexOf(valueFromArg1[0]) == -1)
          valueFromArg1 = this.GetValueFromArg(valueFromArg1);
        string criteria = this.findCriteria(valueFromArg1, ref op);
        string str = length1 == 2 ? args1 : strArray[2];
        string[] cellsFromArgs1 = this.GetCellsFromArgs(args1);
        string[] cellsFromArgs2 = this.GetCellsFromArgs(str);
        if (cellsFromArgs1[0].Equals(this.ErrorStrings[5]) || cellsFromArgs2[0].Equals(this.ErrorStrings[5]))
          return this.ErrorStrings[5].ToString();
        int length2 = cellsFromArgs1.GetLength(0);
        if (length2 > cellsFromArgs2.GetLength(0))
        {
          int length3 = str.IndexOf(':');
          int length4 = args1.IndexOf(':');
          int startRow1 = this.RowIndex(args1.Substring(0, length4));
          int endRow1 = this.RowIndex(args1.Substring(length4 + 1));
          int startCol1 = this.ColIndex(args1.Substring(0, length4));
          int endCol1 = this.ColIndex(args1.Substring(length4 + 1));
          if (!(!startRow1.Equals(-1) || endRow1.Equals(-1)).Equals(startRow1.Equals(-1) || !endRow1.Equals(-1)))
            return this.ErrorStrings[5].ToString();
          this.FindRowColIndex(ref startRow1, ref endRow1, ref startCol1, ref endCol1);
          int num1 = endRow1 - startRow1;
          int num2 = endCol1 - startCol1;
          string args2;
          if (length3 > -1)
          {
            int startRow2 = this.RowIndex(str.Substring(0, length3));
            int endRow2 = this.RowIndex(str.Substring(length3 + 1));
            if (!(!startRow2.Equals(-1) || endRow2.Equals(-1)).Equals(startRow2.Equals(-1) || !endRow2.Equals(-1)))
              return this.ErrorStrings[5].ToString();
            int startCol2 = this.ColIndex(str.Substring(0, length3));
            int endCol2 = this.ColIndex(str.Substring(length3 + 1));
            this.FindRowColIndex(ref startRow2, ref endRow2, ref startCol2, ref endCol2);
            int num3 = endCol2 - startCol2;
            int num4 = endRow2 - startRow2;
            if (num3 != num2)
              endCol2 = startCol2 + num2;
            if (num4 != num1)
              endRow2 = startRow2 + num1;
            args2 = RangeInfo.GetAlphaLabel(startCol2) + str.Substring(1, length3) + RangeInfo.GetAlphaLabel(endCol2) + endRow2.ToString();
          }
          else
          {
            string empty = string.Empty;
            int num5 = this.RowIndex(str);
            int num6 = this.ColIndex(str);
            int num7 = num5 + num1;
            string alphaLabel = RangeInfo.GetAlphaLabel(num6 + num2);
            args2 = $"{str}:{alphaLabel}{(object) num7}";
          }
          cellsFromArgs2 = this.GetCellsFromArgs(args2);
        }
        double num = 0.0;
        double result1 = 0.0;
        string empty1 = string.Empty;
        double result2 = double.MinValue;
        bool isNumber = double.TryParse(criteria, NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentCulture, out result2);
        for (int index = 0; index < length2; ++index)
        {
          string valueFromArg2 = this.GetValueFromArg(cellsFromArgs1[index]);
          if (this.ErrorStrings.Contains((object) valueFromArg2))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentNullException(this.FormulaErrorStrings[this.invalid_arguments]);
            return valueFromArg2;
          }
          if (this.CheckForCriteriaMatch(valueFromArg2.ToUpper(), op, criteria.ToUpper(), isNumber, result2) && double.TryParse(this.GetValueFromArg(cellsFromArgs2[index]), NumberStyles.Any, (IFormatProvider) null, out result1))
            num += result1;
        }
        return num.ToString();
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  private void FindRowColIndex(ref int startRow, ref int endRow, ref int startCol, ref int endCol)
  {
    if (startRow == -1)
      startRow = ((ISheetData) this.grid).GetFirstRow();
    if (startCol == -1)
      startCol = ((ISheetData) this.grid).GetFirstColumn();
    if (endRow == -1)
      endRow = ((ISheetData) this.grid).GetLastRow();
    if (endCol != -1)
      return;
    endCol = ((ISheetData) this.grid).GetLastColumn();
  }

  public string ComputeAsc(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    char[] charArray = this.StripTics0(this.GetValueFromArg(strArray[0])).ToCharArray();
    for (int index = 0; index < charArray.Length; ++index)
    {
      if (charArray[index] == '　')
        charArray[index] = ' ';
      else if (charArray[index] > '\uFF00' && charArray[index] < '｟')
        charArray[index] = (char) ((uint) charArray[index] - 65248U);
    }
    return new string(charArray);
  }

  public string ComputeAcot(string argList)
  {
    if (this.SplitArgsPreservingQuotedCommas(argList).GetLength(0) != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string acot = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) acot))
      return acot;
    argList = this.GetValueFromArg(argList);
    bool result1;
    argList = bool.TryParse(argList, out result1) ? Convert.ToInt16(result1).ToString() : argList;
    if (double.TryParse(this.StripTics0(argList), out double _))
    {
      double result2 = 0.0;
      double num = 0.0;
      if (double.TryParse(this.StripTics0(argList), out result2))
        num = result2 > 0.0 ? Math.Atan(1.0 / result2) : Math.PI / 2.0 - Math.Atan(result2);
      return num.ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.ErrorStrings[5].ToString();
  }

  public string ComputeAcoth(string argList)
  {
    if (this.SplitArgsPreservingQuotedCommas(argList).GetLength(0) > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string acoth = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) acoth))
      return acoth;
    argList = this.GetValueFromArg(argList);
    double result;
    if (double.TryParse(this.StripTics0(argList), out result))
    {
      string range = (Math.Log((result + 1.0) / (result - 1.0)) / 2.0).ToString();
      if (!(this.ComputeIsErr(range) == this.TRUEVALUESTR))
        return range;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
      return this.ErrorStrings[4].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.ErrorStrings[5].ToString();
  }

  public string ComputeAsech(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (argList.StartsWith(this.TIC) && argList.EndsWith(this.TIC))
      argList = argList.Replace(this.TIC, string.Empty);
    if (argList == string.Empty)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
      return this.ErrorStrings[4].ToString();
    }
    if (this.ComputeIsNumber(argList) == this.TRUEVALUESTR)
    {
      string str = argList;
      if (Convert.ToDouble(str.Contains("u") ? str.Replace("u", string.Empty) : str) > 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
        return this.ErrorStrings[4].ToString();
      }
      double result;
      if (double.TryParse(argList, out result))
        return Math.Log((Math.Sqrt(-result * result + 1.0) + 1.0) / result).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
      return this.ErrorStrings[5].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.ErrorStrings[5].ToString();
  }

  public string ComputeBase(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 2:
      case 3:
        if (!string.IsNullOrEmpty(argList))
        {
          string str1 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) str1))
            return str1;
          int num1;
          int num2;
          int num3;
          try
          {
            strArray[0] = this.GetValueFromArg(strArray[0]);
            strArray[1] = this.GetValueFromArg(strArray[1]);
            strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
            bool result;
            strArray[0] = bool.TryParse(strArray[0], out result) ? Convert.ToInt16(result).ToString() : strArray[0];
            strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
            strArray[1] = bool.TryParse(strArray[1], out result) ? Convert.ToInt16(result).ToString() : strArray[1];
            if (length == 3)
            {
              strArray[2] = this.GetValueFromArg(strArray[2]);
              strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
              strArray[2] = bool.TryParse(strArray[2], out result) ? Convert.ToInt16(result).ToString() : strArray[2];
            }
            num1 = int.Parse(this.GetValueFromArg(strArray[0]).Replace(this.TIC, ""));
            num2 = int.Parse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, ""));
            num3 = length == 3 ? int.Parse(strArray[2].Replace(this.TIC, "")) : 1;
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument] + ex.Message);
            return this.ErrorStrings[5].ToString();
          }
          if (num1 < 0 || num2 < 2 || num2 > "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".Length || num3 < 0)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentOutOfRangeException("Base requested outside range, it should be from 2 - 16");
            return this.ErrorStrings[4].ToString();
          }
          if (num1 == 0)
            return "0";
          int num4 = 63 /*0x3F*/;
          long num5 = (long) Math.Abs(num1);
          char[] chArray = new char[64 /*0x40*/];
          for (; num5 != 0L; num5 /= (long) num2)
          {
            int index = (int) (num5 % (long) num2);
            chArray[num4--] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[index];
          }
          string str2 = new string(chArray, num4 + 1, 64 /*0x40*/ - num4 - 1);
          StringBuilder stringBuilder = new StringBuilder();
          for (int index = 0; index < num3 - str2.Length; ++index)
            stringBuilder.Append("0");
          string str3 = stringBuilder.ToString() + str2;
          if (num1 < 0)
            str3 = "-" + str3;
          return str3.ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeCosh(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string cosh = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) cosh))
      return cosh;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Cosh)).ToString();
  }

  public string ComputeCot(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string cot = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) cot))
      return cot;
    bool result;
    argList = bool.TryParse(this.GetValueFromArg(argList), out result) ? Convert.ToInt16(result).ToString() : argList;
    if (this.ComputeIsNumber(argList) == this.TRUEVALUESTR)
    {
      string str = argList;
      if (Convert.ToDouble(str.Contains("u") ? str.Replace("u", string.Empty) : str) >= 134217728.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    if (argList == "0")
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[3].ToString());
      return this.ErrorStrings[3].ToString();
    }
    string math = this.ComputeMath(argList, new CalcEngine.MathFunc(Math.Tan));
    if (math != "#NUM!" || math != "#VALUE!")
      math = (1M / Convert.ToDecimal(math)).ToString();
    return math;
  }

  public string ComputeCoth(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    int length = strArray.GetLength(0);
    bool flag = false;
    if (length != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string coth1 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) coth1))
      return coth1;
    bool result;
    argList = bool.TryParse(this.GetValueFromArg(argList), out result) ? Convert.ToInt16(result).ToString() : argList;
    if (this.ComputeIsNumber(argList) == this.TRUEVALUESTR)
    {
      string str = argList;
      if (str.Contains("-"))
        flag = true;
      if (Convert.ToDouble(str.Contains("u") ? str.Replace("u", string.Empty) : str) >= 134217728.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    if (argList == "0")
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[3].ToString());
      return this.ErrorStrings[3].ToString();
    }
    argList = argList.Contains("-") ? argList.Replace("-", string.Empty) : argList;
    string coth2 = this.ComputeMath(argList, new CalcEngine.MathFunc(Math.Tanh));
    if (coth2 != "#NUM!" || coth2 != "#VALUE!")
      coth2 = (1M / Convert.ToDecimal(coth2)).ToString();
    if (flag)
      coth2 = "-" + coth2;
    return coth2;
  }

  public string ComputeCsc(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string csc = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) csc))
      return csc;
    bool result;
    argList = bool.TryParse(this.GetValueFromArg(argList), out result) ? Convert.ToInt16(result).ToString() : argList;
    if (this.ComputeIsNumber(argList) == this.TRUEVALUESTR)
    {
      string str = argList;
      if (Convert.ToDouble(str.Contains("u") ? str.Replace("u", string.Empty) : str) >= 134217728.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    if (argList == "0")
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[3].ToString());
      return this.ErrorStrings[3].ToString();
    }
    string math = this.ComputeMath(argList, new CalcEngine.MathFunc(Math.Sin));
    if (math != "#NUM!" || math != "#VALUE!")
      math = (1M / Convert.ToDecimal(math)).ToString();
    return math;
  }

  public string ComputeCsch(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string csch = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) csch))
      return csch;
    bool result1;
    argList = bool.TryParse(this.GetValueFromArg(argList), out result1) ? Convert.ToInt16(result1).ToString() : argList;
    if (this.ComputeIsNumber(argList) == this.TRUEVALUESTR)
    {
      string str = argList;
      if (Convert.ToDouble(str.Contains("u") ? str.Replace("u", string.Empty) : str) >= 134217728.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    if (argList == "0")
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[3].ToString());
      return this.ErrorStrings[3].ToString();
    }
    argList = argList.Contains("-") ? argList.Replace("-", string.Empty) : argList;
    double result2;
    return double.TryParse(argList, out result2) ? (2.0 / (Math.Exp(result2) - Math.Exp(-result2))).ToString() : this.ErrorStrings[5].ToString();
  }

  public string ComputeDecimal(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) > 3)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str;
    int num1;
    try
    {
      str = this.GetValueFromArg(strArray[0]).Replace(this.TIC, "");
      num1 = int.Parse(this.GetValueFromArg(strArray[1]).Replace(this.TIC, ""));
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument] + ex.Message);
      return this.ErrorStrings[1].ToString();
    }
    if (num1 < 2 || num1 > "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/".Length)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentOutOfRangeException("Base requested outside range, it should be from 2 - 16");
      return this.ErrorStrings[4].ToString();
    }
    string s = str.Trim();
    if (num1 <= 36)
      s = s.ToUpper();
    int num2 = 0;
    long num3 = 0;
    if ((s.Contains("e") || s.Contains("E")) && double.TryParse(s, out double _))
      s = Decimal.Parse(s, NumberStyles.Any).ToString();
    for (; num2 < s.Length && !char.IsWhiteSpace(s[num2]); ++num2)
    {
      int num4 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/".IndexOf(s.Substring(num2, 1));
      if (num4 >= 0 && num4 < num1)
      {
        num3 = num3 * (long) num1 + (long) num4;
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentOutOfRangeException("Base requested outside range, it should be from 2 - 16");
        return this.ErrorStrings[4].ToString();
      }
    }
    return num3.ToString();
  }

  public string ComputeDegrees(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string degrees = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) degrees))
      return degrees;
    bool result1;
    args = bool.TryParse(this.GetValueFromArg(args), out result1) ? Convert.ToInt16(result1).ToString() : args;
    double result2;
    if (double.TryParse(this.GetValueFromArg(args), NumberStyles.Any, (IFormatProvider) null, out result2))
      return (180.0 * result2 / Math.PI).ToString();
    if (!(this.ComputeIsText(args).ToString() == this.TRUEVALUESTR))
      return this.FormulaErrorStrings[this.invalid_arguments];
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[5].ToString());
    return this.ErrorStrings[5].ToString();
  }

  public string ComputeEven(string args)
  {
    double num1 = 0.0;
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string even = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) even))
      return even;
    bool result1;
    args = bool.TryParse(this.GetValueFromArg(args), out result1) ? Convert.ToInt16(result1).ToString() : args;
    double result2;
    if (double.TryParse(this.GetValueFromArg(args.Replace(this.TIC, string.Empty)), NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      int num2 = Math.Sign(result2);
      result2 = Math.Abs(result2);
      if ((double) (int) result2 != result2)
        result2 = (double) (int) (result2 + 1.0);
      num1 = result2 % 2.0 != 1.0 ? (double) num2 * result2 : (double) num2 * (result2 + 1.0);
    }
    return num1.ToString();
  }

  public string ComputeFact(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string fact = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) fact))
      return fact;
    bool result1;
    args = bool.TryParse(this.GetValueFromArg(args), out result1) ? Convert.ToInt16(result1).ToString() : args;
    double result2;
    double.TryParse(this.GetValueFromArg(args).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2);
    if (result2 < 0.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.ErrorStrings[4].ToString();
    }
    int index1 = (int) result2;
    double num;
    if (index1 > 12)
    {
      num = (double) CalcEngine.factorialTable[12];
      for (int index2 = 13; index2 <= index1; ++index2)
        num *= (double) index2;
    }
    else
      num = (double) CalcEngine.factorialTable[index1];
    return num.ToString();
  }

  public string ComputeFactdouble(string args)
  {
    double num1 = 1.0;
    if (this.SplitArgsPreservingQuotedCommas(args).GetLength(0) > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string factdouble = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) factdouble))
      return factdouble;
    double result;
    if (!double.TryParse(this.GetValueFromArg(args).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result))
    {
      if (!args.StartsWith(this.TIC))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[1].ToString();
      }
    }
    else
    {
      if (result < 0.0)
        return this.ErrorStrings[4].ToString();
      int num2 = (int) result;
      int num3 = num2;
      if (num2 > 3)
      {
        for (; num3 > 0; num3 -= 2)
          num1 *= (double) num3;
      }
      else
        num1 = num2 != 0 ? (double) num2 : 1.0;
    }
    return num1.ToString();
  }

  public string ComputeFloor(string args)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string floor = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Date);
    if (this.ErrorStrings.Contains((object) floor))
      return floor;
    double result1 = 0.0;
    double result2 = 0.0;
    double num = 0.0;
    string str1 = this.GetValueFromArg(strArray[0]).ToString();
    string str2 = this.GetValueFromArg(strArray[1]).ToString();
    DateTime result3;
    if (this.TryParseExactDateTime(str1.Replace(this.TIC, string.Empty), out result3))
      result1 = this.GetSerialDateTimeFromDate(result3) - this.GetSerialDateTimeFromDate(DateTime.Today);
    else if (double.TryParse(str1.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1))
      result1 = result1;
    if (this.TryParseExactDateTime(str2.Replace(this.TIC, string.Empty), out result3))
      result2 = this.GetSerialDateTimeFromDate(result3) - this.GetSerialDateTimeFromDate(DateTime.Today);
    else if (double.TryParse(str2.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2))
      result2 = result2;
    if (result1 == 0.0)
      return num.ToString();
    if (result1 * result2 > 0.0 || result1 < 0.0)
      return this.CalculateFloorValue(result1, result2).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  private double CalculateFloorValue(double d1, double d2)
  {
    double floorValue = Math.Ceiling(d1 / d2) * d2;
    if (d2 > 0.0)
    {
      while (floorValue > d1)
        floorValue -= d2;
    }
    else
    {
      while (floorValue < d1)
        floorValue -= d2;
    }
    if (d2 == 0.1)
      floorValue = d1;
    return floorValue;
  }

  public string ComputeFormulaText(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    string empty = string.Empty;
    if (length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string cell1 = strArray[0];
    if (this.NamedRanges.ContainsValue((object) cell1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[1].ToString();
    }
    string fromParentObject = this.GetValueFromParentObject(cell1, false);
    if (string.IsNullOrEmpty(fromParentObject))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    return fromParentObject[0] != '=' ? this.ErrorStrings[0].ToString() : fromParentObject;
  }

  public string ComputeGcd(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    List<int> intList = new List<int>();
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException("Wrong number of arguments");
      this.FormulaErrorStrings[25].ToString();
    }
    double result;
    foreach (string args in strArray)
    {
      if (args.IndexOf(':') > -1)
      {
        string[] cellsFromArgs = this.GetCellsFromArgs(args);
        int index = 0;
        if (index < cellsFromArgs.Length)
        {
          string str = cellsFromArgs[index];
          string valueFromArg = this.GetValueFromArg(str);
          if (this.ErrorStrings.Contains((object) valueFromArg))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentNullException("Passed arguments contains invalid argument");
            return valueFromArg;
          }
          if ((double.TryParse(this.GetValueFromArg(str).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result) || str.Length > 0) && (int) result > 0)
            intList.Add((int) result);
          else if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException("Passed arguments contains invalid argument");
          return this.ErrorStrings[4].ToString();
        }
      }
      else
      {
        string valueFromArg = this.GetValueFromArg(args);
        if (this.ErrorStrings.Contains((object) valueFromArg))
          return valueFromArg;
        if (!this.IsCellReference(args) && string.IsNullOrEmpty(valueFromArg))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException("Passed arguments contains invalid argument");
          return this.ErrorStrings[0].ToString();
        }
        if (!double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result))
        {
          if (!this.IsCellReference(args) && !args.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentNullException("Passed arguments contains invalid argument");
            return this.ErrorStrings[5].ToString();
          }
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException("Passed arguments contains invalid argument");
          return this.ErrorStrings[1].ToString();
        }
        if (result >= 0.0)
        {
          intList.Add((int) result);
        }
        else
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException("Passed arguments contains invalid argument");
          return this.ErrorStrings[4].ToString();
        }
      }
    }
    if (intList.Count == 1)
      return intList[0].ToString();
    for (int index = 0; index < intList.Count - 1; ++index)
    {
      while (intList[1] != 0)
      {
        int num = intList[0] % intList[1];
        intList[0] = intList[1];
        intList[1] = num;
      }
      if (intList.Count > 2 && index < intList.Count - 2)
        intList[1] = intList[index + 2];
    }
    return intList[0].ToString();
  }

  public string ComputeHyperlink(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length > 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string hyperlink = this.StripTics0(this.GetValueFromArg(strArray[0]));
    if (length != 2)
      return hyperlink;
    string str = this.StripTics0(this.GetValueFromArg(strArray[1]));
    if (str == null)
      return "0";
    return str == string.Empty ? string.Empty : str;
  }

  public string ComputeInt(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (range.Contains(":") && this.exteriorFormula)
    {
      string str = string.Empty + "{";
      foreach (string cellsFromArg in this.GetCellsFromArgs(range))
        str = str + this.ComputeInt(cellsFromArg) + (object) ';';
      return '\u0092'.ToString() + (str.Remove(str.Length - 1) + "}") + (object) '\u0092';
    }
    if (strArray.Length > 1 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    range = this.GetValueFromArg(range);
    string str1 = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) str1))
      return str1;
    bool result1;
    range = bool.TryParse(range, out result1) ? Convert.ToInt16(result1).ToString() : range;
    double result2;
    return double.TryParse(range, NumberStyles.Any, (IFormatProvider) null, out result2) ? Math.Floor(result2).ToString("F0") : "0";
  }

  public string ComputeIsEven(string args)
  {
    string empty = string.Empty;
    double result = 0.0;
    if (this.SplitArguments(args, CalcEngine.ParseArgumentSeparator).GetLength(0) != 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string isEven = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) isEven))
      return isEven;
    if (args.Equals(string.Empty))
      return this.TRUEVALUESTR;
    if (args.IndexOfAny(new char[2]
    {
      CalcEngine.ParseArgumentSeparator,
      ':'
    }) != -1)
      return "#VALUE!";
    this.PutTokensForSheets(ref args);
    if (!double.TryParse(this.GetValueFromArg(args).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result))
      return this.ErrorStrings[1].ToString();
    return (int) result % 2 == 0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeIsNumber(string range)
  {
    range = this.GetValueFromArg(range);
    return double.TryParse(range, NumberStyles.Any, (IFormatProvider) null, out double _) ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeIsOdd(string args)
  {
    string empty = string.Empty;
    double result = 0.0;
    if (this.SplitArguments(args, CalcEngine.ParseArgumentSeparator).GetLength(0) != 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string isOdd = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) isOdd))
      return isOdd;
    if (args.Equals(string.Empty))
      return this.TRUEVALUESTR;
    if (args.IndexOfAny(new char[2]
    {
      CalcEngine.ParseArgumentSeparator,
      ':'
    }) != -1)
      return "#VALUE!";
    if (!double.TryParse(this.GetValueFromArg(args).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result))
      return this.ErrorStrings[1].ToString();
    return (int) result % 2 != 0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
  }

  public string ComputeLcm(string range)
  {
    int index1 = 0;
    int length = 0;
    string empty = string.Empty;
    this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.Length > 0)
    {
      foreach (string args in strArray)
      {
        ++length;
        if (args.IndexOf(':') > -1)
        {
          --length;
          foreach (string cellsFromArg in this.GetCellsFromArgs(args))
            ++length;
        }
      }
    }
    int[] numArray = new int[length];
    double result;
    foreach (string args in strArray)
    {
      if (args.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(args))
        {
          if (!double.TryParse(this.GetValueFromArg(cellsFromArg).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result))
            return this.ErrorStrings[1].ToString();
          if (cellsFromArg.Length <= 0 || (int) result < 0)
            return this.ErrorStrings[4].ToString();
          numArray[index1] = (int) result;
          ++index1;
        }
      }
      else
      {
        if (!double.TryParse(this.GetValueFromArg(args).Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result))
          return this.ErrorStrings[1].ToString();
        if (args.Length <= 0)
          return this.ErrorStrings[4].ToString();
        numArray[index1] = (int) result;
        ++index1;
      }
    }
    if (numArray.Length == 1)
      return numArray[0].ToString();
    int num = numArray[0] * numArray[1] / int.Parse(this.ComputeGcd(numArray[0].ToString() + (object) CalcEngine.ParseArgumentSeparator + numArray[1].ToString()));
    for (int index2 = 2; index2 < numArray.Length; ++index2)
      num = num * numArray[index2] / int.Parse(this.ComputeGcd(num.ToString() + (object) CalcEngine.ParseArgumentSeparator + numArray[index2].ToString()));
    return num.ToString();
  }

  public string ComputeLn(string argList)
  {
    string empty = string.Empty;
    string ln1 = string.Empty;
    if (this.SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string ln2 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) ln2))
      return ln2;
    bool result;
    argList = bool.TryParse(this.GetValueFromArg(argList), out result) ? Convert.ToInt16(result).ToString() : argList;
    if (argList.Contains(":"))
    {
      string[] cellsFromArgs = this.GetCellsFromArgs(argList);
      for (int index = 0; index < cellsFromArgs.Length; ++index)
      {
        string valueFromArg = this.GetValueFromArg(cellsFromArgs[index]);
        if (valueFromArg.Length > 0)
        {
          if (!double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out double _))
            return this.ErrorStrings[1].ToString();
          string str = index != cellsFromArgs.Length - 1 ? this.ComputeMath(valueFromArg, new CalcEngine.MathFunc(Math.Log)).ToString() + (object) CalcEngine.parseArgumentSeparator : this.ComputeMath(valueFromArg, new CalcEngine.MathFunc(Math.Log)).ToString();
          ln1 += str;
        }
      }
      if (!ln1.StartsWith(this.TIC) && !ln1.EndsWith(this.TIC))
        ln1 = this.TIC + ln1 + this.TIC;
      return ln1;
    }
    return !argList.StartsWith(this.TIC) ? this.ComputeMath(argList, new CalcEngine.MathFunc(Math.Log)).ToString() : this.ErrorStrings[1].ToString();
  }

  private string ComputeMath(string args, CalcEngine.MathFunc func)
  {
    double num = 0.0;
    bool flag = false;
    if (args.Length > 0)
      args = this.SplitArgsPreservingQuotedCommas(args)[0];
    string oldValue = string.Empty;
    string str1 = string.Empty;
    if (args.Contains('!'.ToString()))
    {
      oldValue = this.ExternalBookToken(args);
      str1 = args;
      if (!string.IsNullOrEmpty(oldValue))
        args = args.Replace(oldValue, string.Empty);
    }
    if (args.Length > 0 && (!char.IsLetter(args[0]) && args[0] != '!' && args[0] != '\u0092' || args[0] == 'u' && char.IsDigit(args[1])))
    {
      if (args.IndexOfAny(new char[2]
      {
        CalcEngine.ParseArgumentSeparator,
        ':'
      }) == -1)
      {
        args = args.Replace('u', '-').Replace("n", string.Empty);
        double result;
        if (double.TryParse(args.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result))
        {
          num = func(result);
          goto label_40;
        }
        goto label_40;
      }
    }
    if (args.Length > 0 && (args[0] == '\u0092' || args[0] == 'u' || args[0] == 'n' || args.IndexOfAny(this.tokens) > -1))
    {
      args = args.Replace('{', '(');
      args = args.Replace('}', ')');
      string str2 = string.Empty;
      string str3 = Math.PI.ToString("R");
      string s1;
      try
      {
        if (args.Contains(str3) && !this.ComputedValue(args).Equals(str3))
        {
          string str4 = args.Substring(1, args.IndexOf(str3) - 2);
          s1 = string.IsNullOrEmpty(str4) ? "1" : str4;
          str2 = args.IndexOfAny(this.tokens) > -1 ? args.Substring(args.IndexOf(str3) - 1) : "1";
          flag = true;
        }
        else
          s1 = this.ComputedValue(args);
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return ex.Message;
      }
      if (flag)
      {
        string s2 = this.ComputedValue(s1 + str2);
        if (s2 == Math.PI.ToString())
        {
          num = func(Math.PI);
        }
        else
        {
          double result;
          if (double.TryParse(s2, out result))
          {
            num = func(result);
          }
          else
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
        }
      }
      else
      {
        double result;
        if (double.TryParse(s1, out result))
        {
          num = func(result);
        }
        else
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
      }
    }
    else
    {
      if (!string.IsNullOrEmpty(oldValue))
        args = str1;
      args = args.Replace('u', '-');
      string[] cellsFromArgs = this.GetCellsFromArgs(args);
      int index = 0;
      if (index < cellsFromArgs.Length)
      {
        string str5 = cellsFromArgs[index];
        string valueFromArg;
        try
        {
          valueFromArg = this.GetValueFromArg(str5);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        double result;
        if (valueFromArg.Length > 0 && double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result))
          num = func(result);
      }
    }
label_40:
    if (!this.ExcelLikeComputations && num.ToString() == Convert.ToString(double.NaN))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
      return num.ToString();
    }
    if (!(this.ComputeIsErr(num.ToString()) == this.TRUEVALUESTR))
      return num.ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return !this.ExcelLikeComputations ? num.ToString() : this.ErrorStrings[4].ToString();
  }

  public string ComputeMdeterm(string arg)
  {
    if (this.SplitArgsPreservingQuotedCommas(arg).Length != 1 || string.IsNullOrEmpty(arg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string mdeterm = this.FormulaErrorStringCheck(arg, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) mdeterm))
      return mdeterm;
    string scopedRange = string.Empty;
    if (!this.IsCellReference(arg) && !this.TryGetNamedRange(arg, out scopedRange) && !arg.Contains(";"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.ErrorStrings[1].ToString();
    }
    double num1 = 0.0;
    if (arg.IndexOf(':') > -1)
    {
      string[] cellsFromArgs = this.GetCellsFromArgs(arg);
      int index1 = 0;
      int length1 = int.Parse(this.ComputeRows(arg));
      int length2 = int.Parse(this.ComputeColumns(arg));
      if (length1 != length2)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
        return this.ErrorStrings[1].ToString();
      }
      int k = length1;
      double[,] a = new double[length1, length2];
      for (int index2 = 0; index2 < k; ++index2)
      {
        for (int index3 = 0; index3 < k; ++index3)
        {
          a[index2, index3] = double.Parse(this.GetValueFromArg(cellsFromArgs[index1]));
          ++index1;
        }
      }
      num1 = this.Determinant(a, k);
    }
    else if (arg.IndexOf(';') > -1)
    {
      string[] strArray1 = this.SplitArguments(arg.Replace(this.TIC, ""), ';');
      int length3 = this.SplitArgsPreservingQuotedCommas(strArray1[0]).Length;
      if (strArray1.Length != length3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
        return this.ErrorStrings[1].ToString();
      }
      double[,] a = new double[strArray1.Length, length3];
      int num2 = length3;
      for (int index4 = 0; index4 < strArray1.Length; ++index4)
      {
        string[] strArray2 = this.SplitArgsPreservingQuotedCommas(strArray1[index4]);
        int length4 = strArray2.Length;
        if (num2 != length4)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
          return this.FormulaErrorStrings[this.wrong_number_arguments];
        }
        for (int index5 = 0; index5 < num2; ++index5)
          a[index4, index5] = double.Parse(this.GetValueFromArg(strArray2[index5]));
      }
      num1 = this.Determinant(a, strArray1.Length);
    }
    return num1.ToString();
  }

  internal void GetCofactor(double[,] matrix, out double[,] iMatrix)
  {
    int length = matrix.GetLength(0);
    iMatrix = new double[matrix.GetLength(0), matrix.GetLength(1)];
    this.Cofactor(matrix, length, out iMatrix);
  }

  public string ComputeMInverse(string arg)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray1.Length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (string.IsNullOrEmpty(strArray1[0].Replace(this.TIC, string.Empty)))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.ErrorStrings[1].ToString();
    }
    string scopedRange = string.Empty;
    if (!this.IsCellReference(strArray1[0]) && !this.TryGetNamedRange(strArray1[0], out scopedRange) && !strArray1[0].Contains(";") && !double.TryParse(strArray1[0].Replace(this.TIC, ""), out double _))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return !strArray1[0].StartsWith(this.TIC) ? this.ErrorStrings[5].ToString() : this.ErrorStrings[1].ToString();
    }
    double num1;
    if (arg.IndexOf(':') > -1)
    {
      string[] cellsFromArgs = this.GetCellsFromArgs(strArray1[0]);
      int index1 = 0;
      int arrayHeight = int.Parse(this.ComputeRows(strArray1[0]));
      int arrayWidth = int.Parse(this.ComputeColumns(strArray1[0]));
      if (arrayHeight != arrayWidth)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
        return this.ErrorStrings[1].ToString();
      }
      int num2 = arrayHeight;
      double[,] numArray1 = new double[arrayHeight, arrayWidth];
      for (int index2 = 0; index2 < num2; ++index2)
      {
        for (int index3 = 0; index3 < num2; ++index3)
        {
          double result;
          if (double.TryParse(this.GetValueFromArg(cellsFromArgs[index1]), out result))
          {
            numArray1[index2, index3] = result;
            ++index1;
          }
          else
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
            return this.ErrorStrings[1].ToString();
          }
        }
      }
      double[,] inverse = numArray1;
      if (this.Determinant(numArray1, num2) == 0.0)
        return this.ErrorStrings[4].ToString();
      this.Cofactor(numArray1, num2, out inverse);
      if (this.computedValueLevel > 1)
      {
        string empty = string.Empty;
        string minverse = string.Empty;
        int num3 = 0;
        double[,] numArray2 = inverse;
        int upperBound1 = numArray2.GetUpperBound(0);
        int upperBound2 = numArray2.GetUpperBound(1);
        for (int lowerBound1 = numArray2.GetLowerBound(0); lowerBound1 <= upperBound1; ++lowerBound1)
        {
          for (int lowerBound2 = numArray2.GetLowerBound(1); lowerBound2 <= upperBound2; ++lowerBound2)
          {
            double num4 = numArray2[lowerBound1, lowerBound2];
            ++num3;
            string str = num4.ToString();
            if (num3 == inverse.Length / 2)
              str += ";";
            else if (num3 != inverse.Length)
              str += (string) (object) CalcEngine.parseArgumentSeparator;
            minverse += str;
          }
        }
        if (!minverse.StartsWith(this.TIC) && !minverse.EndsWith(this.TIC))
          minverse = this.TIC + minverse + this.TIC;
        return minverse;
      }
      if (string.IsNullOrEmpty(this.cell))
        return inverse[0, 0].ToString();
      int num5 = this.ColIndex(this.cell);
      int num6 = this.RowIndex(this.cell);
      int firstRowIndex;
      int firstColIndex;
      this.GetFormulaArrayBounds(this.cell, arrayHeight, arrayWidth, out firstRowIndex, out firstColIndex, out int _, out int _);
      int index4 = num6 - firstRowIndex;
      int index5 = num5 - firstColIndex;
      num1 = inverse[index4, index5];
    }
    else if (arg.IndexOf(';') > -1)
    {
      string[] strArray2 = this.SplitArguments(arg.Replace(this.TIC, ""), ';');
      int length1 = this.SplitArgsPreservingQuotedCommas(strArray2[0]).Length;
      if (strArray2.Length != length1)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
        return this.ErrorStrings[1].ToString();
      }
      double[,] numArray = new double[strArray2.Length, length1];
      int arrayWidth = length1;
      for (int index6 = 0; index6 < strArray2.Length; ++index6)
      {
        string[] strArray3 = this.SplitArgsPreservingQuotedCommas(strArray2[index6]);
        int length2 = strArray3.Length;
        if (arrayWidth != length2)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
          return this.FormulaErrorStrings[this.wrong_number_arguments];
        }
        for (int index7 = 0; index7 < arrayWidth; ++index7)
          numArray[index6, index7] = double.Parse(this.GetValueFromArg(strArray3[index7]));
      }
      double[,] inverse = numArray;
      if (this.Determinant(numArray, strArray2.Length) == 0.0)
        return this.ErrorStrings[4].ToString();
      this.Cofactor(numArray, strArray2.Length, out inverse);
      if (string.IsNullOrEmpty(this.cell))
        return inverse[0, 0].ToString();
      int num7 = this.ColIndex(this.cell);
      int num8 = this.RowIndex(this.cell);
      int firstRowIndex;
      int firstColIndex;
      this.GetFormulaArrayBounds(this.cell, inverse.Length - arrayWidth, arrayWidth, out firstRowIndex, out firstColIndex, out int _, out int _);
      int index8 = num8 - firstRowIndex;
      int index9 = num7 - firstColIndex;
      num1 = inverse[index8, index9];
    }
    else
    {
      double result;
      if (!double.TryParse(this.GetValueFromArg(strArray1[0]).Replace(this.TIC, ""), out result))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
        return this.ErrorStrings[1].ToString();
      }
      if (result != 0.0)
        return (1.0 / result).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
      return this.ErrorStrings[4].ToString();
    }
    return num1.ToString();
  }

  public string ComputeMmult(string arg)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray1.Length != 2 || string.IsNullOrEmpty(arg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    int arrayHeight = 0;
    int arrayWidth = 0;
    int length1 = 0;
    int length2 = 0;
    double[,] numArray1 = (double[,]) null;
    double[,] numArray2 = (double[,]) null;
    int index1 = 0;
    for (int index2 = 0; index2 < strArray1.Length; ++index2)
    {
      if (strArray1[index2].IndexOf(":") > -1)
      {
        string mmult = this.FormulaErrorStringCheck(strArray1[index2], CalcEngine.FormulaArgumentType.Range);
        if (this.ErrorStrings.Contains((object) mmult))
          return mmult;
        double result = 0.0;
        if (!this.IsCellReference(strArray1[index2]) && !double.TryParse(this.StripTics0(strArray1[index2]), out result))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
          return this.ErrorStrings[1].ToString();
        }
        strArray1[index2] = this.StripTics0(strArray1[index2]);
        if (index2 == 0)
        {
          string[] cellsFromArgs = this.GetCellsFromArgs(strArray1[index2]);
          arrayHeight = int.Parse(this.ComputeRows(strArray1[0]));
          arrayWidth = int.Parse(this.ComputeColumns(strArray1[0]));
          numArray1 = new double[arrayHeight, arrayWidth];
          for (int index3 = 0; index3 <= arrayHeight - 1; ++index3)
          {
            for (int index4 = 0; index4 <= arrayWidth - 1; ++index4)
            {
              numArray1[index3, index4] = double.Parse(this.GetValueFromArg(cellsFromArgs[index1]));
              ++index1;
            }
          }
        }
        else
        {
          string[] cellsFromArgs = this.GetCellsFromArgs(strArray1[1]);
          length1 = int.Parse(this.ComputeRows(strArray1[1]));
          length2 = int.Parse(this.ComputeColumns(strArray1[1]));
          numArray2 = new double[length1, length2];
          index1 = 0;
          for (int index5 = 0; index5 <= length1 - 1; ++index5)
          {
            for (int index6 = 0; index6 <= length2 - 1; ++index6)
            {
              numArray2[index5, index6] = double.Parse(this.GetValueFromArg(cellsFromArgs[index1]));
              ++index1;
            }
          }
        }
      }
      else if (strArray1[index2].IndexOf(";") > -1)
      {
        string[] strArray2 = this.SplitArguments(strArray1[index2].ToString().Replace(this.TIC, ""), ';');
        if (index2 == 0)
        {
          arrayWidth = this.SplitArgsPreservingQuotedCommas(strArray2[0]).Length;
          arrayHeight = strArray2.Length;
          if (strArray2.Length != arrayWidth)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
            return this.ErrorStrings[1].ToString();
          }
          numArray1 = new double[strArray2.Length, arrayWidth];
          int num = arrayWidth;
          for (int index7 = 0; index7 < strArray2.Length; ++index7)
          {
            string[] strArray3 = this.SplitArgsPreservingQuotedCommas(strArray2[index7]);
            int length3 = strArray3.Length;
            if (num != length3)
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
              return this.FormulaErrorStrings[this.wrong_number_arguments];
            }
            for (int index8 = 0; index8 < num; ++index8)
              numArray1[index7, index8] = double.Parse(this.GetValueFromArg(strArray3[index8]));
          }
        }
        else
        {
          length2 = this.SplitArgsPreservingQuotedCommas(strArray2[0]).Length;
          length1 = strArray2.Length;
          if (strArray2.Length != length2)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
            return this.ErrorStrings[1].ToString();
          }
          numArray2 = new double[strArray2.Length, length2];
          int num = length2;
          for (int index9 = 0; index9 < strArray2.Length; ++index9)
          {
            string[] strArray4 = this.SplitArgsPreservingQuotedCommas(strArray2[index9]);
            int length4 = strArray4.Length;
            if (num != length4)
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
              return this.FormulaErrorStrings[this.wrong_number_arguments];
            }
            for (int index10 = 0; index10 < num; ++index10)
              numArray2[index9, index10] = double.Parse(this.GetValueFromArg(strArray4[index10]));
          }
        }
      }
      else
      {
        string mmult = this.FormulaErrorStringCheck(strArray1[index2], CalcEngine.FormulaArgumentType.Range);
        if (this.ErrorStrings.Contains((object) mmult))
          return mmult;
      }
    }
    double[,] numArray3 = new double[arrayHeight, length2];
    for (int index11 = 0; index11 <= arrayHeight - 1; ++index11)
    {
      for (int index12 = 0; index12 <= length2 - 1; ++index12)
      {
        for (int index13 = 0; index13 <= length1 - 1; ++index13)
          numArray3[index11, index12] += numArray1[index11, index13] * numArray2[index13, index12];
      }
    }
    if (string.IsNullOrEmpty(this.cell))
      return numArray3[0, 0].ToString();
    int num1 = this.ColIndex(this.cell);
    int num2 = this.RowIndex(this.cell);
    int firstRowIndex;
    int firstColIndex;
    this.GetFormulaArrayBounds(this.cell, arrayHeight, arrayWidth, out firstRowIndex, out firstColIndex, out int _, out int _);
    int index14 = num2 - firstRowIndex;
    int index15 = num1 - firstColIndex;
    return numArray3[index14, index15].ToString();
  }

  public string ComputeMround(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string mround1 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) mround1))
      return mround1;
    if (string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    bool result1;
    if (bool.TryParse(this.GetValueFromArg(strArray[0]), out result1) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double result2 = 0.0;
    double result3 = 0.0;
    string str = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    string mround2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty);
    if (!double.TryParse(str, NumberStyles.Any, (IFormatProvider) null, out result2) || !double.TryParse(mround2, NumberStyles.Any, (IFormatProvider) null, out result3))
      return this.ErrorStrings[1].ToString();
    if (result3 == 0.0)
      return mround2;
    if (this.ComputeSign(str) != this.ComputeSign(mround2) && str != "0" && mround2 != "0")
      return this.ErrorStrings[4].ToString();
    double num = result2 / result3;
    return (double.Parse(!(this.ComputeSign(result3.ToString()) == "1") || Math.Round(result2 % result3, 2) < result3 / 2.0 ? this.ComputeRound(num.ToString()) : this.ComputeRoundup(num.ToString())) * result3).ToString();
  }

  public string ComputeMultinomial(string range)
  {
    string empty = string.Empty;
    int index1 = 0;
    int length = 0;
    string fact1 = this.ComputeFact(this.ComputeSum(range));
    this.AdjustRangeArg(ref range);
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray1.Length > 0)
    {
      foreach (string args in strArray1)
      {
        ++length;
        if (args.IndexOf(':') > -1)
        {
          --length;
          foreach (string cellsFromArg in this.GetCellsFromArgs(args))
            ++length;
        }
      }
    }
    string[] strArray2 = new string[length];
    double result1;
    foreach (string args in strArray1)
    {
      if (args.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(args))
        {
          string s;
          try
          {
            s = this.GetValueFromArg(cellsFromArg).Replace(this.TIC, string.Empty);
          }
          catch
          {
            this.ExceptionThrown = true;
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[26]);
            return this.FormulaErrorStrings[26];
          }
          if (s.Length > 0)
          {
            if (double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result1))
            {
              string fact2 = this.ComputeFact(result1.ToString());
              strArray2[index1] = fact2;
              ++index1;
            }
            else if (this.ErrorStrings.Contains((object) s))
              return s;
          }
        }
      }
      else
      {
        string s;
        try
        {
          s = this.GetValueFromArg(args).Replace(this.TIC, string.Empty);
        }
        catch
        {
          this.ExceptionThrown = true;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[26]);
          return this.FormulaErrorStrings[26];
        }
        if (s.Length > 0)
        {
          if (!double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result1))
            return this.ErrorStrings[1].ToString();
          string fact3 = this.ComputeFact(result1.ToString());
          strArray2[index1] = fact3;
          ++index1;
        }
      }
    }
    string range1 = strArray2[0];
    for (int index2 = 1; index2 < strArray2.Length; ++index2)
      range1 = $"{range1},{strArray2[index2]}";
    string product = this.ComputeProduct(range1);
    double result2;
    double result3;
    return double.TryParse(fact1, out result2) && double.TryParse(product, out result3) ? (result2 / result3).ToString() : this.FormulaErrorStringCheck($"{product},{fact1}", CalcEngine.FormulaArgumentType.Numbers);
  }

  public string ComputeMUnit(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray.Length != 1 || string.IsNullOrEmpty(arg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string munit = this.FormulaErrorStringCheck(arg, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) munit))
      return munit;
    bool result;
    strArray[0] = bool.TryParse(this.GetValueFromArg(strArray[0]), out result) ? Convert.ToInt16(result).ToString() : strArray[0];
    int length = int.Parse(this.GetValueFromArg(strArray[0].Replace(this.TIC, "")));
    if (length == 0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double[,] numArray = new double[length, length];
    for (int index1 = 0; index1 < length; ++index1)
    {
      for (int index2 = 0; index2 < length; ++index2)
        numArray[index1, index2] = index1 != index2 ? 0.0 : 1.0;
    }
    return numArray[0, 0].ToString();
  }

  public string ComputeOdd(string args)
  {
    double num1 = 0.0;
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string odd = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) odd))
      return odd;
    bool result1;
    args = bool.TryParse(this.GetValueFromArg(args), out result1) ? Convert.ToInt16(result1).ToString() : args;
    double result2;
    if (double.TryParse(this.GetValueFromArg(args), NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      int num2 = result2 == 0.0 ? 1 : Math.Sign(result2);
      result2 = Math.Abs(result2);
      if ((double) (int) result2 != result2 || result2 == 0.0)
        result2 = (double) (int) (result2 + 1.0);
      num1 = result2 % 2.0 != 0.0 ? (double) num2 * result2 : (double) num2 * (result2 + 1.0);
    }
    return num1.ToString();
  }

  public string ComputePI(string args)
  {
    string str = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.None);
    return this.FormulaErrorStrings[this.invalid_arguments] == str ? str : Math.PI.ToString("R");
  }

  public string ComputePow(string args)
  {
    double num = 0.0;
    if (this.SplitArgsPreservingQuotedCommas(args).Length != 2 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string pow = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) pow))
      return pow;
    if (args.Length > 0 && !char.IsLetter(args[0]))
    {
      if (args.IndexOfAny(new char[2]
      {
        CalcEngine.ParseArgumentSeparator,
        ':'
      }) == -1)
        return this.FormulaErrorStrings[this.requires_2_args];
    }
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    if (strArray.GetLength(0) == 2)
    {
      if (!string.IsNullOrEmpty(args))
      {
        string s1;
        string s2;
        try
        {
          string valueFromArg1 = this.GetValueFromArg(strArray[0]);
          string valueFromArg2 = this.GetValueFromArg(strArray[1]);
          if (string.IsNullOrEmpty(valueFromArg1) && string.IsNullOrEmpty(valueFromArg2))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[4].ToString();
          }
          string str1 = !string.IsNullOrEmpty(valueFromArg1) || !this.TreatStringsAsZero ? valueFromArg1 : "0";
          string str2 = !string.IsNullOrEmpty(valueFromArg2) || !this.TreatStringsAsZero ? valueFromArg2 : "0";
          bool result;
          s1 = bool.TryParse(this.GetValueFromArg(str1), out result) ? Convert.ToInt16(result).ToString() : str1;
          s2 = bool.TryParse(this.GetValueFromArg(str2), out result) ? Convert.ToInt16(result).ToString() : str2;
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        double result1;
        double result2;
        if (double.TryParse(s1, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1) && double.TryParse(s2, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result2))
        {
          if (result1 == 0.0 && result2 < 0.0)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[3].ToString();
          }
          num = Math.Pow(result1, result2);
        }
        return num.ToString();
      }
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.requires_2_args]);
    return this.FormulaErrorStrings[this.requires_2_args];
  }

  private string GetValueForBool(string arg)
  {
    if (arg == this.TRUEVALUESTR || arg == 'n'.ToString() + this.TRUEVALUESTR)
      return "1";
    return arg == this.FALSEVALUESTR || arg == 'n'.ToString() + this.FALSEVALUESTR ? "0" : arg;
  }

  public string ComputeProduct(string range)
  {
    double num = 1.0;
    bool flag = true;
    this.AdjustRangeArg(ref range);
    double result;
    foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(range.Replace(this.TIC, string.Empty)))
    {
      if (preservingQuotedComma.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma))
        {
          string valueForBool;
          try
          {
            valueForBool = this.GetValueForBool(this.GetValueFromArg(cellsFromArg));
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.RethrowLibraryComputationExceptions)
              throw ex;
            return ex.Message;
          }
          if (valueForBool.Length > 0)
          {
            if (double.TryParse(valueForBool.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result))
            {
              num *= result;
              flag = false;
            }
            else if (this.ErrorStrings.Contains((object) valueForBool))
              return valueForBool;
          }
        }
      }
      else
      {
        string valueForBool;
        try
        {
          valueForBool = this.GetValueForBool(this.GetValueFromArg(preservingQuotedComma));
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.RethrowLibraryComputationExceptions)
            throw ex;
          return ex.Message;
        }
        if (valueForBool.Length > 0)
        {
          if (double.TryParse(valueForBool.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result))
          {
            num *= result;
            flag = false;
          }
          else if (this.ErrorStrings.Contains((object) valueForBool))
            return valueForBool;
        }
      }
    }
    return !flag ? num.ToString() : "0";
  }

  public string ComputeQuotient(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.Length > 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string quotient = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) quotient))
      return quotient;
    string str1 = strArray[0];
    string str2 = strArray[1];
    string empty = string.Empty;
    string s1 = this.GetValueFromArg(str1).Replace(this.TIC, string.Empty);
    string s2 = this.GetValueFromArg(str2).Replace(this.TIC, string.Empty);
    bool result1;
    if (string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result1) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double result2;
    double result3;
    return !double.TryParse(s1, NumberStyles.Any, (IFormatProvider) null, out result2) || !double.TryParse(s2, NumberStyles.Any, (IFormatProvider) null, out result3) ? this.ErrorStrings[1].ToString() : Math.Truncate(result2 / result3).ToString();
  }

  public string ComputeRadians(string args)
  {
    double num = 0.0;
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string radians = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) radians))
      return radians;
    bool result1;
    args = bool.TryParse(this.GetValueFromArg(args), out result1) ? Convert.ToInt16(result1).ToString() : args;
    string valueFromArg = this.GetValueFromArg(args);
    if (string.IsNullOrEmpty(valueFromArg))
      return num.ToString();
    double result2;
    return double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result2) ? (Math.PI * result2 / 180.0).ToString() : this.FormulaErrorStrings[this.invalid_arguments];
  }

  public string ComputeRoman(string argList)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray1.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string roman1 = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) roman1))
      return roman1;
    string empty = string.Empty;
    string str1 = string.Empty;
    string str2 = string.Empty;
    string str3 = string.Empty;
    string str4 = string.Empty;
    int index1 = 0;
    if (strArray1.Length > 2)
      return this.FormulaErrorStrings[this.invalid_arguments];
    int[] numArray1 = new int[2];
    foreach (string range in strArray1)
    {
      double result;
      if (this.IsRange(range) || !double.TryParse(this.GetValueFromArg(range), NumberStyles.Any, (IFormatProvider) null, out result) && range.Length <= 0 || (int) result < 0)
        return this.ErrorStrings[1].ToString();
      numArray1[index1] = (int) result;
      ++index1;
    }
    if (numArray1[0] < 0 || numArray1[0] > 3999)
      return this.ErrorStrings[1].ToString();
    if (numArray1[1] < 0 || numArray1[1] > 4)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    int[] numArray2 = new int[13]
    {
      1000,
      900,
      500,
      400,
      100,
      90,
      50,
      40,
      10,
      9,
      5,
      4,
      1
    };
    string[] strArray2 = new string[13]
    {
      "M",
      "CM",
      "D",
      "CD",
      "C",
      "XC",
      "L",
      "XL",
      "X",
      "IX",
      "V",
      "IV",
      "I"
    };
    StringBuilder stringBuilder = new StringBuilder();
    int num1 = numArray1[0];
    string str5 = num1.ToString();
    bool flag1 = true;
    bool flag2 = false;
    bool flag3 = false;
    bool flag4 = false;
    bool flag5 = false;
    for (int index2 = 0; index2 < 13; ++index2)
    {
      while (num1 >= numArray2[index2])
      {
        num1 -= numArray2[index2];
        stringBuilder.Append(strArray2[index2]);
      }
    }
    string roman2 = stringBuilder.ToString();
    if (str5.Contains("45") || str5.Contains("46") || str5.Contains("47") || str5.Contains("48") || str5.Contains("49"))
      flag2 = true;
    if (str5.Contains("95") || str5.Contains("96") || str5.Contains("97") || str5.Contains("98") || str5.Contains("99"))
      flag3 = true;
    if (str5.EndsWith("45") || str5.EndsWith("46") || str5.EndsWith("47") || str5.EndsWith("48") || str5.EndsWith("49"))
      flag4 = true;
    if (str5.EndsWith("95") || str5.EndsWith("96") || str5.EndsWith("97") || str5.EndsWith("98") || str5.EndsWith("99"))
      flag5 = true;
    if (!flag2 && !flag3)
      return stringBuilder.ToString();
    if (str5.EndsWith("499") || str5.EndsWith("999"))
    {
      str1 = roman2.Replace('C', 'L').Replace('X', 'V');
      string[] strArray3 = str1.Replace('L', 'X').Split('V');
      char[] charArray1 = strArray3[1].ToCharArray();
      char[] charArray2 = strArray3[0].ToCharArray();
      Array.Reverse((Array) charArray1);
      string str6 = new string(charArray1);
      str2 = new string(charArray2) + str6;
      str3 = str2.Replace('X', 'V');
      string[] strArray4 = str3.Split('V');
      char[] charArray3 = strArray4[1].ToCharArray();
      Array.Reverse((Array) charArray3);
      string str7 = new string(charArray3);
      for (int index3 = 0; index3 < strArray3.Length - 1; ++index3)
        str4 = index3 != 1 ? str4 + strArray4[index3] : str4 + str7;
      flag1 = false;
    }
    if (str5.Contains("95") || str5.Contains("96") || str5.Contains("97") || str5.Contains("98"))
    {
      switch (int.Parse("4".Replace('4', str5[str5.IndexOf('9')])))
      {
        case 4:
        case 9:
          string str8 = roman2.Replace('C', 'L');
          int num2 = str8.IndexOf('X');
          string[] strArray5 = str8.Split('X');
          int num3 = 0;
          int index4 = 0;
          while (num3 < num2 + 1)
          {
            num3 += strArray5[index4].Length;
            ++index4;
          }
          char[] charArray4 = strArray5[1].ToCharArray();
          Array.Reverse((Array) charArray4);
          string str9 = new string(charArray4);
          int length1 = str9.Length;
          int num4 = length1;
          int startIndex1;
          for (startIndex1 = 0; startIndex1 < num4 - 2; ++startIndex1)
          {
            str9 += (string) (object) str9[length1 - 3];
            --length1;
          }
          string str10 = str9.Substring(startIndex1);
          str1 = strArray5[0] + str10;
          string[] strArray6 = str1.Split('L');
          str2 = strArray6[0] + "X";
          for (int index5 = 1; index5 < strArray6.Length; ++index5)
            str2 += strArray6[index5];
          string[] strArray7 = str2.Split('X');
          char[] charArray5 = strArray7[1].ToCharArray();
          Array.Reverse((Array) charArray5);
          string str11 = new string(charArray5);
          int length2 = str11.Length;
          int num5 = length2;
          for (int index6 = 0; index6 < num5 - 2; ++index6)
          {
            str11 += (string) (object) str11[length2 - 3];
            --length2;
          }
          string str12 = str11.Substring(startIndex1);
          str3 = strArray7[0] + str12;
          str4 = str3;
          flag1 = false;
          break;
      }
    }
    if (flag1 && (flag4 || flag5))
    {
      int num6 = roman2.IndexOf('X');
      string[] strArray8 = roman2.Split('X');
      if (strArray8.Length == 2)
      {
        int num7 = 0;
        int index7 = 0;
        while (num7 < num6 + 1)
        {
          num7 += strArray8[index7].Length;
          ++index7;
        }
        char[] charArray6 = strArray8[index7 - 1].ToCharArray();
        Array.Reverse((Array) charArray6);
        string str13 = new string(charArray6);
        int length3 = str13.Length;
        int num8 = length3;
        int startIndex2;
        for (startIndex2 = 0; startIndex2 < num8 - 2; ++startIndex2)
        {
          str13 += (string) (object) str13[length3 - 3];
          --length3;
        }
        string str14 = str13.Substring(startIndex2);
        string str15;
        str1 = str15 = strArray8[0] + str14;
        str4 = str15;
        str3 = str15;
        str2 = str15;
      }
      if (strArray8.Length == 3)
      {
        str1 = roman2.Replace("X", "V");
        string[] strArray9 = str1.Split('V');
        str2 = string.Empty;
        char[] charArray7 = strArray9[1].ToCharArray();
        Array.Reverse((Array) charArray7);
        string str16 = new string(charArray7);
        for (int index8 = 0; index8 < strArray9.Length; ++index8)
          str2 = index8 == 1 ? str2 + str16 : str2 + strArray9[index8];
        str3 = str4 = str2;
      }
    }
    else if (flag1 && !flag4 && !flag5)
    {
      int num9 = roman2.IndexOf('C');
      string[] strArray10 = roman2.Split('C');
      if (strArray10.Length == 2)
      {
        int num10 = 0;
        int index9 = 0;
        while (num10 < num9 + 1)
        {
          num10 += strArray10[index9].Length;
          ++index9;
        }
        char[] charArray8 = strArray10[index9 - 1].ToCharArray();
        Array.Reverse((Array) charArray8);
        string str17 = new string(charArray8);
        int length4 = str17.Length;
        int num11 = length4;
        int startIndex3;
        for (startIndex3 = 0; startIndex3 < num11 - 2; ++startIndex3)
        {
          str17 += (string) (object) str17[length4 - 3];
          --length4;
        }
        string str18 = str17.Substring(startIndex3);
        str1 = strArray10[0] + str18;
        string str19;
        str4 = str19 = str1;
        str3 = str19;
        str2 = str19;
      }
      if (strArray10.Length == 3)
      {
        str1 = roman2.Replace("C", "L");
        string[] strArray11 = str1.Split('L');
        str2 = string.Empty;
        char[] charArray9 = strArray11[1].ToCharArray();
        Array.Reverse((Array) charArray9);
        string str20 = new string(charArray9);
        for (int index10 = 0; index10 < strArray11.Length; ++index10)
          str2 = index10 == 1 ? str2 + str20 : str2 + strArray11[index10];
        str3 = str4 = str2;
      }
    }
    else if (flag1)
      return roman2;
    switch (numArray1[1])
    {
      case 1:
        roman2 = str1;
        break;
      case 2:
        roman2 = str2;
        break;
      case 3:
        roman2 = str3;
        break;
      case 4:
        roman2 = str4;
        break;
    }
    return roman2;
  }

  public string ComputeRound(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string round = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) round))
      return round;
    if (length == 1)
    {
      bool result;
      argList = bool.TryParse(this.GetValueFromArg(argList), out result) ? Convert.ToInt16(result).ToString() : argList;
      return this.ComputeMath(argList, new CalcEngine.MathFunc(Math.Round)).ToString();
    }
    double result1 = 0.0;
    double result2 = 0.0;
    string str1 = "0";
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    string str2 = string.IsNullOrEmpty(strArray[1]) ? "0" : this.GetValueFromArg(strArray[1]);
    bool result3;
    string s1 = bool.TryParse(valueFromArg, out result3) ? Convert.ToInt16(result3).ToString() : valueFromArg;
    bool result4;
    string s2 = bool.TryParse(str2, out result4) ? Convert.ToInt16(result4).ToString() : str2;
    if ((s1 == string.Empty || double.TryParse(s1, NumberStyles.Any, (IFormatProvider) null, out result1)) && (s2 == string.Empty || double.TryParse(s2, NumberStyles.Any, (IFormatProvider) null, out result2)))
    {
      if (result2 > 0.0)
      {
        str1 = Math.Round((Decimal) result1, (int) result2, MidpointRounding.AwayFromZero).ToString();
      }
      else
      {
        double num = Math.Pow(10.0, -result2);
        str1 = (Math.Round(result1 / num, MidpointRounding.AwayFromZero) * num).ToString();
      }
    }
    return str1.ToString();
  }

  public string ComputeRounddown(string argList)
  {
    double result1 = 0.0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string rounddown = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) rounddown))
      return rounddown;
    switch (length)
    {
      case 1:
        bool result2;
        argList = bool.TryParse(this.GetValueFromArg(argList), out result2) ? Convert.ToInt16(result2).ToString() : argList;
        if (double.TryParse(this.GetValueFromArg(argList.Replace(this.TIC, string.Empty)), NumberStyles.Any, (IFormatProvider) null, out result1))
          return this.ComputeRound($"{result1 - 0.4999999999 * (double) Math.Sign(result1)}");
        goto case 2;
      case 2:
        string valueFromArg1 = this.GetValueFromArg(strArray[0]);
        string valueFromArg2 = this.GetValueFromArg(strArray[1]);
        bool result3;
        string str1 = bool.TryParse(valueFromArg1, out result3) ? Convert.ToInt16(result3).ToString() : valueFromArg1;
        bool result4;
        string str2 = bool.TryParse(valueFromArg2, out result4) ? Convert.ToInt16(result4).ToString() : valueFromArg2;
        double result5 = 0.0;
        double.TryParse(str1.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1);
        double.TryParse(str2.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result5);
        if (result1.Equals(double.NaN))
          return "#VALUE!";
        result1 -= 0.4999999999 * Math.Pow(10.0, -result5) * (double) Math.Sign(result1);
        return this.ComputeRound($"{result1}{CalcEngine.ParseArgumentSeparator}{result5}");
      default:
        return this.FormulaErrorStrings[this.invalid_arguments];
    }
  }

  public string ComputeRoundup(string argList)
  {
    double result1 = 0.0;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string roundup = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) roundup))
      return roundup;
    switch (length)
    {
      case 1:
        bool result2;
        argList = bool.TryParse(this.GetValueFromArg(argList), out result2) ? Convert.ToInt16(result2).ToString() : argList;
        double.TryParse(this.GetValueFromArg(argList), NumberStyles.Any, (IFormatProvider) null, out result1);
        if (result1 > 0.0)
          result1 += 0.4999999999;
        else if (result1 < 0.0)
          result1 -= 0.4999999999;
        return $"{Math.Round(result1, 0, MidpointRounding.AwayFromZero)}";
      case 2:
        double result3 = 0.0;
        string valueFromArg1 = this.GetValueFromArg(strArray[0]);
        string valueFromArg2 = this.GetValueFromArg(strArray[1]);
        bool result4;
        string str1 = bool.TryParse(valueFromArg1, out result4) ? Convert.ToInt16(result4).ToString() : valueFromArg1;
        bool result5;
        string str2 = bool.TryParse(valueFromArg2, out result5) ? Convert.ToInt16(result5).ToString() : valueFromArg2;
        double.TryParse(str1.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1);
        double.TryParse(str2.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result3);
        double num1 = Math.Ceiling(result3);
        double num2;
        if (num1 >= 0.0)
        {
          if (result1 > 0.0)
            result1 += 0.4999999999 / Math.Pow(10.0, num1);
          else if (result1 < 0.0)
            result1 -= 0.4999999999 / Math.Pow(10.0, num1);
          num2 = Math.Round(result1, (int) num1, MidpointRounding.AwayFromZero);
        }
        else
        {
          if (result1 > 0.0)
            result1 = result1 / Math.Pow(10.0, -num1) + 0.49999;
          else if (result1 < 0.0)
            result1 = result1 / Math.Pow(10.0, -num1) - 0.49999;
          num2 = Math.Round(result1, 0, MidpointRounding.AwayFromZero) * Math.Pow(10.0, -num1);
        }
        return $"{num2}";
      default:
        return this.FormulaErrorStrings[this.invalid_arguments];
    }
  }

  public string ComputeRows(string arg)
  {
    string scopedRange = string.Empty;
    if (!this.IsCellReference(arg) && !this.TryGetNamedRange(arg, out scopedRange) && !arg.Contains(";"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    if (this.SplitArgsPreservingQuotedCommas(arg).Length != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    int num1 = 1;
    if (arg.IndexOf(':') > -1)
    {
      string[] cellsFromArgs = this.GetCellsFromArgs(arg);
      int num2 = this.RowIndex(cellsFromArgs[0].ToString());
      int num3 = this.RowIndex(cellsFromArgs[cellsFromArgs.Length - 1].ToString()) - num2 + 1;
      num1 = num3 > 0 ? num3 : 1;
    }
    else if (arg.IndexOf(';') > -1)
    {
      string[] strArray = this.SplitArguments(arg.Replace(this.TIC, ""), ';');
      for (int index = 1; index < strArray.Length; ++index)
      {
        if (this.SplitArgsPreservingQuotedCommas(strArray[index - 1]).Length != this.SplitArgsPreservingQuotedCommas(strArray[1]).Length)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
          return this.FormulaErrorStrings[this.wrong_number_arguments];
        }
        num1 = strArray.Length;
      }
    }
    return num1.ToString();
  }

  public string ComputeSecant(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string secant = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) secant))
      return secant;
    bool result;
    argList = bool.TryParse(this.GetValueFromArg(argList), out result) ? Convert.ToInt16(result).ToString() : argList;
    if (this.ComputeIsNumber(argList) == this.TRUEVALUESTR)
    {
      string str = argList;
      if (Convert.ToDouble(str.Contains("u") ? str.Replace("u", string.Empty) : str) >= 134217728.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    string math = this.ComputeMath(argList, new CalcEngine.MathFunc(Math.Cos));
    if (math != "#NUM!" || math != "#VALUE!")
      math = (1.0 / Convert.ToDouble(math)).ToString();
    return math;
  }

  public string ComputeSecanth(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string secanth = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) secanth))
      return secanth;
    bool result;
    argList = bool.TryParse(this.GetValueFromArg(argList), out result) ? Convert.ToInt16(result).ToString() : argList;
    if (this.ComputeIsNumber(argList) == this.TRUEVALUESTR)
    {
      string str = argList;
      if (Convert.ToDouble(str.Contains("u") ? str.Replace("u", string.Empty) : str) >= 134217728.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
    }
    argList = argList.Contains("-") ? argList.Replace("-", string.Empty) : argList;
    string math = this.ComputeMath(argList, new CalcEngine.MathFunc(Math.Cosh));
    if (math != "#NUM!" || math != "#VALUE!")
      math = (1.0 / Convert.ToDouble(math)).ToString();
    return math;
  }

  public string ComputeSheet(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    string empty = string.Empty;
    if (length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string upper = strArray[0].Replace(this.TIC, "").ToUpper();
    string sheet = string.IsNullOrEmpty(upper) ? this.cell : upper;
    if (string.IsNullOrEmpty(sheet))
      return "1";
    if (this.ErrorStrings.Contains((object) sheet))
      return sheet;
    string scopedRange = string.Empty;
    if (!this.IsCellReference(sheet) && !this.TryGetNamedRange(sheet, out scopedRange) && !this.SortedSheetNames.Contains((object) sheet))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.cannot_parse]);
      return this.ErrorStrings[0].ToString();
    }
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    string tokenFromReference = this.GetSheetTokenFromReference(sheet);
    int num = 0;
    if (string.IsNullOrEmpty(tokenFromReference) && !this.SortedSheetNames.Contains((object) sheet) && !sheet.Contains('!'.ToString()))
      num = this.GetSheetID(this.grid) + 1;
    else if (tokenFromReference.Length > 0)
    {
      num = int.Parse(tokenFromReference.Replace('!'.ToString(), string.Empty)) + 1;
    }
    else
    {
      try
      {
        foreach (DictionaryEntry dictionaryEntry in sheetFamilyItem.TokenToParentObject)
        {
          if (sheetFamilyItem.SheetNameToParentObject[(object) sheet].Equals(dictionaryEntry.Value))
          {
            num = this.GetSheetID(dictionaryEntry.Value as ICalcData) + 1;
            break;
          }
        }
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (!this.RethrowLibraryComputationExceptions)
          return this.ErrorStrings[2].ToString();
        throw;
      }
    }
    return num.ToString();
  }

  public string ComputeSheets(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    string empty = string.Empty;
    if (length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string upper = strArray[0].Replace(this.TIC, "").ToUpper();
    if (this.ErrorStrings.Contains((object) upper))
      return upper;
    string scopedRange = string.Empty;
    if (string.IsNullOrEmpty(upper))
      return this.SortedSheetNames.Count.ToString();
    if (!this.IsCellReference(upper))
    {
      if (!this.TryGetNamedRange(upper, out scopedRange))
      {
        if (!this.SortedSheetNames.Contains((object) upper))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.cannot_parse]);
          return this.ErrorStrings[0].ToString();
        }
      }
    }
    int num;
    try
    {
      num = (this.SplitArguments(upper, '!').Length - 1) / 2;
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (!this.RethrowLibraryComputationExceptions)
        return this.ErrorStrings[2].ToString();
      throw;
    }
    return num.ToString();
  }

  public string ComputeSign(string args)
  {
    int num = 0;
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string sign = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) sign))
      return sign;
    bool result1;
    args = bool.TryParse(this.GetValueFromArg(args), out result1) ? Convert.ToInt16(result1).ToString() : args;
    if (args.Length > 0 && !char.IsLetter(args[0]))
    {
      if (args.IndexOfAny(new char[2]
      {
        CalcEngine.ParseArgumentSeparator,
        ':'
      }) == -1)
      {
        double result2;
        if (double.TryParse(args, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result2))
        {
          num = Math.Sign(result2);
          goto label_38;
        }
        goto label_38;
      }
    }
    if (args.Length > 0 && (args[0] == '\u0092' || args[0] == 'u' || args[0] == 'n' || args.IndexOfAny(this.tokens) > -1))
    {
      args = args.Replace('{', '(');
      args = args.Replace('}', ')');
      string s;
      try
      {
        s = this.ComputedValue(args);
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return ex.Message;
      }
      double result3;
      if (!double.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result3))
        return this.FormulaErrorStrings[this.invalid_Math_argument];
      num = Math.Sign(result3);
    }
    else
    {
      foreach (string cellsFromArg in this.GetCellsFromArgs(args))
      {
        string valueFromArg;
        try
        {
          valueFromArg = this.GetValueFromArg(cellsFromArg);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        if (valueFromArg.Length > 0)
        {
          double result4;
          if (double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result4))
          {
            num = Math.Sign(result4);
            break;
          }
          if (!valueFromArg.StartsWith(this.TIC) && !this.IsCellReference(valueFromArg))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[5].ToString();
          }
          if (valueFromArg.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
        }
      }
    }
label_38:
    return num.ToString();
  }

  public string ComputeSin(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string sin = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) sin))
      return sin;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Sin)).ToString();
  }

  public string ComputeSinh(string args)
  {
    if (this.SplitArgsPreservingQuotedCommas(args).Length > 1 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string sinh = this.FormulaErrorStringCheck(args, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) sinh))
      return sinh;
    bool result;
    args = bool.TryParse(this.GetValueFromArg(args), out result) ? Convert.ToInt16(result).ToString() : args;
    return this.ComputeMath(args, new CalcEngine.MathFunc(Math.Sinh)).ToString();
  }

  internal string[] ComputeSumArray(string range)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(range);
    string str1 = string.Empty;
    string str2 = string.Empty;
    string str3 = string.Empty;
    string empty = string.Empty;
    foreach (string str4 in strArray1)
    {
      string str5 = str4.Replace('\u0092'.ToString(), string.Empty);
      int num1 = Array.IndexOf<string>(this.FormulaErrorStrings, str5.Replace(this.TIC, string.Empty));
      if (str5.IndexOfAny(this.tokens) > -1 && num1 == -1)
      {
        int num2;
        for (int index1 = 0; index1 < str5.Length - 1; index1 = num2 + 1)
        {
          string str6 = string.Empty;
          if (index1 != str5.Length && str5[index1] == '"')
          {
            string str7 = str6;
            string str8 = str5;
            int index2 = index1;
            int index3 = index2 + 1;
            // ISSUE: variable of a boxed type
            __Boxed<char> local1 = (System.ValueType) str8[index2];
            string str9 = str7 + (object) local1;
            while (index3 != range.Length && str5[index3] != '"')
              str9 += (string) (object) str5[index3++];
            string str10 = str9;
            string str11 = str5;
            int index4 = index3;
            index1 = index4 + 1;
            // ISSUE: variable of a boxed type
            __Boxed<char> local2 = (System.ValueType) str11[index4];
            str6 = str10 + (object) local2;
            str1 = $"{str1}{str6};";
          }
          while (index1 != str5.Length && (this.IsUpper(str5[index1]) | char.IsDigit(str5[index1]) | str5[index1] == 'n' || (int) str5[index1] == (int) CalcEngine.parseDecimalSeparator || str5[index1] == 'm'))
            empty += (string) (object) str5[index1++];
          foreach (char logicalOperator in this.logicalOperators)
          {
            if (index1 != str5.Length && (int) str5[index1] == (int) logicalOperator)
            {
              empty += (string) (object) str5[index1++];
              break;
            }
          }
          if (!str6.Equals(string.Empty) && !empty.Equals(string.Empty) || index1 == str5.Length)
          {
            num2 = index1 - 1;
            string str12 = string.Empty;
            string[] strArray2 = str1.Split(';');
            string[] strArray3 = strArray2[0].Replace(this.TIC, string.Empty).Split(',');
            if (strArray2.Length > 2)
            {
              string[] strArray4 = strArray2[1].Replace(this.TIC, string.Empty).Split(',');
              for (int index5 = 0; index5 <= strArray3.Length - 1; ++index5)
                str12 = $"{str12}{this.GetValueFromArg('\u0092'.ToString() + str2 + (object) 'n' + strArray3[index5] + (object) 'n' + strArray4[index5] + empty + '\u0092'.ToString())},";
              str1 = str12.Substring(0, str12.Length - 1) + ";";
              str2 = empty = string.Empty;
            }
            else if (strArray2.Length > 1)
            {
              for (int index6 = 0; index6 <= strArray3.Length - 1; ++index6)
                str12 = $"{str12}{this.GetValueFromArg('\u0092'.ToString() + str2 + (object) 'n' + strArray3[index6] + empty + '\u0092'.ToString())},";
              str1 = str12.Substring(0, str12.Length - 1) + ";";
              str2 = empty = string.Empty;
            }
          }
          else
          {
            num2 = index1 - 1;
            str2 += empty;
            empty = string.Empty;
          }
        }
        str3 = str3 + str1.Replace(";", string.Empty) + (object) ',';
      }
      else if (num1 == -1 && !string.IsNullOrEmpty(str5.Replace(this.TIC, string.Empty)))
        str3 = str3 + str4.Replace(this.TIC, string.Empty).Replace(";", ",") + (object) ',';
    }
    return str3.Split(',');
  }

  public string ComputeSum(string range)
  {
    double num = 0.0;
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray1;
    if (range.Contains(this.TIC))
    {
      string[] strArray2 = range.Split(new string[1]
      {
        this.TIC
      }, StringSplitOptions.RemoveEmptyEntries);
      for (int index = 0; index < strArray2.Length; ++index)
      {
        if (char.IsLetter(strArray2[index][0]) && char.IsLetter(strArray2[index][strArray2[index].Length - 1]))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
      }
      if (range.IndexOfAny(this.tokens) > -1)
        strArray1 = this.ComputeSumArray(range);
      else
        strArray1 = range.Replace('\u0092'.ToString(), string.Empty).Replace(";", ",").Split(new string[2]
        {
          this.TIC,
          CalcEngine.parseArgumentSeparator.ToString()
        }, StringSplitOptions.RemoveEmptyEntries);
    }
    else
      strArray1 = this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    foreach (string str in strArray1)
    {
      string args = str;
      double result1;
      if (args.IndexOf(':') > -1)
      {
        if (this.IsRange(str))
        {
          if (str.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
          foreach (string cellsFromArg in this.GetCellsFromArgs(args))
          {
            string valueFromArg;
            try
            {
              valueFromArg = this.GetValueFromArg(cellsFromArg);
              if (this.ErrorStrings.Contains((object) valueFromArg))
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                return valueFromArg;
              }
            }
            catch (Exception ex)
            {
              this.ExceptionThrown = true;
              if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                throw this.LibraryComputationException;
              return ex.Message;
            }
            if (valueFromArg != string.Empty && double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
              num += result1;
          }
          continue;
        }
      }
      string s;
      try
      {
        string valueFromArg = this.GetValueFromArg(args);
        if (this.ErrorStrings.Contains((object) valueFromArg))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return valueFromArg;
        }
        bool result2;
        s = !bool.TryParse(valueFromArg, out result2) || this.IsCellReference(str) ? valueFromArg : Convert.ToInt16(result2).ToString();
        if (this.ExcelLikeComputations)
        {
          if (this.useDatesInCalcs)
          {
            if (!double.TryParse(s.Replace(this.TIC, string.Empty), out double _))
            {
              DateTime dt;
              if (this.TryParseExactDateTime(str.Replace(this.TIC, string.Empty), out dt))
                s = (this.GetSerialDateTimeFromDate(dt) - this.GetSerialDateTimeFromDate(DateTime.Today)).ToString();
              else if (this.IsDate((object) str.Replace(this.TIC, string.Empty), out dt))
                s = this.GetSerialDateTimeFromDate(dt).ToString();
            }
          }
        }
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return this.ErrorStrings[5].ToString();
      }
      if (s.Length > 0 && (this.IsCellReference(args) && double.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1) && !double.IsNaN(result1) || !this.IsCellReference(args) && double.TryParse(s.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1) && !double.IsNaN(result1)))
        num += result1;
    }
    return num.ToString();
  }

  public string ComputeSumIFS(string argList) => this.CalculateIFSFormula(argList, "SUMIFS");

  private string CalculateIFSFormula(string argList, string condition)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length1 = strArray.GetLength(0);
    List<string> stringList1 = new List<string>();
    List<string> stringList2 = new List<string>();
    List<string> stringList3 = new List<string>();
    int index1;
    for (int index2 = 1; index2 < length1; index2 = index1 + 1)
    {
      stringList1.Add(strArray[index2]);
      index1 = index2 + 1;
      stringList2.Add(strArray[index1]);
    }
    if (length1 < 3 && stringList1.Count == stringList2.Count)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string args = strArray[0];
    double num1 = 0.0;
    double num2 = double.MinValue;
    double num3 = double.MaxValue;
    string empty = string.Empty;
    this.GetCellsFromArgs(strArray[0]);
    string[] cellsFromArgs1 = this.GetCellsFromArgs(args);
    for (int index3 = 0; index3 < stringList2.Count; ++index3)
    {
      char op = 'e';
      string valueFromArg = stringList2[index3];
      if ((int) valueFromArg[0] != (int) this.TIC[0] && "=><".IndexOf(valueFromArg[0]) == -1)
        valueFromArg = this.GetValueFromArg(valueFromArg);
      string criteria = this.findCriteria(valueFromArg, ref op);
      string[] cellsFromArgs2 = this.GetCellsFromArgs(stringList1[index3]);
      if (cellsFromArgs2[0] != null && cellsFromArgs2[0].Equals(this.ErrorStrings[5]) || cellsFromArgs1[0] != null && cellsFromArgs1[0].Equals(this.ErrorStrings[5]))
        return this.ErrorStrings[5].ToString();
      if (cellsFromArgs2.GetLength(0) != cellsFromArgs1.GetLength(0))
        return this.ErrorStrings[1].ToString();
      int length2 = cellsFromArgs2.GetLength(0);
      if (length2 > cellsFromArgs1.GetLength(0))
      {
        int length3 = args.IndexOf(':');
        if (length3 > -1)
        {
          int num4 = this.RowIndex(args.Substring(0, length3));
          int num5 = this.RowIndex(args.Substring(length3 + 1));
          if (!(!num4.Equals(-1) || num5.Equals(-1)).Equals(num4.Equals(-1) || !num5.Equals(-1)))
            return this.ErrorStrings[5].ToString();
          int num6 = this.ColIndex(args.Substring(0, length3));
          int col = this.ColIndex(args.Substring(length3 + 1));
          if (this.grid is ISheetData)
          {
            if (num4 == -1)
              num4 = ((ISheetData) this.grid).GetFirstRow();
            if (num6 == -1)
              num6 = ((ISheetData) this.grid).GetFirstColumn();
            if (num5 == -1)
              num5 = ((ISheetData) this.grid).GetLastRow();
            if (col == -1)
              col = ((ISheetData) this.grid).GetLastColumn();
          }
          if (num4 != num5)
            num5 += length2 - cellsFromArgs1.GetLength(0);
          else if (num6 != col)
            col += length2 - cellsFromArgs1.GetLength(0);
          args = args.Substring(0, length3 + 1) + RangeInfo.GetAlphaLabel(col) + num5.ToString();
          cellsFromArgs1 = this.GetCellsFromArgs(args);
        }
      }
      List<string> stringList4 = new List<string>();
      criteria.IndexOf("*");
      double result = double.MinValue;
      bool isNumber = double.TryParse(criteria, out result);
      for (int index4 = 0; index4 < length2; ++index4)
      {
        if (this.CheckForCriteriaMatch(this.GetValueFromArg(cellsFromArgs2[index4]).ToUpper(), op, criteria.ToUpper(), isNumber, result))
        {
          if (stringList3.Count > 0 && index3 != 0)
          {
            int count = stringList3.Count;
            for (int index5 = 0; index5 < count; ++index5)
            {
              if (stringList3[index5] != null && this.RowIndex(stringList3[index5].ToString()).Equals(this.RowIndex(cellsFromArgs2[index4])))
                stringList4.Add(cellsFromArgs1[index4]);
            }
          }
          else if (cellsFromArgs1[index4] != null)
            stringList4.Add(cellsFromArgs1[index4]);
        }
      }
      if (stringList4.Count == 0)
      {
        stringList3.Clear();
        break;
      }
      stringList3 = stringList4;
    }
    switch (condition)
    {
      case "SUMIFS":
        for (int index6 = 0; index6 < stringList3.Count; ++index6)
        {
          double result;
          double.TryParse(this.GetValueFromArg(stringList3[index6]), out result);
          num1 += result;
        }
        break;
      case "MAXIFS":
        for (int index7 = 0; index7 < stringList3.Count; ++index7)
        {
          double result;
          double.TryParse(this.GetValueFromArg(stringList3[index7]), out result);
          if (result > num2)
            num2 = result;
        }
        break;
      case "MINIFS":
        for (int index8 = 0; index8 < stringList3.Count; ++index8)
        {
          double result;
          double.TryParse(this.GetValueFromArg(stringList3[index8]), out result);
          if (result < num3)
            num3 = result;
        }
        break;
    }
    if (condition == "SUMIFS")
      empty = num1.ToString();
    if (condition == "MAXIFS")
      empty = num2.ToString();
    if (condition == "MINIFS")
      empty = num3.ToString();
    return empty;
  }

  public string ComputeSumsq(string range)
  {
    double num = 0.0;
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double result1;
    foreach (string args in strArray)
    {
      if (args.IndexOf(':') > -1)
      {
        if (args.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        foreach (string cellsFromArg in this.GetCellsFromArgs(args))
        {
          string valueFromArg;
          try
          {
            valueFromArg = this.GetValueFromArg(cellsFromArg);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
          if (valueFromArg.Length > 0 && double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
            num += result1 * result1;
        }
      }
      else
      {
        string str;
        try
        {
          string valueFromArg = this.GetValueFromArg(args);
          if (this.ErrorStrings.Contains((object) valueFromArg))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return valueFromArg;
          }
          bool result2;
          str = bool.TryParse(valueFromArg, out result2) ? Convert.ToInt16(result2).ToString() : valueFromArg;
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        if (str.Length > 0)
        {
          if (double.TryParse(str.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
            num += result1 * result1;
          else if (str.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
        }
      }
    }
    return num.ToString();
  }

  public string ComputeSumx2my2(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string sumx2my2 = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) sumx2my2))
      return sumx2my2;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    string range1 = strArray[0];
    string range2 = strArray[1];
    double[] doubleArray1 = this.GetDoubleArray(range1);
    double[] doubleArray2 = this.GetDoubleArray(range2);
    int length = doubleArray1.GetLength(0);
    if (length != doubleArray2.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num2 = doubleArray1[index];
      double num3 = doubleArray2[index];
      if (!num2.Equals(double.NaN) && !num3.Equals(double.NaN))
        num1 += num2 * num2 - num3 * num3;
    }
    return num1.ToString();
  }

  public string ComputeSumx2py2(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string sumx2py2 = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) sumx2py2))
      return sumx2py2;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    string range1 = strArray[0];
    string range2 = strArray[1];
    double[] doubleArray1 = this.GetDoubleArray(range1);
    double[] doubleArray2 = this.GetDoubleArray(range2);
    int length = doubleArray1.GetLength(0);
    if (length != doubleArray2.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num2 = doubleArray1[index];
      double num3 = doubleArray2[index];
      if (!num2.Equals(double.NaN) && !num3.Equals(double.NaN))
        num1 += num2 * num2 + num3 * num3;
    }
    return num1.ToString();
  }

  public string ComputeSumxmy2(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.requires_2_args];
    }
    string sumxmy2 = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) sumxmy2))
      return sumxmy2;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    string range1 = strArray[0];
    string range2 = strArray[1];
    double[] doubleArray1 = this.GetDoubleArray(range1);
    double[] doubleArray2 = this.GetDoubleArray(range2);
    int length = doubleArray1.GetLength(0);
    if (length != doubleArray2.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num2 = doubleArray1[index];
      double num3 = doubleArray2[index];
      if (!num2.Equals(double.NaN) && !num3.Equals(double.NaN))
        num1 += Math.Pow(num2 - num3, 2.0);
    }
    return num1.ToString();
  }

  public string ComputeTranspose(string arg)
  {
    string transpose1 = this.FormulaErrorStringCheck(arg, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) transpose1))
      return transpose1;
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray1.Length != 1 || string.IsNullOrEmpty(arg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (strArray1.Length == 1 && !this.IsCellReference(arg))
      return this.SplitArgsPreservingQuotedCommas(this.StripTics0(strArray1[0]))[0];
    string empty = string.Empty;
    string transpose2;
    if (arg.IndexOf(';') > -1)
    {
      string[] strArray2 = this.SplitArguments(arg.Replace(this.TIC, ""), ';');
      for (int index = 1; index < strArray2.Length; ++index)
      {
        if (this.SplitArgsPreservingQuotedCommas(strArray2[index - 1]).Length != this.SplitArgsPreservingQuotedCommas(strArray2[1]).Length)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
          return this.FormulaErrorStrings[this.wrong_number_arguments];
        }
      }
      transpose2 = this.SplitArgsPreservingQuotedCommas(strArray2[0])[0];
    }
    else
    {
      string[] cellsFromArgs = this.GetCellsFromArgs(arg);
      int num1 = this.RowIndex(cellsFromArgs[0].ToString());
      int num2 = this.RowIndex(cellsFromArgs[cellsFromArgs.Length - 1].ToString());
      int num3 = this.ColIndex(cellsFromArgs[0].ToString());
      int num4 = this.ColIndex(cellsFromArgs[cellsFromArgs.Length - 1].ToString());
      string cell = this.cell;
      int num5 = this.ColIndex(cell);
      int num6 = this.RowIndex(cell);
      int firstRowIndex;
      int firstColIndex;
      this.GetFormulaArrayBounds(this.cell, num2 - num1 + 1, num4 - num3 + 1, out firstRowIndex, out firstColIndex, out int _, out int _);
      int num7 = num6 - firstRowIndex;
      int num8 = num5 - firstColIndex;
      int length = arg.IndexOf(":");
      if (length == -1)
      {
        arg = $"{arg}:{arg}";
        length = arg.IndexOf(":");
      }
      int num9 = arg.Substring(0, length).LastIndexOf('!');
      ICalcData grid = this.grid;
      GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
      if (num9 > -1)
        this.grid = (ICalcData) sheetFamilyItem.TokenToParentObject[(object) arg.Substring(0, num9 + 1)];
      transpose2 = this.GetValueComputeFormulaIfNecessary(num1 + num8, num3 + num7, this.grid);
      this.grid = grid;
    }
    if (string.IsNullOrEmpty(transpose2))
      transpose2 = "0";
    return transpose2;
  }

  public string ComputeTruncate(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (argList.Length > 15)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    string empty = string.Empty;
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    double result1;
    if (double.TryParse(valueFromArg, out result1))
    {
      empty = result1.ToString();
    }
    else
    {
      Decimal result2;
      if (Decimal.TryParse(valueFromArg, out result2))
        empty = result2.ToString();
    }
    return empty.ToString();
  }

  public string ComputeRandbetween(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    string randbetween = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) randbetween))
      return randbetween;
    string str1 = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    string str2 = this.GetValueFromArg(strArray[1]).Replace(this.TIC, string.Empty);
    double result1;
    double result2;
    if (!double.TryParse(str1, NumberStyles.Any, (IFormatProvider) null, out result1) || !double.TryParse(str2, NumberStyles.Any, (IFormatProvider) null, out result2))
      return this.ErrorStrings[1].ToString();
    string round1 = this.ComputeRound(str1);
    string round2 = this.ComputeRound(str2);
    if (!double.TryParse(str1, NumberStyles.Any, (IFormatProvider) null, out result1) || !double.TryParse(str2, NumberStyles.Any, (IFormatProvider) null, out result2))
      return "#NAME?";
    if (result1 > result2)
      return this.ErrorStrings[4].ToString();
    if (this.rand == null)
      this.rand = new Random();
    return this.rand.Next(int.Parse(round1), int.Parse(round2)).ToString();
  }

  public string ComputeSeriessum(string arg)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray1.Length != 4 || string.IsNullOrEmpty(arg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    for (int index = 0; index <= 2; ++index)
    {
      string seriessum = this.FormulaErrorStringCheck(strArray1[index], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) seriessum))
        return seriessum;
    }
    string seriessum1 = this.FormulaErrorStringCheck(strArray1[3], CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) seriessum1))
      return seriessum1;
    double result1 = 0.0;
    double result2 = 0.0;
    double result3 = 0.0;
    double result4 = 0.0;
    double num = 0.0;
    string[] strArray2 = strArray1[3].IndexOf(';') <= -1 ? this.GetCellsFromArgs(strArray1[3].Replace(this.TIC, "")) : this.SplitArguments(strArray1[3].Replace(this.TIC, ""), ';');
    double.TryParse(this.GetValueFromArg(strArray1[0].Replace(this.TIC, "")), out result1);
    double.TryParse(this.GetValueFromArg(strArray1[1].Replace(this.TIC, "")), out result2);
    double.TryParse(this.GetValueFromArg(strArray1[2].Replace(this.TIC, "")), out result3);
    for (int index = 0; index < strArray2.Length; ++index)
    {
      if (double.TryParse(this.GetValueFromArg(strArray2[index].Replace(this.TIC, "")), out result4))
      {
        num += result4 * Math.Pow(result1, result2 + (double) index * result3);
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[1].ToString();
      }
    }
    return num.ToString();
  }

  internal double[] GetDoubleArray(string range)
  {
    string args = string.Empty;
    ArrayList arrayList = new ArrayList();
    this.AdjustRangeArg(ref range);
    double result1;
    foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(range.Replace(this.TIC, string.Empty)))
    {
      if (preservingQuotedComma.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma))
        {
          try
          {
            args = this.GetValueFromArg(cellsFromArg);
            bool result2;
            args = bool.TryParse(args, out result2) ? Convert.ToInt16(result2).ToString() : args;
          }
          catch
          {
          }
          if (args.Length > 0)
          {
            if (double.TryParse(args.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
              arrayList.Add((object) result1);
            else if (this.ComputeIsText(cellsFromArg) == this.TRUEVALUESTR)
              arrayList.Add((object) double.NaN);
            else
              arrayList.Add((object) 0.0);
          }
          else
            arrayList.Add((object) double.NaN);
        }
      }
      else
      {
        try
        {
          args = this.GetValueFromArg(preservingQuotedComma);
          bool result3;
          args = bool.TryParse(args, out result3) ? Convert.ToInt16(result3).ToString() : args;
        }
        catch
        {
        }
        if (args.Length > 0)
        {
          if (double.TryParse(args.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
            arrayList.Add((object) result1);
          else if (this.ComputeIsText(args) == this.TRUEVALUESTR)
            arrayList.Add((object) double.NaN);
          else
            arrayList.Add((object) 0.0);
        }
        else
          arrayList.Add((object) double.NaN);
      }
    }
    return (double[]) arrayList.ToArray(typeof (double));
  }

  private double Covariance(double[] array1, double[] array2)
  {
    if (array1.Length != array2.Length)
      throw new ArgumentException("Arrays must be the same length");
    int length = array1.Length;
    if (length == 1)
      return double.NaN;
    double num1 = this.Mean(array1);
    double num2 = this.Mean(array2);
    double num3 = 0.0;
    for (int index = 0; index < length; ++index)
      num3 += (array1[index] - num1) * (array2[index] - num2);
    return num3 / (double) (length - 1);
  }

  public double Mean(double[] array) => CalcEngine.Mean(array, 1.0);

  public static double Mean(double[] array, double decayFactor)
  {
    int length = array.Length;
    double num1 = 0.0;
    double num2 = 1.0;
    for (int index = 0; index < length; ++index)
    {
      num1 += num2 * array[length - 1 - index];
      num2 *= decayFactor;
    }
    return num1 * CalcEngine.InverseSumOfGeometricSeries(decayFactor, length);
  }

  public static double InverseSumOfGeometricSeries(double decayFactor, int length)
  {
    if (length < 1)
      return double.NaN;
    return decayFactor == 1.0 ? 1.0 / (double) length : (1.0 - decayFactor) / (1.0 - Math.Pow(decayFactor, (double) length));
  }

  private double GammaLn(double x)
  {
    if (x <= 0.0)
      return 0.0;
    double d1 = x;
    double num1 = 0.0;
    if (d1 <= 7.0)
    {
      double d2 = d1;
      for (++d1; d1 <= 7.0; ++d1)
        d2 *= d1;
      num1 = -Math.Log(d2);
    }
    double num2 = 1.0 / (d1 * d1);
    return num1 + (d1 - 0.5) * Math.Log(d1) - d1 + CalcEngine.gammaAs[0] + (((-CalcEngine.gammaAs[1] * num2 + CalcEngine.gammaAs[2]) * num2 - CalcEngine.gammaAs[3]) * num2 + CalcEngine.gammaAs[4]) / d1;
  }

  public string ComputeAvedev(string range)
  {
    double num1 = 0.0;
    ArrayList arrayList = new ArrayList();
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    double result1;
    foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(range))
    {
      if (preservingQuotedComma.IndexOf(':') > -1)
      {
        if (preservingQuotedComma.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma))
        {
          string valueFromArg;
          try
          {
            valueFromArg = this.GetValueFromArg(cellsFromArg);
            bool result2;
            if (bool.TryParse(valueFromArg, out result2))
              valueFromArg = Convert.ToInt32(result2).ToString();
            if (this.ErrorStrings.Contains((object) valueFromArg))
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return valueFromArg;
            }
          }
          catch
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return this.ErrorStrings[4].ToString();
          }
          if (double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1))
          {
            num1 += result1;
            arrayList.Add((object) result1);
          }
          else
          {
            if (this.ErrorStrings.Contains((object) valueFromArg))
              return valueFromArg;
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.ErrorStrings[5].ToString());
            return this.ErrorStrings[5].ToString();
          }
        }
      }
      else
      {
        string valueFromArg;
        try
        {
          valueFromArg = this.GetValueFromArg(preservingQuotedComma);
          bool result3;
          if (bool.TryParse(valueFromArg, out result3))
            valueFromArg = Convert.ToInt32(result3).ToString();
          string avedev = this.FormulaErrorStringCheck(valueFromArg, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) avedev))
            return avedev;
        }
        catch
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return this.ErrorStrings[4].ToString();
        }
        if (double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1))
        {
          num1 += result1;
          arrayList.Add((object) result1);
        }
        else
        {
          if (this.ErrorStrings.Contains((object) valueFromArg))
            return valueFromArg;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[5].ToString());
          return this.ErrorStrings[1].ToString();
        }
      }
    }
    if (arrayList.Count > 0)
    {
      double num2 = num1 / (double) arrayList.Count;
      double num3 = 0.0;
      for (int index = 0; index < arrayList.Count; ++index)
        num3 += Math.Abs((double) arrayList[index] - num2);
      num1 = num3 / (double) arrayList.Count;
    }
    return num1.ToString();
  }

  public string ComputeAveragea(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray1.Length < 1 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    string args = string.Empty;
    double num1 = 0.0;
    int num2 = 0;
    double result1 = 0.0;
    for (int index1 = 0; index1 < strArray1.Length; ++index1)
    {
      if (strArray1[index1].Contains(CalcEngine.ParseArgumentSeparator.ToString()))
      {
        string[] strArray2 = this.SplitArgsPreservingQuotedCommas(strArray1[index1].Replace(this.TIC, string.Empty));
        int index2 = 0;
        foreach (string str in strArray2)
        {
          args = args + str + (object) CalcEngine.ParseArgumentSeparator;
          strArray1[index2] = str;
        }
      }
      else
        args = !strArray1[index1].Equals(string.Empty) ? (!this.IsCellReference(strArray1[index1]) ? args + strArray1[index1] + (object) CalcEngine.ParseArgumentSeparator : args + strArray1[index1] + (object) CalcEngine.ParseArgumentSeparator) : $"{args}0{(object) CalcEngine.ParseArgumentSeparator}";
    }
    if (args.EndsWith(CalcEngine.ParseArgumentSeparator.ToString()))
      args = args.Substring(0, args.Length - 1);
    double result2;
    foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(args))
    {
      if (preservingQuotedComma.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma))
        {
          string valueFromArg = this.GetValueFromArg(cellsFromArg);
          bool result3;
          string s1 = bool.TryParse(valueFromArg, out result3) ? Convert.ToInt16(result3).ToString() : valueFromArg;
          string s2 = double.TryParse(s1, out result2) || !this.TreatStringsAsZero ? s1 : "0";
          if (this.ErrorStrings.Contains((object) s2))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return s2;
          }
          if (s2.Length > 0 && double.TryParse(s2, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
          {
            num1 += result1;
            ++num2;
          }
        }
      }
      else
      {
        string averagea = this.GetValueFromArg(preservingQuotedComma);
        if (this.ErrorStrings.Contains((object) averagea))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return averagea;
        }
        if (strArray1.Length == 1 && this.IsCellReference(preservingQuotedComma) && string.IsNullOrEmpty(averagea))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[3].ToString();
        }
        if (string.IsNullOrEmpty(preservingQuotedComma) && this.TreatStringsAsZero)
          averagea = "0";
        bool result4;
        string s = bool.TryParse(averagea, out result4) ? Convert.ToInt16(result4).ToString() : averagea;
        string str = double.TryParse(s, out result2) || !this.IsCellReference(preservingQuotedComma) || !this.TreatStringsAsZero ? s : "0";
        if (str.Length > 0)
        {
          if (double.TryParse(str.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
          {
            num1 += result1;
            ++num2;
          }
          else if (str.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
        }
      }
    }
    if (num2 > 0)
      num1 /= (double) num2;
    return num1.ToString();
  }

  public string ComputeAverageIFS(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length1 = strArray.GetLength(0);
    double num1 = 0.0;
    List<string> stringList1 = new List<string>();
    List<string> stringList2 = new List<string>();
    List<string> stringList3 = new List<string>();
    List<string> stringList4 = new List<string>();
    int index1;
    for (int index2 = 1; index2 < length1; index2 = index1 + 1)
    {
      stringList1.Add(strArray[index2]);
      index1 = index2 + 1;
      stringList2.Add(strArray[index1]);
    }
    if (length1 < 3 && stringList1.Count == stringList2.Count)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string args = strArray[0];
    double num2 = 0.0;
    this.GetCellsFromArgs(strArray[0]);
    string[] cellsFromArgs1 = this.GetCellsFromArgs(args);
    bool flag = false;
    for (int index3 = 0; index3 < stringList2.Count; ++index3)
    {
      char op = 'e';
      string valueFromArg = stringList2[index3];
      if ((int) valueFromArg[0] != (int) this.TIC[0] && "=><".IndexOf(valueFromArg[0]) == -1)
        valueFromArg = this.GetValueFromArg(valueFromArg);
      if (index3 == stringList1.Count - 1)
        flag = true;
      string criteria = this.findCriteria(valueFromArg, ref op);
      string[] cellsFromArgs2 = this.GetCellsFromArgs(stringList1[index3]);
      if (cellsFromArgs2[0].Equals(this.ErrorStrings[5]) || cellsFromArgs1[0].Equals(this.ErrorStrings[5]))
        return this.ErrorStrings[5].ToString();
      int length2 = cellsFromArgs2.GetLength(0);
      if (length2 > cellsFromArgs1.GetLength(0))
      {
        int length3 = args.IndexOf(':');
        if (length3 > -1)
        {
          int num3 = this.RowIndex(args.Substring(0, length3));
          int num4 = this.RowIndex(args.Substring(length3 + 1));
          if (!(!num3.Equals(-1) || num4.Equals(-1)).Equals(num3.Equals(-1) || !num4.Equals(-1)))
            return this.ErrorStrings[5].ToString();
          if (num3 == -1 && this.grid is ISheetData)
            num3 = ((ISheetData) this.grid).GetFirstRow();
          int num5 = this.ColIndex(args.Substring(0, length3));
          if (num5 == -1 && this.grid is ISheetData)
            num5 = ((ISheetData) this.grid).GetFirstColumn();
          if (num4 == -1 && this.grid is ISheetData)
            num4 = ((ISheetData) this.grid).GetLastRow();
          int col = this.ColIndex(args.Substring(length3 + 1));
          if (col == -1 && this.grid is ISheetData)
            col = ((ISheetData) this.grid).GetLastColumn();
          if (num3 != num4)
            num4 += length2 - cellsFromArgs1.GetLength(0);
          else if (num5 != col)
            col += length2 - cellsFromArgs1.GetLength(0);
          args = args.Substring(0, length3 + 1) + RangeInfo.GetAlphaLabel(col) + num4.ToString();
          cellsFromArgs1 = this.GetCellsFromArgs(args);
        }
      }
      double result1 = 0.0;
      string empty = string.Empty;
      double result2 = double.MinValue;
      bool isNumber = double.TryParse(criteria, out result2);
      for (int index4 = 0; index4 < length2; ++index4)
      {
        if (this.CheckForCriteriaMatch(this.GetValueFromArg(cellsFromArgs2[index4]).ToUpper(), op, criteria.ToUpper(), isNumber, result2))
        {
          if (flag && stringList2.Count == 1)
          {
            ++num1;
            num2 += result1;
          }
          else if (stringList3.Count > 0 && index3 != 0)
          {
            int count = stringList3.Count;
            if (count.Equals(cellsFromArgs2.Length) && this.RowIndex(stringList3[index4].ToString()).Equals(this.RowIndex(cellsFromArgs2[index4])))
            {
              stringList4.Add(cellsFromArgs2[index4]);
              if (flag && cellsFromArgs1[index4] != null && double.TryParse(this.GetValueFromArg(cellsFromArgs1[index4]), NumberStyles.Any, (IFormatProvider) null, out result1) && flag)
              {
                num2 += result1;
                ++num1;
              }
            }
            else
            {
              for (int index5 = 0; index5 < count; ++index5)
              {
                if (stringList3[index5] != null && this.RowIndex(stringList3[index5].ToString()).Equals(this.RowIndex(cellsFromArgs2[index4])))
                {
                  stringList4.Add(cellsFromArgs2[index4]);
                  if (flag && cellsFromArgs1[index4] != null && double.TryParse(this.GetValueFromArg(cellsFromArgs1[index4]), NumberStyles.Any, (IFormatProvider) null, out result1) && flag)
                  {
                    num2 += result1;
                    ++num1;
                  }
                }
              }
            }
          }
          else
            stringList4.Add(cellsFromArgs2[index4]);
        }
      }
      stringList3 = stringList4;
      stringList4 = new List<string>();
    }
    double num6 = num2 / num1;
    if (!(this.ComputeIsErr(num6.ToString()) == this.TRUEVALUESTR))
      return num6.ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  private string findCriteria(string criteria, ref char op)
  {
    int startIndex = criteria.Length <= 0 || (int) criteria[0] != (int) this.TIC[0] ? 0 : 1;
    if (criteria.Substring(startIndex).StartsWith(">="))
    {
      criteria = criteria.Substring(startIndex + 2, criteria.Length - 2 - 2 * startIndex);
      op = 'j';
    }
    else if (criteria.Substring(startIndex).StartsWith("<="))
    {
      criteria = criteria.Substring(startIndex + 2, criteria.Length - 2 - 2 * startIndex);
      op = 'k';
    }
    else if (criteria.Substring(startIndex).StartsWith("<>"))
    {
      criteria = criteria.Substring(startIndex + 2, criteria.Length - 2 - 2 * startIndex);
      op = 'o';
    }
    else if (criteria.Substring(startIndex).StartsWith("<"))
    {
      criteria = criteria.Substring(startIndex + 1, criteria.Length - 1 - 2 * startIndex);
      op = 'l';
    }
    else if (criteria.Substring(startIndex).StartsWith(">"))
    {
      criteria = criteria.Substring(startIndex + 1, criteria.Length - 1 - 2 * startIndex);
      op = 'g';
    }
    else if (criteria.Substring(startIndex).StartsWith("="))
      criteria = criteria.Substring(startIndex + 1, criteria.Length - 1 - 2 * startIndex);
    criteria = criteria.Replace(this.TIC, string.Empty);
    return criteria;
  }

  internal bool CheckForCriteriaMatch(
    string s,
    char op,
    string criteria,
    bool isNumber,
    double compare)
  {
    string str = criteria;
    double result = 0.0;
    s = s.Replace(this.TIC, string.Empty);
    switch (op)
    {
      case 'e':
        if (isNumber)
          return double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result) && result == compare;
        int num1 = str.IndexOf("*");
        if (num1 != -1 && !string.IsNullOrEmpty(s))
        {
          bool flag1 = num1 == 0;
          bool flag2 = str.EndsWith("*");
          string[] strArray1 = criteria.Split('*');
          if (strArray1.Length > 2)
          {
            bool flag3 = false;
            for (int index = 0; index < strArray1.Length; ++index)
            {
              flag3 = index != 0 || flag1 ? s.Contains(strArray1[index]) : s.StartsWith(strArray1[0]);
              if (!flag3)
                return flag3;
            }
            return flag3;
          }
          if (!flag1 && !flag2)
          {
            string[] strArray2 = criteria.Split('*');
            return s.StartsWith(strArray2[0]) && s.EndsWith(strArray2[1]);
          }
          if (flag1 && flag2)
          {
            criteria = criteria.Replace("*", string.Empty);
            return s.Contains(criteria);
          }
          if (flag1)
          {
            criteria = criteria.Replace("*", string.Empty);
            return s.EndsWith(criteria);
          }
          if (flag2)
          {
            criteria = criteria.Replace("*", string.Empty);
            return s.StartsWith(criteria);
          }
        }
        return !string.IsNullOrEmpty(s) && s == criteria;
      case 'g':
        int num2 = string.Compare(s.ToUpper(), criteria.ToUpper());
        return !isNumber ? !string.IsNullOrEmpty(s) && num2 > 0 : double.TryParse(s, out result) && result > compare;
      case 'j':
        int num3 = string.Compare(s.ToUpper(), criteria.ToUpper());
        return !isNumber ? !string.IsNullOrEmpty(s) && num3 >= 0 : double.TryParse(s, out result) && result >= compare;
      case 'k':
        int num4 = string.Compare(s.ToUpper(), criteria.ToUpper());
        return !isNumber ? !string.IsNullOrEmpty(s) && num4 <= 0 : double.TryParse(s, out result) && result <= compare;
      case 'l':
        int num5 = string.Compare(s.ToUpper(), criteria.ToUpper());
        return !isNumber ? !string.IsNullOrEmpty(s) && num5 < 0 : double.TryParse(s, out result) && result < compare;
      case 'o':
        return !isNumber ? !string.IsNullOrEmpty(s) && s.ToUpper() != criteria.ToUpper() : double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result) && result != compare;
      default:
        return false;
    }
  }

  public string ComputeChidist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string chidist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) chidist))
      return chidist;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = this.StripTics(strArray[index]);
    }
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    double result1;
    double result2;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result1 < 0.0 || result2 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (result1 == 0.0)
        return "1";
      if ((result2 != 1.0 || !this.excelLikeComputations) && result2 < 1.0)
        return this.excelLikeComputations ? "#NUM!" : this.FormulaErrorStrings[this.invalid_arguments];
      num = 1.0 - this.chidist(result1, result2);
    }
    return num.ToString();
  }

  public string ComputeGrowth(string range)
  {
    string[] collection;
    if (range.Contains(this.TIC))
    {
      collection = range.Split(new string[1]{ this.TIC }, StringSplitOptions.RemoveEmptyEntries);
      for (int index = 0; index < collection.Length; ++index)
      {
        if (collection[index] == ",")
        {
          List<string> stringList = new List<string>((IEnumerable<string>) collection);
          stringList.Remove(collection[index]);
          collection = stringList.ToArray();
        }
      }
    }
    else
      collection = range.Split(CalcEngine.ParseArgumentSeparator);
    int length1 = collection.GetLength(0);
    foreach (string cellsFromArg in this.GetCellsFromArgs(collection[0]))
    {
      if (!double.TryParse(this.GetValueFromArg(cellsFromArg).Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out double _))
        return this.ErrorStrings[1].ToString();
    }
    if (length1 >= 2)
    {
      foreach (string cellsFromArg in this.GetCellsFromArgs(collection[1]))
      {
        if (!double.TryParse(this.GetValueFromArg(cellsFromArg).Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out double _))
          return this.ErrorStrings[1].ToString();
      }
    }
    bool flag = length1 == 1;
    if (length1 == 0 || length1 > 4)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.ErrorStrings[1].ToString();
    }
    double[] doubleArray = this.GetDoubleArray(collection[0]);
    for (int index = 0; index < doubleArray.GetLength(0); ++index)
    {
      if (doubleArray[index] <= 0.0)
        return this.ErrorStrings[4].ToString();
    }
    double[] x = length1 <= 1 || !(collection[1] == string.Empty) ? (flag ? new double[doubleArray.GetLength(0)] : this.GetDoubleArray(collection[1])) : doubleArray;
    double[] numArray = length1 < 3 ? new double[x.GetLength(0)] : this.GetDoubleArray(collection[2]);
    if (doubleArray.GetLength(0) != x.GetLength(0))
      return this.ErrorStrings[2].ToString();
    int length2 = x.GetLength(0);
    if (length2 <= 2 || length2 != doubleArray.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.ErrorStrings[1].ToString();
    }
    if (flag)
    {
      for (int index = 0; index < length2; ++index)
        x[index] = (double) (index + 1);
    }
    for (int index = 0; index < length2; ++index)
      doubleArray[index] = Math.Log10(doubleArray[index]);
    double m = 0.0;
    double b = 1.0;
    this.ComputeLogestMB(doubleArray, x, out m, out b);
    int length3 = numArray.GetLength(0);
    if (length1 < 3)
    {
      for (int index = 0; index < length3; ++index)
        numArray[index] = x[index];
    }
    for (int index = 0; index < length3; ++index)
    {
      if (length1 > 3 && collection[3].Contains(this.FALSEVALUESTR))
        b = 1.0;
      numArray[index] = b * Math.Pow(m, numArray[index]);
    }
    if (length3 > 1 && length1 > 2)
    {
      string[] cellsFromArgs = this.GetCellsFromArgs(collection[2]);
      foreach (string str in cellsFromArgs)
      {
        if (!double.TryParse(this.GetValueFromArg(str).Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out double _))
          return this.ErrorStrings[1].ToString();
      }
      this.RowIndex(cellsFromArgs[0]);
      this.RowIndex(cellsFromArgs[1]);
      for (int index = 1; index < length3; ++index)
      {
        if (!string.IsNullOrEmpty(this.cell))
          this.grid.SetValueRowCol((object) numArray[index], this.RowIndex(this.cell), this.ColIndex(this.cell));
      }
    }
    return numArray[0].ToString();
  }

  internal void ComputeLogestMB(double[] y, double[] x, out double m, out double b)
  {
    m = 0.0;
    b = 1.0;
    int length = x.GetLength(0);
    double num1 = 0.0;
    double num2 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      num1 += x[index];
      num2 += y[index];
    }
    double num3 = num1 / (double) length;
    double num4 = num2 / (double) length;
    double num5 = 0.0;
    double num6 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num7 = x[index] - num3;
      num5 += num7 * (y[index] - num4);
      num6 += num7 * num7;
    }
    b = Math.Pow(10.0, num4 - num5 / num6 * num3);
    m = Math.Pow(10.0, num5 / num6);
  }

  public string ComputeGammaln(string argList) => this.ComputeGammaln0Precise(argList);

  private double chidist(double x, double v)
  {
    double num1 = v / 2.0;
    double num2 = 1.0 / (Math.Pow(2.0, num1) * Math.Exp(this.GammaLn(num1)));
    double y = num1 - 1.0;
    double num3 = 0.0;
    double num4 = x;
    double num5 = (num3 + num4) / 2.0;
    double num6 = (num4 - num3) / 2.0;
    double num7 = 0.0;
    for (int index = 0; index < CalcEngine.gauss_n; ++index)
    {
      double num8 = CalcEngine.gauss_x[index] * num6;
      num7 += CalcEngine.gauss_w[index] * (Math.Pow(num5 + num8, y) * Math.Exp(-(num5 + num8) / 2.0) + Math.Pow(num5 - num8, y) * Math.Exp(-(num5 - num8) / 2.0));
    }
    return num2 * num7 * num6;
  }

  private double chiinv(double p, double v)
  {
    double x = p;
    double num1 = x / 2.0;
    double num2 = 1E-07;
    int num3 = 100;
    int num4 = 3;
    while (num3 == 100 && num4 > 0)
    {
      --num4;
      x /= 2.0;
      double num5 = x / 2.0;
      for (num3 = 0; num3 < 100; ++num3)
      {
        double num6 = 1.0 - this.chidist(x, v);
        if (Math.Abs((num6 - p) / p) >= num2)
        {
          if (num6 > p)
          {
            x += num5;
          }
          else
          {
            num5 /= 2.0;
            if (x - num5 < 0.0)
              num5 = x / 2.0;
            x -= num5;
          }
        }
        else
          break;
      }
    }
    if (num3 == 100)
      x = -1.0;
    return x;
  }

  public string ComputeLinest(string range)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(range);
    int length1 = strArray1.Length;
    bool padXValues = length1 == 1;
    double m = 0.0;
    double b = 1.0;
    string errorValue = string.Empty;
    if (length1 == 0 || length1 > 4)
    {
      string[] strArray2 = range.Split(this.TIC[0]);
      List<string> stringList = new List<string>();
      for (int index = 0; index < strArray2.Length; ++index)
      {
        if (index % 2 != 0)
          stringList.Add(strArray2[index]);
      }
      strArray1 = stringList.ToArray();
      length1 = strArray1.GetLength(0);
      padXValues = length1 == 1;
      if (length1 == 0 || length1 > 4)
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    else if (length1 > 2)
    {
      if (strArray1[2] == string.Empty)
        strArray1[2] = this.TRUEVALUESTR;
      else if (!this.ComputeIsLogical(strArray1[2]).Equals(this.TRUEVALUESTR) && this.ComputeIsNumber(strArray1[2]) != this.TRUEVALUESTR)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.ErrorStrings[1].ToString();
      }
    }
    if (length1 == 4)
    {
      if (strArray1[3] == string.Empty)
        strArray1[3] = this.FALSEVALUESTR;
      else if (!this.ComputeIsLogical(strArray1[3]).Equals(this.TRUEVALUESTR) && this.ComputeIsNumber(strArray1[2]) != this.TRUEVALUESTR)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.ErrorStrings[1].ToString();
      }
    }
    double[] doubleArray = this.GetDoubleArray(strArray1[0]);
    double[] x = (double[]) null;
    double[] coefficients;
    if (strArray1[1].Contains(this.TIC))
    {
      if (this.computedValueLevel <= 1)
        return this.LinearRegression.ComputeXArithmetic(doubleArray, x, strArray1[1], b, m, padXValues, errorValue, out double[] _);
      string str1 = string.Empty;
      str1 = this.LinearRegression.ComputeXArithmetic(doubleArray, x, strArray1[1], b, m, padXValues, errorValue, out coefficients);
      string str2 = this.TIC;
      if (coefficients != null && coefficients.Length > 0)
      {
        for (int index = coefficients.Length - 1; index >= 0; --index)
          str2 = $"{str2}{(object) coefficients[index]};";
        return str2.Substring(0, str2.Length - 1) + this.TIC;
      }
    }
    else
      x = padXValues || length1 > 1 && strArray1[1] == string.Empty ? new double[doubleArray.GetLength(0)] : this.GetDoubleArray(strArray1[1]);
    int length2 = x.GetLength(0);
    if (length2 != doubleArray.Length)
    {
      if (this.computedValueLevel <= 1)
        return this.LinearRegression.ComputeXArg(doubleArray, x, strArray1[1], b, m, padXValues, errorValue, out coefficients);
      string str3 = string.Empty;
      str3 = this.LinearRegression.ComputeXArg(doubleArray, x, strArray1[1], b, m, padXValues, errorValue, out coefficients);
      string str4 = this.TIC;
      if (coefficients != null && coefficients.Length > 0)
      {
        for (int index = coefficients.Length - 1; index >= 0; --index)
          str4 = $"{str4}{(object) coefficients[index]};";
        return str4.Substring(0, str4.Length - 1) + this.TIC;
      }
    }
    if (length2 <= 1)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    if (padXValues || length1 > 1 && strArray1[1] == string.Empty)
    {
      for (int index = 0; index < length2; ++index)
        x[index] = (double) (index + 1);
    }
    this.LinearRegression.ComputeLinest(doubleArray, x, out m, out b, out errorValue);
    return errorValue != string.Empty ? errorValue : b.ToString();
  }

  public string ComputeChiinv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string chiinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) chiinv))
      return chiinv;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = this.StripTics(strArray[index]);
    }
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    double result2;
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3))
    {
      if (result2 < 0.0 || result2 > 1.0 || result3 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (result2 == 1.0)
        return "0";
      num = this.chiinv(result2, result3);
    }
    return num.ToString();
  }

  public string ComputeChitest(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string chitest = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) chitest))
      return chitest;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    string str = strArray[0];
    double num1 = 0.0;
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    int length = doubleArray1.GetLength(0);
    if (str.IndexOf(':') > -1)
    {
      string s1 = str.Substring(0, str.IndexOf(':'));
      int num2 = this.ColIndex(s1);
      int num3 = this.RowIndex(s1);
      string s2 = str.Substring(str.IndexOf(':') + 1);
      int num4 = this.ColIndex(s2);
      int num5 = this.RowIndex(s2);
      if (this.grid is ISheetData)
      {
        if (!(!num3.Equals(-1) || num5.Equals(-1)).Equals(num3.Equals(-1) || !num5.Equals(-1)))
          return this.ErrorStrings[5].ToString();
        if (num3 == -1)
          num3 = ((ISheetData) this.grid).GetFirstRow();
        if (num2 == -1)
          num2 = ((ISheetData) this.grid).GetFirstColumn();
        if (num4 == -1)
          num4 = ((ISheetData) this.grid).GetLastColumn();
        if (num5 == -1)
          num5 = ((ISheetData) this.grid).GetLastRow();
      }
      num1 = (double) (Math.Abs(num2 - num4) * Math.Abs(num3 - num5));
      if (1.0001 < 1.0)
        return this.FormulaErrorStrings[this.invalid_Math_argument];
    }
    else if (this.excelLikeComputations && doubleArray1.Length < 1 && doubleArray2.Length < 1)
      return "#N/A";
    double v = 0.99555;
    if (length <= 0 || length != doubleArray2.GetLength(0))
      return this.ErrorStrings[0].ToString();
    double x = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num6 = doubleArray2[index] - doubleArray1[index];
      x += num6 * num6 / doubleArray1[index];
    }
    return (1.0 - this.chidist(x, v)).ToString();
  }

  private double normaldensity(double x, double u, double s)
  {
    return 1.0 / (Math.Sqrt(2.0 * Math.PI) * s) * Math.Exp(-(x - u) * (x - u) / (2.0 * s * s));
  }

  private double normaldist(double x, double u, double s)
  {
    int num1 = 32 /*0x20*/;
    double x1;
    double x2;
    if (x > u)
    {
      x1 = u - (x - u);
      x2 = x;
    }
    else
    {
      x1 = x;
      x2 = u + (u - x);
    }
    double num2 = (x2 - x1) / (double) num1;
    double num3 = num2 / 3.0;
    double num4 = this.normaldensity(x1, u, s) + this.normaldensity(x2, u, s);
    double num5 = 0.0;
    for (int index = 1; index < num1; index += 2)
      num5 += 4.0 * this.normaldensity(x1 + (double) index * num2, u, s);
    double num6 = 0.0;
    for (int index = 2; index < num1; index += 2)
      num6 += 2.0 * this.normaldensity(x1 + (double) index * num2, u, s);
    double num7 = num3 * (num4 + num6 + num5);
    double num8 = num7;
    double num9 = 1E-07;
    for (int index1 = 0; index1 < 10; ++index1)
    {
      num1 *= 2;
      num6 += num5 / 2.0;
      double num10 = 0.0;
      double num11;
      double num12 = num11 = (x2 - x1) / (double) num1;
      for (int index2 = 0; index2 < num1; ++index2)
      {
        if (index2 % 2 == 1)
        {
          double num13 = this.normaldensity(x1 + num12 * (double) index2, u, s);
          num10 += num13;
        }
      }
      num5 = 4.0 * num10;
      num7 = num12 / 3.0 * (num4 + num6 + num5);
      if (Math.Abs((num7 - num8) / num8) >= num9)
        num8 = num7;
      else
        break;
    }
    return x <= u ? (1.0 - num7) / 2.0 : num7 + (1.0 - num7) / 2.0;
  }

  public string ComputeNormdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 3:
      case 4:
        string normdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
        if (this.ErrorStrings.Contains((object) normdist))
          return normdist;
        double result1 = 0.0;
        double result2 = 0.0;
        double result3 = 0.0;
        double num1 = 0.0;
        double num2 = 0.0;
        for (int index = 0; index < length; ++index)
          strArray[index] = this.GetValueFromArg(strArray[index]);
        string str1 = strArray[0];
        string str2 = strArray[1];
        string str3 = strArray[2];
        string str4 = strArray[3];
        string str5 = !string.IsNullOrEmpty(str1) || !this.treatStringsAsZero ? str1 : "0";
        string str6 = !string.IsNullOrEmpty(str2) || !this.treatStringsAsZero ? str2 : "0";
        bool result4;
        string str7 = bool.TryParse(str5, out result4) ? Convert.ToInt16(result4).ToString() : str5;
        bool result5;
        string str8 = bool.TryParse(str6, out result5) ? Convert.ToInt16(result5).ToString() : str6;
        bool result6;
        string str9 = bool.TryParse(str3, out result6) ? Convert.ToInt16(result6).ToString() : str3;
        bool result7;
        string str10 = bool.TryParse(str4, out result7) ? Convert.ToInt16(result7).ToString() : str4;
        if (string.IsNullOrEmpty(str9) || string.IsNullOrEmpty(str10))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[4].ToString();
        }
        if (double.TryParse(str7.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(str8.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(str9.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result3))
        {
          if (length != 3)
          {
            double result8 = 0.0;
            num1 = !double.TryParse(strArray[3], out result8) ? (strArray[3].Replace(this.TIC, string.Empty).ToUpper() == this.TRUEVALUESTR ? 1.0 : (strArray[3].Replace(this.TIC, string.Empty).ToUpper() == this.FALSEVALUESTR ? 0.0 : -1.0)) : (result8 == 0.0 ? 0.0 : 1.0);
          }
          if (num1 == -1.0)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
          num2 = num1 != 0.0 ? this.normaldist(result1, result2, result3) : this.normaldensity(result1, result2, result3);
        }
        return num2.ToString();
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  public string ComputeNormsDist(string argList)
  {
    if (this.SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string normsDist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) normsDist))
      return normsDist;
    bool result;
    argList = bool.TryParse(this.GetValueFromArg(argList), out result) ? Convert.ToInt16(result).ToString() : argList;
    return this.ComputeNormdist($"{argList}, 0, 1, {this.TRUEVALUESTR}");
  }

  public string ComputeNorminv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string norminv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) norminv))
      return norminv;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && result2 > 0.0 && result2 < 1.0 && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 <= 0.0 || result2 >= 1.0 || result4 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Numerator and denominator should not be less than one");
        return this.ErrorStrings[4].ToString();
      }
      num = this.normalinv(result2, result3, result4);
    }
    return num <= 0.0 ? this.FormulaErrorStrings[this.iterations_dont_converge] : num.ToString();
  }

  private double normalinv(double p, double u, double s)
  {
    double x = p >= 0.05 ? (p >= 0.5 ? (p >= 0.95 ? u + 5.0 * s : u + 2.0 * s) : u) : u - 2.0 * s;
    double num1 = x / 2.0;
    double num2 = 1E-07;
    int num3 = 100;
    int num4 = 3;
    int num5 = 0;
    while (num3 == 100 && num4 > 0)
    {
      --num4;
      x /= 2.0;
      double num6 = x / 2.0;
      for (num3 = 0; num3 < 100; ++num3)
      {
        ++num5;
        double num7 = this.normaldist(x, u, s);
        if (Math.Abs((num7 - p) / p) >= num2)
        {
          if (num7 < p)
          {
            x += num6;
          }
          else
          {
            num6 /= 2.0;
            if (x - num6 < 0.0)
              num6 = x / 2.0;
            x -= num6;
          }
        }
        else
          break;
      }
    }
    if (num3 == 100)
      x = -1.0;
    return x;
  }

  private double newnormalinv(double p)
  {
    double[] numArray1 = new double[6]
    {
      -39.696830286653757,
      220.9460984245205,
      -275.92851044696869,
      138.357751867269,
      -30.66479806614716,
      2.5066282774592392
    };
    double[] numArray2 = new double[5]
    {
      -54.476098798224058,
      161.58583685804089,
      -155.69897985988661,
      66.80131188771972,
      -13.280681552885721
    };
    double[] numArray3 = new double[6]
    {
      -0.0077848940024302926,
      -0.32239645804113648,
      -2.4007582771618381,
      -2.5497325393437338,
      4.3746641414649678,
      2.9381639826987831
    };
    double[] numArray4 = new double[4]
    {
      0.0077846957090414622,
      0.32246712907003983,
      2.445134137142996,
      3.7544086619074162
    };
    double num1 = 0.02425;
    double num2 = 1.0 - num1;
    if (p < num1)
    {
      double num3 = Math.Sqrt(-2.0 * Math.Log(p));
      return (((((numArray3[0] * num3 + numArray3[1]) * num3 + numArray3[2]) * num3 + numArray3[3]) * num3 + numArray3[4]) * num3 + numArray3[5]) / ((((numArray4[0] * num3 + numArray4[1]) * num3 + numArray4[2]) * num3 + numArray4[3]) * num3 + 1.0);
    }
    if (num2 < p)
    {
      double num4 = Math.Sqrt(-2.0 * Math.Log(1.0 - p));
      return -(((((numArray3[0] * num4 + numArray3[1]) * num4 + numArray3[2]) * num4 + numArray3[3]) * num4 + numArray3[4]) * num4 + numArray3[5]) / ((((numArray4[0] * num4 + numArray4[1]) * num4 + numArray4[2]) * num4 + numArray4[3]) * num4 + 1.0);
    }
    double num5 = p - 0.5;
    double num6 = num5 * num5;
    return (((((numArray1[0] * num6 + numArray1[1]) * num6 + numArray1[2]) * num6 + numArray1[3]) * num6 + numArray1[4]) * num6 + numArray1[5]) * num5 / (((((numArray2[0] * num6 + numArray2[1]) * num6 + numArray2[2]) * num6 + numArray2[3]) * num6 + numArray2[4]) * num6 + 1.0);
  }

  public string ComputeNormsInv(string argList)
  {
    if (this.SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string normsInv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) normsInv))
      return normsInv;
    double result1 = 0.0;
    argList = this.GetValueFromArg(argList);
    bool result2;
    argList = bool.TryParse(argList, out result2) ? Convert.ToInt16(result2).ToString() : argList;
    double.TryParse(this.StripTics0(argList), out result1);
    if (result1 <= 0.0 || result1 >= 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    bool flag = false;
    if (this.ExcelLikeComputations)
      return this.newnormalinv(double.Parse(argList)).ToString();
    if (!char.IsLetter(argList, 0))
    {
      double num = double.Parse(argList);
      if (num <= 0.0 || num >= 1.0)
        return "#NUM!";
      if (num < 0.5)
      {
        argList = (1.0 - num).ToString();
        flag = true;
      }
      else if (num == 0.5)
        return "0";
    }
    string argList1 = argList + ", 0, 1";
    return flag ? $"-{this.ComputeNorminv(argList1)}" : this.ComputeNorminv(argList1);
  }

  public string ComputeConfidence(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string confidence = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) confidence))
      return confidence;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = this.StripTics(strArray[index]);
    }
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 <= 0.0 || result2 >= 1.0 || result3 <= 0.0 || result4 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Passed argument value is different from minimum par");
        return this.ErrorStrings[4].ToString();
      }
      if (result4 == 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[3].ToString();
      }
      num = (this.ExcelLikeComputations ? this.newnormalinv(1.0 - result2 + result2 / 2.0) : this.normalinv(1.0 - result2 + result2 / 2.0, 0.0, 1.0)) * result3 / Math.Sqrt(result4);
    }
    return num.ToString();
  }

  public string ComputeCorrel(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string correl = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) correl))
      return correl;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    int length = doubleArray2.GetLength(0);
    if (length <= 0 || length != doubleArray1.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    double num2 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      num1 += doubleArray2[index];
      num2 += doubleArray1[index];
    }
    double num3 = num1 / (double) length;
    double num4 = num2 / (double) length;
    double num5 = 0.0;
    double num6 = 0.0;
    double num7 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num8 = doubleArray2[index] - num3;
      double num9 = doubleArray1[index] - num4;
      num5 += num8 * num9;
      num6 += num8 * num8;
      num7 += num9 * num9;
    }
    string range1 = (num5 / Math.Sqrt(num6 * num7)).ToString();
    if (!(this.ComputeIsErr(range1) == this.TRUEVALUESTR))
      return range1;
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputeCount(string range)
  {
    int num = 0;
    string s = string.Empty;
    if (this.isIndexInteriorFormula)
      this.isIndexInteriorFormula = false;
    foreach (string preservingQuotedComma1 in this.SplitArgsPreservingQuotedCommas(range))
    {
      double result1;
      DateTime result2;
      if (preservingQuotedComma1.IndexOf(':') > -1)
      {
        if (this.IsRange(preservingQuotedComma1))
        {
          foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma1.Replace(this.TIC, string.Empty)))
          {
            try
            {
              s = this.GetValueFromArg(cellsFromArg);
            }
            catch (Exception ex)
            {
              this.ExceptionThrown = true;
              if (!this.rethrowLibraryComputationExceptions)
                return this.ErrorStrings[4].ToString();
              if (this.LibraryComputationException != null)
                throw this.LibraryComputationException;
              throw new ArgumentException(this.ErrorStrings[4].ToString());
            }
            if (s.Length > 0)
            {
              if (s.Equals(this.FormulaErrorStrings[19]))
              {
                if (!this.rethrowLibraryComputationExceptions)
                  return this.FormulaErrorStrings[19];
                if (this.LibraryComputationException != null)
                  throw this.LibraryComputationException;
                throw new Exception(this.FormulaErrorStrings[19]);
              }
              if (double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result1) || DateTime.TryParse(s, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result2))
                ++num;
            }
          }
          continue;
        }
      }
      try
      {
        if (preservingQuotedComma1.Equals(string.Empty) && !preservingQuotedComma1.StartsWith(this.TIC))
          ++num;
        if (preservingQuotedComma1.Contains(CalcEngine.ParseArgumentSeparator.ToString()))
        {
          foreach (string preservingQuotedComma2 in this.SplitArgsPreservingQuotedCommas(this.StripTics0(preservingQuotedComma1)))
          {
            if (double.TryParse(preservingQuotedComma2, NumberStyles.Any, (IFormatProvider) null, out result1) || DateTime.TryParse(preservingQuotedComma2, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result2))
              ++num;
          }
        }
        else
          s = this.GetValueFromArg(preservingQuotedComma1);
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (!this.rethrowLibraryComputationExceptions)
          return this.ErrorStrings[4].ToString();
        if (this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      }
      if (s.Length > 0)
      {
        if (s.Equals(this.FormulaErrorStrings[19]))
        {
          if (!this.rethrowLibraryComputationExceptions)
            return this.FormulaErrorStrings[19];
          if (this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          throw new Exception(this.FormulaErrorStrings[19]);
        }
        if (double.TryParse(s.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1) || DateTime.TryParse(s.Replace(this.TIC, string.Empty), (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result2) || s.Equals(this.TRUEVALUESTR) || s.Equals(this.FALSEVALUESTR))
          ++num;
      }
    }
    return num.ToString();
  }

  public string ComputeCounta(string range)
  {
    int num = 0;
    string empty = string.Empty;
    if (this.isIndexInteriorFormula)
      this.isIndexInteriorFormula = false;
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    foreach (string str in strArray)
    {
      if (str.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(str))
        {
          string valueFromArg;
          try
          {
            valueFromArg = this.GetValueFromArg(cellsFromArg);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
          if (valueFromArg.Length > 0)
            ++num;
          else if (this.GetValueFromParentObject(cellsFromArg, false) != string.Empty)
            ++num;
        }
      }
      else if (str.Equals(string.Empty))
        ++num;
      else if (char.IsLetter(str, 0))
      {
        if (this.GetValueFromArg(str).Length > 0)
          ++num;
      }
      else if (str.Contains(CalcEngine.ParseArgumentSeparator.ToString()))
      {
        foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(str.Replace(this.TIC, string.Empty)))
        {
          if (!preservingQuotedComma.StartsWith(this.TIC) && this.IsCellReference(preservingQuotedComma))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
            return this.FormulaErrorStrings[this.invalid_arguments];
          }
          if (preservingQuotedComma.Length > 0 || preservingQuotedComma.Equals(string.Empty))
            ++num;
        }
      }
      else if (str.Length > 0)
        ++num;
    }
    return num.ToString();
  }

  public string ComputeCountblank(string range)
  {
    int num = 0;
    string str1 = this.TIC + this.TIC;
    if (this.isIndexInteriorFormula)
      this.isIndexInteriorFormula = false;
    this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range) || strArray.Length > 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    foreach (string str2 in strArray)
    {
      if (str2.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(str2))
        {
          string valueFromArg;
          try
          {
            valueFromArg = this.GetValueFromArg(cellsFromArg);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return this.ErrorStrings[4].ToString();
          }
          if (valueFromArg == string.Empty || valueFromArg == str1)
            ++num;
        }
      }
      else
      {
        string valueFromArg;
        try
        {
          if (!double.TryParse(str2, out double _) && !this.IsCellReference(str2))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.ErrorStrings[5].ToString());
            return this.ErrorStrings[5].ToString();
          }
          valueFromArg = this.GetValueFromArg(str2);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return this.ErrorStrings[4].ToString();
        }
        if (!this.IsCellReference(str2))
        {
          if (double.TryParse(valueFromArg, out double _) || this.ErrorStrings.Contains((object) valueFromArg))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments].ToString());
            return this.FormulaErrorStrings[this.invalid_arguments].ToString();
          }
          if (!valueFromArg.Replace(this.TIC, string.Empty).Equals(string.Empty))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.ErrorStrings[5].ToString());
            return this.ErrorStrings[5].ToString();
          }
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments].ToString());
          return this.FormulaErrorStrings[this.invalid_arguments].ToString();
        }
        if (valueFromArg == string.Empty || valueFromArg == str1)
          ++num;
      }
    }
    return num.ToString();
  }

  public string ComputeCountif(string argList) => this.ComputeCountIFFunctions(argList, true);

  private string ComputeCountIFFunctions(string argList, bool isCountif)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length1 = strArray.GetLength(0);
    double num = 0.0;
    string empty = string.Empty;
    if (this.isIndexInteriorFormula)
      this.isIndexInteriorFormula = false;
    bool flag = false;
    List<string> stringList1 = new List<string>();
    List<string> stringList2 = new List<string>();
    List<string> stringList3 = new List<string>();
    List<string> stringList4 = new List<string>();
    int index1;
    for (int index2 = 0; index2 < length1; index2 = index1 + 1)
    {
      stringList1.Add(strArray[index2]);
      index1 = index2 + 1;
      stringList2.Add(strArray[index1]);
    }
    string[] cellsFromArgs1 = this.GetCellsFromArgs(stringList1[0]);
    if (length1 < 2 && stringList1.Count == stringList2.Count && !isCountif)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    if (stringList1.Count != stringList2.Count)
      return this.ErrorStrings[1].ToString();
    if (length1 != 2 && length1 != 3 && isCountif)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    for (int index3 = 0; index3 < stringList2.Count; ++index3)
    {
      char op = 'e';
      string valueFromArg1 = stringList2[index3];
      if ((int) valueFromArg1[0] != (int) this.TIC[0] && "=><".IndexOf(valueFromArg1[0]) == -1)
        valueFromArg1 = this.GetValueFromArg(valueFromArg1);
      if (index3 == stringList1.Count - 1 && !isCountif)
        flag = true;
      if (isCountif)
        flag = true;
      if (valueFromArg1.Length < 1 && isCountif)
        return "0";
      string str = !this.IsArrayFormula || !isCountif ? this.findCriteria(valueFromArg1, ref op) : this.findCriteria(stringList2[0].Replace('\u0092'.ToString(), string.Empty), ref op);
      string[] cellsFromArgs2 = this.GetCellsFromArgs(stringList1[index3]);
      if (cellsFromArgs2.GetLength(0) != cellsFromArgs1.GetLength(0))
        return this.ErrorStrings[1].ToString();
      if (cellsFromArgs2[0].Equals(this.ErrorStrings[5]))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
        return this.ErrorStrings[5].ToString();
      }
      int length2 = cellsFromArgs2.GetLength(0);
      double result1 = double.MinValue;
      bool isNumber = double.TryParse(str, out result1);
      if (this.IsArrayFormula)
        return this.ArrayParser.ComputeCountIF(cellsFromArgs2, op, str, isNumber, result1, this.computeFunctionLevel, length2);
      for (int index4 = 0; index4 < length2; ++index4)
      {
        double result2 = double.MinValue;
        string valueFromArg2 = this.GetValueFromArg(cellsFromArgs2[index4]);
        isNumber = isNumber && double.TryParse(valueFromArg2, out result2) && isNumber;
        if (this.CheckForCriteriaMatch(valueFromArg2.ToUpper(), op, str.ToUpper(), isNumber, result1))
        {
          if (isCountif && flag || flag && stringList2.Count == 1)
            ++num;
          else if (stringList3.Count > 0 && index3 != 0)
          {
            int count = stringList3.Count;
            for (int index5 = 0; index5 < count; ++index5)
            {
              if (stringList3[index5] != null && this.RowIndex(stringList3[index5].ToString()).Equals(this.RowIndex(cellsFromArgs2[index4])))
              {
                stringList4.Add(cellsFromArgs2[index4]);
                if (flag)
                  ++num;
              }
            }
          }
          else
            stringList4.Add(cellsFromArgs2[index4]);
        }
      }
      stringList3 = stringList4;
      stringList4 = new List<string>();
    }
    return num.ToString();
  }

  public string ComputeCOUNTIFS(string argList) => this.ComputeCountIFFunctions(argList, false);

  public string ComputeCovar(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string covar = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) covar))
      return covar;
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    int length = doubleArray2.GetLength(0);
    if (length <= 0 || length != doubleArray1.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double num1 = 0.0;
    double num2 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      num1 += doubleArray2[index];
      num2 += doubleArray1[index];
    }
    double num3 = num1 / (double) length;
    double num4 = num2 / (double) length;
    double num5 = 0.0;
    for (int index = 0; index < length; ++index)
      num5 += (doubleArray2[index] - num3) * (doubleArray1[index] - num4);
    return (num5 / (double) length).ToString();
  }

  public string ComputeCritbinom(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string critbinom = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) critbinom))
      return critbinom;
    double result1 = 0.0;
    int num = 0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = this.StripTics(strArray[index]);
    }
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result2;
    strArray[0] = bool.TryParse(strArray[0], out result2) ? Convert.ToInt16(result2).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result2) ? Convert.ToInt16(result2).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result2) ? Convert.ToInt16(result2).ToString() : strArray[2];
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (result4 > 0.0 && result4 < 1.0 && result1 > 0.0 && result1 < 1.0)
      {
        num = this.critbinom((int) result3, result4, result1);
        if (num == int.MaxValue)
          return this.FormulaErrorStrings[this.calculation_overflow];
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
    }
    return num.ToString();
  }

  private int critbinom(int nTrials, double p, double alpha)
  {
    int successes = nTrials;
    int num1 = nTrials;
    double num2 = 1.0;
    do
    {
      num1 = num1 / 2 + 1;
      if (num2 >= alpha)
      {
        double d = this.binomdist(nTrials, successes - 1, p);
        if (double.IsNaN(d))
          return int.MaxValue;
        if (d >= alpha || d <= 0.0)
          successes -= num1;
        else
          break;
      }
      else
      {
        if (this.binomdist(nTrials, successes + 1, p) >= alpha)
        {
          ++successes;
          break;
        }
        successes += num1;
      }
      num2 = this.binomdist(nTrials, successes, p);
    }
    while (successes < nTrials && successes > 0);
    return successes;
  }

  public string ComputeExpondist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string expondist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) expondist))
      return expondist;
    double result1 = 0.0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result2;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
    }
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (result3 < 0.0 || result4 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      num = result1 != 0.0 ? 1.0 - Math.Exp(-result4 * result3) : result4 * Math.Exp(-result4 * result3);
    }
    return num.ToString();
  }

  public string ComputeFdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string fdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) fdist))
      return fdist;
    double result1 = 0.0;
    double result2 = 0.0;
    string valueFromArg1 = this.GetValueFromArg(strArray[0]);
    string str1 = string.IsNullOrEmpty(valueFromArg1) ? "0" : valueFromArg1;
    bool result3;
    string s1 = bool.TryParse(str1, out result3) ? Convert.ToInt16(result3).ToString() : str1;
    string valueFromArg2 = this.GetValueFromArg(strArray[1]);
    string str2 = string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2;
    string s2 = bool.TryParse(str2, out result3) ? Convert.ToInt16(result3).ToString() : str2;
    string valueFromArg3 = this.GetValueFromArg(strArray[2]);
    string str3 = string.IsNullOrEmpty(valueFromArg3) ? "0" : valueFromArg3;
    string s3 = bool.TryParse(str3, out result3) ? Convert.ToInt16(result3).ToString() : str3;
    double result4;
    double.TryParse(s1, NumberStyles.Any, (IFormatProvider) null, out result4);
    double.TryParse(s2, NumberStyles.Any, (IFormatProvider) null, out result1);
    double.TryParse(s3, NumberStyles.Any, (IFormatProvider) null, out result2);
    if (result4 < 0.0 || result1 < 1.0 || result1 >= Math.Pow(10.0, 10.0) || result2 < 1.0 || result2 >= Math.Pow(10.0, 10.0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    double num = 1.0 - Math.Exp(this.GammaLn((result1 + result2) / 2.0) - this.GammaLn(result1 / 2.0) - this.GammaLn(result2 / 2.0) + result1 / 2.0 * Math.Log(result1 / result2)) * this.fdist(result4, (int) result1, (int) result2);
    if (result4 == 1.0 && result1 == 1.0 && result2 == 1.0)
      num = Math.Round(Math.Exp(this.GammaLn((result1 + result2) / 2.0)) / 2.0, 2);
    return num.ToString();
  }

  private double fdensity(double x, int df1, int df2)
  {
    return Math.Pow(x, (double) (df1 - 2) / 2.0) / Math.Pow(1.0 + (double) df1 * x / (double) df2, (double) (df1 + df2) / 2.0);
  }

  private double fdist(double x, int df1, int df2)
  {
    int num1 = 32 /*0x20*/;
    double x1 = 0.0;
    double x2 = x;
    double num2 = (x2 - x1) / (double) num1;
    double num3 = num2 / 3.0;
    double num4 = this.fdensity(x1, df1, df2) + this.fdensity(x2, df1, df2);
    double num5 = 0.0;
    for (int index = 1; index < num1; index += 2)
      num5 += 4.0 * this.fdensity(x1 + (double) index * num2, df1, df2);
    double num6 = 0.0;
    for (int index = 2; index < num1; index += 2)
      num6 += 2.0 * this.fdensity(x1 + (double) index * num2, df1, df2);
    double num7 = num3 * (num4 + num6 + num5);
    double num8 = num7;
    double num9 = 1E-07;
    for (int index1 = 0; index1 < 10; ++index1)
    {
      num1 *= 2;
      num6 += num5 / 2.0;
      double num10 = 0.0;
      double num11 = (x2 - x1) / (double) num1;
      for (int index2 = 0; index2 < num1; ++index2)
      {
        if (index2 % 2 == 1)
        {
          double num12 = this.fdensity(x1 + num11 * (double) index2, df1, df2);
          num10 += num12;
        }
      }
      num5 = 4.0 * num10;
      num7 = num11 / 3.0 * (num4 + num6 + num5);
      if (Math.Abs((num7 - num8) / num8) >= num9)
        num8 = num7;
      else
        break;
    }
    return num7;
  }

  private double finv(double p, int df1, int df2)
  {
    double num1 = Math.Exp(this.GammaLn((double) (df1 + df2) / 2.0) - this.GammaLn((double) df1 / 2.0) - this.GammaLn((double) df2 / 2.0) + (double) df1 / 2.0 * Math.Log((double) df1 / (double) df2));
    double x = num1;
    double num2 = x / 2.0;
    double num3 = 1E-07;
    double num4 = 1000.0;
    int num5 = 100;
    int num6 = 3;
    int num7 = 0;
    double num8 = num1 / 2.0;
    while (x > num4)
    {
      double y = 2.0;
      if (Regex.IsMatch(x.ToString(), "[0-9.]+E[-+][0-9]+"))
      {
        string[] strArray = x.ToString().Split('+', '-');
        y = double.Parse(strArray[strArray.Length - 1]);
      }
      x /= Math.Pow(2.0, y);
      x /= 2.0;
      num8 = x / 2.0;
    }
    while (num5 == 100 && num6 > 0)
    {
      --num6;
      x /= 2.0;
      double num9 = x / 2.0;
      for (num5 = 0; num5 < 100; ++num5)
      {
        ++num7;
        double num10 = 1.0 - num1 * this.fdist(x, df1, df2);
        if (Math.Abs((num10 - p) / p) >= num3)
        {
          if (num10 > p)
          {
            x += num9;
            if (x > num8)
            {
              x = num9 * 2.0;
              x /= 2.0;
              num9 = x / 2.0;
            }
          }
          else
          {
            num9 /= 2.0;
            if (x - num9 < 0.0)
              num9 = x / 2.0;
            x -= num9;
            if (num9 < num3)
            {
              x /= 2.0;
              num9 = x / 2.0;
            }
          }
        }
        else
          break;
      }
    }
    if (num5 == 100)
      x = -1.0;
    return x;
  }

  public string ComputeFinv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string finv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) finv))
      return finv;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 < 0.0 || result2 > 1.0 || result3 < 1.0 || result4 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Numerator and denominator should not be less than one");
        return this.ErrorStrings[4].ToString();
      }
      num = this.finv(result2, (int) result3, (int) result4);
    }
    return num <= 0.0 ? "0" : num.ToString();
  }

  public string ComputeFisher(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string fisher = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) fisher))
      return fisher;
    double result;
    if (double.TryParse(this.GetValueFromArg(strArray[0]), NumberStyles.Any, (IFormatProvider) null, out result) && result > -1.0 && result < 1.0)
      return (0.5 * Math.Log((1.0 + result) / (1.0 - result))).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeFisherinv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string fisherinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) fisherinv))
      return fisherinv;
    double num1 = 0.0;
    double result;
    if (double.TryParse(this.GetValueFromArg(strArray[0]), NumberStyles.Any, (IFormatProvider) null, out result))
    {
      double num2 = Math.Exp(2.0 * result);
      num1 = (num2 - 1.0) / (num2 + 1.0);
    }
    return num1.ToString();
  }

  public string ComputeForecast(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 3 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string forecast1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) forecast1))
      return forecast1;
    for (int index = 1; index <= 2; ++index)
    {
      string forecast2 = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Range);
      if (this.ErrorStrings.Contains((object) forecast2))
        return forecast2;
    }
    bool result1;
    if (!this.IsRange(strArray[1]) && (string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(strArray[1], out result1)) || !this.IsRange(strArray[2]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[2])) || !this.IsRange(strArray[0]) && bool.TryParse(strArray[0], out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    double result2;
    double.TryParse(string.IsNullOrEmpty(valueFromArg) ? "0" : valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result2);
    double[] doubleArray1 = this.GetDoubleArray(strArray[1]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[2]);
    int length = doubleArray2.GetLength(0);
    if (length <= 0 || length != doubleArray1.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    double num2 = 0.0;
    int num3 = length;
    for (int index = 0; index < length; ++index)
    {
      if (doubleArray2[index].Equals(double.NaN) || doubleArray1[index].Equals(double.NaN))
      {
        --num3;
      }
      else
      {
        num1 += doubleArray2[index];
        num2 += doubleArray1[index];
      }
    }
    double num4 = num1 / (double) num3;
    double num5 = num2 / (double) num3;
    double num6 = 0.0;
    double num7 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      if (!doubleArray2[index].Equals(double.NaN) && !doubleArray1[index].Equals(double.NaN))
      {
        double num8 = doubleArray2[index] - num4;
        num6 += num8 * (doubleArray1[index] - num5);
        num7 += num8 * num8;
      }
    }
    double num9 = num6 / num7;
    if (!(this.ComputeIsErr(num9.ToString()) == this.TRUEVALUESTR))
      return (num5 - num9 * num4 + num9 * result2).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  private double var(double[] x)
  {
    double num1 = 0.0;
    int length = x.GetLength(0);
    for (int index = 0; index < length; ++index)
      num1 += x[index];
    double num2 = num1 / (double) length;
    double num3 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num4 = x[index] - num2;
      num3 += num4 * num4;
    }
    return num3 / (double) (length - 1);
  }

  public string ComputeKurt(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    double[] doubleArray = this.GetDoubleArray(range);
    int length = doubleArray.GetLength(0);
    if (length < 1)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
      num1 += doubleArray[index];
    double num2 = num1 / (double) length;
    int num3 = length;
    double num4 = 0.0;
    double num5 = (double) num3;
    for (int index = 1; index <= num3; ++index)
      num4 += Math.Pow(doubleArray[index - 1] - num2, 2.0);
    double num6 = 0.0;
    double num7 = Math.Sqrt(num4 / (num5 - 1.0));
    foreach (double num8 in doubleArray)
    {
      double x = (num8 - num2) / num7;
      num6 += Math.Pow(x, 4.0);
    }
    double num9 = num5 * (num5 + 1.0) / ((num5 - 1.0) * (num5 - 2.0) * (num5 - 3.0));
    double num10 = 3.0 * Math.Pow(num5 - 1.0, 2.0) / ((num5 - 2.0) * (num5 - 3.0));
    return (num9 * num6 - num10).ToString();
  }

  public string ComputeLarge(string range)
  {
    string[] strArray1 = new string[2];
    bool flag = false;
    double result1;
    string[] strArray2;
    if (!range.Contains(":") && !range.StartsWith(this.TIC))
    {
      string[] strArray3 = this.SplitArgsPreservingQuotedCommas(range);
      for (int index = 0; index < strArray3.Length; ++index)
      {
        if (this.IsCellReference(strArray3[index]))
        {
          if (index == strArray3.Length - 2)
          {
            string[] strArray4;
            (strArray4 = strArray1)[0] = strArray4[0] + strArray3[index];
          }
          else
          {
            string[] strArray5;
            (strArray5 = strArray1)[0] = strArray5[0] + strArray3[index] + (object) CalcEngine.parseArgumentSeparator;
          }
        }
        if (double.TryParse(strArray3[index], out result1))
          strArray1[1] = strArray3[index];
      }
      strArray2 = strArray1;
      flag = true;
    }
    else
      strArray2 = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray2.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string large1 = this.FormulaErrorStringCheck(strArray2[0], CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) large1))
      return large1;
    string large2 = this.FormulaErrorStringCheck(strArray2[1], CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) large2))
      return large2;
    if (strArray2[1].Contains("n"))
      strArray2[1] = this.GetValueFromArg(strArray2[1]);
    bool result2;
    if (!double.TryParse(strArray2[1], out result1) && !flag && (string.IsNullOrEmpty(this.GetValueFromArg(strArray2[0])) || string.IsNullOrEmpty(this.GetValueFromArg(strArray2[1])) || bool.TryParse(this.GetValueFromArg(strArray2[0]), out result2) || bool.TryParse(this.GetValueFromArg(strArray2[1]), out result2)))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    double result3;
    if (!double.TryParse(this.GetValueFromArg(strArray2[1]), NumberStyles.Integer, (IFormatProvider) null, out result3))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    int num = (int) result3;
    double[] doubleArray = this.GetDoubleArray(strArray2[0]);
    int length = doubleArray.GetLength(0);
    Array.Sort<double>(doubleArray);
    if (num >= 1 && num <= length && !doubleArray[length - num].Equals(double.NaN))
      return doubleArray[length - num].ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeLognormdist(string argList)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray1.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string lognormdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) lognormdist))
      return lognormdist;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray1[index] = this.GetValueFromArg(strArray1[index]);
    strArray1[0] = string.IsNullOrEmpty(strArray1[0]) ? "0" : strArray1[0];
    bool result1;
    strArray1[0] = bool.TryParse(strArray1[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray1[0];
    strArray1[1] = string.IsNullOrEmpty(strArray1[1]) ? "0" : strArray1[1];
    strArray1[1] = bool.TryParse(strArray1[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray1[1];
    strArray1[2] = string.IsNullOrEmpty(strArray1[2]) ? "0" : strArray1[2];
    strArray1[2] = bool.TryParse(strArray1[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray1[2];
    if (strArray1[0].Contains(CalcEngine.ParseArgumentSeparator.ToString()))
    {
      string[] strArray2 = this.SplitArgsPreservingQuotedCommas(strArray1[0].Replace(this.TIC, string.Empty));
      strArray1[0] = this.GetValueFromArg(strArray2[0]);
    }
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray1[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray1[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray1[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 <= 0.0 || result4 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Numerator and denominator should not be less than one");
        return this.ErrorStrings[4].ToString();
      }
      num = this.normaldist(Math.Log(result2), result3, result4);
    }
    return num.ToString();
  }

  public string ComputeLoginv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string loginv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) loginv))
      return loginv;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 > 0.0 && result2 < 1.0 && result4 > 0.0)
        return Math.Exp(this.normalinv(result2, result3, result4)).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Numerator and denominator should not be less than one");
      return this.ErrorStrings[4].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeMaxa(string range)
  {
    double val1 = double.MinValue;
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.Length == 1 && !range.StartsWith(this.TIC) && string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    foreach (string args in strArray)
    {
      if (args.IndexOf(':') > -1)
      {
        if (args.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        foreach (string cellsFromArg in this.GetCellsFromArgs(args))
        {
          string s;
          try
          {
            string valueFromArg = this.GetValueFromArg(cellsFromArg);
            bool result;
            s = bool.TryParse(valueFromArg, out result) ? Convert.ToInt16(result).ToString() : valueFromArg;
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
          if (s.Length > 0)
          {
            double result = 0.0;
            if (this.ErrorStrings.Contains((object) s))
              return s;
            double.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result);
            val1 = Math.Max(val1, result);
          }
        }
      }
      else
      {
        string s;
        try
        {
          if (!args.StartsWith(this.TIC) && string.IsNullOrEmpty(args))
          {
            s = "0";
          }
          else
          {
            string valueFromArg = this.GetValueFromArg(args);
            bool result;
            s = bool.TryParse(valueFromArg, out result) ? Convert.ToInt16(result).ToString() : valueFromArg;
            if (this.ErrorStrings.Contains((object) s))
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return s;
            }
            if (s == string.Empty)
              s = "0";
          }
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        if (s.Length > 0)
        {
          double result = 0.0;
          if (double.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result))
            val1 = Math.Max(val1, result);
          else if (s.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
        }
      }
    }
    return val1 != double.MinValue ? val1.ToString() : "0";
  }

  public string ComputeMedian(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string median = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) median))
      return median;
    string empty1 = string.Empty;
    double[] doubleArray = this.GetDoubleArray(range);
    Array.Sort<double>(doubleArray);
    int index = doubleArray.GetLength(0) / 2;
    string empty2 = string.Empty;
    return doubleArray.GetLength(0) % 2 != 1 ? ((doubleArray[index] + doubleArray[index - 1]) / 2.0).ToString() : doubleArray[index].ToString();
  }

  public string ComputeMina(string range)
  {
    double val1 = double.MaxValue;
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(range);
    string[] strArray2 = this.SplitArguments(range, ';');
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (strArray2.Length > 1)
    {
      foreach (string args in strArray2)
      {
        foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(args))
        {
          string valueFromArg = this.GetValueFromArg(preservingQuotedComma);
          if (valueFromArg.Length > 0)
          {
            if (this.ErrorStrings.Contains((object) valueFromArg))
              return valueFromArg;
            bool result1;
            double result2;
            double.TryParse(bool.TryParse(valueFromArg, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result2);
            val1 = Math.Min(val1, result2);
          }
        }
      }
      if (val1 != double.MaxValue)
        return val1.ToString();
    }
    foreach (string args in strArray1)
    {
      if (args.IndexOf(':') > -1)
      {
        if (args.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        foreach (string cellsFromArg in this.GetCellsFromArgs(args))
        {
          string s;
          try
          {
            string valueFromArg = this.GetValueFromArg(cellsFromArg);
            bool result;
            s = bool.TryParse(valueFromArg, out result) ? Convert.ToInt16(result).ToString() : valueFromArg;
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
          if (s.Length > 0)
          {
            double result = 0.0;
            if (this.ErrorStrings.Contains((object) s))
              return s;
            double.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result);
            val1 = Math.Min(val1, result);
          }
        }
      }
      else
      {
        string s;
        try
        {
          if (!args.StartsWith(this.TIC) && string.IsNullOrEmpty(args))
          {
            s = "0";
          }
          else
          {
            string valueFromArg = this.GetValueFromArg(args);
            bool result;
            s = bool.TryParse(valueFromArg, out result) ? Convert.ToInt16(result).ToString() : valueFromArg;
            if (s == string.Empty)
              s = "0";
          }
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        if (s.Length > 0)
        {
          double result = 0.0;
          if (this.ErrorStrings.Contains((object) s))
            return s;
          if (double.TryParse(s, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result))
            val1 = Math.Min(val1, result);
          else if (s.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
        }
      }
    }
    return val1 != double.MaxValue ? val1.ToString() : "0";
  }

  public string ComputeMode(string range)
  {
    double[] doubleArray = this.GetDoubleArray(range);
    double[] numArray = doubleArray.Clone() as double[];
    int length = doubleArray.GetLength(0);
    if (length <= 1)
      return "#N/A";
    Array.Sort<double>(doubleArray);
    ArrayList arrayList = new ArrayList();
    double num1 = double.NaN;
    int num2 = 0;
    int num3 = 0;
    for (int index = 1; index < length; ++index)
    {
      if (doubleArray[index] == doubleArray[index - 1])
      {
        ++num2;
      }
      else
      {
        if (num2 > num3)
        {
          num3 = num2;
          num1 = doubleArray[index - 1];
          arrayList.Clear();
          arrayList.Add((object) num1);
        }
        else if (num2 == num3)
          arrayList.Add((object) doubleArray[index - 1]);
        num2 = 0;
      }
    }
    if (num2 > num3)
    {
      num3 = num2;
      num1 = doubleArray[length - 1];
      arrayList.Clear();
      arrayList.Add((object) num1);
    }
    if (num3 <= 0)
      return "#N/A";
    if (num2 == num3)
      arrayList.Add((object) doubleArray[length - 1]);
    if (arrayList.Count > 1)
    {
      foreach (double num4 in numArray)
      {
        if (arrayList.IndexOf((object) num4) > -1)
        {
          num1 = num4;
          break;
        }
      }
    }
    return num1.ToString();
  }

  public string ComputeNegbinomdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    double result1;
    double result2;
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3))
      num = this.negbinomdensity((int) result1, (int) result2, result3);
    return num.ToString();
  }

  private double negbinomdensity(int failures, int successes, double p)
  {
    return this.comb(successes - 1, failures + successes - 1) * Math.Pow(p, (double) successes) * Math.Pow(1.0 - p, (double) failures);
  }

  public string ComputePearson(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string pearson = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) pearson))
      return pearson;
    bool result;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    int length = doubleArray2.GetLength(0);
    if (length <= 0 || length != doubleArray1.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    string range1 = this.pearson(doubleArray2, doubleArray1, length).ToString();
    if (!(this.ComputeIsErr(range1) == this.TRUEVALUESTR))
      return range1;
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputePercentile(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    List<double> doubleList = new List<double>();
    if (length != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (strArray[0].Contains(":"))
    {
      int num = 0;
      foreach (string cellsFromArg in this.GetCellsFromArgs(strArray[0]))
      {
        double result = 0.0;
        if (double.TryParse(this.GetValueFromArg(cellsFromArg).Replace(this.TIC, ""), NumberStyles.Number, (IFormatProvider) null, out result))
          doubleList.Add(result);
        ++num;
      }
    }
    else
    {
      string percentile1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Text);
      if (this.ErrorStrings.Contains((object) percentile1))
        return percentile1;
      string percentile2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) percentile2))
        return percentile2;
      bool result;
      if (string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      doubleList = new List<double>((IEnumerable<double>) this.GetDoubleArray(strArray[0]));
    }
    double result1;
    if (!double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Any, (IFormatProvider) null, out result1) && (result1 < 0.0 || result1 > 1.0))
      return this.FormulaErrorStrings[this.invalid_arguments];
    doubleList.Sort();
    int count = doubleList.Count;
    double num1 = 1.0 / (double) (count - 1);
    double num2 = doubleList[count - 1];
    for (int index = 0; index < count - 1; ++index)
    {
      if ((double) (index + 1) * num1 > result1)
      {
        double num3 = (result1 - (double) index * num1) / num1;
        num2 = doubleList[index] + num3 * (doubleList[index + 1] - doubleList[index]);
        break;
      }
    }
    return num2.ToString();
  }

  internal string ComputeContionalFomattingPercentile(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    List<double> doubleList = new List<double>();
    double result1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      if (strArray[index].Contains(":"))
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(strArray[index]))
        {
          double result2 = 0.0;
          if (double.TryParse(this.GetValueFromArg(cellsFromArg).Replace(this.TIC, ""), NumberStyles.None, (IFormatProvider) null, out result2))
            doubleList.Add(result2);
        }
      }
      else if (!double.TryParse(this.GetValueFromArg(strArray[index]), NumberStyles.Any, (IFormatProvider) null, out result1) && (result1 < 0.0 || result1 > 1.0))
        return this.FormulaErrorStrings[this.invalid_arguments];
    }
    int count = doubleList.Count;
    doubleList.Sort();
    double num1 = 1.0 / (double) (count - 1);
    double num2 = doubleList[count - 1];
    for (int index = 0; index < count - 1; ++index)
    {
      if ((double) (index + 1) * num1 > result1)
      {
        double num3 = (result1 - (double) index * num1) / num1;
        num2 = doubleList[index] + num3 * (doubleList[index + 1] - doubleList[index]);
        break;
      }
    }
    return num2.ToString();
  }

  public string ComputePercentrank(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length1 = strArray.GetLength(0);
    switch (length1)
    {
      case 2:
      case 3:
        if (!string.IsNullOrEmpty(range))
        {
          string percentrank1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Range);
          if (this.ErrorStrings.Contains((object) percentrank1))
            return percentrank1;
          string percentrank2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) percentrank2))
            return percentrank2;
          double result1 = 3.0;
          string valueFromArg1 = this.GetValueFromArg(strArray[1]);
          double result2;
          double.TryParse(string.IsNullOrEmpty(valueFromArg1) ? "0" : valueFromArg1, NumberStyles.Any, (IFormatProvider) null, out result2);
          if (length1 == 3)
          {
            string percentrank3 = this.FormulaErrorStringCheck(strArray[2], CalcEngine.FormulaArgumentType.Numbers);
            if (this.ErrorStrings.Contains((object) percentrank3))
              return percentrank3;
            string valueFromArg2 = this.GetValueFromArg(strArray[2]);
            double.TryParse(string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2, NumberStyles.Integer, (IFormatProvider) null, out result1);
            if (result1 < 1.0 && result2 > 0.0)
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return this.ErrorStrings[4].ToString();
            }
          }
          double[] doubleArray = this.GetDoubleArray(strArray[0]);
          int length2 = doubleArray.GetLength(0);
          Array.Sort<double>(doubleArray);
          double num1 = 1.0;
          for (int index = 0; index < length2; ++index)
          {
            if (doubleArray[index] > result2)
            {
              int num2 = 0;
              while (num2 + index < length2 && doubleArray[num2 + index] == result2)
                ++num2;
              num1 = (double) (index - 1) / (double) (index + length2 - index - num2 - 1);
              if (index > 0 && doubleArray[index - 1] < result2)
              {
                double num3 = (double) index / (double) (length2 - 1);
                num1 = num3 + (num1 - num3) * (1.0 - (result2 - doubleArray[index - 1]) / (doubleArray[index] - doubleArray[index - 1]));
                break;
              }
              break;
            }
          }
          if (num1 < 0.0)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[0].ToString();
          }
          string format = "0." + new string('#', (int) result1);
          return num1.ToString(format);
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputePermut(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string permut = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) permut))
      return permut;
    strArray[0] = this.GetValueFromArg(strArray[0]);
    strArray[1] = this.GetValueFromArg(strArray[1]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    double result2;
    double result3;
    if (!double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) || !double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3))
      return this.FormulaErrorStrings[this.invalid_arguments];
    if (result2 <= 0.0 && result3 != 0.0 || result3 < 0.0 || result2 < result3 && result2 != 0.0 && result3 != 0.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    int num1 = (int) (result3 + 0.1);
    int num2 = (int) (result2 + 0.1);
    double num3 = 1.0;
    for (int index = num2 - num1 + 1; index <= num2; ++index)
      num3 *= (double) index;
    return num3.ToString();
  }

  public string ComputePoisson(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string poisson = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) poisson))
      return poisson;
    double result1 = 0.0;
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result2;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
    }
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (result3 < 0.0 || result4 < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      int y = (int) result3;
      if (result1 == 0.0)
      {
        double num2 = 1.0;
        for (int index = 2; index <= y; ++index)
          num2 *= (double) index;
        num1 = Math.Exp(-result4) * Math.Pow(result4, (double) y) / num2;
      }
      else
      {
        double num3 = 1.0;
        double num4 = 0.0;
        double num5 = 1.0;
        for (int index = 0; index <= y; ++index)
        {
          num4 += num5 / num3;
          num3 *= (double) (index + 1);
          num5 *= result4;
        }
        num1 = Math.Exp(-result4) * num4;
      }
    }
    return num1.ToString();
  }

  public string ComputeProb(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length1 = strArray.GetLength(0);
    switch (length1)
    {
      case 3:
      case 4:
        if (!string.IsNullOrEmpty(range))
        {
          for (int index = 0; index < 2; ++index)
          {
            string prob = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Range);
            if (this.ErrorStrings.Contains((object) prob))
              return prob;
          }
          for (int index = 2; index <= 3; ++index)
          {
            if (index <= length1 - 1)
            {
              string prob = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Numbers);
              if (this.ErrorStrings.Contains((object) prob))
                return prob;
            }
          }
          string valueFromArg1 = this.GetValueFromArg(strArray[2]);
          string str1 = string.IsNullOrEmpty(valueFromArg1) ? "0" : valueFromArg1;
          bool result1;
          string s = bool.TryParse(str1, out result1) ? Convert.ToInt16(result1).ToString() : str1;
          double result2 = 0.0;
          double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result2);
          double result3 = result2;
          if (length1 == 4)
          {
            string valueFromArg2 = this.GetValueFromArg(strArray[3]);
            string str2 = string.IsNullOrEmpty(valueFromArg2) ? "0" : valueFromArg2;
            double.TryParse(bool.TryParse(str2, out result1) ? Convert.ToInt16(result1).ToString() : str2, NumberStyles.Any, (IFormatProvider) null, out result3);
          }
          double[] doubleArray1 = this.GetDoubleArray(strArray[1]);
          double[] doubleArray2 = this.GetDoubleArray(strArray[0]);
          int length2 = doubleArray2.GetLength(0);
          if (length2 != doubleArray1.GetLength(0))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[0].ToString();
          }
          double num1 = 0.0;
          for (int index = 0; index < length2; ++index)
          {
            double num2 = doubleArray2[index];
            if (num2 >= result2 && num2 <= result3)
              num1 += doubleArray1[index];
          }
          return num1.ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeQuartile(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string quartile1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) quartile1))
      return quartile1;
    string quartile2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) quartile2))
      return quartile2;
    bool result1;
    if (!this.IsRange(strArray[0]) && (string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result1)) || !this.IsRange(strArray[1]) && (string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result1)))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    double result2;
    if (double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Integer, (IFormatProvider) null, out result2) && result2 >= 0.0 && result2 <= 4.0)
      return this.ComputePercentile(strArray[0] + (object) CalcEngine.ParseArgumentSeparator + (result2 * 0.25).ToString());
    if (result2 >= 0.0 && result2 <= 4.0)
      return this.FormulaErrorStrings[this.invalid_arguments];
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeRank(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 2:
      case 3:
        if (!string.IsNullOrEmpty(range))
        {
          string rank1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) rank1))
            return rank1;
          string rank2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Range);
          if (this.ErrorStrings.Contains((object) rank2))
            return rank2;
          int num = 0;
          string valueFromArg = this.GetValueFromArg(strArray[0]);
          double result1;
          if (double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1))
          {
            double result2 = 0.0;
            if (length == 3)
            {
              string rank3 = this.FormulaErrorStringCheck(strArray[2], CalcEngine.FormulaArgumentType.Numbers);
              if (this.ErrorStrings.Contains((object) rank3))
                return rank3;
              valueFromArg = this.GetValueFromArg(strArray[2]);
              double.TryParse(valueFromArg, NumberStyles.Integer, (IFormatProvider) null, out result2);
            }
            double result3 = 0.0;
            bool flag = false;
            string str = strArray[1];
            double[] doubleArray = this.GetDoubleArray(strArray[1]);
            double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result3);
            if (result2 == 0.0)
              Array.Sort<double>(doubleArray, (Comparison<double>) ((a, b) => -a.CompareTo(b)));
            else
              Array.Sort<double>(doubleArray);
            foreach (double d in doubleArray)
            {
              if (!double.IsNaN(d))
              {
                ++num;
                if (d == result1)
                {
                  flag = true;
                  break;
                }
              }
            }
            if (!flag)
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return this.ErrorStrings[0].ToString();
            }
          }
          return num.ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeRsq(string range)
  {
    string pearson = this.ComputePearson(range);
    double result = 0.0;
    if (double.TryParse(pearson, NumberStyles.Any, (IFormatProvider) null, out result))
      result *= result;
    else if (this.ErrorStrings.Contains((object) pearson))
      return pearson;
    return result.ToString();
  }

  public string ComputeSkew(string range)
  {
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string skew = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) skew))
      return skew;
    double[] doubleArray = this.GetDoubleArray(range);
    int length = doubleArray.GetLength(0);
    if (length < 3)
      return this.FormulaErrorStrings[this.invalid_arguments];
    double xbar = 0.0;
    double num1 = this.sd(doubleArray, out xbar);
    double num2 = 0.0;
    for (int index = 0; index < length; ++index)
      num2 += Math.Pow((doubleArray[index] - xbar) / num1, 3.0);
    return ((double) length * num2 / (double) (length - 1) / (double) (length - 2)).ToString();
  }

  private double sd(double[] x, out double xbar)
  {
    int length = x.GetLength(0);
    xbar = 0.0;
    for (int index = 0; index < length; ++index)
      xbar += x[index];
    xbar /= (double) length;
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num2 = x[index] - xbar;
      num1 += num2 * num2;
    }
    return length == 1 ? 0.0 : Math.Sqrt(num1 / (double) (length - 1));
  }

  public string ComputeSlope(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (!this.IsCellReference(strArray[0]))
    {
      string slope = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Text);
      if (this.ErrorStrings.Contains((object) slope))
        return slope;
    }
    if (!this.IsCellReference(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsCellReference(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    double length = (double) doubleArray2.Length;
    if (length != (double) doubleArray1.Length)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    double num2 = 0.0;
    double num3 = 0.0;
    double num4 = 0.0;
    for (int index = 0; index < doubleArray2.Length; ++index)
    {
      if (doubleArray2[index].ToString() != double.NaN.ToString() && doubleArray1[index].ToString() != double.NaN.ToString())
      {
        num1 += doubleArray2[index] * doubleArray1[index];
        num2 += doubleArray2[index];
        num3 += doubleArray1[index];
        num4 += doubleArray2[index] * doubleArray2[index];
      }
    }
    string range1 = ((num1 - num2 * num3 / length) / (num4 - num2 * num2 / length)).ToString();
    if (!(this.ComputeIsErr(range1) == this.TRUEVALUESTR))
      return range1;
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputeSmall(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string small1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) small1))
      return small1;
    string small2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) small2))
      return small2;
    double result;
    if (!double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Integer, (IFormatProvider) null, out result))
      return this.FormulaErrorStrings[this.invalid_arguments];
    int num = (int) result;
    double[] doubleArray = this.GetDoubleArray(strArray[0]);
    if (num < 1 || num > doubleArray.GetLength(0))
      return this.ErrorStrings[4].ToString();
    Array.Sort<double>(doubleArray);
    return doubleArray[num - 1].ToString();
  }

  public string ComputeStandardize(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string standardize = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) standardize))
      return standardize;
    double result1 = 0.0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result2;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
    }
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (result1 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      num = (result3 - result4) / result1;
    }
    return num.ToString();
  }

  public string ComputeStdev(string range)
  {
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string stdev = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) stdev))
      return stdev;
    double[] doubleArray = this.GetDoubleArray(range);
    if (doubleArray.GetLength(0) < 2)
      return this.ErrorStrings[3].ToString();
    double xbar = 0.0;
    return this.sd(doubleArray, out xbar).ToString();
  }

  public string ComputeStdeva(string range)
  {
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string stdeva = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) stdeva))
      return stdeva;
    double[] doubleArrayA = this.GetDoubleArrayA(range);
    if (doubleArrayA.GetLength(0) < 2)
      return this.FormulaErrorStrings[this.invalid_arguments];
    double xbar = 0.0;
    return this.sd(doubleArrayA, out xbar).ToString();
  }

  public string ComputeStdevaP(string range)
  {
    double[] doubleArrayA = this.GetDoubleArrayA(range);
    if (doubleArrayA.GetLength(0) >= 2)
      return this.StdevdotP(doubleArrayA).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
    return this.FormulaErrorStrings[this.invalid_arguments];
  }

  public string ComputeStdevp(string range)
  {
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string stdevp = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) stdevp))
      return stdevp;
    double[] doubleArray = this.GetDoubleArray(range);
    int length = doubleArray.GetLength(0);
    if (length < 2)
      return this.FormulaErrorStrings[this.invalid_arguments];
    double xbar = 0.0;
    return (this.sd(doubleArray, out xbar) * Math.Sqrt((double) (length - 1)) / Math.Sqrt((double) length)).ToString();
  }

  public string ComputeStdevpa(string range)
  {
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string stdevpa = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) stdevpa))
      return stdevpa;
    double[] doubleArrayA = this.GetDoubleArrayA(range);
    int length = doubleArrayA.GetLength(0);
    if (length < 2)
      return this.FormulaErrorStrings[this.invalid_arguments];
    double xbar = 0.0;
    return (this.sd(doubleArrayA, out xbar) * Math.Sqrt((double) (length - 1)) / Math.Sqrt((double) length)).ToString();
  }

  public string ComputeSteyx(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string steyx = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) steyx))
      return steyx;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    int length = doubleArray2.GetLength(0);
    if (length != doubleArray1.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    double num2 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      num1 += doubleArray2[index];
      num2 += doubleArray1[index];
    }
    double num3 = num1 / (double) length;
    double num4 = num2 / (double) length;
    double num5 = 0.0;
    double num6 = 0.0;
    double num7 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num8 = doubleArray2[index] - num3;
      double num9 = doubleArray1[index] - num4;
      num5 += num8 * num9;
      num6 += num8 * num8;
      num7 += num9 * num9;
    }
    string range1 = Math.Sqrt((num7 - num5 * num5 / num6) / (double) (length - 2)).ToString();
    if (!(this.ComputeIsErr(range1) == this.TRUEVALUESTR))
      return range1;
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputeTrimmean(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string trimmean1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) trimmean1))
      return trimmean1;
    string trimmean2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) trimmean2))
      return trimmean2;
    double result;
    double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Any, (IFormatProvider) null, out result);
    double[] doubleArray = this.GetDoubleArray(strArray[0]);
    int length = doubleArray.GetLength(0);
    int num1 = (int) (result * (double) length) / 2;
    if (result < 0.0 || result > 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    Array.Sort<double>(doubleArray);
    double num2 = 0.0;
    int num3 = length - num1;
    for (int index = num1; index < num3; ++index)
      num2 += doubleArray[index];
    return (num2 / (double) (num3 - num1)).ToString();
  }

  public string ComputeVar(string range)
  {
    string str = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    return this.ErrorStrings.Contains((object) str) ? str : this.var(this.GetDoubleArray(range)).ToString();
  }

  private double[] GetDoubleArrayA(string range)
  {
    string str = string.Empty;
    ArrayList arrayList = new ArrayList();
    this.AdjustRangeArg(ref range);
    foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(range.Replace(this.TIC, string.Empty)))
    {
      if (preservingQuotedComma.IndexOf(':') > -1)
      {
        foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma))
        {
          try
          {
            str = this.GetValueFromArg(cellsFromArg);
          }
          catch
          {
          }
          if (str.Length > 0)
          {
            double result = 0.0;
            if (str.ToUpper() == this.TRUEVALUESTR)
              result = 1.0;
            else
              double.TryParse(str.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result);
            arrayList.Add((object) result);
          }
        }
      }
      else
      {
        try
        {
          str = this.GetValueFromArg(preservingQuotedComma);
        }
        catch
        {
        }
        if (str.Length > 0)
        {
          double result = 0.0;
          if (str.ToUpper() == this.TRUEVALUESTR)
            result = 1.0;
          else
            double.TryParse(str.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result);
          arrayList.Add((object) result);
        }
      }
    }
    return (double[]) arrayList.ToArray(typeof (double));
  }

  public string ComputeVara(string range)
  {
    string str = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    return this.ErrorStrings.Contains((object) str) ? str : this.var(this.GetDoubleArrayA(range)).ToString();
  }

  public string ComputeVarp(string range)
  {
    string varp = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) varp))
      return varp;
    double[] doubleArray = this.GetDoubleArray(range);
    int length = doubleArray.GetLength(0);
    return ((double) (length - 1) * this.var(doubleArray) / (double) length).ToString();
  }

  public string ComputeVarpa(string range)
  {
    string varpa = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) varpa))
      return varpa;
    double[] doubleArrayA = this.GetDoubleArrayA(range);
    int length = doubleArrayA.GetLength(0);
    return ((double) (length - 1) * this.var(doubleArrayA) / (double) length).ToString();
  }

  public string ComputeWeibull(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 3:
      case 4:
        string weibull = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
        if (this.ErrorStrings.Contains((object) weibull))
          return weibull;
        double num1 = 0.0;
        double num2 = 0.0;
        for (int index = 0; index < length; ++index)
        {
          strArray[index] = this.GetValueFromArg(strArray[index]);
          strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
          bool result;
          strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result) ? Convert.ToInt16(result).ToString() : strArray[index];
        }
        double result1;
        double result2;
        double result3;
        if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3))
        {
          if (result1 < 0.0 || result2 <= 0.0 || result3 <= 0.0)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[4].ToString();
          }
          if (length != 3)
          {
            double result4 = 0.0;
            double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result4);
            num1 = strArray[3] == this.TRUEVALUESTR || result4 != 0.0 ? 1.0 : 0.0;
          }
          num2 = num1 != 0.0 ? 1.0 - Math.Exp(-Math.Pow(result1 / result3, result2)) : result2 / Math.Pow(result3, result2) * Math.Pow(result1, result2 - 1.0) * Math.Exp(-Math.Pow(result1 / result3, result2));
        }
        return num2.ToString();
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  public string ComputeZtest(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 2:
      case 3:
        if (!string.IsNullOrEmpty(range))
        {
          string ztest1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Range);
          if (this.ErrorStrings.Contains((object) ztest1))
            return ztest1;
          for (int index = 1; index < length; ++index)
          {
            if (index <= length - 1)
            {
              string ztest2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
              if (this.ErrorStrings.Contains((object) ztest2))
                return ztest2;
            }
          }
          string valueFromArg = this.GetValueFromArg(strArray[1]);
          double result1;
          if (!double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1))
            return this.FormulaErrorStrings[this.invalid_arguments];
          double[] doubleArray = this.GetDoubleArray(strArray[0]);
          double xbar;
          double result2 = this.sd(doubleArray, out xbar);
          if (length == 3)
            double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result2);
          return (1.0 - this.normaldist((xbar - result1) / (result2 / Math.Sqrt((double) doubleArray.GetLength(0))), 0.0, 1.0)).ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeMax(string range)
  {
    double val1 = double.MinValue;
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.Length == 1 && !range.StartsWith(this.TIC) && string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    foreach (string str in strArray)
    {
      double result1;
      if (str.IndexOf(':') > -1)
      {
        if (this.IsRange(str))
        {
          if (str.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
          foreach (string cellsFromArg in this.GetCellsFromArgs(str))
          {
            string valueFromArg;
            try
            {
              valueFromArg = this.GetValueFromArg(cellsFromArg);
              DateTime result2;
              if (valueFromArg != null && DateTime.TryParse(valueFromArg.Replace(this.TIC, string.Empty), (IFormatProvider) null, DateTimeStyles.None, out result2) && !double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1))
                valueFromArg = this.GetSerialDateTimeFromDate(result2).ToString();
              if (this.ErrorStrings.Contains((object) valueFromArg))
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                return valueFromArg;
              }
            }
            catch (Exception ex)
            {
              this.ExceptionThrown = true;
              if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                throw this.LibraryComputationException;
              return ex.Message;
            }
            if (valueFromArg.Length > 0)
            {
              if (double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
                val1 = Math.Max(val1, result1);
              else if (this.ErrorStrings.Contains((object) valueFromArg))
                return valueFromArg;
            }
          }
          continue;
        }
      }
      string s;
      try
      {
        if (!str.StartsWith(this.TIC) && string.IsNullOrEmpty(str))
        {
          s = "0";
        }
        else
        {
          string valueFromArg = this.GetValueFromArg(str);
          bool result3;
          s = !bool.TryParse(valueFromArg, out result3) || this.IsCellReference(str) ? valueFromArg : Convert.ToInt16(result3).ToString();
          DateTime result4;
          if (s != null && this.TryParseExactDateTime(s.Replace(this.TIC, string.Empty), out result4))
            s = (this.GetSerialDateTimeFromDate(result4) - this.GetSerialDateTimeFromDate(DateTime.Today)).ToString();
          if (s != null && DateTime.TryParse(s.Replace(this.TIC, string.Empty), (IFormatProvider) null, DateTimeStyles.None, out result4) && !double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result1))
            s = this.GetSerialDateTimeFromDate(result4).ToString();
          if (this.ErrorStrings.Contains((object) s))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return s;
          }
          if (s == string.Empty)
          {
            if (this.treatStringsAsZero)
            {
              if (!this.IsCellReference(str))
                s = "0";
            }
          }
        }
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return ex.Message;
      }
      if (s.Length > 0)
      {
        if (double.TryParse(s.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
          val1 = Math.Max(val1, result1);
        else if (s.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
      }
    }
    return val1 != double.MinValue ? val1.ToString() : "0";
  }

  public string ComputeMINIFS(string argList) => this.CalculateIFSFormula(argList, "MINIFS");

  public string ComputeMAXIFS(string argList) => this.CalculateIFSFormula(argList, "MAXIFS");

  public string ComputeSubTotal(string args)
  {
    string empty1 = string.Empty;
    int num = 0;
    string[] strArray = this.SplitArguments(args, CalcEngine.ParseArgumentSeparator);
    if (strArray.GetLength(0) < 2 || string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double result;
    if (double.TryParse(!this.IsCellReference(strArray[0]) ? strArray[0] : this.GetValueFromArg(strArray[0]), out result))
    {
      num = (int) result;
      if ((num < 1 || num > 11) && (num < 101 || num > 111))
        return this.ErrorStrings[1].ToString();
    }
    if (this.IgnoreSubtotal)
      return string.Empty;
    string range = args.Remove(0, strArray[0].Length + 1);
    this.IgnoreSubtotal = true;
    string empty2 = string.Empty;
    string subTotal;
    switch (num)
    {
      case 1:
      case 101:
        subTotal = this.ComputeAvg(range);
        break;
      case 2:
      case 102:
        subTotal = this.ComputeCount(range);
        break;
      case 3:
      case 103:
        subTotal = this.ComputeCounta(range);
        break;
      case 4:
      case 104:
        subTotal = this.ComputeMax(range);
        break;
      case 5:
      case 105:
        subTotal = this.ComputeMin(range);
        break;
      case 6:
      case 106:
        subTotal = this.ComputeProduct(range);
        break;
      case 7:
      case 107:
        subTotal = this.ComputeStdev(range);
        break;
      case 8:
      case 108:
        subTotal = this.ComputeStdevp(range);
        break;
      case 9:
      case 109:
        subTotal = this.ComputeSum(range);
        break;
      case 10:
      case 110:
        subTotal = this.ComputeVar(range);
        break;
      case 11:
      case 111:
        subTotal = this.ComputeVarp(range);
        break;
      default:
        subTotal = this.ErrorStrings[1].ToString();
        break;
    }
    this.IgnoreSubtotal = false;
    return subTotal;
  }

  public string ComputeMin(string range)
  {
    double val1 = double.MaxValue;
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    foreach (string str in strArray)
    {
      double result1;
      if (str.IndexOf(':') > -1)
      {
        if (this.IsRange(str))
        {
          if (str.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
          foreach (string cellsFromArg in this.GetCellsFromArgs(str))
          {
            string valueFromArg;
            try
            {
              valueFromArg = this.GetValueFromArg(cellsFromArg);
              DateTime result2;
              if (valueFromArg != null && DateTime.TryParse(valueFromArg.Replace(this.TIC, string.Empty), (IFormatProvider) null, DateTimeStyles.None, out result2) && !double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1))
                valueFromArg = this.GetSerialDateTimeFromDate(result2).ToString();
              if (this.ErrorStrings.Contains((object) valueFromArg))
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                return valueFromArg;
              }
            }
            catch (Exception ex)
            {
              this.ExceptionThrown = true;
              if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
                throw this.LibraryComputationException;
              return ex.Message;
            }
            if (valueFromArg.Length > 0 && double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
              val1 = Math.Min(val1, result1);
          }
          continue;
        }
      }
      string s;
      try
      {
        if (!str.StartsWith(this.TIC) && string.IsNullOrEmpty(str))
        {
          s = "0";
        }
        else
        {
          string valueFromArg = this.GetValueFromArg(str);
          bool result3;
          s = !bool.TryParse(valueFromArg, out result3) || this.IsCellReference(str) ? valueFromArg : Convert.ToInt16(result3).ToString();
          DateTime result4;
          if (this.TryParseExactDateTime(s.Replace(this.TIC, string.Empty), out result4))
            s = (this.GetSerialDateTimeFromDate(result4) - this.GetSerialDateTimeFromDate(DateTime.Today)).ToString();
          else if (s != null && DateTime.TryParse(s.Replace(this.TIC, string.Empty), (IFormatProvider) null, DateTimeStyles.None, out result4) && !double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result1))
            s = this.GetSerialDateTimeFromDate(result4).ToString();
          if (this.ErrorStrings.Contains((object) s))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return s;
          }
          if (s == string.Empty)
          {
            if (!this.IsCellReference(str))
              s = "0";
          }
        }
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return ex.Message;
      }
      if (s.Length > 0)
      {
        if (double.TryParse(s.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result1))
          val1 = Math.Min(val1, result1);
        else if (s.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
      }
    }
    return val1 != double.MaxValue ? val1.ToString() : "0";
  }

  public string ComputeAvg(string range)
  {
    double num1 = 0.0;
    int num2 = 0;
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.Length < 1 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    foreach (string args in strArray)
    {
      double result;
      if (args.IndexOf(':') > -1)
      {
        if (!this.TryParseExactDateTime(args.Replace(this.TIC, string.Empty), out DateTime _))
        {
          foreach (string cellsFromArg in this.GetCellsFromArgs(args))
          {
            string valueFromArg;
            try
            {
              valueFromArg = this.GetValueFromArg(cellsFromArg);
              if (this.ErrorStrings.Contains((object) valueFromArg))
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                return valueFromArg;
              }
            }
            catch
            {
              this.ExceptionThrown = true;
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.ErrorStrings[4].ToString());
              return this.ErrorStrings[4].ToString();
            }
            if (valueFromArg.Length > 0 && double.TryParse(valueFromArg, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result))
            {
              num1 += result;
              ++num2;
            }
          }
          continue;
        }
      }
      string avg;
      try
      {
        avg = this.GetValueFromArg(args);
        if (this.ErrorStrings.Contains((object) avg))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return avg;
        }
        if (this.ExcelLikeComputations && this.useDatesInCalcs && !double.TryParse(avg.Replace(this.TIC, string.Empty), out double _))
        {
          DateTime dt;
          if (this.TryParseExactDateTime(avg.Replace(this.TIC, string.Empty), out dt))
            avg = (this.GetSerialDateTimeFromDate(dt) - this.GetSerialDateTimeFromDate(DateTime.Today)).ToString();
          else if (this.IsDate((object) avg.Replace(this.TIC, string.Empty), out dt))
            avg = this.GetSerialDateTimeFromDate(dt).ToString();
        }
        if (string.IsNullOrEmpty(args))
          avg = "0";
        if (strArray.Length == 1)
        {
          if (this.IsCellReference(args))
          {
            if (string.IsNullOrEmpty(avg))
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return this.ErrorStrings[3].ToString();
            }
          }
        }
      }
      catch
      {
        this.ExceptionThrown = true;
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (avg.Length > 0)
      {
        if (double.TryParse(avg.Replace(this.TIC, string.Empty), NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result))
        {
          num1 += result;
          ++num2;
        }
        else if (avg.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
      }
    }
    if (num2 > 0)
      num1 /= (double) num2;
    else if (num2 == 0 && num1 == 0.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[3].ToString());
      return this.ErrorStrings[3].ToString();
    }
    return num1.ToString();
  }

  public string ComputeHarmean(string range)
  {
    double num1 = 0.0;
    int num2 = 0;
    this.AdjustRangeArg(ref range);
    double result;
    foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(range))
    {
      if (preservingQuotedComma.IndexOf(':') > -1)
      {
        if (preservingQuotedComma.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma))
        {
          string valueFromArg;
          try
          {
            valueFromArg = this.GetValueFromArg(cellsFromArg);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
          if (valueFromArg.Length > 0)
          {
            if (this.ErrorStrings.Contains((object) valueFromArg))
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return valueFromArg;
            }
            if (double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result) && result != 0.0)
            {
              ++num2;
              num1 += 1.0 / result;
            }
            else if (this.ErrorStrings.Contains((object) valueFromArg))
              return valueFromArg;
          }
        }
      }
      else
      {
        string valueFromArg;
        try
        {
          valueFromArg = this.GetValueFromArg(preservingQuotedComma);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        if (valueFromArg.Length > 0)
        {
          string harmean = this.FormulaErrorStringCheck(valueFromArg, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) harmean))
            return harmean;
          if (double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result) && result != 0.0)
          {
            ++num2;
            num1 += 1.0 / result;
          }
          else if (this.ErrorStrings.Contains((object) valueFromArg))
            return valueFromArg;
        }
      }
    }
    if (num2 > 0)
      num1 = (double) num2 / num1;
    return num1.ToString();
  }

  public string ComputeHypgeomdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string hypgeomdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) hypgeomdist))
      return hypgeomdist;
    double result1 = 0.0;
    double result2 = 0.0;
    double result3 = 0.0;
    double result4 = 0.0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result5;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result5) ? Convert.ToInt16(result5).ToString() : strArray[index];
    }
    if (double.TryParse(strArray[0], NumberStyles.Integer, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Integer, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Integer, (IFormatProvider) null, out result3) && double.TryParse(strArray[3], NumberStyles.Integer, (IFormatProvider) null, out result4))
    {
      int k1 = (int) result1;
      int k2 = (int) result2;
      int n1 = (int) result3;
      int n2 = (int) result4;
      if (k1 < 0 || k2 < k1 || n1 <= 0 || n2 < n1 || k1 > n1 || k2 > n2 || k2 <= 0 || n2 <= 0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      num = this.comb(k1, n1) * this.comb(k2 - k1, n2 - n1) / this.comb(k2, n2);
    }
    return num.ToString();
  }

  public string ComputeHypgeomOdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 5)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    double result1 = 0.0;
    double result2 = 0.0;
    double result3 = 0.0;
    double result4 = 0.0;
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      int k1 = (int) result1;
      int k2 = (int) result2;
      int n1 = (int) result3;
      int n2 = (int) result4;
      if (k1 < 0 || k2 < k1 || n1 <= 0 || n2 < n1 || k1 > n1 || k2 > n2 || k2 <= 0 || n2 <= 0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (strArray[4] == this.TRUEVALUESTR)
      {
        int num2 = (int) result1;
        for (int k3 = 0; k3 <= num2; ++k3)
          num1 += this.comb(k3, n1) * this.comb(k2 - k3, n2 - n1) / this.comb(k2, n2);
      }
      else
        num1 = this.comb(k1, n1) * this.comb(k2 - k1, n2 - n1) / this.comb(k2, n2);
    }
    return !double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) || !double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) || !double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3) || !double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result4) ? this.ErrorStrings[1].ToString() : num1.ToString();
  }

  public string ComputeIf(string args)
  {
    if (string.IsNullOrEmpty(args))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string empty = string.Empty;
    if (args.Length > 0)
    {
      if (args.IndexOfAny(new char[2]
      {
        CalcEngine.ParseArgumentSeparator,
        ':'
      }) == -1)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.requires_3_args]);
        return this.FormulaErrorStrings[this.requires_3_args];
      }
    }
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    if (strArray.GetLength(0) <= 3)
    {
      string str1;
      try
      {
        double result1 = 0.0;
        if (this.IsArrayFormula && strArray[0].IndexOf(':') > -1)
        {
          string interiorFunction = this.ArrayParser.ComputeInteriorFunction(args, "IF", this.computeFunctionLevel);
          if (interiorFunction != string.Empty)
            return interiorFunction;
        }
        string s = string.IsNullOrEmpty(strArray[0]) ? "0" : this.GetValueFromArg(strArray[0]);
        if (!double.TryParse(s, out result1))
        {
          if (this.ErrorStrings.Contains((object) s))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return s;
          }
          if (!this.IsCellReference(strArray[0]) && !bool.TryParse(s.Replace(this.TIC, string.Empty), out bool _) && s.StartsWith(this.TIC) || this.IsCellReference(strArray[0]) && s.StartsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            return this.ErrorStrings[1].ToString();
          }
        }
        str1 = this.GetValueFromArg(strArray[0]);
        double result2 = 0.0;
        if (str1.Replace(this.TIC, string.Empty).ToUpper().Equals(this.TRUEVALUESTR) || double.TryParse(str1, NumberStyles.Any, (IFormatProvider) null, out result2) && result2 != 0.0)
        {
          str1 = this.computedValueLevel <= 1 || !this.IsRange(strArray[1]) || strArray[1].Contains(this.TIC) ? (!string.IsNullOrEmpty(strArray[1]) || !this.TreatStringsAsZero ? this.GetValueFromArg(strArray[1]) : "0") : strArray[1];
          if (string.IsNullOrEmpty(str1) && this.TreatStringsAsZero && this.computedValueLevel > 1)
            str1 = "0";
          else if (!string.IsNullOrEmpty(str1))
          {
            if ((int) str1[0] == (int) this.TIC[0])
            {
              if (!this.IsCellReference(strArray[1]))
              {
                if (this.UseNoAmpersandQuotes)
                  str1 = Regex.Replace(str1, "^\"|\"$", "");
              }
            }
          }
        }
        else if (strArray.Length < 3 && (str1.Replace(this.TIC, string.Empty).ToUpper().Equals(this.FALSEVALUESTR) || double.TryParse(str1, NumberStyles.Any, (IFormatProvider) null, out result2) && result2 == 0.0))
          str1 = this.FALSEVALUESTR;
        else if (str1.Replace(this.TIC, string.Empty).ToUpper().Equals(this.FALSEVALUESTR) || str1 == string.Empty || double.TryParse(str1, NumberStyles.Any, (IFormatProvider) null, out result2) && result2 == 0.0)
        {
          str1 = this.computedValueLevel <= 1 || !this.IsRange(strArray[2]) || strArray[2].Contains(this.TIC) ? (!string.IsNullOrEmpty(strArray[2]) || !this.TreatStringsAsZero ? this.GetValueFromArg(strArray[2]) : "0") : strArray[2];
          if (string.IsNullOrEmpty(str1) && this.TreatStringsAsZero && this.computedValueLevel > 1)
            str1 = "0";
          else if (!string.IsNullOrEmpty(str1))
          {
            if ((int) str1[0] == (int) this.TIC[0])
            {
              if (!this.IsCellReference(strArray[2]))
              {
                if (this.UseNoAmpersandQuotes)
                  str1 = Regex.Replace(strArray.GetLength(0) == 3 ? str1 : this.FALSEVALUESTR, "^\"|\"$", "");
              }
            }
          }
        }
        else if (strArray[0].Contains(this.TIC))
        {
          int startIndex = strArray[0].IndexOf(this.TIC) + 1;
          int num = strArray[0].LastIndexOf(this.TIC) - 1;
          string str2 = strArray[0].Substring(startIndex, num - startIndex + 1);
          foreach (string formulaErrorString in this.FormulaErrorStrings)
          {
            if (str2.Equals(formulaErrorString))
              return formulaErrorString;
          }
        }
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        return ex.Message;
      }
      return str1;
    }
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.requires_3_args]);
    return this.FormulaErrorStrings[this.requires_3_args];
  }

  public string ComputeIfError(string args)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    if (strArray.Length != 2)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string str1 = strArray[0];
    if (str1.StartsWith(this.TIC.ToString()))
      return this.GetValueFromArg(strArray[0]);
    string str2;
    try
    {
      if (str1[0] == '\u0092')
      {
        str1 = str1.Replace('\u0092', ' ');
        str1 = str1.Trim();
        if (str1.StartsWith("NAN") || str1.StartsWith("-NAN") || str1.StartsWith("INFINITY") || str1.StartsWith("-INFINITY") || str1.StartsWith("#") || str1.StartsWith("n#") || str1.StartsWith(double.PositiveInfinity.ToString()) || str1.StartsWith(double.NegativeInfinity.ToString()))
          return this.GetValueFromArg(strArray[1]);
      }
      str1 = strArray[0];
      str2 = this.GetValueFromArg(str1).ToUpper().Replace(this.TIC, string.Empty);
    }
    catch
    {
      str2 = str1.ToUpper();
    }
    return str2.StartsWith("NAN") || str2.StartsWith("-NAN") || str2.StartsWith("INFINITY") || str2.StartsWith("-INFINITY") || str2.StartsWith("#") || str2.StartsWith("n#") || str2.StartsWith(double.PositiveInfinity.ToString()) || str2.StartsWith(double.NegativeInfinity.ToString()) ? this.GetValueFromArg(strArray[1]) : this.GetValueFromArg(strArray[0]);
  }

  public string ComputeIntercept(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string intercept = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) intercept))
      return intercept;
    bool result;
    if (!this.IsRange(strArray[0]) && (string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result)) || !this.IsRange(strArray[1]) && (string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result)))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    int length = doubleArray2.GetLength(0);
    if (length <= 0 || length != doubleArray1.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    double num2 = 0.0;
    int num3 = 0;
    for (int index = 0; index < length; ++index)
    {
      if (doubleArray2[index].ToString() != double.NaN.ToString() && doubleArray1[index].ToString() != double.NaN.ToString())
      {
        ++num3;
        num1 += doubleArray2[index];
        num2 += doubleArray1[index];
      }
    }
    double num4 = num1 / (double) num3;
    double num5 = num2 / (double) num3;
    double num6 = 0.0;
    double num7 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      if (doubleArray2[index].ToString() != double.NaN.ToString() && doubleArray1[index].ToString() != double.NaN.ToString())
      {
        double num8 = doubleArray2[index] - num4;
        num6 += num8 * (doubleArray1[index] - num5);
        num7 += num8 * num8;
      }
    }
    string range1 = (num5 - num6 / num7 * num4).ToString();
    if (!(this.ComputeIsErr(range1) == this.TRUEVALUESTR))
      return range1;
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputeBinomdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    for (int index = 0; index < length - 1; ++index)
    {
      string binomdist = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) binomdist))
        return binomdist;
    }
    double result1 = 0.0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      if (index != 3)
      {
        strArray[index] = this.StripTics(strArray[index]);
        strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      }
    }
    if (strArray[3].StartsWith(this.TIC))
    {
      strArray[3] = this.StripTics(strArray[3]);
      if (strArray[3].ToUpper() != this.TRUEVALUESTR && strArray[3].ToUpper() != this.FALSEVALUESTR)
        return this.ErrorStrings[1].ToString();
    }
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 < 0.0 || result2 > result3 || result4 < 0.0 || result4 > 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result1);
      num = result1 != 0.0 || !(strArray[3].ToUpper() != this.TRUEVALUESTR) ? this.binomdist((int) result3, (int) result2, result4) : this.comb((int) result2, (int) result3) * Math.Pow(result4, result2) * Math.Pow(1.0 - result4, result3 - result2);
    }
    return num.ToString();
  }

  private double binomdist(int trials, int successes, double p)
  {
    double num1 = 1.0;
    double x = 1.0 - p;
    Math.Pow(x, (double) trials);
    double num2 = 0.0;
    double d = num1 * Math.Pow(x, (double) trials);
    if (d == 0.0)
      return double.NaN;
    for (int index = 0; index <= successes; ++index)
    {
      num2 += d;
      d = d * p / x * (double) (trials - index) / (double) (index + 1);
      if (double.IsInfinity(d) || double.IsNaN(d))
      {
        num2 = double.NaN;
        break;
      }
    }
    return num2;
  }

  public string ComputeSkewP(string range)
  {
    double[] doubleArray = this.GetDoubleArray(range);
    int length = doubleArray.GetLength(0);
    if (length < 3)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    double xbar = 0.0;
    double num1 = this.sd(doubleArray, out xbar);
    double num2 = 0.0;
    for (int index = 0; index < length; ++index)
      num2 += Math.Pow((doubleArray[index] - xbar) / num1, 3.0);
    return ((double) length * num2 / (double) (length - 1) / (double) (length - 2)).ToString();
  }

  public string ComputeCovarianceP(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string covarianceP = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) covarianceP))
      return covarianceP;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    if (doubleArray1.GetLength(0) == 1 && doubleArray2.GetLength(0) == 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[3].ToString());
      return this.ErrorStrings[3].ToString();
    }
    int length1 = doubleArray2.GetLength(0);
    if (length1 <= 0 || length1 != doubleArray1.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = this.Mean(doubleArray1);
    double num2 = this.Mean(doubleArray2);
    double num3 = 0.0;
    int length2 = doubleArray1.Length;
    for (int index = 0; index < length1; ++index)
      num3 += (doubleArray1[index] - num1) * (doubleArray2[index] - num2);
    return (num3 / (double) length2).ToString();
  }

  public string ComputeCovarianceS(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string covarianceS = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) covarianceS))
      return covarianceS;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    int length = doubleArray2.GetLength(0);
    if (doubleArray1.GetLength(0) == 1 && doubleArray2.GetLength(0) == 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[3].ToString());
      return this.ErrorStrings[3].ToString();
    }
    if (length <= 0 || length != doubleArray1.GetLength(0))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[0].ToString();
    }
    double num1 = 0.0;
    double num2 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      num1 += doubleArray2[index];
      num2 += doubleArray1[index];
    }
    double num3 = num1 / (double) length;
    double num4 = num2 / (double) length;
    double num5 = 0.0;
    for (int index = 0; index < length; ++index)
      num5 += (doubleArray2[index] - num3) * (doubleArray1[index] - num4);
    return this.Covariance(doubleArray1, doubleArray2).ToString();
  }

  public string ComputePercentileInc(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string percentileInc1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) percentileInc1))
      return percentileInc1;
    string percentileInc2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) percentileInc2))
      return percentileInc2;
    bool result1;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result1) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    string valueFromArg = this.GetValueFromArg(strArray[1]);
    double result2;
    if (!double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result2) && (result2 < 0.0 || result2 > 1.0))
      return this.FormulaErrorStrings[this.invalid_arguments];
    double num1 = Convert.ToDouble(valueFromArg);
    if (num1 == 0.0 || num1 <= 0.0 || num1 > 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    double[] doubleArray = this.GetDoubleArray(strArray[0]);
    int length = doubleArray.GetLength(0);
    Array.Sort<double>(doubleArray);
    double num2 = 1.0 / (double) (length - 1);
    double num3 = doubleArray[length - 1];
    for (int index = 0; index < length - 1; ++index)
    {
      if ((double) (index + 1) * num2 > result2)
      {
        double num4 = (result2 - (double) index * num2) / num2;
        num3 = doubleArray[index] + num4 * (doubleArray[index + 1] - doubleArray[index]);
        break;
      }
    }
    return num3.ToString();
  }

  public string ComputePercentrankExc(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length1 = strArray.GetLength(0);
    switch (length1)
    {
      case 2:
      case 3:
        double result1 = 3.0;
        double result2;
        if (!double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Any, (IFormatProvider) null, out result2))
          return this.FormulaErrorStrings[this.invalid_arguments];
        if (result2 == 0.0)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[4].ToString());
          return this.ErrorStrings[4].ToString();
        }
        if (length1 == 3 && !double.TryParse(this.GetValueFromArg(strArray[2]), NumberStyles.Integer, (IFormatProvider) null, out result1) && result1 < 1.0)
          return this.FormulaErrorStrings[this.invalid_arguments];
        double[] doubleArray = this.GetDoubleArray(strArray[0]);
        int length2 = doubleArray.GetLength(0);
        Array.Sort<double>(doubleArray);
        double num1 = 1.0;
        for (int index = 0; index < length2; ++index)
        {
          if (doubleArray[index] == result2)
          {
            int num2 = 0;
            while (num2 + index < length2 && doubleArray[num2 + index] == result2)
              ++num2;
            num1 = (double) (index - 1) / (double) (index + length2 - index - num2 - 1);
            if (index > 0 && doubleArray[index - 1] < result2)
            {
              double num3 = (double) index / (double) (length2 - 1);
              num1 = num3 + (num1 - num3) * (1.0 - (result2 - doubleArray[index - 1]) / (doubleArray[index] - doubleArray[index - 1]));
              break;
            }
            break;
          }
        }
        string format = "0." + new string('#', (int) result1);
        return num1.ToString(format);
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  public string ComputePercentileExc(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string percentileExc1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) percentileExc1))
      return percentileExc1;
    string percentileExc2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) percentileExc2))
      return percentileExc2;
    bool result1;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result1) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    string valueFromArg = this.GetValueFromArg(strArray[1]);
    double result2;
    if (!double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result2) && (result2 <= 0.0 || result2 >= 1.0))
      return this.FormulaErrorStrings[this.invalid_arguments];
    double num = Convert.ToDouble(valueFromArg);
    if (num == 0.0 || num <= 0.0 || num >= 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    double[] doubleArray = this.GetDoubleArray(strArray[0]);
    doubleArray.GetLength(0);
    Array.Sort<double>(doubleArray);
    int length = doubleArray.GetLength(0);
    if (result2 > (double) (1 / (length + 1)) || result2 < (double) (length / (length + 1)))
      return (result2 * (double) (length + 1)).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[4].ToString());
    return this.ErrorStrings[4].ToString();
  }

  public string ComputePercentrankInc(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length1 = strArray.GetLength(0);
    switch (length1)
    {
      case 2:
      case 3:
        double result1 = 3.0;
        double result2;
        if (!double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Any, (IFormatProvider) null, out result2))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
          return this.FormulaErrorStrings[this.invalid_arguments];
        }
        if (length1 == 3 && !double.TryParse(this.GetValueFromArg(strArray[2]), NumberStyles.Integer, (IFormatProvider) null, out result1) && result1 < 1.0)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
          return this.FormulaErrorStrings[this.invalid_arguments];
        }
        string min = this.ComputeMin(strArray[0].Replace(this.TIC, string.Empty));
        string max = this.ComputeMax(strArray[0].Replace(this.TIC, string.Empty));
        double result3;
        double result4;
        if (double.TryParse(min, out result3) && double.TryParse(max, out result4) && (result3 > result2 || result4 < result2))
          return this.ErrorStrings[0].ToString();
        double[] doubleArray = this.GetDoubleArray(strArray[0]);
        int length2 = doubleArray.GetLength(0);
        Array.Sort<double>(doubleArray);
        double num1 = 1.0;
        for (int index = 0; index < length2; ++index)
        {
          if (doubleArray[index] >= result2)
          {
            int num2 = 0;
            while (num2 + index < length2 && doubleArray[num2 + index] == result2)
              ++num2;
            num1 = (double) (index - 1) / (double) (index + length2 - index - num2 - 1);
            if (index > 0 && doubleArray[index - 1] < result2)
            {
              double num3 = (double) index / (double) (length2 - 1);
              num1 = num3 + (num1 - num3) * (1.0 - (result2 - doubleArray[index - 1]) / (doubleArray[index] - doubleArray[index - 1]));
              break;
            }
            break;
          }
        }
        string format = "0." + new string('#', (int) result1);
        return num1.ToString(format);
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  private double sdP(double[] x, out double xbar)
  {
    int length = x.GetLength(0);
    xbar = 0.0;
    for (int index = 0; index < length; ++index)
      xbar += x[index];
    xbar /= (double) length;
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num2 = x[index] - xbar;
      num1 += num2 * num2;
    }
    return Math.Sqrt(num1 / (double) length);
  }

  public string ComputeStdevaS(string range)
  {
    double[] doubleArrayA = this.GetDoubleArrayA(range);
    if (doubleArrayA.GetLength(0) < 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    double xbar = 0.0;
    return this.sd(doubleArrayA, out xbar).ToString();
  }

  public string ComputeVarPAdv(string range)
  {
    double[] doubleArrayA = this.GetDoubleArrayA(range);
    int length = doubleArrayA.GetLength(0);
    return ((double) (length - 1) * this.var(doubleArrayA) / (double) length).ToString();
  }

  public string ComputeVarSAdv(string range)
  {
    double[] doubleArrayA = this.GetDoubleArrayA(range);
    int length = doubleArrayA.GetLength(0);
    return ((double) (length - 1) * this.var(doubleArrayA) / (double) length - 1.0).ToString();
  }

  public string ComputePermutationA(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string permutationA = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) permutationA))
      return permutationA;
    strArray[0] = this.GetValueFromArg(strArray[0]);
    strArray[1] = this.GetValueFromArg(strArray[1]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    int result2;
    int result3;
    if (!int.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) || !int.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3))
      return this.FormulaErrorStrings[this.invalid_arguments];
    if (result2 == 0 && result3 < 0 || result2 < 0 || result3 < 0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    string range = Math.Pow((double) result2, (double) result3).ToString();
    if (!(this.ComputeIsErr(range) == this.TRUEVALUESTR))
      return range;
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeNormOdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string normOdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) normOdist))
      return normOdist;
    double num1 = 0.0;
    double num2 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result) ? Convert.ToInt16(result).ToString() : strArray[index];
    }
    double result1;
    double result2;
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3))
    {
      if (result3 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (length != 3)
        num1 = strArray[3] == this.TRUEVALUESTR ? 1.0 : 0.0;
      num2 = num1 != 0.0 ? this.normaldist(result1, result2, result3) : this.normaldensity(result1, result2, result3);
    }
    return num2.ToString();
  }

  public string ComputeNormOinv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string normOinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) normOinv))
      return normOinv;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 >= 1.0 || result2 <= 0.0 || result4 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments] + this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      num = this.NormalCumulativeDistributionFunctionInverse(result2, result3, result4);
    }
    return num.ToString();
  }

  public string ComputeNormOsODist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 1:
      case 2:
        if (!string.IsNullOrEmpty(argList))
        {
          string normOsOdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) normOsOdist))
            return normOsOdist;
          double num = 0.0;
          for (int index = 0; index < length; ++index)
            strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
          double result1;
          if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1))
          {
            if (length == 2)
            {
              num = strArray[1] == this.TRUEVALUESTR ? 1.0 : 0.0;
              double result2 = 0.0;
              if (double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2))
                num = 1.0;
            }
            return (num != 0.0 ? this.StandardNormalCumulativeDistributionFunction(result1) : this.StandardNormalProbabilityDensity(result1)).ToString();
          }
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException("#VALUE! Passed argument value is non numeric");
          return this.ErrorStrings[1].ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public double StandardNormalProbabilityDensity(double x)
  {
    return 0.398942280401433 * Math.Exp(-0.5 * x * x);
  }

  public double StandardNormalCumulativeDistributionFunction(double x)
  {
    if (x < 0.0)
      return 1.0 - this.StandardNormalCumulativeDistributionFunction(-x);
    double num = this.StandardNormalProbabilityDensityFunction(x);
    double x1 = 1.0 / (1.0 + 0.2316419 * x);
    return 1.0 - num * (0.31938153 * x1 + -0.356563782 * Math.Pow(x1, 2.0) + 1.781477937 * Math.Pow(x1, 3.0) + -1.821255978 * Math.Pow(x1, 4.0) + 1.330274429 * Math.Pow(x1, 5.0));
  }

  private double StandardNormalProbabilityDensityFunction(double x)
  {
    return 0.398942280401433 * Math.Exp(-0.5 * x * x);
  }

  public double StandardNormalCumulativeDistribution(double x)
  {
    if (x < 0.0)
      return 1.0 - this.StandardNormalCumulativeDistribution(-x);
    double num = this.StandardNormalProbabilityDensityFunction(x);
    double x1 = 1.0 / (1.0 + 0.2316419 * x);
    return 1.0 - num * (0.31938153 * x1 + -0.356563782 * Math.Pow(x1, 2.0) + 1.781477937 * Math.Pow(x1, 3.0) + -1.821255978 * Math.Pow(x1, 4.0) + 1.330274429 * Math.Pow(x1, 5.0));
  }

  public double StandardNormalCumulativeDistributionFunctionInverse(double p)
  {
    if (p < 0.0 || p > 1.0)
      throw new ArgumentException("Probability must be between 0 and 1");
    if (p == 0.0)
      return double.NegativeInfinity;
    if (p == 1.0)
      return double.PositiveInfinity;
    if (p == 0.5)
      return 0.0;
    if (0.0 < p && p < 0.02425)
    {
      double num = Math.Sqrt(-2.0 * Math.Log(p));
      return (((((-0.0077848940024302926 * num - 0.32239645804113648) * num - 2.4007582771618381) * num - 2.5497325393437338) * num + 4.3746641414649678) * num + 2.9381639826987831) / ((((0.0077846957090414622 * num + 0.32246712907003983) * num + 2.445134137142996) * num + 3.7544086619074162) * num + 1.0);
    }
    if (0.02425 <= p && p <= 0.97575)
    {
      double num1 = p - 0.5;
      double num2 = num1 * num1;
      return (((((-39.696830286653757 * num2 + 220.9460984245205) * num2 - 275.92851044696869) * num2 + 138.357751867269) * num2 - 30.66479806614716) * num2 + 2.5066282774592392) * num1 / (((((-54.476098798224058 * num2 + 161.58583685804089) * num2 - 155.69897985988661) * num2 + 66.80131188771972) * num2 - 13.280681552885721) * num2 + 1.0);
    }
    double num3 = Math.Sqrt(-2.0 * Math.Log(1.0 - p));
    return -(((((-0.0077848940024302926 * num3 - 0.32239645804113648) * num3 - 2.4007582771618381) * num3 - 2.5497325393437338) * num3 + 4.3746641414649678) * num3 + 2.9381639826987831) / ((((0.0077846957090414622 * num3 + 0.32246712907003983) * num3 + 2.445134137142996) * num3 + 3.7544086619074162) * num3 + 1.0);
  }

  public string ComputeNormOsOInv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string normOsOinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) normOsOinv))
      return normOsOinv;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    double result2;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result2 <= 0.0 || result2 >= 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("#NUM! Passed argument value doesnot match with in range level");
        return this.ErrorStrings[4].ToString();
      }
      num = this.StandardNormalCumulativeDistributionFunctionInverse(result2);
    }
    return num.ToString();
  }

  public string ComputeWeiBullODist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double num = 0.0;
    for (int index = 0; index < length - 1; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    double result1;
    double result2;
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3))
    {
      if (result1 < 0.0 || result2 <= 0.0 || result3 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Passed argument value is below 0");
        return this.errorStrings[4].ToString();
      }
      if (result2.ToString().Length >= 5 && result3.ToString().Length >= 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Passed argument length exceeded the minimum length");
        return this.errorStrings[4].ToString();
      }
      if (length != 3)
      {
        num = strArray[3] == this.TRUEVALUESTR ? 1.0 : 0.0;
        double result4 = 0.0;
        if (double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result4))
          num = 1.0;
      }
      return (num == 1.0 ? 1.0 - Math.Exp(-Math.Pow(result1 / result3, result2)) : Math.Pow(result1, result2 - 1.0) * Math.Exp(-Math.Pow(result1 / result3, result2)) * result2 / Math.Pow(result3, result2)).ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException("Passed argument value is non-numerical");
    return this.errorStrings[1].ToString();
  }

  public string ComputeExponODist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.errorStrings[4].ToString();
    }
    string exponOdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) exponOdist))
      return exponOdist;
    double result1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result2;
      strArray[index] = bool.TryParse(strArray[index], out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
    }
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (result3 >= 0.0 && result4 > 0.0)
        return (result1 != 0.0 ? 1.0 - Math.Exp(-result4 * result3) : result4 * Math.Exp(-result4 * result3)).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Passed argument value is below or equal to 0");
      return this.errorStrings[4].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException("Passed argument value is non-numerical");
    return this.errorStrings[1].ToString();
  }

  private double GammaInv(double p, double a, double b)
  {
    p = 1.0 - p;
    double beginX = 0.0;
    double endX = 4.5035996273705E+15;
    double beginY = 0.0;
    double endY = 1.0;
    double di = 1.0 / (9.0 * a);
    double num1 = 1.0 - di - this.StandardNormalCumulativeDistributionFunctionInverse(p) * Math.Sqrt(di);
    double result = a * num1 * num1 * num1;
    int num2 = 1;
    while (num2 != 0)
    {
      switch (num2 - 1)
      {
        case 0:
          num2 = this.GammaInvInitialState(a, p, ref beginX, ref beginY, ref endX, ref endY, ref di, ref result);
          continue;
        case 1:
          num2 = this.GammaInvMiddleState(a, p, ref beginX, ref beginY, ref endX, ref endY, ref di, ref result);
          continue;
        case 2:
          num2 = this.GammaInvFinalState(a, p, ref beginX, ref beginY, ref endX, ref endY, ref di, ref result);
          continue;
        default:
          continue;
      }
    }
    return result * b;
  }

  private int GammaInvInitialState(
    double a,
    double p,
    ref double beginX,
    ref double beginY,
    ref double endX,
    ref double endY,
    ref double di,
    ref double result)
  {
    for (int index = 0; index < 10; ++index)
    {
      if (result > endX || result < beginX)
      {
        di = 1.0 / 16.0;
        break;
      }
      double num = this.GammaInvUpperIncomplete(a, result);
      if (num < beginY || num > endY)
      {
        di = 1.0 / 16.0;
        break;
      }
      if (num < p)
      {
        endX = result;
        beginY = num;
      }
      else
      {
        beginX = result;
        endY = num;
      }
      di = (a - 1.0) * Math.Log(result) - result - this.GammaLn(a);
      if (di < -709.782712893384)
      {
        di = 1.0 / 16.0;
        break;
      }
      di = (num - p) / -Math.Exp(di);
      if (Math.Abs(di / result) < 1E-15)
        return 0;
      result -= di;
    }
    return 2;
  }

  private int GammaInvMiddleState(
    double a,
    double p,
    ref double beginX,
    ref double beginY,
    ref double endX,
    ref double endY,
    ref double di,
    ref double result)
  {
    if (endX == 4.5035996273705E+15)
    {
      if (result <= 0.0)
        result = 1.0;
      while (endX == 4.5035996273705E+15)
      {
        result = (1.0 + di) * result;
        double num = this.GammaInvUpperIncomplete(a, result);
        if (num < p)
        {
          endX = result;
          beginY = num;
          break;
        }
        di *= 2.0;
      }
    }
    return 3;
  }

  private int GammaInvFinalState(
    double a,
    double p,
    ref double beginX,
    ref double beginY,
    ref double endX,
    ref double endY,
    ref double di,
    ref double result)
  {
    di = 0.5;
    double num1 = 0.0;
    for (int index = 0; index < 400; ++index)
    {
      result = beginX + di * (endX - beginX);
      double num2 = this.GammaInvUpperIncomplete(a, result);
      if (Math.Abs((endX - beginX) / (beginX + endX)) >= 5.0000000000000008E-15 && Math.Abs((num2 - p) / p) >= 5.0000000000000008E-15 && result > 0.0)
      {
        if (num2 >= p)
        {
          beginX = result;
          endY = num2;
          if (num1 < 0.0)
          {
            di = 0.5;
            num1 = 0.0;
          }
          else
            di = num1 > 1.0 ? 0.5 * di + 0.5 : (p - beginY) / (endY - beginY);
          ++num1;
        }
        else
        {
          endX = result;
          beginY = num2;
          if (di > 0.0)
          {
            di = 0.5;
            num1 = 0.0;
          }
          else
            di = num1 < -1.0 ? 0.5 * di : (p - beginY) / (endY - beginY);
          --num1;
        }
      }
      else
        break;
    }
    return 0;
  }

  private double GammaInvUpperIncomplete(double a, double x)
  {
    double num = Math.Exp(a * Math.Log(x) - x - this.GammaLn(a));
    return x < 1.0 || x < a ? 1.0 - num * this.GammaLowerIncomplete(a, x) : num * this.GammaUpperIncomplete(a, x);
  }

  private double GammaLowerIncomplete(double a, double x)
  {
    double num1 = a;
    double num2 = 1.0;
    double num3 = 1.0;
    do
    {
      ++num1;
      num2 *= x / num1;
      num3 += num2;
    }
    while (num2 / num3 > 1E-15);
    return num3 / a;
  }

  private double GammaUpperIncomplete(double a, double x)
  {
    double num1 = 1.0 - a;
    double num2 = x + num1 + 1.0;
    double num3 = 0.0;
    double num4 = x + 1.0;
    double num5 = 1.0;
    double num6 = num2 * x;
    double num7 = x;
    double num8 = num4 / num6;
    double num9 = 1.0;
    do
    {
      ++num3;
      ++num1;
      num2 += 2.0;
      double num10 = num1 * num3;
      double num11 = num4 * num2 - num5 * num10;
      double num12 = num6 * num2 - num7 * num10;
      if (num12 != 0.0)
      {
        num9 = Math.Abs((num12 * num8 - num11) / num11);
        num8 = num11 / num12;
      }
      num5 = num4;
      num4 = num11;
      num7 = num6;
      num6 = num12;
      if (Math.Abs(num11) > 4.5035996273705E+15)
      {
        num5 *= 2.2204460492503131E-16;
        num4 *= 2.2204460492503131E-16;
        num7 *= 2.2204460492503131E-16;
        num6 *= 2.2204460492503131E-16;
      }
    }
    while (num9 > 1E-15);
    return num8;
  }

  private double GammaDistCummulative(double a, double b, double x)
  {
    x /= b;
    if (x == 0.0)
      return 0.0;
    double num = Math.Exp(a * Math.Log(x) - x - this.GammaLn(a));
    return x > 1.0 && x > a ? 1.0 - num * this.GammaUpperIncomplete(a, x) : num * this.GammaLowerIncomplete(a, x);
  }

  private double GammaDistProbability(double a, double b, double x)
  {
    return x == 0.0 ? 0.0 : Math.Exp(-this.GammaLn(a) - a * Math.Log(b) + (a - 1.0) * Math.Log(x) - x / b);
  }

  public string ComputeGammadist(string argList) => this.ComputeGammaOdist(argList);

  public string ComputeGammainv(string argList) => this.ComputeGammaOinv(argList);

  public string ComputeGeomean(string range)
  {
    double x = 1.0;
    int num = 0;
    this.AdjustRangeArg(ref range);
    double result;
    foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(range))
    {
      if (preservingQuotedComma.IndexOf(':') > -1)
      {
        if (preservingQuotedComma.StartsWith(this.TIC))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        foreach (string cellsFromArg in this.GetCellsFromArgs(preservingQuotedComma))
        {
          string valueFromArg;
          try
          {
            valueFromArg = this.GetValueFromArg(cellsFromArg);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
              throw this.LibraryComputationException;
            return ex.Message;
          }
          if (valueFromArg.Length > 0)
          {
            if (this.ErrorStrings.Contains((object) valueFromArg))
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return valueFromArg;
            }
            if (double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result))
            {
              ++num;
              x *= result;
            }
            else if (this.ErrorStrings.Contains((object) valueFromArg))
              return valueFromArg;
          }
        }
      }
      else
      {
        string valueFromArg;
        try
        {
          valueFromArg = this.GetValueFromArg(preservingQuotedComma);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
            throw this.LibraryComputationException;
          return ex.Message;
        }
        if (valueFromArg.Length > 0)
        {
          string geomean = this.FormulaErrorStringCheck(valueFromArg, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) geomean))
            return geomean;
          if (double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result))
          {
            ++num;
            x *= result;
          }
          else if (this.ErrorStrings.Contains((object) valueFromArg))
            return valueFromArg;
        }
      }
    }
    if (num > 0)
      x = Math.Pow(x, 1.0 / (double) num);
    return x.ToString();
  }

  public string ComputeGammaOdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 3:
      case 4:
        if (!string.IsNullOrEmpty(argList))
        {
          string gammaOdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) gammaOdist))
            return gammaOdist;
          double result1 = 0.0;
          if (strArray[3].StartsWith(this.TIC) && strArray[3].EndsWith(this.TIC))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException("Check argument value");
            return this.errorStrings[1].ToString();
          }
          for (int index = 0; index < length; ++index)
          {
            strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
            strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
            bool result2;
            strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
          }
          double result3;
          double result4;
          double result5;
          if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result5))
          {
            if (result3 < 0.0 || result4 <= 0.0 || result5 <= 0.0)
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException("Passed argument value is below 0");
              return this.errorStrings[4].ToString();
            }
            double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result1);
            return (result1 != 0.0 ? this.GammaDistCummulative(result4, result5, result3) : this.GammaDistProbability(result4, result5, result3)).ToString();
          }
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException("Passed argument value is non-numerical");
          return this.errorStrings[1].ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeGammaOinv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string gammaOinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) gammaOinv))
      return gammaOinv;
    double result1 = 0.0;
    double result2 = 0.0;
    double result3 = 0.0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result4;
    strArray[0] = bool.TryParse(strArray[0], out result4) ? Convert.ToInt16(result4).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result4) ? Convert.ToInt16(result4).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result4) ? Convert.ToInt16(result4).ToString() : strArray[2];
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3))
    {
      if (result1 < 0.0 || result1 >= 1.0 || result2 <= 0.0 || result3 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (result1 == 0.0)
        return "0";
      num = this.GammaInv(result1, result2, result3);
    }
    return num <= 0.0 ? "#N/A" : num.ToString();
  }

  public string ComputeGammaln0Precise(string argList)
  {
    if (this.SplitArgsPreservingQuotedCommas(argList).Length > 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string gammaln0Precise = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) gammaln0Precise))
      return gammaln0Precise;
    argList = this.GetValueFromArg(argList);
    bool result1;
    argList = bool.TryParse(argList, out result1) ? Convert.ToInt16(result1).ToString() : argList;
    double result2 = 0.0;
    if (double.TryParse(argList, NumberStyles.Any, (IFormatProvider) null, out result2) && result2 == 1.0)
      return "0";
    if (result2 > 0.0)
      return this.GammaLn(result2).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeTOInv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string toInv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) toInv))
      return toInv;
    int result1 = 0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result2;
    strArray[0] = bool.TryParse(strArray[0], out result2) ? Convert.ToInt16(result2).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result2) ? Convert.ToInt16(result2).ToString() : strArray[1];
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && int.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (result1 < 1 || result3 < 0.0 || result3.ToString().StartsWith("-"))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception("#NUM! Passed argument value is incorrect");
        return this.errorStrings[4].ToString();
      }
      double num = this.TCumulativeDistributionInverse(result3, result1);
      if (!(this.ComputeIsErr(num.ToString()) == this.TRUEVALUESTR))
        return num.ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[3].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new Exception("#VALUE! Passed argument value is incorrect");
    return this.errorStrings[1].ToString();
  }

  private double TCumulativeDistributionInverse(double p, int k)
  {
    if (p < 0.0 || p > 1.0)
      throw new ArgumentException("Probability must be between 0 and 1");
    if (p == 0.0)
      return double.NegativeInfinity;
    if (p == 1.0)
      return double.PositiveInfinity;
    if (p == 0.5)
      return 0.0;
    switch (k)
    {
      case 1:
        return Math.Tan(Math.PI * (p - 0.5));
      case 2:
        double num1 = 4.0 * p * (1.0 - p);
        return 2.0 * (p - 0.5) * Math.Sqrt(2.0 / num1);
      case 4:
        double d = Math.Sqrt(4.0 * p * (1.0 - p));
        double num2 = Math.Cos(1.0 / 3.0 * Math.Acos(d)) / d;
        return (double) (Math.Sign(p - 0.5) * 2) * Math.Sqrt(num2 - 1.0);
      default:
        double x = k <= 6 ? this.TCumulativeDistributionInverse(p, 4) : this.StandardNormalCumulativeDistributionFunctionInverse(p);
        for (int index = 0; index < 10; ++index)
        {
          double num3 = this.TCumulativeDensity(x, k);
          if (Math.Abs(p - num3) < 0.0001)
            return x;
          double num4 = this.TProbabilityDensity(x, k);
          x += (p - num3) / num4;
        }
        throw new Exception("Solution did not converge");
    }
  }

  private double TProbabilityDensity(double x, int k)
  {
    return CalcEngine.GammaFunction(0.5 * (double) k + 0.5) * Math.Pow(1.0 + x * x / (double) k, -0.5 * (double) k - 0.5) / (Math.Sqrt((double) k * Math.PI) * CalcEngine.GammaFunction(0.5 * (double) k));
  }

  private double TCumulativeDensity(double x, int k)
  {
    if (double.IsNaN(x))
      return double.NaN;
    if (x == 0.0)
      return 0.5;
    return x > 0.0 ? 1.0 - 0.5 * this.RIBetaFunction((double) k / (x * x + (double) k), 0.5 * (double) k, 0.5) : 1.0 - this.TCumulativeDensity(-x, k);
  }

  public string ComputeFOinvORt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string foinvOrt = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) foinvOrt))
      return foinvOrt;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && result2 > 0.0 && result2 < 1.0 && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 < 0.0 || result2 > 1.0 || result3 < 1.0 || result4 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Passed Argument value is less than or equal to minimum value");
        return this.ErrorStrings[4].ToString();
      }
      num = this.finv(result2, (int) result3, (int) result4);
    }
    if (num > 0.0)
      return num.ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.iterations_dont_converge]);
    return this.FormulaErrorStrings[this.iterations_dont_converge];
  }

  public string ComputeBinomOInv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string binomOinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) binomOinv))
      return binomOinv;
    double result1 = 0.0;
    string str = this.GetValueFromArg(strArray[0]);
    string valueFromArg1 = this.GetValueFromArg(strArray[1]);
    string valueFromArg2 = this.GetValueFromArg(strArray[2]);
    if (string.IsNullOrEmpty(str))
      strArray[0] = str = "0";
    if (string.IsNullOrEmpty(valueFromArg1) || string.IsNullOrEmpty(valueFromArg2))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("invalid expression");
      return this.ErrorStrings[4].ToString();
    }
    double result2;
    double.TryParse(str.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result2);
    double result3;
    double.TryParse(valueFromArg1.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result3);
    double.TryParse(valueFromArg2.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result1);
    if (result2 == 0.0)
      return "0";
    if (result2 < 0.0 || result3 <= 0.0 || result3 >= 1.0 || result1 <= 0.0 || result1 >= 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("invalid expression");
      return this.ErrorStrings[4].ToString();
    }
    if (result3 > 0.0 && result3 < 1.0 && result1 >= 0.0 && result1 < 1.0)
    {
      int num = this.critbinom((int) result2, result3, result1);
      if (num != int.MaxValue)
        return num.ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Calculation overflow");
      return this.FormulaErrorStrings[this.calculation_overflow];
    }
    if (result2 <= 0.0 || result3 <= 0.0 || result3 >= 1.0 || result1 < 0.0 || result1 > 1.0)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("Passed argument value is different from minimum par");
      return this.ErrorStrings[4].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException("Passed argument value is incorrect");
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeLognormOinv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string lognormOinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) lognormOinv))
      return lognormOinv;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 < 0.0 || result2 > 1.0 || result4 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Numerator and denominator should not be less than one");
        return this.ErrorStrings[4].ToString();
      }
      num = Math.Exp(this.normalinv(result2, result3, result4));
    }
    return num.ToString();
  }

  public string ComputeLognormOdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TRUEVALUESTR, string.Empty);
    double result1;
    double result2;
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3))
    {
      if (result1 > 0.0 && result3 > 0.0)
        return (!(strArray[3] == this.FALSEVALUESTR) ? this.StandardNormalCumulativeDistribution((Math.Log(result1) - result2) / result3) : Math.Exp(-(Math.Pow(Math.Log(result1) - result2, 2.0) / (2.0 * Math.Pow(result3, 2.0)))) / result1 * result2 * Math.Sqrt(2.0 * Math.PI)).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("#Num! Passsed value is incorrect");
      return this.ErrorStrings[4].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException("#Value! Passsed value is non - numeric");
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeConfidenceOnorm(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new Exception("Wrong number of arguments");
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string confidenceOnorm = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) confidenceOnorm))
      return confidenceOnorm;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 <= 0.0 || result2 >= 1.0 || result3 <= 0.0 || result4 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Passed argument value is different from minimum par");
        return this.ErrorStrings[4].ToString();
      }
      num = (this.ExcelLikeComputations ? this.newnormalinv(1.0 - result2 + result2 / 2.0) : this.normalinv(1.0 - result2 + result2 / 2.0, 0.0, 1.0)) * result3 / Math.Sqrt(result4);
    }
    return num.ToString();
  }

  public string ComputeChisqOdistORt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string chisqOdistOrt = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) chisqOdistOrt))
      return chisqOdistOrt;
    double d = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    double result1;
    double result2;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result1 < 0.0 || result2 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (result1 == 0.0)
        return result2.ToString();
      if (result2 == 1.0)
      {
        int num1 = this.excelLikeComputations ? 1 : 0;
      }
      d = 1.0 - this.chidist(result1, result2);
      int num2 = 0;
      while (num2 < d.ToString().Length)
        ++num2;
      Math.Round((Decimal) d);
    }
    return d.ToString();
  }

  public string ComputeFOdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    int result1 = 0;
    int result2 = 0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && int.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result1) && int.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result1 < 1 || result2 < 1 || result3.ToString().StartsWith("-"))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception("#NUM! Passed argument value is incorrect");
        return this.errorStrings[4].ToString();
      }
      if (strArray[3] == this.TRUEVALUESTR)
        num = this.FCumulativeDensity(result3, result1, result2);
      else if (strArray[3] == this.FALSEVALUESTR)
        num = this.FProbabilityDensity(result3, result1, result2);
      return num.ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new Exception("#VALUE! Passed argument value is incorrect");
    return this.errorStrings[1].ToString();
  }

  private double FProbabilityDensity(double x, int k1, int k2)
  {
    if (k1 <= 0 || k2 <= 0)
      throw new ArgumentException("k1 and k2 must be greater than 0.");
    if (x == 0.0)
      return 0.0;
    double num1 = Math.Pow((double) k1 * x, 0.5 * (double) k1) * Math.Pow((double) k2, 0.5 * (double) k2) / Math.Pow((double) k1 * x + (double) k2, 0.5 * (double) (k1 + k2));
    double num2 = CalcEngine.BetaFunction(0.5 * (double) k1, 0.5 * (double) k2);
    double num3 = x * num2;
    return num1 / num3;
  }

  private double FCumulativeDensity(double x, int k1, int k2)
  {
    if (k1 <= 0 || k2 <= 0)
      throw new ArgumentException("k1 and k2 must be greater than 0.");
    if (x < 0.0)
      throw new ArgumentException("x must be greater than 0.");
    return x == 0.0 ? 0.0 : Math.Min(1.0, this.RIBetaFunction((double) k1 * x / ((double) k1 * x + (double) k2), 0.5 * (double) k1, 0.5 * (double) k2));
  }

  private static double BetaFunction(double a, double b)
  {
    if (a + b <= 143.0)
      return CalcEngine.GammaFunction(a) * CalcEngine.GammaFunction(b) / CalcEngine.GammaFunction(a + b);
    return b > 20.0 ? 2.5066282746310002 * Math.Pow(a, a - 0.5) * Math.Pow(b, b - 0.5) / Math.Pow(a + b, a + b - 0.5) : CalcEngine.GammaFunction(b) * Math.Pow(a, -b);
  }

  private static double GammaFunction(double z)
  {
    if (z > 143.0)
      throw new ArgumentException("Cannot currently compute gamma function for z > 143");
    if (z > 0.0 && z < 21.0 && z % 1.0 == 0.0)
      return (double) CalcEngine.Factorial((int) Math.Round(z - 1.0, 0));
    if (z > 0.0 && z < 11.0 && z % 0.5 == 0.0)
    {
      int num = (int) z;
      return 1.77245385090552 * (double) CalcEngine.Factorial(2 * num) / (Math.Pow(4.0, (double) num) * (double) CalcEngine.Factorial(num));
    }
    double num1 = 1.0 + 1.0 / (12.0 * z) + 1.0 / (288.0 * z * z) - 139.0 / (51840.0 * Math.Pow(z, 3.0)) - 571.0 / (2488320.0 * Math.Pow(z, 4.0)) + 163879.0 / (209018880.0 * Math.Pow(z, 5.0)) + 5246819.0 / (75246796800.0 * Math.Pow(z, 6.0));
    return Math.Pow(z, z - 0.5) * Math.Exp(-z) * 2.5066282746310002 * num1;
  }

  private double RIBetaFunction(double x, double a, double b)
  {
    if (x <= 0.0)
      return 0.0;
    if (x >= 1.0)
      return 1.0;
    if (a % 1.0 == 0.0 && b % 1.0 == 0.0 && a + b > 0.0)
      return this.RIBetaFunction(x, (int) a, (int) b);
    if (b % 1.0 == 0.0 && a + b < 172.0)
      return this.RIBetaFunction(x, a, (int) b);
    if (a % 1.0 == 0.0 && a + b < 172.0)
      return 1.0 - this.RIBetaFunction(1.0 - x, b, (int) a);
    if (a == 0.5 && b == 0.5)
      return 2.0 / Math.PI * Math.Atan(Math.Sqrt(x / (1.0 - x)));
    if (a == 0.5 && b % 0.5 == 0.0)
      return 1.0 - this.RIBetaFunction(1.0 - x, b, 0.5);
    if (a % 0.5 == 0.0 && b == 0.5)
    {
      if (a < 45.0)
      {
        double num1 = 0.0;
        int num2 = (int) Math.Round(a - 0.5, 0);
        double num3 = Convert.ToDouble(this.ComputeGammaln("0.5".ToString()));
        for (int y = 0; y < num2; ++y)
          num1 += Math.Exp(this.GammaLn((double) (y + 1)) - this.GammaLn((double) y + 1.5) - num3) * Math.Pow(x, (double) y);
        return this.RIBetaFunction(x, 0.5, 0.5) - Math.Sqrt(x * (1.0 - x)) * num1;
      }
      double num4 = Math.Sqrt(1.0 - Math.Pow(CalcEngine.BetaFunction(a, 0.5) * Math.Sqrt((a - 1.0) / Math.PI) * double.Epsilon, 1.0 / (a - 1.0)));
      double[] numArray1 = new double[10]
      {
        0.066671344308688,
        0.14945134915058,
        0.21908636251598,
        0.26926671931,
        0.29552422471475,
        0.29552422471475,
        0.26926671931,
        0.21908636251598,
        0.14945134915058,
        0.066671344308688
      };
      double[] numArray2 = new double[10]
      {
        0.013046735791414,
        0.067468316655507,
        0.16029521585049,
        0.28330230293538,
        0.42556283050918,
        0.57443716949081,
        0.71669769706462,
        0.83970478414951,
        0.93253168334449,
        0.98695326420859
      };
      double num5 = Math.Sqrt(1.0 - x);
      double num6 = 0.0;
      for (int index = 0; index < 10; ++index)
        num6 += numArray1[index] * Math.Pow(1.0 - Math.Pow((num4 - num5) * numArray2[index] + num5, 2.0), a - 1.0);
      double num7 = Math.Exp(this.GammaLn(a + 0.5) - this.GammaLn(a) - this.GammaLn(0.5));
      return (num4 - num5) * num7 * num6;
    }
    if (a % 0.5 == 0.0 && b % 0.5 == 0.0)
    {
      double num8 = 0.0;
      int num9 = (int) Math.Round(b - 0.5, 0);
      double num10 = this.GammaLn(a);
      double num11 = Math.Pow(x, a);
      for (int y = 0; y < num9; ++y)
        num8 += Math.Exp(this.GammaLn(a + (double) y + 0.5) - num10 - this.GammaLn((double) y + 1.5)) * Math.Pow(1.0 - x, (double) y) * num11;
      return Math.Max(0.0, Math.Min(1.0, this.RIBetaFunction(x, a, 0.5) + Math.Sqrt(1.0 - x) * num8));
    }
    return x > 0.5 ? 1.0 - this.RIBetaFunction(1.0 - x, b, a) : Math.Max(0.0, Math.Min(1.0, this.IBetaFunction(x, a, b) / CalcEngine.BetaFunction(a, b)));
  }

  private double RIBetaFunction(double x, int a, int b)
  {
    double val2 = 0.0;
    int n = a + b - 1;
    if (n < 21)
    {
      for (int index = a; index < a + b; ++index)
        val2 += Math.Pow(x, (double) index) * Math.Pow(1.0 - x, (double) (n - index)) / (double) (CalcEngine.Factorial(index) * CalcEngine.Factorial(n - index));
      val2 *= (double) CalcEngine.Factorial(n);
    }
    else
    {
      for (int index = a; index < a + b; ++index)
        val2 += Math.Pow(x, (double) index) * Math.Pow(1.0 - x, (double) (n - index)) * CalcEngine.Combinations(n, index);
    }
    return Math.Max(0.0, Math.Min(1.0, val2));
  }

  private double RIBetaFunction(double x, double a, int b)
  {
    if (a + (double) b > 172.0)
      throw new ArgumentException("Cannot currently compute RegularizedIncompleteBetaFunction for a + b > 172");
    double num = 0.0;
    for (int x1 = 1; x1 < b + 1; ++x1)
      num += Math.Pow(1.0 - x, (double) (x1 - 1)) * Math.Exp(this.GammaLn(a + (double) x1 - 1.0) - this.GammaLn((double) x1));
    return num * (Math.Pow(x, a) * Math.Exp(-this.GammaLn(a)));
  }

  private double IBetaFunction(double x, double a, double b)
  {
    if (x == 0.0)
      return 0.0;
    if (x == 1.0)
      return CalcEngine.BetaFunction(a, b);
    if (x <= 0.9)
      return this.PIBetaFunction(0.0, x, a, b);
    return x <= 0.99 ? this.PIBetaFunction(0.0, 0.9, a, b) + this.PIBetaFunction(0.9, x, a, b) : this.PIBetaFunction(0.0, 0.9, a, b) + this.PIBetaFunction(0.9, 0.99, a, b) + this.PIBetaFunction(0.99, x, a, b);
  }

  private double PIBetaFunction(double xL, double xU, double a, double b)
  {
    if (xU == xL)
      return 0.0;
    if (xU < xL)
      return double.NaN;
    int num1 = 1000;
    if (a < 1.0)
      num1 = 80000;
    double num2 = (xU - xL) / (double) num1;
    double x = xL + 0.5 * num2;
    double num3 = 0.0;
    for (int index = 0; index < num1; ++index)
    {
      num3 += Math.Pow(x, a - 1.0) * Math.Pow(1.0 - x, b - 1.0) * num2;
      x += num2;
    }
    return num3;
  }

  public string ComputeFOdistORt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string fodistOrt = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) fodistOrt))
      return fodistOrt;
    double result1 = 0.0;
    double result2 = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result3;
    strArray[0] = bool.TryParse(strArray[0], out result3) ? Convert.ToInt16(result3).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result3) ? Convert.ToInt16(result3).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result3) ? Convert.ToInt16(result3).ToString() : strArray[2];
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result4 >= 0.0 && result1 >= 1.0 && result2 >= 1.0)
        return (1.0 - Math.Exp(this.GammaLn((result1 + result2) / 2.0) - this.GammaLn(result1 / 2.0) - this.GammaLn(result2 / 2.0) + result1 / 2.0 * Math.Log(result1 / result2)) * this.fdist(result4, (int) result1, (int) result2)).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    if (this.rethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.FormulaErrorStrings[this.invalid_Math_argument];
  }

  public string ComputeChisqOdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 2:
      case 3:
        double num = 0.0;
        for (int index = 0; index < length; ++index)
          strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
        double result1;
        double result2;
        if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2))
        {
          if ((result2 != 1.0 || !this.excelLikeComputations) && result2 < 1.0)
            return this.excelLikeComputations ? "#NUM!" : this.FormulaErrorStrings[this.invalid_arguments];
          if (strArray[2] == this.TRUEVALUESTR)
          {
            num = this.chidist(result1, result2);
            if (result1 <= 0.0 || Math.Abs(result1) - Math.Abs(result1) != 0.0)
              throw new Exception("Invalid n: $n\n");
          }
          else
            num = this.ChiSquaredProbabilityDensityFunction(result1, (int) result2);
        }
        return num.ToString();
      default:
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
  }

  public string ComputeChisqOinv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string chisqOinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) chisqOinv))
      return chisqOinv;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    double result1;
    double result2;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result1 < 0.0 || result1 >= 1.0 || result2 <= 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (result1 == 0.0)
        return "0";
      num = this.chiinv(1.0 - result1, result2);
    }
    return num.ToString();
  }

  public string ComputeChisqOTest(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string str = strArray[0];
    double num1 = 0.0;
    if (str.IndexOf(':') > -1)
    {
      string s1 = str.Substring(0, str.IndexOf(':'));
      int num2 = this.ColIndex(s1);
      int num3 = this.RowIndex(s1);
      string s2 = str.Substring(str.IndexOf(':') + 1);
      int num4 = this.RowIndex(s2);
      int num5 = this.ColIndex(s2);
      if (this.grid is ISheetData)
      {
        if (!(!num3.Equals(-1) || num4.Equals(-1)).Equals(num3.Equals(-1) || !num4.Equals(-1)))
          return this.ErrorStrings[5].ToString();
        if (num3 == -1)
          num3 = ((ISheetData) this.grid).GetFirstRow();
        if (num2 == -1)
          num2 = ((ISheetData) this.grid).GetFirstColumn();
        if (num5 == -1)
          num5 = ((ISheetData) this.grid).GetLastColumn();
        if (num4 == -1)
          num4 = ((ISheetData) this.grid).GetLastRow();
      }
      num1 = (double) (Math.Abs(num2 - num5) * Math.Abs(num3 - num4));
      if (1.0001 < 1.0)
        return this.FormulaErrorStrings[this.invalid_Math_argument];
    }
    else if (this.excelLikeComputations)
      return "#N/A";
    double v = 0.99555;
    double[] doubleArray1 = this.GetDoubleArray(strArray[0]);
    double[] doubleArray2 = this.GetDoubleArray(strArray[1]);
    int length = doubleArray2.GetLength(0);
    if (length <= 0 || length != doubleArray1.GetLength(0))
      return this.ErrorStrings[0].ToString();
    double x = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num6 = doubleArray1[index] - doubleArray2[index];
      x += num6 * num6 / doubleArray2[index];
    }
    return (1.0 - this.chidist(x, v)).ToString();
  }

  public string ComputeChisqOinvORt(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string chisqOinvOrt = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) chisqOinvOrt))
      return chisqOinvOrt;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    double result1;
    double result2;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result1 <= 0.0 || result1 > 1.0 || result2 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      if (result1 == 1.0)
        return "0";
      num = this.chiinv(result1, result2);
    }
    return num.ToString();
  }

  public string ComputeBinomOdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string binomOdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) binomOdist))
      return binomOdist;
    double result1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result2;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
    }
    double result3;
    double result4;
    double result5;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result5))
    {
      if (result3 < 0.0 || result3 > result4 || result5 < 0.0 || result5 > 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception("#NAME! Passed argument value is not equal to minimum par value");
        return this.ErrorStrings[4].ToString();
      }
      double.TryParse(strArray[3], NumberStyles.Any, (IFormatProvider) null, out result1);
      return (result1 != 0.0 ? this.binomdist((int) result4, (int) result3, result5) : this.comb((int) result3, (int) result4) * Math.Pow(result5, result3) * Math.Pow(1.0 - result5, result4 - result3)).ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new Exception("#VALUE! Passed value is nonnumeric");
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeZOtest(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 2:
      case 3:
        if (!string.IsNullOrEmpty(range))
        {
          string zotest1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Text);
          if (this.ErrorStrings.Contains((object) zotest1))
            return zotest1;
          for (int index = 1; index < length; ++index)
          {
            if (index <= length - 1)
            {
              string zotest2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
              if (this.ErrorStrings.Contains((object) zotest2))
                return zotest2;
            }
          }
          string valueFromArg = this.GetValueFromArg(strArray[1]);
          double result1;
          if (!double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1))
            return this.FormulaErrorStrings[this.invalid_arguments];
          double[] doubleArray = this.GetDoubleArray(strArray[0]);
          double xbar;
          double result2 = this.sd(doubleArray, out xbar);
          if (length == 3)
            double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result2);
          string range1 = (1.0 - this.normaldist((xbar - result1) / (result2 / Math.Sqrt((double) doubleArray.GetLength(0))), 0.0, 1.0)).ToString();
          if (!(this.ComputeIsErr(range1) == this.TRUEVALUESTR))
            return range1;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[3].ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeRankOAvg(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 2:
      case 3:
        if (!string.IsNullOrEmpty(range))
        {
          string rankOavg1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) rankOavg1))
            return rankOavg1;
          string rankOavg2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Text);
          if (this.ErrorStrings.Contains((object) rankOavg2))
            return rankOavg2;
          double num1 = 0.0;
          string valueFromArg = this.GetValueFromArg(strArray[0]);
          double result1;
          if (double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result1))
          {
            double result2 = 0.0;
            if (length == 3)
            {
              string rankOavg3 = this.FormulaErrorStringCheck(strArray[2], CalcEngine.FormulaArgumentType.Numbers);
              if (this.ErrorStrings.Contains((object) rankOavg3))
                return rankOavg3;
              valueFromArg = this.GetValueFromArg(strArray[2]);
              double.TryParse(valueFromArg, NumberStyles.Integer, (IFormatProvider) null, out result2);
            }
            double result3 = 0.0;
            bool flag = false;
            string str = strArray[1];
            double[] doubleArray = this.GetDoubleArray(strArray[1]);
            double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result3);
            if (result2 == 0.0)
              Array.Sort<double>(doubleArray, (Comparison<double>) ((a, b) => -a.CompareTo(b)));
            else
              Array.Sort<double>(doubleArray);
            int num2 = -1;
            foreach (double num3 in doubleArray)
            {
              ++num2;
              ++num1;
              if (num3 == result1)
              {
                double num4 = double.Parse(this.ComputeRank($"{strArray[0]}{(object) CalcEngine.ParseArgumentSeparator}{strArray[1]}{(object) CalcEngine.ParseArgumentSeparator}0"));
                double num5 = double.Parse(this.ComputeRank($"{strArray[0]}{(object) CalcEngine.ParseArgumentSeparator}{strArray[1]}{(object) CalcEngine.ParseArgumentSeparator}1"));
                double num6 = ((double) (doubleArray.Length + 1) - num4 - num5) / 2.0;
                num1 += num6;
                flag = true;
                break;
              }
            }
            if (!flag)
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return this.ErrorStrings[0].ToString();
            }
          }
          return num1.ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeRankOEq(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 2:
      case 3:
        if (!string.IsNullOrEmpty(range))
        {
          string rankOeq1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) rankOeq1))
            return rankOeq1;
          string rankOeq2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Text);
          if (this.ErrorStrings.Contains((object) rankOeq2))
            return rankOeq2;
          int num1 = 0;
          string s = this.GetValueFromArg(strArray[0]);
          if (strArray[1].StartsWith(this.TIC) || strArray[1].Contains(","))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
            return this.FormulaErrorStrings[this.invalid_arguments];
          }
          if (strArray[0].Equals(string.Empty) || strArray[1].Equals(string.Empty))
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.ErrorStrings[4].ToString());
            return this.ErrorStrings[4].ToString();
          }
          double result1;
          if (double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result1))
          {
            double result2 = 0.0;
            if (length == 3)
            {
              string rankOeq3 = this.FormulaErrorStringCheck(strArray[2], CalcEngine.FormulaArgumentType.Numbers);
              if (this.ErrorStrings.Contains((object) rankOeq3))
                return rankOeq3;
              s = this.GetValueFromArg(strArray[2]);
              if (s.Equals(string.Empty))
                s = "0";
              else if (Convert.ToDouble(s) > 1.0)
                s = "1";
              double.TryParse(s, NumberStyles.Integer, (IFormatProvider) null, out result2);
            }
            double result3 = 0.0;
            bool flag = false;
            string str = strArray[1];
            double[] doubleArray = this.GetDoubleArray(strArray[1]);
            double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result3);
            if (result2 == 0.0)
              Array.Sort<double>(doubleArray, (Comparison<double>) ((a, b) => -a.CompareTo(b)));
            else
              Array.Sort<double>(doubleArray);
            foreach (double num2 in doubleArray)
            {
              ++num1;
              if (num2 == result1)
              {
                flag = true;
                break;
              }
            }
            if (!flag)
            {
              if (this.RethrowLibraryComputationExceptions)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              return this.ErrorStrings[0].ToString();
            }
          }
          if (!num1.Equals(0))
            return num1.ToString();
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[0].ToString());
          return this.ErrorStrings[0].ToString();
        }
        break;
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.FormulaErrorStrings[this.wrong_number_arguments];
  }

  public string ComputeIHDIST(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    int result1 = 0;
    string valueFromArg1 = this.GetValueFromArg(strArray[0]);
    string valueFromArg2 = this.GetValueFromArg(strArray[1]);
    double result2;
    if (double.TryParse(valueFromArg1, NumberStyles.Any, (IFormatProvider) null, out result2))
      int.TryParse(valueFromArg2, NumberStyles.Any, (IFormatProvider) null, out result1);
    return CalcEngine.IHProbDens(result2, result1).ToString();
  }

  public static double IHProbDens(double x, int n)
  {
    if (x < 0.0 || x > (double) n)
      return 0.0;
    double num = 0.0;
    for (int index = 0; index <= n; ++index)
      num += Math.Pow(-1.0, (double) index) * CalcEngine.Combinations(n, index) * Math.Pow(x - (double) index, (double) (n - 1)) * (double) Math.Sign(x - (double) index);
    return num * 0.5 / (double) CalcEngine.Factorial(n - 1);
  }

  public static double Combinations(int n, int k)
  {
    return Math.Round(Math.Exp(CalcEngine.LogCombin(n, k)), 0);
  }

  internal static double LogCombin(int n, int k)
  {
    return CalcEngine.LogFactorial(n) - CalcEngine.LogFactorial(k) - CalcEngine.LogFactorial(n - k);
  }

  private static double LogFactorial(int x)
  {
    double num = 0.0;
    for (int d = 2; d <= x; ++d)
      num += Math.Log((double) d);
    return num;
  }

  public static long Factorial(int n)
  {
    if (n < 0)
      throw new ArgumentException("Factorial not defined for negative n");
    if (n > 20)
      throw new ArgumentException("Answer will exceed max long");
    long num = 1;
    for (int index = n; index > 0; --index)
      num *= (long) index;
    return num;
  }

  public string ComputeUnidist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    double result1;
    double result2;
    double result3;
    return !double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) || !double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) || !double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3) ? this.FormulaErrorStrings[this.invalid_arguments] : CalcEngine.UniProbDens(result1, result2, result3).ToString();
  }

  public static double UniProbDens(double x, double min, double max)
  {
    if (max <= min)
      throw new ArgumentException("max must be greater than min");
    return x < min || x > max ? 0.0 : 1.0 / (max - min);
  }

  public string ComputeQuartileOExc(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string quartileOexc1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) quartileOexc1))
      return quartileOexc1;
    string quartileOexc2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) quartileOexc2))
      return quartileOexc2;
    bool result1;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result1) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    double result2;
    if (double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Integer, (IFormatProvider) null, out result2) && result2 >= 0.0 && result2 <= 4.0)
      return this.ComputePercentile(strArray[0] + (object) CalcEngine.ParseArgumentSeparator + (result2 * 0.25).ToString());
    if (result2 > 0.0 && result2 < 4.0)
      return this.FormulaErrorStrings[this.invalid_arguments];
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeQuartileOInc(string range)
  {
    if (!range.Contains(CalcEngine.parseArgumentSeparator.ToString()))
      this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string quartileOinc1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) quartileOinc1))
      return quartileOinc1;
    string quartileOinc2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) quartileOinc2))
      return quartileOinc2;
    bool result1;
    if (!this.IsRange(strArray[0]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[0])) || !this.IsRange(strArray[1]) && string.IsNullOrEmpty(this.GetValueFromArg(strArray[1])) || bool.TryParse(this.GetValueFromArg(strArray[0]), out result1) || bool.TryParse(this.GetValueFromArg(strArray[1]), out result1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[4].ToString();
    }
    double result2;
    if (double.TryParse(this.GetValueFromArg(strArray[1]), NumberStyles.Integer, (IFormatProvider) null, out result2) && result2 >= 0.0 && result2 <= 4.0)
      return this.ComputePercentile(strArray[0] + (object) CalcEngine.ParseArgumentSeparator + (result2 * 0.25).ToString());
    if (result2 >= 0.0 && result2 <= 4.0)
      return this.FormulaErrorStrings[this.invalid_arguments];
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[4].ToString();
  }

  public string ComputeNegbinomODist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 4)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    double result1;
    double result2;
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result3))
      num = this.negbinomdensity((int) result1, (int) result2, result3);
    return num.ToString();
  }

  public string ComputePoissonODist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string poissonOdist = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) poissonOdist))
      return poissonOdist;
    double result1 = 0.0;
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      strArray[index] = this.GetValueFromArg(strArray[index]);
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result2;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result2) ? Convert.ToInt16(result2).ToString() : strArray[index];
    }
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result4) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (result3 < 0.0 || result4 < 0.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[4].ToString();
      }
      int y = (int) result3;
      if (result1 == 0.0)
      {
        double num2 = 1.0;
        for (int index = 2; index <= y; ++index)
          num2 *= (double) index;
        num1 = Math.Exp(-result4) * Math.Pow(result4, (double) y) / num2;
      }
      else
      {
        double num3 = 1.0;
        double num4 = 0.0;
        double num5 = 1.0;
        for (int index = 0; index <= y; ++index)
        {
          num4 += num5 / num3;
          num3 *= (double) (index + 1);
          num5 *= result4;
        }
        num1 = Math.Exp(-result4) * num4;
      }
    }
    return num1.ToString();
  }

  public string ComputeDelta(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string delta = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) delta))
      return delta;
    string str1 = (string) null;
    string str2 = (string) null;
    try
    {
      if (strArray.Length > 2 || strArray.Length < 1)
        return this.FormulaErrorStrings[10].ToString();
      double num1;
      double num2;
      if (strArray.Length == 1)
      {
        str1 = this.GetValueFromArg(strArray[0]);
        str1 = str1.Replace(this.TIC, "");
        num1 = double.Parse(str1);
        num2 = 0.0;
      }
      else
      {
        str1 = this.GetValueFromArg(strArray[0]);
        str2 = this.GetValueFromArg(strArray[1]);
        if (string.IsNullOrEmpty(str1))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[0].ToString();
        }
        str1 = string.IsNullOrEmpty(str1) ? "0" : str1;
        str1 = str1.Replace(this.TIC, "");
        str2 = string.IsNullOrEmpty(str2) ? "0" : str2;
        str2 = str2.Replace(this.TIC, "");
        num1 = double.Parse(str1);
        num2 = double.Parse(str2);
      }
      return num1 == num2 ? "1" : "0";
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      return this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR ? this.ErrorStrings[5].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeGestep(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.Length > 2 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string gestep = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) gestep))
      return gestep;
    string str1 = (string) null;
    string str2 = (string) null;
    try
    {
      if (strArray.Length > 2 || strArray.Length < 1)
        return this.FormulaErrorStrings[10].ToString();
      double num1;
      double num2;
      if (strArray.Length == 1)
      {
        str1 = this.GetValueFromArg(strArray[0]);
        str1 = str1.Replace(this.TIC, "");
        num1 = double.Parse(str1);
        num2 = 0.0;
      }
      else
      {
        str1 = this.GetValueFromArg(strArray[0]);
        str1 = str1.Replace(this.TIC, "");
        str2 = this.GetValueFromArg(strArray[1]);
        str2 = string.IsNullOrEmpty(str2) ? "0" : str2;
        str2 = str2.Replace(this.TIC, "");
        num1 = double.Parse(str1);
        num2 = double.Parse(str2);
      }
      return num1 >= num2 ? "1" : "0";
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw new ArgumentException("The Parameters are not correct");
      if (this.ComputeIsText(str1) == this.TRUEVALUESTR || this.ComputeIsText(str2) == this.TRUEVALUESTR)
        return this.ErrorStrings[5].ToString();
      if (str1 == "")
        return this.ErrorStrings[0].ToString();
      return double.Parse(str1) < 0.0 || double.Parse(str2) < 0.0 ? this.ErrorStrings[4].ToString() : this.ErrorStrings[1].ToString();
    }
  }

  public string ComputeDevsq(string range)
  {
    string devsq = this.FormulaErrorStringCheck(range, CalcEngine.FormulaArgumentType.Range);
    if (this.ErrorStrings.Contains((object) devsq))
      return devsq;
    double[] doubleArray = this.GetDoubleArray(range);
    int length = doubleArray.GetLength(0);
    if (length <= 0 || string.IsNullOrEmpty(range))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double num1 = 0.0;
    for (int index = 0; index < length; ++index)
      num1 += doubleArray[index];
    double num2 = num1 / (double) length;
    double num3 = 0.0;
    for (int index = 0; index < length; ++index)
    {
      double num4 = doubleArray[index] - num2;
      num3 += num4 * num4;
    }
    return num3.ToString();
  }

  public string ComputeAverageIF(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length1 = strArray.GetLength(0);
    double num1 = 0.0;
    if (length1 != 2 && length1 != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string averageIf = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) averageIf))
      return averageIf;
    string args1 = strArray[0];
    string str1 = strArray[1];
    string criteria1 = string.IsNullOrEmpty(str1) ? "0" : str1;
    if (criteria1.Length < 1)
      return "0";
    char op = 'e';
    if ((int) criteria1[0] != (int) this.TIC[0] && "=><".IndexOf(criteria1[0]) == -1)
      criteria1 = this.GetValueFromArg(criteria1);
    double result1 = double.MinValue;
    string criteria2 = this.findCriteria(criteria1, ref op);
    double.TryParse(criteria2, out result1);
    string args2 = length1 == 2 ? args1 : strArray[2];
    string[] cellsFromArgs1 = this.GetCellsFromArgs(args1);
    string[] cellsFromArgs2 = this.GetCellsFromArgs(args2);
    if (cellsFromArgs1[0].Equals(this.ErrorStrings[5]) || cellsFromArgs2[0].Equals(this.ErrorStrings[5]))
      return this.ErrorStrings[5].ToString();
    int length2 = cellsFromArgs1.GetLength(0);
    if (length2 > cellsFromArgs2.GetLength(0))
    {
      int length3 = args2.IndexOf(':');
      if (length3 > -1)
      {
        int num2 = this.RowIndex(args2.Substring(0, length3));
        int num3 = this.RowIndex(args2.Substring(length3 + 1));
        if (!(!num2.Equals(-1) || num3.Equals(-1)).Equals(num2.Equals(-1) || !num3.Equals(-1)))
          return this.ErrorStrings[5].ToString();
        if (num2 == -1 && this.grid is ISheetData)
          num2 = ((ISheetData) this.grid).GetLastRow();
        int num4 = this.ColIndex(args2.Substring(0, length3));
        if (num4 == -1 && this.grid is ISheetData)
          num4 = ((ISheetData) this.grid).GetFirstColumn();
        if (num3 == -1 && this.grid is ISheetData)
          num3 = ((ISheetData) this.grid).GetLastRow();
        int col = this.ColIndex(args2.Substring(length3 + 1));
        if (col == -1 && this.grid is ISheetData)
          col = ((ISheetData) this.grid).GetLastColumn();
        if (num2 != num3)
          num3 += length2 - cellsFromArgs2.GetLength(0);
        else if (num4 != col)
          col += length2 - cellsFromArgs2.GetLength(0);
        cellsFromArgs2 = this.GetCellsFromArgs(args2.Substring(0, length3 + 1) + RangeInfo.GetAlphaLabel(col) + num3.ToString());
      }
    }
    double num5 = 0.0;
    switch (op)
    {
      case 'e':
        if (criteria2.Contains("*"))
        {
          int length4 = criteria2.IndexOf("*");
          string str2 = criteria2.Substring(0, length4);
          for (int index = 0; index < length2; ++index)
          {
            string valueFromArg = this.GetValueFromArg(cellsFromArgs1[index]);
            double result2;
            if ((valueFromArg.Replace(this.TIC, string.Empty).Substring(0, length4) == str2 || double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result2) && result2 == result1) && double.TryParse(this.GetValueFromArg(cellsFromArgs2[index]), NumberStyles.Any, (IFormatProvider) null, out result2))
            {
              num5 += result2;
              ++num1;
            }
          }
          break;
        }
        for (int index = 0; index < length2; ++index)
        {
          string valueFromArg = this.GetValueFromArg(cellsFromArgs1[index]);
          double result3;
          if ((valueFromArg.Replace(this.TIC, string.Empty) == criteria2 || double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result3) && result3 == result1) && double.TryParse(this.GetValueFromArg(cellsFromArgs2[index]), NumberStyles.Any, (IFormatProvider) null, out result3))
          {
            num5 += result3;
            ++num1;
          }
        }
        break;
      case 'g':
        for (int index = 0; index < length2; ++index)
        {
          double result4;
          if (double.TryParse(this.GetValueFromArg(cellsFromArgs1[index]), out result4) && result4 > result1 && double.TryParse(this.GetValueFromArg(cellsFromArgs2[index]), NumberStyles.Any, (IFormatProvider) null, out result4))
          {
            num5 += result4;
            ++num1;
          }
        }
        break;
      case 'j':
        for (int index = 0; index < length2; ++index)
        {
          double result5;
          if (double.TryParse(this.GetValueFromArg(cellsFromArgs1[index]), out result5) && result5 >= result1 && double.TryParse(this.GetValueFromArg(cellsFromArgs2[index]), out result5))
          {
            num5 += result5;
            ++num1;
          }
        }
        break;
      case 'k':
        for (int index = 0; index < length2; ++index)
        {
          double result6;
          if (double.TryParse(this.GetValueFromArg(cellsFromArgs1[index]), out result6) && result6 <= result1 && double.TryParse(this.GetValueFromArg(cellsFromArgs2[index]), NumberStyles.Any, (IFormatProvider) null, out result6))
          {
            num5 += result6;
            ++num1;
          }
        }
        break;
      case 'l':
        for (int index = 0; index < length2; ++index)
        {
          double result7;
          if (double.TryParse(this.GetValueFromArg(cellsFromArgs1[index]), out result7) && result7 < result1 && double.TryParse(this.GetValueFromArg(cellsFromArgs2[index]), NumberStyles.Any, (IFormatProvider) null, out result7))
          {
            num5 += result7;
            ++num1;
          }
        }
        break;
      case 'o':
        for (int index = 0; index < length2; ++index)
        {
          string valueFromArg = this.GetValueFromArg(cellsFromArgs1[index]);
          double result8;
          if ((valueFromArg.Replace(this.TIC, string.Empty) != criteria2 || double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result8) && result8 != result1) && double.TryParse(this.GetValueFromArg(cellsFromArgs2[index]), NumberStyles.Any, (IFormatProvider) null, out result8))
          {
            num5 += result8;
            ++num1;
          }
        }
        break;
    }
    double num6 = num5 / num1;
    if (!(this.ComputeIsErr(num6.ToString()) == this.TRUEVALUESTR))
      return num6.ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[3].ToString();
  }

  public string ComputeConfidenceT(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string confidenceT = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) confidenceT))
      return confidenceT;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 <= 0.0 || result2 >= 1.0 || result3 <= 0.0 || result4 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Passed argument value is different from minimum par");
        return this.ErrorStrings[4].ToString();
      }
      if (result4 == 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[3].ToString();
      }
      num = (this.ExcelLikeComputations ? this.newnormalinv(1.0 - result2 + result2 / 2.0) : this.normalinv(1.0 - result2 + result2 / 2.0, 0.0, 1.0)) * result3 / Math.Sqrt(result4);
    }
    return num.ToString();
  }

  public string ComputeFOinv(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string foinv = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) foinv))
      return foinv;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    strArray[0] = string.IsNullOrEmpty(strArray[0]) ? "0" : strArray[0];
    bool result1;
    strArray[0] = bool.TryParse(strArray[0], out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    strArray[1] = string.IsNullOrEmpty(strArray[1]) ? "0" : strArray[1];
    strArray[1] = bool.TryParse(strArray[1], out result1) ? Convert.ToInt16(result1).ToString() : strArray[1];
    strArray[2] = string.IsNullOrEmpty(strArray[2]) ? "0" : strArray[2];
    strArray[2] = bool.TryParse(strArray[2], out result1) ? Convert.ToInt16(result1).ToString() : strArray[2];
    double result2;
    double result3;
    double result4;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result4))
    {
      if (result2 < 0.0 || result2 > 1.0 || result3 < 1.0 || result4 < 1.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException("Passed Argument value is less than or equal to minimum value");
        return this.errorStrings[4].ToString();
      }
      double num = this.FCumulativeDistributionInverse(result2, (int) result3, (int) result4);
      if (num > 0.0)
        return num.ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.iterations_dont_converge]);
      return this.FormulaErrorStrings[this.iterations_dont_converge];
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException("Passed argument value is non-numerical");
    return this.errorStrings[1].ToString();
  }

  public string ComputeModeOMult(string range)
  {
    double[] doubleArray = this.GetDoubleArray(range);
    double[] numArray = doubleArray.Clone() as double[];
    int length = doubleArray.GetLength(0);
    if (length <= 1)
      return "#N/A";
    Array.Sort<double>(doubleArray);
    ArrayList arrayList = new ArrayList();
    double num1 = double.NaN;
    int num2 = 0;
    int num3 = 0;
    for (int index = 1; index < length; ++index)
    {
      if (doubleArray[index] == doubleArray[index - 1])
      {
        ++num2;
      }
      else
      {
        if (num2 > num3)
        {
          num3 = num2;
          num1 = doubleArray[index - 1];
          arrayList.Clear();
          arrayList.Add((object) num1);
        }
        else if (num2 == num3)
          arrayList.Add((object) doubleArray[index - 1]);
        num2 = 0;
      }
    }
    if (num2 > num3)
    {
      num3 = num2;
      num1 = doubleArray[length - 1];
      arrayList.Clear();
      arrayList.Add((object) num1);
    }
    if (num3 <= 0)
      return "#N/A";
    if (num2 == num3)
      arrayList.Add((object) doubleArray[length - 1]);
    if (arrayList.Count > 1)
    {
      foreach (double num4 in numArray)
      {
        if (arrayList.IndexOf((object) num4) > -1)
        {
          num1 = num4;
          break;
        }
      }
    }
    return num1.ToString();
  }

  public string ComputeModeOsngl(string range)
  {
    double[] doubleArray = this.GetDoubleArray(range);
    double[] numArray = doubleArray.Clone() as double[];
    int length = doubleArray.GetLength(0);
    if (length <= 1)
      return "#N/A";
    Array.Sort<double>(doubleArray);
    ArrayList arrayList = new ArrayList();
    double num1 = double.NaN;
    int num2 = 0;
    int num3 = 0;
    for (int index = 1; index < length; ++index)
    {
      if (doubleArray[index] == doubleArray[index - 1])
      {
        ++num2;
      }
      else
      {
        if (num2 > num3)
        {
          num3 = num2;
          num1 = doubleArray[index - 1];
          arrayList.Clear();
          arrayList.Add((object) num1);
        }
        else if (num2 == num3)
          arrayList.Add((object) doubleArray[index - 1]);
        num2 = 0;
      }
    }
    if (num2 > num3)
    {
      num3 = num2;
      num1 = doubleArray[length - 1];
      arrayList.Clear();
      arrayList.Add((object) num1);
    }
    if (num3 <= 0)
      return "#N/A";
    if (num2 == num3)
      arrayList.Add((object) doubleArray[length - 1]);
    if (arrayList.Count > 1)
    {
      foreach (double num4 in numArray)
      {
        if (arrayList.IndexOf((object) num4) > -1)
        {
          num1 = num4;
          break;
        }
      }
    }
    return num1.ToString();
  }

  public string ComputeTOdist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length != 3)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    int result1 = 0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]).Replace(this.TIC, string.Empty);
    double result2;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result2) && int.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result1))
    {
      if (result1 < 1 || result2.ToString().StartsWith("-"))
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception("#NUM! Passed argument value is incorrect");
        return this.errorStrings[4].ToString();
      }
      if (strArray[2] == this.TRUEVALUESTR)
        num = this.TCumulativeDensity(result2, result1);
      else if (strArray[2] == this.FALSEVALUESTR)
        num = this.TProbabilityDensity(result2, result1);
      return num.ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new Exception("#VALUE! Passed argument value is incorrect");
    return this.errorStrings[1].ToString();
  }

  public string ComputeBetaDist(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    if (length < 4 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double result1 = 0.0;
    double result2 = 0.0;
    double num = 0.0;
    for (int index = 0; index < length; ++index)
      strArray[index] = this.GetValueFromArg(strArray[index]);
    double result3;
    if (double.TryParse(strArray[0], NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(strArray[1], NumberStyles.Any, (IFormatProvider) null, out result1) && double.TryParse(strArray[2], NumberStyles.Any, (IFormatProvider) null, out result2))
    {
      if (result1 < 0.0 || result2 < 0.0)
        return this.ErrorStrings[4].ToString();
      if (strArray[3] == this.TRUEVALUESTR)
        num = this.BetaCumulativeDist(result3, result1, result2);
      else if (strArray[3] == this.FALSEVALUESTR)
        num = this.BetaProbabilityDens(result3, result1, result2);
    }
    return num.ToString();
  }

  public double BetaCumulativeDist(double x, double a, double b) => this.RIBetaFunction(x, a, b);

  private double BetaProbabilityDens(double x, double a, double b)
  {
    double num = CalcEngine.BetaFunction(a, b);
    return Math.Pow(x, a - 1.0) * Math.Pow(1.0 - x, b - 1.0) / num;
  }

  private static string Spell(int number)
  {
    Hashtable hashtable = new Hashtable();
    hashtable.Add((object) 0, (object) "");
    hashtable.Add((object) 1, (object) "one");
    hashtable.Add((object) 2, (object) "two");
    hashtable.Add((object) 3, (object) "three");
    hashtable.Add((object) 4, (object) "four");
    hashtable.Add((object) 5, (object) "five");
    hashtable.Add((object) 6, (object) "six");
    hashtable.Add((object) 7, (object) "seven");
    hashtable.Add((object) 8, (object) "eight");
    hashtable.Add((object) 9, (object) "nine");
    hashtable.Add((object) 10, (object) "ten");
    hashtable.Add((object) 11, (object) "eleven");
    hashtable.Add((object) 12, (object) "twelve");
    hashtable.Add((object) 13, (object) "thirteen");
    hashtable.Add((object) 14, (object) "fourteen");
    hashtable.Add((object) 15, (object) "fifteen");
    hashtable.Add((object) 16 /*0x10*/, (object) "sixteen");
    hashtable.Add((object) 17, (object) "seventeen");
    hashtable.Add((object) 18, (object) "eighteen");
    hashtable.Add((object) 19, (object) "nineteen");
    hashtable.Add((object) 20, (object) "twenty");
    hashtable.Add((object) 30, (object) "thirty");
    hashtable.Add((object) 40, (object) "forty");
    hashtable.Add((object) 50, (object) "fifty");
    hashtable.Add((object) 60, (object) "sixty");
    hashtable.Add((object) 70, (object) "seventy");
    hashtable.Add((object) 80 /*0x50*/, (object) "eighty");
    hashtable.Add((object) 90, (object) "ninety");
    if (number >= 1000)
      return $"{CalcEngine.Spell(number / 1000)} thousand {CalcEngine.Spell(number % 1000)}";
    if (number >= 100)
      return $"{CalcEngine.Spell(number / 100)} hundred {CalcEngine.Spell(number % 100)}";
    return number >= 21 ? $"{hashtable[(object) (number / 10 * 10)]} {hashtable[(object) (number % 10)]}" : hashtable[(object) number].ToString();
  }

  public string TranslateText(string input, string languagePair)
  {
    try
    {
      string address = $"http://www.google.com/translate_t?hl=en&ie=UTF8&text={input}&langpair={languagePair}";
      WebClient webClient = new WebClient();
      webClient.Headers.Add("Authorization", "Basic " + Convert.ToBase64String(Encoding.ASCII.GetBytes("user:pass")));
      webClient.Encoding = Encoding.UTF8;
      NetworkCredential networkCredential = new NetworkCredential("archowdhury", "Secure*45", "corp");
      webClient.Credentials = (ICredentials) networkCredential;
      webClient.Proxy = (IWebProxy) new WebProxy();
      webClient.Credentials = (ICredentials) new NetworkCredential("archowdhury", "Secure*45", "corp");
      string str1 = webClient.DownloadString(address);
      string str2 = str1.Substring(str1.IndexOf("id=result_box") + 22, 500);
      string str3 = str2.Substring(0, str2.IndexOf("</span"));
      return str3.Substring(str3.IndexOf("Ë\u00B9"));
    }
    catch
    {
      return "Can't able to get text";
    }
  }

  public string ComputeCode(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string s = this.GetValueFromArg(strArray[0]).Replace(this.TIC, string.Empty);
    string code = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) code))
      return code;
    if (!string.IsNullOrEmpty(s))
      return ((int) Encoding.ASCII.GetBytes(s)[0]).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeFindB(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray.Length != 2 && strArray.Length != 3)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    string str1 = this.StripTics0(this.GetValueFromArg(strArray[0]));
    string str2 = this.StripTics0(this.GetValueFromArg(strArray[1]));
    int result = 1;
    if (strArray.Length == 3 && !int.TryParse(this.GetValueFromArg(strArray[2]), out result))
      result = 1;
    if (result <= 0 || result > str2.Length)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.ErrorStrings[1].ToString();
    }
    int num = str2.IndexOf(str1, result - 1);
    if (num >= 0)
      return (num + 1).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeLeftB(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length1 = strArray.GetLength(0);
    switch (length1)
    {
      case 1:
      case 2:
        string valueFromArg = this.GetValueFromArg(strArray[0]);
        bool flag = valueFromArg.StartsWith(this.TIC) && valueFromArg.EndsWith(this.TIC);
        int num = int.Parse(this.ComputedValue(length1 == 2 ? strArray[1] : "1")) + (flag ? 1 : 0);
        int length2 = valueFromArg.Length >= num ? num : valueFromArg.Length;
        string leftB = valueFromArg.Substring(0, length2);
        if (flag && !leftB.EndsWith(this.TIC))
          leftB += this.TIC;
        return leftB;
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.FormulaErrorStrings[this.invalid_arguments];
    }
  }

  public string ComputeJis(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    char[] charArray = this.StripTics0(this.GetValueFromArg(strArray[0])).ToCharArray();
    for (int index = 0; index < charArray.Length; ++index)
    {
      if (charArray[index] == ' ')
        charArray[index] = '　';
      else if (charArray[index] < '\u007F')
        charArray[index] = (char) ((uint) charArray[index] + 65248U);
    }
    return new string(charArray);
  }

  public string ComputeLenB(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    return (valueFromArg.StartsWith(this.TIC) && valueFromArg.EndsWith(this.TIC) ? valueFromArg.Length - 2 : valueFromArg.Length).ToString();
  }

  public string ComputeMidB(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 3)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.FormulaErrorStrings[this.invalid_arguments];
    }
    string valueFromArg = this.GetValueFromArg(strArray[0]);
    bool flag = valueFromArg.StartsWith(this.TIC) && valueFromArg.EndsWith(this.TIC);
    int length = int.Parse(this.GetValueFromArg(strArray[2]));
    if (strArray[1].IndexOf("#VALUE!") > -1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    int startIndex = int.Parse(this.GetValueFromArg(strArray[1])) + (flag ? 0 : -1);
    if (startIndex + length > valueFromArg.Length)
      return this.FormulaErrorStrings[this.invalid_arguments];
    string midB = valueFromArg.Substring(startIndex, length);
    if (flag && !midB.StartsWith(this.TIC))
      midB = this.TIC + midB;
    if (flag && !midB.EndsWith(this.TIC))
      midB += this.TIC;
    return midB;
  }

  public string ComputeRightB(string range)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    int length = strArray.GetLength(0);
    switch (length)
    {
      case 1:
      case 2:
        string valueFromArg = this.GetValueFromArg(strArray[0]);
        bool flag = valueFromArg.StartsWith(this.TIC) && valueFromArg.EndsWith(this.TIC);
        string formula = length == 2 ? strArray[1] : "1";
        if (formula.IndexOf("#VALUE!") > -1)
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentNullException(this.FormulaErrorStrings[this.bad_formula]);
          return this.ErrorStrings[1].ToString();
        }
        int num = int.Parse(this.ComputedValue(formula)) + (flag ? 1 : 0);
        int startIndex = valueFromArg.Length >= num ? valueFromArg.Length - num : 0;
        string rightB = valueFromArg.Substring(startIndex);
        if (flag && !rightB.StartsWith(this.TIC))
          rightB = this.TIC + rightB;
        return rightB;
      default:
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.FormulaErrorStrings[this.invalid_arguments];
    }
  }

  public string ComputeNumberValue(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    char decimalSeparator = CalcEngine.ParseDecimalSeparator;
    char argumentSeparator = CalcEngine.ParseArgumentSeparator;
    if (length > 3)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str1 = this.StripTics0(this.GetValueFromArg(strArray[0]));
    if (length > 1)
    {
      try
      {
        string s1 = this.StripTics0(this.GetValueFromArg(strArray[1]));
        string s2 = this.StripTics0(this.GetValueFromArg(strArray[2]));
        if (s1.Equals("invalid expression") || s2.Equals("invalid expression") || string.IsNullOrEmpty(s1) && string.IsNullOrEmpty(s2))
        {
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
        decimalSeparator = this.StripTics0(s1)[0];
        argumentSeparator = this.StripTics0(s2)[0];
      }
      catch (Exception ex)
      {
        this.ExceptionThrown = true;
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(ex.Message);
        return this.ErrorStrings[1].ToString();
      }
    }
    if (string.IsNullOrEmpty(str1))
      return "0";
    int num1 = str1.IndexOf(decimalSeparator);
    int num2 = str1.IndexOf(argumentSeparator);
    if (num2 >= num1 && (num1 != -1 || num2 != -1))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[1].ToString());
      return this.ErrorStrings[1].ToString();
    }
    string str2 = str1.Replace(this.TIC, string.Empty).Replace(" ", string.Empty).Replace(argumentSeparator.ToString(), string.Empty).Replace(decimalSeparator, CalcEngine.ParseDecimalSeparator).Replace(",", string.Empty);
    string range = this.ComputeValue(str2);
    if (!(this.ComputeIsNumber(range) != this.TRUEVALUESTR) && !str2.EndsWith("$"))
      return range;
    TimeSpan result;
    if (TimeSpan.TryParse(str2, out result))
      return result.TotalDays.ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[1].ToString());
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeProper(string argList)
  {
    string[] strArray1 = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray1.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string valueFromArg = this.GetValueFromArg(strArray1[0]);
    if (string.IsNullOrEmpty(valueFromArg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.bad_formula];
    }
    string input = this.StripTics0(valueFromArg);
    int num = input.IndexOf("'");
    if (num >= 0 && num < input.Length - 1)
    {
      string upperInvariant = Regex.Replace(input, "[']", " '").ToUpperInvariant();
      if (string.IsNullOrEmpty(upperInvariant))
        return string.Empty;
      if (!upperInvariant.Equals("invalid expression"))
        return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(upperInvariant.ToLower()).Replace(" '", "'").ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[5].ToString());
      return this.ErrorStrings[5].ToString();
    }
    if (Regex.IsMatch(input, "^([A-Za-z0-9\\-]+)"))
    {
      string[] strArray2 = Regex.Split(input, "(?<=[a-zA-Z])(?=\\d)");
      string empty = string.Empty;
      foreach (string str in strArray2)
        empty += CultureInfo.CurrentCulture.TextInfo.ToTitleCase(str.ToLower());
      return empty;
    }
    return Regex.IsMatch(input, "^[a-zA-Z0-9]+$") ? Regex.Replace(input, "[^a-zA-Z0-9_\\\\]", "").ToUpperInvariant() : CultureInfo.CurrentCulture.TextInfo.ToTitleCase(input.ToLower());
  }

  public string ComputeReplace(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    int result1 = 0;
    int result2 = 0;
    if (length != 4 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string replace1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) replace1))
      return replace1;
    string replace2 = this.FormulaErrorStringCheck(strArray[3], CalcEngine.FormulaArgumentType.Text);
    if (this.ErrorStrings.Contains((object) replace2))
      return replace2;
    for (int index = 1; index <= 2; ++index)
    {
      strArray[index] = string.IsNullOrEmpty(strArray[index]) ? "0" : strArray[index];
      bool result3;
      strArray[index] = bool.TryParse(this.GetValueFromArg(strArray[index]), out result3) ? Convert.ToInt16(result3).ToString() : strArray[index];
      string replace3 = this.FormulaErrorStringCheck(strArray[index], CalcEngine.FormulaArgumentType.Numbers);
      if (this.ErrorStrings.Contains((object) replace3))
        return replace3;
    }
    string str = this.StripTics0(this.GetValueFromArg(strArray[0]));
    string newValue = this.StripTics0(this.GetValueFromArg(strArray[3]));
    string empty1 = string.Empty;
    if (int.TryParse(this.GetValueFromArg(strArray[1]), out result1))
    {
      if (int.TryParse(this.GetValueFromArg(strArray[2]), out result2))
      {
        string replace4;
        try
        {
          string empty2 = string.Empty;
          if (string.IsNullOrEmpty(str))
            return newValue;
          if (str.Length <= result1 && result1 > result2)
            replace4 = str + newValue;
          else if (str.Length <= result1)
          {
            string oldValue = str;
            replace4 = str.Replace(oldValue, newValue);
          }
          else
          {
            string oldValue = str.Substring(result1 - 1, result2);
            replace4 = str.Replace(oldValue, newValue);
          }
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (!this.RethrowLibraryComputationExceptions)
            return this.ErrorStrings[1].ToString();
          throw;
        }
        return replace4;
      }
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeRept(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str = this.StripTics0(this.GetValueFromArg(strArray[0]));
    double result = 1.0;
    string valueFromArg = this.GetValueFromArg(strArray[1]);
    string rept = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.TextWithNumber);
    if (this.ErrorStrings.Contains((object) rept))
      return rept;
    if (string.IsNullOrEmpty(str) || string.IsNullOrEmpty(valueFromArg) || valueFromArg.Equals("invalid expression"))
      return string.Empty;
    if (!double.TryParse(valueFromArg.Replace(this.TIC, string.Empty), out result))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.ErrorStrings[5].ToString();
    }
    StringBuilder stringBuilder = new StringBuilder();
    for (int index = 0; (double) index < result; ++index)
      stringBuilder.Append(str);
    return stringBuilder.ToString();
  }

  public string ComputeSearchB(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    int result = 1;
    if (length != 2 && length != 3)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    CultureInfo currentCulture = CultureInfo.CurrentCulture;
    string str1 = this.StripTics0(this.GetValueFromArg(strArray[0]));
    string str2 = this.StripTics0(this.GetValueFromArg(strArray[1]));
    int num = str2.IndexOf(str1) + 1;
    if (length == 3)
    {
      if (int.TryParse(this.GetValueFromArg(strArray[2]), out result))
      {
        try
        {
          num = str2.IndexOf(str1, result) + 1;
        }
        catch
        {
          this.ExceptionThrown = true;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
      }
    }
    return num.Equals(0) ? this.ErrorStrings[1].ToString() : num.ToString();
  }

  public string ComputeUniChar(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string uniChar = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) uniChar))
      return uniChar;
    bool result1;
    strArray[0] = bool.TryParse(this.GetValueFromArg(strArray[0]), out result1) ? Convert.ToInt16(result1).ToString() : strArray[0];
    string s = this.StripTics0(this.GetValueFromArg(strArray[0]));
    int result2 = 0;
    if (s.Equals("invalid expression"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[5].ToString());
      return this.ErrorStrings[5].ToString();
    }
    if (int.TryParse(s, out result2) && result2 != 0)
      return char.ConvertFromUtf32(result2).ToString().ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[1].ToString());
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeUniCode(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string s = this.StripTics0(this.GetValueFromArg(strArray[0]));
    int result = 0;
    if (s.Equals("invalid expression"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[5].ToString());
      return this.ErrorStrings[5].ToString();
    }
    if (!s.Equals("invalid expression") && !string.IsNullOrEmpty(s) && (!int.TryParse(s, out result) || result != 0))
      return char.ConvertToUtf32(s, 0).ToString().ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[1].ToString());
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeChar(string arg)
  {
    if (this.SplitArgsPreservingQuotedCommas(arg).GetLength(0) > 1 || string.IsNullOrEmpty(arg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string str = this.FormulaErrorStringCheck(arg, CalcEngine.FormulaArgumentType.Numbers);
    if (this.ErrorStrings.Contains((object) str))
      return str;
    string valueFromArg = this.GetValueFromArg(arg);
    bool result1;
    string s = bool.TryParse(valueFromArg, out result1) ? Convert.ToInt16(result1).ToString() : valueFromArg;
    string empty = string.Empty;
    int result2;
    if (int.TryParse(s, out result2) && result2 > 0 && result2 < 256 /*0x0100*/)
      return ((char) result2).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeClean(string arg)
  {
    if (this.SplitArgsPreservingQuotedCommas(arg).Length != 1)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    bool result = true;
    string scopedRange = string.Empty;
    if (!arg.Contains(this.TIC) && !this.IsCellReference(arg) && !double.TryParse(arg, out double _) && !this.TryGetNamedRange(arg, out scopedRange) && !bool.TryParse(this.ComputeIsLogical(arg), out result))
      return this.ErrorStrings[5].ToString();
    int index1 = this.ErrorStrings.IndexOf((object) arg);
    if (index1 > -1)
      return this.ErrorStrings[index1].ToString();
    string clean = this.GetValueFromArg(arg);
    for (int index2 = 0; index2 <= 31 /*0x1F*/; ++index2)
    {
      string oldValue = this.ComputeChar(index2.ToString());
      if (clean.Contains(oldValue))
        clean = clean.Replace(oldValue, string.Empty);
    }
    if (clean.StartsWith(this.TIC) && clean.EndsWith(this.TIC))
      clean = clean.Substring(1, clean.Length - 2);
    return clean;
  }

  public string ComputeExact(string range)
  {
    this.AdjustRangeArg(ref range);
    string[] strArray = this.SplitArgsPreservingQuotedCommas(range);
    if (strArray.GetLength(0) != 2)
      return this.FormulaErrorStrings[this.requires_2_args];
    string valueFromArg1 = this.GetValueFromArg(strArray[0]);
    string valueFromArg2 = this.GetValueFromArg(strArray[1]);
    double result;
    if (double.TryParse(valueFromArg1, out result))
      valueFromArg1 = result.ToString();
    if (double.TryParse(valueFromArg2, out result))
      valueFromArg2 = result.ToString();
    return !(valueFromArg1 == valueFromArg2) ? this.FALSEVALUESTR : this.TRUEVALUESTR;
  }

  public string ComputeFind(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray.Length != 2 && strArray.Length != 3)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string find = this.FormulaErrorStringCheck(arg, CalcEngine.FormulaArgumentType.TwoTextWithNumber);
    if (this.ErrorStrings.Contains((object) find))
      return find;
    string str1 = this.StripTics0(this.GetValueFromArg(strArray[0]));
    string str2 = this.StripTics0(this.GetValueFromArg(strArray[1]));
    int result = 1;
    if (strArray.Length == 3 && !int.TryParse(this.GetValueFromArg(strArray[2]), out result))
      result = 1;
    if (result <= 0 || result > str2.Length)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
      return this.ErrorStrings[1].ToString();
    }
    int num = str2.IndexOf(str1, result - 1);
    if (num >= 0)
      return (num + 1).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeIndex(string arg)
  {
    string[] args = this.SplitArgsPreservingQuotedCommas(arg);
    int length1 = args.GetLength(0);
    if (length1 < 2 || length1 == 0 || string.IsNullOrEmpty(arg))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    for (int index1 = 1; index1 < length1; ++index1)
    {
      if (index1 <= length1 - 1)
      {
        string index2 = this.FormulaErrorStringCheck(args[1], CalcEngine.FormulaArgumentType.Numbers);
        if (this.ErrorStrings.Contains((object) index2))
          return index2;
      }
    }
    int length2 = args[0].IndexOf(":");
    if (string.IsNullOrEmpty(args[1]))
    {
      if (this.RowIndex(args[0].Substring(0, length2)) == this.RowIndex(args[0].Substring(length2 + 1)))
      {
        args[1] = "0";
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[1].ToString();
      }
    }
    else if (string.IsNullOrEmpty(args[0]) || length1 == 3 && string.IsNullOrEmpty(args[2]) && this.ColIndex(args[0].Substring(0, length2)) != this.ColIndex(args[0].Substring(length2 + 1)))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    string str = args[0].Replace(this.TIC, string.Empty);
    if (str.IndexOf(":") == -1)
    {
      if (this.IsCellReference(str))
      {
        str = $"{str}:{str}";
      }
      else
      {
        if (str.IndexOf(';') <= -1)
          return this.FindArrayIndex(str, args);
        string[] strArray1 = this.SplitArguments(str, ';');
        if (strArray1[0].IndexOf(',') <= -1)
          return this.FindArrayIndex(str, args);
        int length3 = this.SplitArgsPreservingQuotedCommas(strArray1[0]).Length;
        double[,] numArray = new double[strArray1.Length, length3];
        int num = length3;
        for (int index3 = 0; index3 < strArray1.Length; ++index3)
        {
          string[] strArray2 = this.SplitArgsPreservingQuotedCommas(strArray1[index3]);
          int length4 = strArray2.Length;
          if (num != length4)
          {
            if (this.RethrowLibraryComputationExceptions)
              throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
            return this.FormulaErrorStrings[this.wrong_number_arguments];
          }
          for (int index4 = 0; index4 < num; ++index4)
            numArray[index3, index4] = double.Parse(this.GetValueFromArg(strArray2[index4]));
        }
        double result1 = -1.0;
        double result2 = -1.0;
        if (length1 == 3 && double.TryParse(this.GetValueFromArg(args[1]), NumberStyles.Integer, (IFormatProvider) null, out result1) && result1 >= 0.0 && double.TryParse(this.GetValueFromArg(args[2]), NumberStyles.Integer, (IFormatProvider) null, out result2) && result2 >= 0.0)
        {
          if (result1 == 0.0 && result2 != 0.0)
            return numArray[(int) result1, (int) result2 - 1].ToString();
          if (result2 == 0.0 && result1 != 0.0)
            return numArray[(int) result1 - 1, (int) result2].ToString();
          return result2 != 0.0 || result1 != 0.0 ? numArray[(int) result1 - 1, (int) result2 - 1].ToString() : numArray[0, 0].ToString();
        }
        if (double.TryParse(this.GetValueFromArg(args[1]), NumberStyles.Integer, (IFormatProvider) null, out result1) && result1 >= 0.0)
          return result1 != 0.0 ? numArray[(int) result1 - 1, 0].ToString() : numArray[0, 0].ToString();
      }
    }
    string oldValue = string.Empty;
    if (str.Contains('!'.ToString()))
    {
      oldValue = this.ExternalBookToken(str);
      if (!string.IsNullOrEmpty(oldValue))
        str = str.Replace(oldValue, string.Empty);
    }
    int length5 = str.IndexOf(":");
    if (arg.IndexOf("#N/A") > -1 || arg.IndexOf("#N~A") > -1)
      return "#N/A";
    if (arg.IndexOf("#DIV/0!") > -1 || arg.IndexOf("#DIV~0!") > -1)
      return "#DIV/0!";
    string tokenFromReference = this.GetSheetTokenFromReference(str);
    double result;
    int num1 = length1 == 1 ? 1 : (double.TryParse(this.GetValueFromArg(args[1]), NumberStyles.Integer, (IFormatProvider) null, out result) ? (int) result : -1);
    int num2 = length1 <= 2 ? 1 : (double.TryParse(this.GetValueFromArg(args[2]), NumberStyles.Integer, (IFormatProvider) null, out result) ? (int) result : -1);
    if (num1 == -1 || num2 == -1)
      return this.ErrorStrings[2].ToString();
    int num3 = this.RowIndex(str.Substring(0, length5));
    int num4 = this.RowIndex(str.Substring(length5 + 1));
    if (!(!num3.Equals(-1) || num4.Equals(-1)).Equals(num3.Equals(-1) || !num4.Equals(-1)))
      return this.ErrorStrings[5].ToString();
    if (num3 == -1 && this.grid is ISheetData)
      num3 = ((ISheetData) this.grid).GetFirstRow();
    if (num4 == -1 && this.grid is ISheetData)
      num4 = ((ISheetData) this.grid).GetLastRow();
    int num5 = this.ColIndex(str.Substring(0, length5));
    int num6 = this.ColIndex(str.Substring(length5 + 1));
    if (num5 == -1 && this.grid is ISheetData)
      num5 = ((ISheetData) this.grid).GetFirstColumn();
    if (num6 == -1 && this.grid is ISheetData)
      num6 = ((ISheetData) this.grid).GetLastColumn();
    if (length1 == 2 && num1 > num4 - num3 + 1)
    {
      num2 = num1;
      num1 = 1;
    }
    if (num1 > num4 - num3 + 1 || num2 > num6 - num5 + 1)
      return this.ErrorStrings[2].ToString();
    int num7 = this.RowIndex(str.Substring(0, length5)) + (num1 <= 0 ? num1 : num1 - 1);
    if (this.RowIndex(str.Substring(0, length5)) == -1 && this.grid is ISheetData)
      num7 += 2;
    int col = this.ColIndex(str.Substring(0, length5)) + (num2 <= 0 ? num2 : num2 - 1);
    if (this.ColIndex(str.Substring(0, length5)) == -1 && this.grid is ISheetData)
      col += 2;
    if (this.computeFunctionLevel > 0 && this.isIndexInteriorFormula && this.hitCount == this.computedValueLevel)
      return string.Format("{2}{0}{1}", (object) RangeInfo.GetAlphaLabel(col), (object) num7, (object) (oldValue + tokenFromReference));
    string valueFromArg = this.GetValueFromArg(string.Format("{2}{0}{1}", (object) RangeInfo.GetAlphaLabel(col), (object) num7, (object) (oldValue + tokenFromReference)));
    return !this.isIndexInteriorFormula && string.IsNullOrEmpty(valueFromArg) && this.treatStringsAsZero ? "0" : valueFromArg;
  }

  private string FindArrayIndex(string r, string[] args)
  {
    string arrayIndex = string.Empty;
    double result1 = -1.0;
    double result2 = -1.0;
    int length = args.GetLength(0);
    string[] strArray = r.IndexOf(';') <= -1 ? this.SplitArgsPreservingQuotedCommas(r) : this.SplitArguments(r, ';');
    if (length == 3 && double.TryParse(this.GetValueFromArg(args[1]), NumberStyles.Integer, (IFormatProvider) null, out result1) && result1 >= 0.0 && result1 == 1.0 && double.TryParse(this.GetValueFromArg(args[2]), NumberStyles.Integer, (IFormatProvider) null, out result2) && result2 >= 0.0)
    {
      if ((double) strArray.Length >= result2)
        arrayIndex = (int) result2 == 0 ? strArray[0] : strArray[(int) result2 - 1];
    }
    else if (double.TryParse(this.GetValueFromArg(args[1]), NumberStyles.Integer, (IFormatProvider) null, out result1) && result1 >= 0.0)
    {
      if ((double) strArray.Length >= result1)
      {
        arrayIndex = (int) result1 == 0 ? strArray[0] : strArray[(int) result1 - 1];
      }
      else
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentNullException(this.FormulaErrorStrings[this.invalid_arguments]);
        return this.ErrorStrings[2].ToString();
      }
    }
    else
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentNullException(this.FormulaErrorStrings[this.invalid_Math_argument]);
      return this.ErrorStrings[1].ToString();
    }
    return arrayIndex;
  }

  public string ComputeSearch(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    int result = 1;
    if (length != 2 && length != 3 || string.IsNullOrEmpty(argList))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string search = this.FormulaErrorStringCheck(argList, CalcEngine.FormulaArgumentType.TwoTextWithNumber);
    if (this.ErrorStrings.Contains((object) search))
      return search;
    string lower1 = this.StripTics0(this.GetValueFromArg(strArray[0])).ToLower();
    string lower2 = this.StripTics0(this.GetValueFromArg(strArray[1])).ToLower();
    if (string.IsNullOrEmpty(lower2))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
      return this.ErrorStrings[1].ToString();
    }
    int num = lower2.IndexOf(lower1) + 1;
    if (length == 3)
    {
      if (int.TryParse(this.GetValueFromArg(strArray[2]), out result))
      {
        try
        {
          num = lower2.IndexOf(lower1, result - 1) + 1;
        }
        catch
        {
          this.ExceptionThrown = true;
          if (this.RethrowLibraryComputationExceptions)
            throw new ArgumentException(this.ErrorStrings[1].ToString());
          return this.ErrorStrings[1].ToString();
        }
      }
    }
    return num.Equals(0) ? this.ErrorStrings[1].ToString() : num.ToString();
  }

  public string ComputeWebService(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string address = this.StripTics0(this.GetValueFromArg(strArray[0]));
    if (address.StartsWith("ftp") || address.StartsWith("file"))
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("InValid URL: " + address);
      return this.ErrorStrings[1].ToString();
    }
    WebClient webClient = new WebClient();
    this.download = string.Empty;
    try
    {
      this.download = Encoding.ASCII.GetString(webClient.DownloadData(address));
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("InValid URL: " + address);
      return this.ErrorStrings[1].ToString();
    }
    return this.download;
  }

  public string ComputeEncodeURL(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string scopedRange = string.Empty;
    if (this.IsCellReference(strArray[0]) || this.TryGetNamedRange(strArray[0], out scopedRange) || strArray[0].Contains(this.TIC))
      return Uri.EscapeDataString(this.StripTics0(this.GetValueFromArg(strArray[0]))).Replace("+", "%20");
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
    return this.ErrorStrings[5].ToString();
  }

  public string ComputeFilterXml(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    string empty = string.Empty;
    string xml = this.StripTics0(this.GetValueFromArg(strArray[0]));
    string xpath = this.StripTics0(this.GetValueFromArg(strArray[1]));
    XmlDocument xmlDocument = new XmlDocument();
    xmlDocument.LoadXml(xml);
    xmlDocument.Save("../../bin/add.xml");
    try
    {
      return new XPathDocument("../../bin/add.xml").CreateNavigator().SelectSingleNode(xpath).Value;
    }
    catch
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("InValid XML data: " + xmlDocument.ToString());
      return this.ErrorStrings[1].ToString();
    }
  }

  static CalcEngine() => CalcEngine.formulaChar = '=';

  public CalcEngine(ICalcData ParentObject)
  {
    if (Utilities.IsSecurityPermissionAvailable())
      Utilities.ValidateLicense(typeof (CalcEngine));
    this.grid = ParentObject;
    this.grid.WireParentObject();
    this.grid.ValueChanged += new ValueChangedEventHandler(this.grid_ValueChanged);
    this.InitLibraryFunctions();
    this.tokens = new char[12]
    {
      'a',
      's',
      'm',
      'd',
      'l',
      'g',
      'e',
      'k',
      'j',
      'o',
      'c',
      '~'
    };
    this.dateTime1900Double = this.dateTime1900.ToOADate();
    this.refreshedCells = new Hashtable();
    this.formulaErrorStrings = new ArrayList(this.FormulaErrorStrings.Length);
    this.formulaErrorStrings.AddRange((ICollection) this.FormulaErrorStrings);
    this.ArrayParser = new ArrayParser(this);
    this.LinearRegression = new LinearRegression(this);
  }

  public event FormulaParsingEventHandler FormulaParsing;

  public event UnknownFunctionEventHandler UnknownFunction;

  internal event UpdateNamedRangeEventHandler UpdateNamedRange;

  internal event FormulaComputedEventHandler FormulaComputed;

  internal event UpdateExternalFormulaEventHandler UpdateExternalFormula;

  internal event GetExternalWorksheetEventHandler QueryExternalWorksheet;

  internal event GetExternalNamedRangeEventHandler GetExternalNamedRange;

  public bool TreatStringsAsZero
  {
    get => this.treatStringsAsZero;
    set => this.treatStringsAsZero = value;
  }

  internal bool IsAreaCalculation
  {
    get => this.isAreaCalculation;
    set => this.isAreaCalculation = value;
  }

  public int MaximumRecursiveCalls
  {
    get => this.maximumRecursiveCalls;
    set => this.maximumRecursiveCalls = value;
  }

  public bool CalculatingSuspended
  {
    get => this.calculationsSuspended;
    set => this.calculationsSuspended = value;
  }

  public Hashtable LibraryFunctions => this.libraryFunctions;

  public bool UseNoAmpersandQuotes
  {
    get => this.useNoAmpersandQuotes;
    set => this.useNoAmpersandQuotes = value;
  }

  internal bool ExceptionThrown
  {
    get => this.exceptionThrown;
    set => this.exceptionThrown = value;
  }

  public Exception LibraryComputationException => this.libraryComputationException;

  public bool RethrowLibraryComputationExceptions
  {
    get => this.rethrowLibraryComputationExceptions;
    set => this.rethrowLibraryComputationExceptions = value;
  }

  [DefaultValue(false)]
  public bool ExcelLikeComputations
  {
    get => this.excelLikeComputations;
    set
    {
      if (this.excelLikeComputations == value)
        return;
      this.excelLikeComputations = value;
    }
  }

  public static int MaxStackDepth
  {
    get
    {
      if (CalcEngine.maxStackDepth == 0)
        CalcEngine.maxStackDepth = 50;
      return CalcEngine.maxStackDepth;
    }
    set => CalcEngine.maxStackDepth = value;
  }

  public string[] ReservedWordOperators
  {
    get
    {
      if (this.reservedWordOperators == null)
        this.reservedWordOperators = new string[7]
        {
          " or ",
          " and ",
          " xor ",
          "if ",
          " then ",
          " else ",
          "not "
        };
      return this.reservedWordOperators;
    }
    set => this.reservedWordOperators = value;
  }

  public static char FormulaCharacter
  {
    get
    {
      if (CalcEngine.formulaChar == char.MinValue)
        CalcEngine.formulaChar = '=';
      return CalcEngine.formulaChar;
    }
    set => CalcEngine.formulaChar = value;
  }

  internal bool CurrentRowNotationEnabled
  {
    get => this.currentRowNotationEnabled;
    set => this.currentRowNotationEnabled = value;
  }

  internal string ActiveFunctionName => this.activeFunctionName;

  public string ActiveCell => this.cell;

  public bool AllowShortCircuitIFs
  {
    get => this.allowShortCircuitIFs;
    set => this.allowShortCircuitIFs = value;
  }

  public bool AlwaysComputeDuringRefresh
  {
    get => this.alwaysComputeDuringRefresh;
    set => this.alwaysComputeDuringRefresh = value;
  }

  public bool UseFormulaValues
  {
    get => this.useFormulaValues;
    set => this.useFormulaValues = value;
  }

  public bool CheckDanglingStack
  {
    get => this.checkDanglingStack;
    set => this.checkDanglingStack = value;
  }

  public int ColumnMaxCount
  {
    get => this.columnMaxCount;
    set => this.columnMaxCount = value;
  }

  public bool EnsureIFCallDuringShortCircuit
  {
    get => this.ensureIFCallDuringShortCircuit;
    set => this.ensureIFCallDuringShortCircuit = value;
  }

  public bool ForceRefreshCall
  {
    get => this.forceRefreshCall;
    set => this.forceRefreshCall = value;
  }

  public Hashtable FormulaInfoTable
  {
    get
    {
      if (this.IsSheeted)
      {
        GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
        if (sheetFamilyItem.sheetFormulaInfoTable == null)
          sheetFamilyItem.sheetFormulaInfoTable = new Hashtable();
        return sheetFamilyItem.sheetFormulaInfoTable;
      }
      if (this._formulaInfoTable == null)
        this._formulaInfoTable = new Hashtable();
      return this._formulaInfoTable;
    }
  }

  public bool GetValueFromArgPreserveLeadingZeros
  {
    get => this.getValueFromArgPreserveLeadingZeros;
    set => this.getValueFromArgPreserveLeadingZeros = value;
  }

  public int IterationMaxCount
  {
    get => this.iterationMaxCount;
    set
    {
      this.iterationMaxCount = value;
      if (this.iterationMaxCount <= 0)
        return;
      this.ThrowCircularException = true;
    }
  }

  public double IterationMaxTolerance
  {
    get => this.iterationMaxTolerance;
    set => this.iterationMaxTolerance = value;
  }

  private Hashtable IterationValues
  {
    get
    {
      if (this.iterationValues == null)
        this.iterationValues = new Hashtable();
      return this.iterationValues;
    }
  }

  public bool LockDependencies
  {
    get => this.lockDependencies;
    set => this.lockDependencies = value;
  }

  public int RowMaxCount
  {
    get => this.rowMaxCount;
    set => this.rowMaxCount = value;
  }

  public bool SupportLogicalOperators
  {
    get => this.supportLogicalOperators;
    set => this.supportLogicalOperators = value;
  }

  public bool SupportRangeOperands
  {
    get => this.supportRangeOperands;
    set => this.supportRangeOperands = value;
  }

  public bool SupportsSheetRanges
  {
    get => this.supportsSheetRanges;
    set => this.supportsSheetRanges = value;
  }

  public bool ThrowCircularException
  {
    get => this.throwCircularException;
    set => this.throwCircularException = value;
  }

  public bool UseDependencies
  {
    get => this.useDependencies;
    set => this.useDependencies = value;
  }

  public string ValidPrecedingChars
  {
    get
    {
      this.validPrecedingChars = " (+-*/^&<>=" + (object) CalcEngine.ParseArgumentSeparator;
      return this.validPrecedingChars;
    }
    set => this.validPrecedingChars = value;
  }

  internal bool PreserveFormula
  {
    get => this.preserveFormula;
    set => this.preserveFormula = value;
  }

  internal bool IsSheeted
  {
    get
    {
      GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
      return sheetFamilyItem != null && sheetFamilyItem.isSheeted;
    }
  }

  public static char ParseArgumentSeparator
  {
    get
    {
      if (CalcEngine.parseArgumentSeparator == char.MinValue)
        CalcEngine.parseArgumentSeparator = ',';
      char result;
      if (!CalcEngine.isParseArgumentSeparator && char.TryParse(Thread.CurrentThread.CurrentCulture.NumberFormat.NumberGroupSeparator, out result) && (int) result != (int) CalcEngine.parseArgumentSeparator)
        CalcEngine.parseArgumentSeparator = result;
      return CalcEngine.parseArgumentSeparator;
    }
    set
    {
      CalcEngine.parseArgumentSeparator = value;
      CalcEngine.isParseArgumentSeparator = true;
    }
  }

  public static char ParseDecimalSeparator
  {
    get
    {
      if (CalcEngine.parseDecimalSeparator == char.MinValue)
        CalcEngine.parseDecimalSeparator = '.';
      char result;
      if (!CalcEngine.isParseDecimalSeparatorChanged && char.TryParse(Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator, out result) && (int) result != (int) CalcEngine.parseDecimalSeparator)
        CalcEngine.parseDecimalSeparator = result;
      return CalcEngine.parseDecimalSeparator;
    }
    set
    {
      CalcEngine.parseDecimalSeparator = value;
      CalcEngine.isParseDecimalSeparatorChanged = true;
    }
  }

  public static char ParseDateTimeSeparator
  {
    get => CalcEngine.parseDateTimeSeparator;
    set
    {
      if ((int) CalcEngine.parseDateTimeSeparator == (int) value)
        return;
      CalcEngine.parseDateTimeSeparator = value;
    }
  }

  public ArrayList ErrorStrings
  {
    get
    {
      if (this.errorStrings == null)
      {
        this.errorStrings = new ArrayList();
        this.errorStrings.AddRange((ICollection) new string[7]
        {
          "#N/A",
          "#VALUE!",
          "#REF!",
          "#DIV/0!",
          "#NUM!",
          "#NAME?",
          "#NULL!"
        });
      }
      return this.errorStrings;
    }
    set => this.errorStrings = value;
  }

  private string FormulaErrorStringCheck(string args, CalcEngine.FormulaArgumentType argumentType)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
    switch (argumentType)
    {
      case CalcEngine.FormulaArgumentType.None:
        if (!string.IsNullOrEmpty(args))
        {
          if (this.RethrowLibraryComputationExceptions)
          {
            this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.invalid_arguments]);
            throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
          }
          return this.FormulaErrorStrings[this.invalid_arguments];
        }
        break;
      case CalcEngine.FormulaArgumentType.Range:
        string args1 = string.Empty;
        foreach (string args2 in strArray)
        {
          if (args2.IndexOf(':') > -1)
          {
            if (args2.StartsWith(this.TIC))
            {
              if (this.RethrowLibraryComputationExceptions)
              {
                this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.bad_formula]);
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              }
              return this.ErrorStrings[1].ToString();
            }
            foreach (string cellsFromArg in this.GetCellsFromArgs(args2))
            {
              try
              {
                args1 = this.GetValueFromArg(cellsFromArg);
              }
              catch
              {
              }
              if (args1.Length > 0 && this.ErrorStrings.Contains((object) args1))
              {
                if (this.RethrowLibraryComputationExceptions)
                {
                  this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.bad_formula]);
                  throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                }
                return args1;
              }
            }
          }
          else
          {
            try
            {
              args1 = this.GetValueFromArg(args2);
            }
            catch
            {
            }
            if (args1.Length > 0)
            {
              string str = this.FormulaErrorStringCheck(args1, CalcEngine.FormulaArgumentType.Numbers);
              if (this.ErrorStrings.Contains((object) str))
                return str;
            }
          }
        }
        break;
      case CalcEngine.FormulaArgumentType.TwoTextWithNumber:
        string str1 = this.FormulaErrorStringCheck(strArray[0], CalcEngine.FormulaArgumentType.Text);
        if (this.ErrorStrings.Contains((object) str1))
          return str1;
        string str2 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Text);
        if (this.ErrorStrings.Contains((object) str2))
          return str2;
        if (strArray.Length == 3)
        {
          string str3 = this.FormulaErrorStringCheck(strArray[2], CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) str3))
            return str3;
          break;
        }
        break;
      case CalcEngine.FormulaArgumentType.TextWithNumber:
        double result1 = 0.0;
        double result2 = 0.0;
        bool result3;
        bool.TryParse(strArray[0], out result3);
        if (strArray.Length == 2)
          bool.TryParse(this.GetValueFromArg(strArray[1]), out result3);
        if (!double.TryParse(strArray[0].Replace(this.TIC, string.Empty), out result1))
        {
          string valueFromArg = this.GetValueFromArg(strArray[0]);
          if (this.ErrorStrings.Contains((object) valueFromArg))
          {
            if (this.RethrowLibraryComputationExceptions)
            {
              this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.bad_formula]);
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            }
            return valueFromArg;
          }
        }
        if (strArray.Length == 2 && !double.TryParse(strArray[1].Replace(this.TIC, string.Empty), out result2))
        {
          string str4 = this.FormulaErrorStringCheck(strArray[1], CalcEngine.FormulaArgumentType.Numbers);
          if (this.ErrorStrings.Contains((object) str4))
            return str4;
          break;
        }
        break;
      case CalcEngine.FormulaArgumentType.Numbers:
        foreach (string args3 in strArray)
        {
          bool flag = bool.TryParse(this.GetValueFromArg(args3), out bool _);
          if (!this.IsArgumentIsNumber(args3.Replace(this.TIC, string.Empty)))
          {
            string valueFromArg = this.GetValueFromArg(args3);
            if (this.ErrorStrings.Contains((object) valueFromArg))
            {
              if (this.RethrowLibraryComputationExceptions)
              {
                this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.bad_formula]);
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              }
              return valueFromArg;
            }
            if (!flag && !double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out double _) && !string.IsNullOrEmpty(valueFromArg) || args3.Contains(":") && this.IsCellReference(args3) || valueFromArg.StartsWith(this.TIC))
            {
              if (this.RethrowLibraryComputationExceptions)
              {
                this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.invalid_arguments]);
                throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
              }
              return this.ErrorStrings[1].ToString();
            }
          }
        }
        break;
      case CalcEngine.FormulaArgumentType.Text:
        foreach (string str5 in strArray)
        {
          bool.TryParse(strArray[0], out bool _);
          if (!double.TryParse(str5.Replace(this.TIC, string.Empty), out double _))
          {
            string valueFromArg = this.GetValueFromArg(str5);
            if (this.ErrorStrings.Contains((object) valueFromArg))
            {
              if (this.RethrowLibraryComputationExceptions)
              {
                this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.bad_formula]);
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
              }
              return valueFromArg;
            }
          }
        }
        break;
      case CalcEngine.FormulaArgumentType.Date:
        double result4 = 0.0;
        foreach (string str6 in strArray)
        {
          bool flag = bool.TryParse(this.GetValueFromArg(str6), out bool _);
          string valueFromArg = this.GetValueFromArg(str6);
          if (this.ErrorStrings.Contains((object) valueFromArg))
          {
            if (this.RethrowLibraryComputationExceptions)
            {
              this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.bad_formula]);
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            }
            return valueFromArg;
          }
          if (!flag && !DateTime.TryParse(this.StripTics0(valueFromArg), out DateTime _) && !double.TryParse(this.StripTics0(valueFromArg), out result4) && valueFromArg != string.Empty)
          {
            if (this.RethrowLibraryComputationExceptions)
            {
              this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.bad_formula]);
              throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
            }
            return this.ErrorStrings[1].ToString();
          }
        }
        break;
    }
    return args;
  }

  private bool IsArgumentIsNumber(string arg)
  {
    string[] strArray = arg.Split(CalcEngine.parseArgumentSeparator);
    bool flag = false;
    for (int index = 0; index < strArray.Length; ++index)
    {
      if (!double.TryParse(strArray[index].Replace(this.TIC, string.Empty).Replace('u', '-'), NumberStyles.Any, (IFormatProvider) null, out double _))
        return false;
      flag = true;
    }
    return flag;
  }

  internal string Parse(string text)
  {
    this.ExceptionThrown = false;
    if (CalcEngine.TextIsEmpty(text))
      return text;
    if (text.Contains(this.TIC))
      text = this.CheckForStringTIC(text);
    this.GetFormulaText(ref text);
    if (CalcEngine.FormulaCharacter != char.MinValue && text.Length > 0 && (int) CalcEngine.FormulaCharacter == (int) text[0])
      text = text.Substring(1);
    if (this.NamedRanges.Count > 0)
    {
      text = this.CheckForNamedRange(text);
      while (this.findNamedRange)
        text = this.CheckForNamedRange(text);
    }
    Hashtable strings = this.SaveStrings(ref text);
    text = text.Replace(this.BRACELEFT, this.TIC);
    text = text.Replace(this.BRACERIGHT, this.TIC);
    text = text.Replace("-+", "-");
    if (!text.EndsWith('\u0092'.ToString(), StringComparison.Ordinal) || text.LastIndexOfAny(this.tokens) != text.Length - 2)
      text = text.ToUpper(CultureInfo.InvariantCulture);
    if (text.IndexOf('!') > -1)
    {
      GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
      if (sheetFamilyItem.SheetNameToParentObject != null)
      {
        if (sheetFamilyItem.SheetNameToParentObject.Count > 0)
        {
          try
          {
            if (!text.StartsWith('!'.ToString()))
            {
              if (text.Contains("!") && (text.Contains("[") && text.Contains("]") || this.CheckHasExternalWorkbook(text)) && this.UpdateExternalFormula != null)
              {
                UpdateExternalFormulaEventArgs e = new UpdateExternalFormulaEventArgs(text);
                this.UpdateExternalFormula((object) this, e);
                if (e.IsFormulaUpdated)
                  text = e.parsedFormula;
              }
              this.PutTokensForSheets(ref text);
            }
            string oldValue = this.SheetToken(text.Replace(this.TIC, string.Empty));
            string scopedRange = string.Empty;
            if (!string.IsNullOrEmpty(oldValue))
            {
              if (this.NamedRanges.Count > 0)
              {
                if (this.TryGetNamedRange(text.Replace("'", string.Empty).Replace(oldValue, string.Empty).ToUpper(), out scopedRange))
                  text = scopedRange;
              }
            }
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.rethrowExceptions)
              throw ex;
            return ex.Message;
          }
        }
      }
    }
    if (this.SupportLogicalOperators)
      this.MarkReserveWords(ref text);
    if (this.isRangeOperand)
    {
      this.isRangeOperand = false;
      return this.GetCellFrom(this.ParseSimple(text));
    }
    string empty1 = string.Empty;
    if (text.Contains("["))
    {
      for (int index = 0; index < text.Length; ++index)
      {
        if (text[index].Equals('['))
        {
          for (; text[index] != ']'; ++index)
            empty1 += (string) (object) text[index];
        }
        if (!text[index].Equals(' '))
          empty1 += (string) (object) text[index];
      }
      text = empty1;
    }
    else if (text.Contains(" ") && this.NamedRanges.Count > 0)
    {
      string empty2 = string.Empty;
      string scopedRange = string.Empty;
      bool flag1 = false;
      string empty3 = string.Empty;
      bool flag2 = false;
      double result = 0.0;
      for (int index = 0; index < text.Length; ++index)
      {
        string empty4 = string.Empty;
        while (index != text.Length && char.IsLetterOrDigit(text[index]) || index != text.Length && text[index] == ':' | text[index] == '\\' | text[index] == '_')
          empty3 += (string) (object) text[index++];
        if (this.TryGetNamedRange(empty3.ToUpper(), out scopedRange) || empty3 != string.Empty && !this.IsCellReference(empty3.ToUpper()) && this.LibraryFunctions[(object) empty3] == null && !double.TryParse(empty3.ToUpper(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentCulture, out result))
        {
          empty4 += empty3;
          flag1 = true;
        }
        else if (this.LibraryFunctions[(object) empty3] != null)
          empty4 += empty3;
        else if (empty3 != string.Empty)
          empty4 += empty3;
        if (index != text.Length && text[index] == ' ' && index != 0 && char.IsLetterOrDigit(text[index - 1]) | text[index - 1] == ')')
        {
          empty3 = string.Empty;
          ++index;
          while (index != text.Length && char.IsLetterOrDigit(text[index]) || index != text.Length && text[index] == ':' | text[index] == '\\' | text[index] == '_')
            empty3 += (string) (object) text[index++];
          if (flag1 && !flag2 && (this.TryGetNamedRange(empty3.ToUpper(), out scopedRange) || empty3 != string.Empty && !this.IsCellReference(empty3.ToUpper()) && this.LibraryFunctions[(object) empty3] == null && !double.TryParse(empty3.ToUpper(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentCulture, out result)))
            empty4 += " " + empty3;
          else if (flag1 && empty3.Contains(":"))
            empty4 += " " + empty3;
          else if (!this.TryGetNamedRange(empty3.ToUpper(), out scopedRange) && this.LibraryFunctions[(object) empty3] != null && flag1)
          {
            empty4 += " " + empty3;
            flag2 = true;
          }
          else if (empty3 != string.Empty)
            empty4 += empty3;
        }
        if (index != text.Length && text[index] == ')')
        {
          empty4 += (string) (object) text[index];
          flag2 = false;
        }
        else if (index != text.Length && text[index] != ')' && text[index] != ' ')
          empty4 += (string) (object) text[index];
        else if (index != text.Length && text[index] == ' ' && flag1 && char.IsLetterOrDigit(text[index - 1]) | text[index - 1] == ')' | text[index - 1] == '\\' | text[index - 1] == '_')
          empty4 += (string) (object) text[index];
        else if (index != text.Length && empty3 == string.Empty && !flag1 && text[index] != ' ')
          empty4 += string.Empty;
        empty2 += empty4;
        empty3 = string.Empty;
      }
      text = empty2;
    }
    else
      text = text.Replace(" ", string.Empty);
    text = text.Replace("=>", ">=");
    text = text.Replace("=<", "<=");
    try
    {
      this.MarkLibraryFormulas(ref text);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowExceptions)
        throw ex;
      return this.ErrorStrings[5].ToString();
    }
    int num;
    string text1;
    if (!this.ignoreBracet)
    {
      int length;
      for (; (length = text.IndexOf(')')) > -1; text = text.Substring(0, num) + this.ParseSimple(text1) + text.Substring(length + 1))
      {
        num = text.Substring(0, length).LastIndexOf('(');
        if (num == -1)
          throw new ArgumentException(this.FormulaErrorStrings[this.mismatched_parentheses]);
        if (num == length - 1)
          throw new ArgumentException(this.FormulaErrorStrings[this.empty_expression]);
        string empty5 = string.Empty;
        text1 = !this.ignoreBracet ? text.Substring(num + 1, length - num - 1) : text.Substring(num, length - num + 1);
      }
    }
    string retValue = this.ignoreBracet || text.IndexOf('(') <= -1 ? this.ParseSimple(text) : throw new ArgumentException(this.FormulaErrorStrings[this.mismatched_parentheses]);
    if (strings != null && strings.Count > 0)
      this.SetStrings(ref retValue, strings);
    return retValue;
  }

  internal bool TryGetNamedRange(string text, out string scopedRange)
  {
    scopedRange = string.Empty;
    string str1 = text;
    int result = this.GetSheetID(this.grid);
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    if (text.StartsWith('!'.ToString()))
    {
      int num = text.IndexOf('!', 1);
      if (num > 1 && int.TryParse(text.Substring(1, num - 1), out result))
        text = text.Substring(num + 1);
    }
    string str2 = '!'.ToString() + result.ToString() + (object) '!';
    if (sheetFamilyItem != null && sheetFamilyItem.SheetNameToToken != null)
    {
      foreach (string key in (IEnumerable) sheetFamilyItem.SheetNameToToken.Keys)
      {
        if (sheetFamilyItem.SheetNameToToken[(object) key].ToString() == str2)
        {
          string upper = (key + (object) '!' + text).ToUpper();
          if (this.NamedRanges.ContainsKey((object) upper))
          {
            scopedRange = ((string) this.NamedRanges[(object) upper]).ToUpper();
            return true;
          }
          break;
        }
      }
    }
    if (!this.NamedRanges.ContainsKey((object) str1.ToUpper().Replace("'", string.Empty)))
      return false;
    scopedRange = ((string) this.NamedRanges[(object) str1.ToUpper().Replace("'", string.Empty)]).ToUpper();
    return true;
  }

  private string CheckForStringTIC(string text)
  {
    bool flag = false;
    string oldValue = this.TIC + this.TIC;
    int num1;
    if ((num1 = text.IndexOf(this.TIC)) > -1)
    {
      while (num1 > -1 && num1 < text.Length - 1)
      {
        int num2 = num1 + 1 < text.Length ? text.IndexOf(this.TIC, num1 + 1) : -1;
        if (num2 > -1)
        {
          if (num2 < text.Length - 2 && (int) text[num2 + 1] == (int) this.TIC[0])
          {
            num2 = text.IndexOf(this.TIC, num2 + 2);
            if (num2 == -1)
              throw new ArgumentException(this.FormulaErrorStrings[this.mismatched_tics]);
          }
          if (num2 < text.Length - 2 && (int) text[num2 + 1] == (int) this.TIC[0])
          {
            flag = true;
            num2 = text.IndexOf(this.TIC, num2 + 2);
            if (num2 == -1)
              throw new ArgumentException(this.FormulaErrorStrings[this.mismatched_tics]);
          }
          string str = text.Substring(num1, num2 - num1 + 1);
          if (str != oldValue && !flag && str.Contains(oldValue))
          {
            str = str.Replace(oldValue, "~");
            this.isDoubleQuotes = true;
          }
          text = text.Substring(0, num1) + str + text.Substring(num2 + 1);
          num1 += str.Length;
          if (num1 < text.Length - 1)
            num1 = text.IndexOf(this.TIC, num1);
        }
        else if (num2 == -1)
          return text;
      }
    }
    return text;
  }

  private bool CheckHasCharBeforeNumber(string tempFormula)
  {
    bool flag = false;
    for (int index = tempFormula.Length - 1; index > 0; --index)
    {
      if (char.IsLetter(tempFormula[index]))
      {
        flag = true;
        break;
      }
    }
    return flag;
  }

  public string ParseFormula(string formula)
  {
    try
    {
      if (formula.StartsWith(this.BRACELEFT) && formula.EndsWith(this.BRACERIGHT) && (int) formula[1] == (int) CalcEngine.FormulaCharacter)
      {
        formula = this.ArrayParser.ParseLibraryFormula(formula);
        this.IsArrayFormula = true;
      }
      if (formula.Length > 0 && (int) formula[0] == (int) CalcEngine.FormulaCharacter)
        formula = formula.Substring(1);
      if (formula.Length > 0 && formula[0] == '+')
        formula = formula.Substring(1);
      this.isRangeOperand = this.supportRangeOperands && this.IsRange(formula);
      if (!this.CheckDanglingStack || formula.Replace(" ", string.Empty).IndexOf(this.BRACERIGHTnLEFT) <= -1)
        return this.Parse(formula.Trim());
      this.computedValueLevel = 0;
      return this.FormulaErrorStrings[this.improper_formula];
    }
    finally
    {
      if (this.computedValueLevel <= 1)
        this.IsArrayFormula = false;
    }
  }

  public string ParseAndComputeFormula(string formula)
  {
    try
    {
      if (string.IsNullOrEmpty(formula))
        return formula;
      if (formula.Length > 0 && (int) formula[0] == (int) CalcEngine.FormulaCharacter)
        formula = formula.Substring(1);
      if (formula.StartsWith(this.BRACELEFT) && formula.EndsWith(this.BRACERIGHT) && (int) formula[1] == (int) CalcEngine.FormulaCharacter)
      {
        formula = this.ArrayParser.ParseLibraryFormula(formula);
        this.IsArrayFormula = true;
      }
      if (formula.Length > 0 && formula[0] == '+')
        formula = formula.Substring(1);
      if (formula.Length > 1 && formula[0] == '#')
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
        return this.ErrorStrings[5].ToString();
      }
      string str1 = formula.Replace(" ", string.Empty);
      if (formula.Length > 1 && (int) formula[0] == (int) CalcEngine.ParseDecimalSeparator)
      {
        if (formula[1] >= '0' && formula[1] <= '9')
          formula = $"0{(object) CalcEngine.ParseDecimalSeparator}{formula.Substring(1)}";
      }
      else if (formula.Length > 1 && formula.StartsWith("(") && formula.EndsWith(")") && formula.Length > formula.LastIndexOf("(") + 1 && (int) str1[str1.IndexOf("(") + 1] == (int) CalcEngine.ParseDecimalSeparator)
      {
        int num = formula.LastIndexOf("(");
        if (str1.Length > num + 1 && (int) str1[num + 1] == (int) CalcEngine.ParseDecimalSeparator && str1.Length > num + 2 && str1[num + 2] >= '0' && str1[num + 2] <= '9')
          formula = $"{str1.Substring(0, num + 1)}0{(object) CalcEngine.ParseDecimalSeparator}{str1.Substring(num + 2)}";
      }
      string str2 = formula.Replace(" ", string.Empty);
      string[] strArray = str2.Split(new string[1]
      {
        this.TIC
      }, StringSplitOptions.RemoveEmptyEntries);
      for (int index1 = str2[0] == '"' ? 1 : 0; index1 < strArray.Length; index1 += 2)
      {
        string str3 = strArray[index1];
        int num1;
        for (int length = str3.IndexOf("("); length > 0 && length < str3.Length; length = length + num1 + 1)
        {
          num1 = !char.IsNumber(str3[length - 1]) || this.CheckHasCharBeforeNumber(str3.Substring(0, length)) ? str3.Substring(length + 1).IndexOf('(') : throw new ArgumentException($"{this.FormulaErrorStrings[this.bad_formula]} {str3.Substring(0, length + 1)}");
          if (num1 == -1)
            break;
        }
        int num2;
        for (int index2 = str3.IndexOf(")"); index2 != -1 && index2 < str3.Length - 1; index2 = index2 + num2 + 1)
        {
          num2 = !char.IsNumber(str3[index2 + 1]) ? str3.Substring(index2 + 1).IndexOf(')') : throw new ArgumentException($"{this.FormulaErrorStrings[this.bad_formula]} {str3.Substring(0, index2 + 2)}");
          if (num2 == -1)
            break;
        }
      }
      this.multiTick = false;
      string andComputeFormula = this.ComputedValue(this.Parse(formula));
      if (this.UseNoAmpersandQuotes && andComputeFormula.Length > 1 && (int) andComputeFormula[0] == (int) this.TIC[0] && (int) andComputeFormula[andComputeFormula.Length - 1] == (int) this.TIC[0])
        andComputeFormula = andComputeFormula.Substring(1, andComputeFormula.Length - 2);
      return andComputeFormula;
    }
    finally
    {
      if (this.computedValueLevel <= 1)
        this.IsArrayFormula = false;
    }
  }

  private bool CheckHasExternalWorkbook(string formula)
  {
    bool flag = false;
    int length = formula.LastIndexOf('!');
    string str1 = formula.Substring(0, length);
    int num1 = str1.IndexOf('\'');
    int num2 = str1.LastIndexOf('\'');
    string[] strArray = new string[6]
    {
      ".xlsx",
      ".xls",
      ".csv",
      ".xltx",
      ".xltm",
      ".xlsm"
    };
    if (num1 != -1 && num1 != num2)
    {
      string str2 = str1.Substring(num1 + 1, num2 - num1 - 1);
      for (int index = 0; index < strArray.Length; ++index)
      {
        if (str2.IndexOf(strArray[index], StringComparison.OrdinalIgnoreCase) != -1)
        {
          flag = true;
          break;
        }
      }
    }
    return flag;
  }

  private string ExternalBookToken(string s)
  {
    int index = 0;
    string str = string.Empty;
    if (index < s.Length && s[index] == '[')
    {
      ++index;
      while (index < s.Length && s[index] != ']')
        ++index;
      str = s.Substring(0, index + 1);
    }
    return index < s.Length ? str : string.Empty;
  }

  private string ParseSimple(string text)
  {
    if (text.Length > 0 && text[0] == '+')
      text = text.Substring(1);
    bool result = false;
    if (text == "#N/A" || text == "#N~A")
      return "#N/A";
    if (text.IndexOf("#N/A") > -1)
      text = text.Replace("#N/A", "#N~A");
    else if (bool.TryParse(text, out result))
      return text;
    if (text == "#DIV/0!" || text == "#DIV~0!")
      return "#DIV/0!";
    if (text.IndexOf("#DIV/0!") > -1)
      text = text.Replace("#DIV/0!", "#DIV~0!");
    text = this.HandleEmbeddedEs(text);
    StringBuilder stringBuilder = new StringBuilder(text);
    bool flag = true;
    while (flag)
    {
      stringBuilder.Replace("--", "+");
      stringBuilder.Replace("++", "+");
      stringBuilder.Replace(CalcEngine.ParseArgumentSeparator.ToString() + "-", CalcEngine.ParseArgumentSeparator.ToString() + "u").Replace(this.LEFTBRACKET.ToString() + "-", this.LEFTBRACKET.ToString() + "u").Replace("=-", "=u").Replace(">-", ">u").Replace("<-", "<u").Replace("/-", "/u").Replace("*-", "*u").Replace("+-", "+u").Replace("^-", "^u");
      stringBuilder.Replace(CalcEngine.ParseArgumentSeparator.ToString() + ",+", CalcEngine.ParseArgumentSeparator.ToString() + ",").Replace(this.LEFTBRACKET.ToString() + "+", this.LEFTBRACKET.ToString()).Replace("=+", "=").Replace(">+", ">").Replace("<+", "<").Replace("/+", "/").Replace("*+", "*").Replace("^+", "^");
      if (stringBuilder.Length > 0 && stringBuilder[0] == '+')
        stringBuilder.Remove(0, 1);
      flag = text != stringBuilder.ToString();
      text = stringBuilder.ToString();
    }
    text = stringBuilder.Replace("<=", 'f'.ToString()).Replace(">=", 'h'.ToString()).Replace("<>", 'p'.ToString()).Replace(this.STRING_or, this.CHAR_or.ToString()).Replace(this.STRING_and, this.CHAR_and.ToString()).ToString();
    string str = text;
    while (str.Contains("$"))
    {
      int startIndex = str.IndexOf('$');
      char[] anyOf = new char[13]
      {
        ')',
        CalcEngine.ParseArgumentSeparator,
        '}',
        '+',
        '-',
        '*',
        '/',
        '<',
        '>',
        '=',
        '&',
        ':',
        '%'
      };
      if (str.Length == 1 && startIndex == 0 || str.Length - 1 == startIndex && startIndex > 0 && str[startIndex - 1].ToString().IndexOfAny(anyOf) > -1 || startIndex < str.Length && str[startIndex + 1].ToString().IndexOfAny(anyOf) > -1)
      {
        if (this.RethrowLibraryComputationExceptions)
        {
          this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.invalid_char_in_front_of] + "operator");
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_char_in_front_of] + " operator");
        }
        return this.ErrorStrings[5].ToString();
      }
      str = str.Remove(startIndex, 1);
      text = str;
    }
    if (text == string.Empty)
      return text;
    bool needToContinue = true;
    text = this.ParseSimple(text, new char[2]{ 't', 'v' }, new char[2]
    {
      this.CHAR_EP,
      this.CHAR_EM
    }, ref needToContinue);
    text = this.ParseSimple(text, new char[1]{ '~' }, new char[1]
    {
      this.CHAR_or
    }, ref needToContinue);
    if (needToContinue)
      text = this.ParseSimple(text, new char[2]{ 'm', 'd' }, new char[2]
      {
        '*',
        '/'
      }, ref needToContinue);
    if (needToContinue)
      text = this.ParseSimple(text, new char[2]{ 'a', 's' }, new char[2]
      {
        '+',
        '-'
      }, ref needToContinue);
    if (needToContinue)
      text = this.ParseSimple(text, new char[1]{ 'c' }, new char[1]
      {
        this.CHAR_and
      }, ref needToContinue);
    if (needToContinue)
      text = this.ParseSimple(text, new char[6]
      {
        'l',
        'g',
        'e',
        'k',
        'j',
        'o'
      }, new char[6]{ '<', '>', '=', 'f', 'h', 'p' }, ref needToContinue);
    if (this.SupportLogicalOperators && needToContinue)
      text = this.ParseSimple(text, new char[1]{ '\u008A' }, new char[1]
      {
        '\u0091'
      }, ref needToContinue);
    if (this.SupportLogicalOperators && needToContinue)
      text = this.ParseSimple(text, new char[3]
      {
        '\u0084',
        '\u0085',
        '\u0086'
      }, new char[3]{ '\u008B', '\u008C', '\u008D' }, ref needToContinue);
    if (text.IndexOf("#N~A") > -1)
      text = text.Replace("#N~A", "#N/A");
    if (text.IndexOf("#DIV~0!") > -1)
      text = text.Replace("#DIV~0!", "#DIV/0!");
    return text;
  }

  internal bool IsUpper(char leter) => char.IsLetter(leter) && !char.IsLower(leter);

  private string ParseSimple(
    string text,
    char[] markers,
    char[] operators,
    ref bool needToContinue)
  {
    string empty1 = string.Empty;
    foreach (char ch in operators)
      empty1 += (string) (object) ch;
    StringBuilder stringBuilder = new StringBuilder(text);
    if (text.Contains(this.TIC + "-"))
    {
      int startIndex = text.IndexOf(this.TIC);
      int num1 = text.LastIndexOf(this.TIC);
      int num2 = text.Substring(startIndex).IndexOf('-');
      if (num2 < num1 && text.Length > startIndex + num2 + 1 && char.IsNumber(text[startIndex + num2 + 1]))
        text = stringBuilder.Replace(this.TIC + "-", this.TIC + "u").ToString();
    }
    if (text.StartsWith(CalcEngine.parseArgumentSeparator.ToString()) || text.StartsWith("%"))
    {
      if (this.RethrowLibraryComputationExceptions)
      {
        this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.invalid_char_in_front_of] + "operator");
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_char_in_front_of] + " operator");
      }
      return this.ErrorStrings[5].ToString();
    }
    text = stringBuilder.Replace("---", "-").Replace("--", "+").Replace(CalcEngine.ParseArgumentSeparator.ToString() + "-", CalcEngine.ParseArgumentSeparator.ToString() + "u").Replace(this.LEFTBRACKET.ToString() + "-", this.LEFTBRACKET.ToString() + "u").Replace("=-", "=u").Replace(">-", ">u").Replace("<-", "<u").Replace("/-", "/u").Replace("*-", "*u").Replace("+-", "-").Replace("--", "-u").Replace("w-", "wu").ToString();
    text = stringBuilder.Replace(CalcEngine.ParseArgumentSeparator.ToString() + "+", CalcEngine.ParseArgumentSeparator.ToString()).Replace(this.LEFTBRACKET.ToString() + "+", this.LEFTBRACKET.ToString()).Replace("=+", "=").Replace(">+", ">").Replace("<+", "<").Replace("/+", "/").Replace("*+", "*").Replace("++", "+").ToString();
    if (text.Length > 0 && text[0] == '-')
    {
      text = text.Substring(1).Replace('-', '\u0084');
      text = "0-" + text;
      text = this.ParseSimple(text, new char[1]{ 's' }, new char[1]
      {
        '-'
      }, ref needToContinue);
      text = text.Replace('\u0084', '-');
    }
    else if (text.Length > 0)
    {
      if (text[0] == '+')
        text = text.Substring(1);
    }
    try
    {
      if (text.IndexOfAny(operators) > -1)
      {
        int index1;
        while ((index1 = text.IndexOfAny(operators)) > -1)
        {
          string str1 = string.Empty;
          string empty2 = string.Empty;
          int length1;
          if (!this.SupportLogicalOperators || text[index1] != '\u0091')
          {
            if (index1 < 1 && text[index1] != '-')
              throw new ArgumentException(this.FormulaErrorStrings[this.operators_cannot_start_an_expression]);
            int index2 = index1 - 1;
            if (index1 == 0 && text[index1] == '-')
            {
              text = $"{(object) '\u0092'}nu{text.Substring(1)}{(object) '\u0092'}";
              continue;
            }
            if ((int) text[index2] == (int) this.TIC[0])
            {
              int startIndex = text.Substring(0, index2 - 1).LastIndexOf(this.TIC);
              if (startIndex < 0)
                throw new ArgumentException(this.FormulaErrorStrings[this.cannot_parse]);
              str1 = text.Substring(startIndex, index2 - startIndex + 1);
              length1 = startIndex;
            }
            else if (text[index2] == '\u0092')
            {
              int lastNonQb = this.FindLastNonQB(text.Substring(0, index2 - 1));
              if (lastNonQb < 0)
                throw new ArgumentException(this.FormulaErrorStrings[this.cannot_parse]);
              str1 = text.Substring(lastNonQb + 1, index2 - lastNonQb - 1);
              length1 = lastNonQb + 1;
            }
            else if (text[index2] == '!' || text[index2] == '?')
            {
              int num3 = 1;
              int num4;
              for (num4 = index2 - 1; text[num4] != '#'; --num4)
                ++num3;
              str1 = text.Substring(num4, num3 + 1);
              length1 = num4;
            }
            else if (index1 > text.IndexOf("#N/A") && text.IndexOf("#N/A") > -1 || index1 > text.IndexOf("#N~A") && text.IndexOf("#N~A") > -1)
            {
              int length2 = 4;
              int num = index2 - 3;
              str1 = text.Substring(index1 - length2, length2);
              length1 = num;
            }
            else if ((int) text[index2] == (int) this.RIGHTBRACKET)
            {
              int num5 = 0;
              int num6;
              for (num6 = index2 - 1; num6 > 0 && (text[num6] != 'q' || num5 != 0); --num6)
              {
                if (text[num6] == 'q')
                  --num5;
                else if ((int) text[num6] == (int) this.RIGHTBRACKET)
                  ++num5;
              }
              if (num6 < 0)
                throw new ArgumentException(this.FormulaErrorStrings[this.bad_library]);
              str1 = text.Substring(num6, index2 - num6 + 1);
              length1 = num6;
            }
            else if (!char.IsDigit(text[index2]) && text[index2] != '%' && (!text.Contains(":") || text.Contains(":") && index1 < text.IndexOf(':')))
            {
              for (bool flag = false; index2 >= 0 && (this.IsUpper(text[index2]) || text[index2] == '_' || text[index2] == '.' || text[index2] == '[' || text[index2] == ']' || text[index2] == '#' || text[index2] == ' ' || text[index2] == '%' || (int) text[index2] == (int) CalcEngine.parseArgumentSeparator && flag || text[index2] == '\\'); --index2)
              {
                if (text[index2] == '[' && text[index2 + 1] == '[')
                  flag = false;
                if (text[index2] == ']' && text[index2 + 1] == ']')
                  flag = true;
              }
              while (index2 > -1 && (this.IsUpper(text[index2]) || char.IsDigit(text[index2]) || text[index2] == '_' || text[index2] == '.'))
                --index2;
              str1 = text.Substring(index2 + 1, index1 - index2 - 1);
              length1 = index2 + 1;
              if (this.NamedRanges.Count > 0 && !string.IsNullOrEmpty(str1.Trim()))
                str1 = this.CheckForNamedRange(str1);
              if (!this.findNamedRange)
              {
                if (str1 == this.TRUEVALUESTR)
                  str1 = 'n'.ToString() + this.TRUEVALUESTR;
                else if (str1 == this.FALSEVALUESTR)
                  str1 = 'n'.ToString() + this.FALSEVALUESTR;
                else if (this.NamedRanges.Count > 0 && !this.IsCellReference(str1) && str1 != string.Empty && (str1.Contains(" ") || !str1.StartsWith(this.TIC)))
                {
                  str1 = this.ErrorStrings[5].ToString();
                }
                else
                {
                  if (this.RethrowLibraryComputationExceptions)
                  {
                    this.libraryComputationException = new Exception($"{this.FormulaErrorStrings[this.invalid_char_in_front_of]} {(object) text[index1]}");
                    throw new ArgumentException($"{this.FormulaErrorStrings[this.invalid_char_in_front_of]} {(object) text[index1]}");
                  }
                  if (!text.Substring(0, length1).Replace(this.LEFTBRACKET.ToString(), string.Empty).Contains("IFERROR") && !text.Substring(0, length1).Replace(this.LEFTBRACKET.ToString(), string.Empty).Contains("ISERROR"))
                    return this.ErrorStrings[5].ToString();
                }
              }
              this.findNamedRange = false;
            }
            else
            {
              bool flag1 = false;
              for (bool flag2 = false; index2 > -1 && (char.IsDigit(text[index2]) || !flag1 && (int) text[index2] == (int) CalcEngine.ParseDecimalSeparator || !flag2 && text[index2] == '%' || text[index2] == 'u' || text[index2] == '_'); --index2)
              {
                if ((int) text[index2] == (int) CalcEngine.ParseDecimalSeparator)
                  flag1 = true;
                else if (text[index2] == '%')
                  flag2 = true;
              }
              if (index2 > -1 && flag1 && (int) text[index2] == (int) CalcEngine.ParseDecimalSeparator)
                throw new ArgumentException(this.FormulaErrorStrings[this.number_contains_2_decimal_points]);
              int startIndex1 = index2 + 1;
              if (startIndex1 == 0 || startIndex1 > 0 && !this.IsUpper(text[startIndex1 - 1]))
              {
                str1 = 'n'.ToString() + text.Substring(startIndex1, index1 - startIndex1);
                length1 = startIndex1;
              }
              else
              {
                int index3 = startIndex1 - 1;
                while (index3 > -1 && this.IsUpper(text[index3]) | char.IsDigit(text[index3]) | text[index3] == '_' | text[index3] == '\\')
                  --index3;
                if (index3 > -1 && text[index3] == 'u')
                  --index3;
                if (index3 > -1 && text[index3] == '!')
                {
                  --index3;
                  while (index3 > -1 && text[index3] != '!')
                    --index3;
                  if (text.Substring(0, index3 + 1).Contains("[") && text.Substring(0, index3 + 1).Contains("]"))
                  {
                    --index3;
                    while (index3 < text.Length && text[index3] != '[' && text[index3] != '!')
                      --index3;
                    if (text[index3] == '[')
                      --index3;
                    if (text[index3] == '\'')
                      --index3;
                  }
                  else
                  {
                    while (index3 > -1 && text[index3] != '!')
                      --index3;
                  }
                  if (index3 > -1 && text[index3] == '!')
                    --index3;
                  if (index3 > -1 && text[index3] == 'u')
                    --index3;
                }
                int startIndex2;
                if (index3 > -1 && text[index3] == ':')
                {
                  int index4 = index3 - 1;
                  while (index4 > -1 && char.IsDigit(text[index4]))
                    --index4;
                  while (index4 > -1 && this.IsUpper(text[index4]))
                    --index4;
                  if (index4 > -1 && text[index4] == '!')
                  {
                    --index4;
                    while (index4 > -1 && text[index4] != '!')
                      --index4;
                    if (index4 > -1 && text[index4] == '!')
                      --index4;
                    if (index4 > -1 && text[index4] == 'u')
                      --index4;
                  }
                  startIndex2 = index4 + 1;
                  str1 = text.Substring(startIndex2, index1 - startIndex2);
                  string[] cellsFromArgs = this.GetCellsFromArgs(str1, false);
                  if (cellsFromArgs.Length > 0)
                    str1 = cellsFromArgs[0];
                }
                else
                {
                  startIndex2 = index3 + 1;
                  str1 = text.Substring(startIndex2, index1 - startIndex2);
                }
                this.UpdateDependencies(str1);
                length1 = startIndex2;
                if (this.NamedRanges.Count > 0)
                  str1 = this.CheckForNamedRange(str1);
              }
            }
          }
          else
            length1 = index1;
          if (index1 == text.Length - 1)
            throw new ArgumentException(this.FormulaErrorStrings[this.expression_cannot_end_with_an_operator]);
          int num7 = index1 + 1;
          bool flag3 = text[num7] == 'u';
          if (flag3)
            ++num7;
          string str2;
          int startIndex3;
          if ((int) text[num7] == (int) this.TIC[0])
          {
            int num8 = text.Substring(num7 + 1).IndexOf(this.TIC);
            if (num8 < 0)
              throw new ArgumentException(this.FormulaErrorStrings[this.cannot_parse]);
            str2 = text.Substring(num7, num8 + 2);
            startIndex3 = num8 + num7 + 2;
          }
          else if (text[num7] == '\u0092')
          {
            int nonQb = this.FindNonQB(text.Substring(num7 + 1));
            if (nonQb < 0)
              throw new ArgumentException(this.FormulaErrorStrings[this.cannot_parse]);
            str2 = text.Substring(num7 + 1, nonQb);
            if (flag3)
              str2 += "nu1m";
            startIndex3 = nonQb + num7 + 2;
          }
          else if (text[num7] == '#')
          {
            int length3 = 0;
            foreach (string errorString in this.ErrorStrings)
            {
              string str3 = errorString.Replace('/', '~');
              if (text.IndexOf(str3) > -1)
              {
                length3 += str3.Length;
                num7 += str3.Length - 1;
                break;
              }
            }
            str2 = text.Substring(index1 + 1, length3);
            startIndex3 = num7 + 1;
          }
          else if (text[num7] == 'q')
          {
            int num9 = 0;
            int index5;
            for (index5 = num7 + 1; index5 < text.Length && ((int) text[index5] != (int) this.RIGHTBRACKET || num9 != 0); ++index5)
            {
              if ((int) text[index5] == (int) this.RIGHTBRACKET)
                ++num9;
              else if (text[index5] == 'q')
                --num9;
            }
            if (index5 == text.Length)
              throw new ArgumentException(this.FormulaErrorStrings[this.cannot_parse]);
            str2 = text.Substring(num7, index5 - num7 + 1);
            if (flag3)
              str2 = 'u'.ToString() + str2;
            startIndex3 = index5 + 1;
          }
          else if (char.IsDigit(text[num7]) || (int) text[num7] == (int) CalcEngine.ParseDecimalSeparator)
          {
            bool flag4 = (int) text[num7] == (int) CalcEngine.ParseDecimalSeparator;
            int index6;
            for (index6 = num7 + 1; index6 < text.Length && (char.IsDigit(text[index6]) || !flag4 && (int) text[index6] == (int) CalcEngine.ParseDecimalSeparator); ++index6)
            {
              if ((int) text[index6] == (int) CalcEngine.ParseDecimalSeparator)
                flag4 = true;
            }
            if (index6 < text.Length && text[index6] == '%')
              ++index6;
            if (flag4 && index6 < text.Length && (int) text[index6] == (int) CalcEngine.ParseDecimalSeparator)
              throw new ArgumentException(this.FormulaErrorStrings[this.number_contains_2_decimal_points]);
            str2 = 'n'.ToString() + text.Substring(index1 + 1, index6 - index1 - 1);
            startIndex3 = index6;
          }
          else if (this.IsUpper(text[num7]) || text[num7] == '!' || text[num7] == 'u' || text.Contains("!") && text.Contains("'[") && text.Contains("]") || text[num7] == '\\' || text[num7] == '_')
          {
            if (text[num7] == '!')
            {
              ++num7;
              while (num7 < text.Length && text[num7] != '!')
                ++num7;
            }
            if (text.Contains("!") && text.Contains("'[") && text.Contains("]"))
            {
              if (num7 < text.Length - 1 && text[num7] == '[')
              {
                int index7 = num7 + 1;
                while (index7 < text.Length - 1 && text[index7] != ']')
                  ++index7;
                num7 = index7 + 1;
              }
              while (num7 < text.Length - 1 && (this.IsUpper(text[num7]) || char.IsDigit(text[num7])))
                ++num7;
              if (num7 < text.Length - 1 && text[num7] == '!')
              {
                ++num7;
                while (num7 < text.Length - 1 && text[num7] != '!')
                  ++num7;
              }
            }
            int index8 = num7 + 1;
            int num10 = 0;
            bool flag5 = false;
            while (index8 < text.Length && (this.IsUpper(text[index8]) || text[index8] == '_' || text[index8] == '.' || text[index8] == '[' || text[index8] == ']' || text[index8] == '#' || text[index8] == ' ' || text[index8] == '%' || (int) text[index8] == (int) CalcEngine.parseArgumentSeparator && flag5 || text[index8] == '\\'))
            {
              if (index8 != text.Length - 1 && text[index8] == '[' && text[index8 + 1] == '[')
                flag5 = true;
              if (index8 != text.Length - 1 && text[index8] == ']' && text[index8 + 1] == ']')
                flag5 = false;
              ++index8;
              ++num10;
            }
            bool flag6 = index8 == text.Length || !char.IsDigit(text[index8]);
            if (num10 > 1)
            {
              while (index8 < text.Length && (this.IsUpper(text[index8]) || char.IsDigit(text[index8]) || char.IsWhiteSpace(text[index8]) || text[index8] == '_' || text[index8] == '.' || text[index8] == '\\'))
                ++index8;
              flag6 = true;
            }
            while (index8 < text.Length && this.IsUpper(text[index8]) | char.IsDigit(text[index8]) | text[index8] == '_' | text[index8] == '.')
              ++index8;
            int index9;
            if (index8 < text.Length && text[index8] == ':')
            {
              int index10 = index8 + 1;
              if (index10 < text.Length && text[index10] == '!')
              {
                ++index10;
                while (index10 < text.Length && text[index10] != '!')
                  ++index10;
                if (index10 < text.Length && text[index10] == '!')
                  ++index10;
              }
              while (index10 < text.Length && this.IsUpper(text[index10]))
                ++index10;
              while (index10 < text.Length && char.IsDigit(text[index10]))
                ++index10;
              index9 = index10 - 1;
              str2 = text.Substring(index1 + 1, index9 - index1);
              string[] cellsFromArgs = this.GetCellsFromArgs(str2, false);
              if (cellsFromArgs.Length > 0)
                str2 = cellsFromArgs[0];
            }
            else
            {
              index9 = index8 - 1;
              str2 = text.Substring(index1 + 1, index9 - index1);
              if (text[index9] == 'u')
                str2 = 'u'.ToString() + str2;
            }
            if (this.IsCellReference(str2))
            {
              if (str2.Contains("!") && str2.Contains("[") && str2.Contains("]") && this.UpdateExternalFormula != null)
              {
                UpdateExternalFormulaEventArgs e = new UpdateExternalFormulaEventArgs(str2);
                this.UpdateExternalFormula((object) this, e);
                if (e.IsFormulaUpdated)
                  str2 = e.parsedFormula;
              }
              this.UpdateDependencies(str2);
            }
            else
            {
              if (this.NamedRanges.Count > 0 && !string.IsNullOrEmpty(str2.Trim()))
                str2 = this.CheckForNamedRange(str2);
              if (!this.findNamedRange)
              {
                if (str2 == this.TRUEVALUESTR)
                  str2 = 'n'.ToString() + this.TRUEVALUESTR;
                else if (str2 == this.FALSEVALUESTR)
                  str2 = 'n'.ToString() + this.FALSEVALUESTR;
                else if (!this.ExcelLikeComputations && str2.ToUpper().Equals(double.NaN.ToString().ToUpper()))
                  str2 = 'n'.ToString() + str2;
                else if (this.NamedRanges.Count > 0 && !this.IsCellReference(str2) && str2 != string.Empty && (str2.Contains(" ") || !str2.StartsWith(this.TIC)))
                {
                  str2 = this.ErrorStrings[5].ToString();
                }
                else
                {
                  if (this.RethrowLibraryComputationExceptions)
                  {
                    this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.invalid_characters_following_an_operator]);
                    throw new ArgumentException(this.FormulaErrorStrings[this.invalid_characters_following_an_operator]);
                  }
                  if (!text.Substring(0, length1).Replace(this.LEFTBRACKET.ToString(), string.Empty).Contains("IFERROR") && !text.Substring(0, length1).Replace(this.LEFTBRACKET.ToString(), string.Empty).Contains("ISERROR"))
                    return this.ErrorStrings[5].ToString();
                }
              }
              this.findNamedRange = false;
            }
            startIndex3 = index9 + 1;
          }
          else
          {
            if (this.ExcelLikeComputations || !text[num7].ToString().Equals(double.PositiveInfinity.ToString()))
              throw new ArgumentException(this.FormulaErrorStrings[this.invalid_characters_following_an_operator]);
            str2 = 'n'.ToString() + double.PositiveInfinity.ToString();
            startIndex3 = num7 + 1;
          }
          int index11 = empty1.IndexOf(text[index1]);
          string str4 = '\u0092'.ToString() + this.ZapBlocks(str1) + this.ZapBlocks(str2) + (object) markers[index11] + (object) '\u0092';
          if (length1 > 0)
            str4 = text.Substring(0, length1) + str4;
          if (startIndex3 < text.Length)
            str4 += text.Substring(startIndex3);
          text = str4.Replace(this.BMARKER2, '\u0092'.ToString());
        }
      }
      else
      {
        int index12 = text.Length - 1;
        if (text[index12] == '\u0092')
        {
          if (this.FindLastNonQB(text.Substring(0, index12 - 1)) < 0)
            throw new ArgumentException(this.FormulaErrorStrings[this.cannot_parse]);
        }
        else if ((int) text[index12] == (int) this.RIGHTBRACKET)
        {
          int num = 0;
          int index13;
          for (index13 = index12 - 1; index13 > 0 && (text[index13] != 'q' || num != 0); --index13)
          {
            if (text[index13] == 'q')
              --num;
            else if ((int) text[index13] == (int) this.RIGHTBRACKET)
              ++num;
          }
          if (index13 < 0)
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_library]);
        }
        else if (char.IsDigit(text[index12]))
        {
          bool flag7 = false;
          for (bool flag8 = false; index12 > -1 && (char.IsDigit(text[index12]) || !flag7 && (int) text[index12] == (int) CalcEngine.ParseDecimalSeparator || !flag8 && text[index12] == '%'); --index12)
          {
            if ((int) text[index12] == (int) CalcEngine.ParseDecimalSeparator)
              flag7 = true;
            else if (text[index12] == '%')
              flag8 = true;
          }
          if (index12 > -1 && flag7 && (int) text[index12] == (int) CalcEngine.ParseDecimalSeparator)
            throw new ArgumentException(this.FormulaErrorStrings[this.number_contains_2_decimal_points]);
        }
        if (text.Length > 0 && (char.IsUpper(text, 0) || text[0] == '!'))
        {
          bool flag9 = true;
          bool flag10 = true;
          bool flag11 = false;
          for (int index14 = 0; index14 < text.Length; ++index14)
          {
            if (text[index14] == '!')
            {
              if (index14 > 0 && !flag11)
              {
                if (this.rethrowExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.missing_sheet]);
                return this.ErrorStrings[2].ToString();
              }
              flag11 = true;
              ++index14;
              while (index14 < text.Length && char.IsDigit(text[index14]))
                ++index14;
              if (index14 == text.Length || text[index14] != '!')
              {
                flag9 = false;
                break;
              }
            }
            else
            {
              if (!flag10 && char.IsLetter(text, index14))
              {
                flag9 = false;
                break;
              }
              if (char.IsLetterOrDigit(text, index14) || text[index14] == '!')
              {
                flag10 = char.IsUpper(text, index14);
              }
              else
              {
                flag9 = false;
                break;
              }
            }
          }
          if (flag9)
          {
            this.UpdateDependencies(text);
            needToContinue = false;
          }
        }
      }
      return text;
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.RethrowLibraryComputationExceptions)
      {
        this.libraryComputationException = ex;
        throw ex;
      }
      return ex.Message;
    }
  }

  public void PutTokensForSheets(ref string text)
  {
    if (this.UpdateExternalFormula != null && text.Contains("[") && text.Contains("]") && text.Contains(".XLSX") || text.Contains(".XLSM"))
    {
      UpdateExternalFormulaEventArgs e = new UpdateExternalFormulaEventArgs(text);
      this.UpdateExternalFormula((object) this, e);
      if (e.IsFormulaUpdated)
        text = e.parsedFormula;
      text = this.CheckForNamedRange(text);
    }
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    if (this.SupportsSheetRanges)
      this.HandleSheetRanges(ref text, sheetFamilyItem);
    if (this.SortedSheetNames != null)
    {
      foreach (string sortedSheetName in this.SortedSheetNames)
      {
        string newValue = ((string) sheetFamilyItem.SheetNameToToken[(object) sortedSheetName]).Replace('!', this.tempSheetPlaceHolder);
        string oldValue1 = $"'{sortedSheetName.ToUpper()}'{(object) '!'}";
        if (text.IndexOf(oldValue1) == -1)
          oldValue1 = '!'.ToString() + sortedSheetName.ToUpper() + (object) '!';
        text = text.Replace(oldValue1, newValue);
        string oldValue2 = sortedSheetName.ToUpper() + (object) '!';
        text = text.Replace(oldValue2, newValue);
      }
    }
    text = text.Replace(this.tempSheetPlaceHolder, '!');
  }

  private void HandleSheetRanges(ref string text, GridSheetFamilyItem family)
  {
    int length = text.IndexOf('!');
    int startIndex = 0;
    char[] charArray = "%!@#$%^&*()?/>.<,:;'\\|}]{[_~`+=-\"".ToCharArray();
    for (; length > 0; length = text.Substring(startIndex + 1).IndexOf('!') + 1)
    {
      int num1 = text.Substring(startIndex, length).LastIndexOf(':');
      if (num1 > -1)
      {
        string str1 = text.Substring(startIndex + num1 + 1, length - num1 - 1).ToUpper().Replace("'", string.Empty);
        if (family.SheetNameToToken.ContainsKey((object) str1.Trim()))
        {
          int index = startIndex + num1 - 1;
          if (this.SortedSheetNames.Contains((object) str1) && str1.IndexOfAny(charArray) != -1)
          {
            index = index - str1.Length - 1;
          }
          else
          {
            while (index > 0 && this.markers.IndexOf(text[index]) == -1)
              --index;
          }
          string str2 = text.Substring(index + 1, num1 - index + startIndex - 1).ToUpper().Replace("'", string.Empty);
          if (family.SheetNameToToken.ContainsKey((object) str2.Trim()))
          {
            int num2 = length + startIndex + 1;
            if (this.SortedSheetNames.Contains((object) str2.Trim()) && str2.IndexOfAny(charArray) != -1)
            {
              num2 = text.Length - 1;
            }
            else
            {
              while (num2 < text.Length && this.markers.IndexOf(text[num2]) == -1)
                ++num2;
            }
            string str3 = text.Substring(startIndex + length + 1, num2 - startIndex - length - 1);
            string strB = family.SheetNameToToken[(object) str2.Trim()].ToString();
            string str4 = family.SheetNameToToken[(object) str1.Trim()].ToString();
            if (str4.CompareTo(strB) == -1)
            {
              string str5 = strB;
              strB = str4;
              str4 = str5;
            }
            string str6 = string.Empty;
            foreach (string sortedSheetName in this.SortedSheetNames)
            {
              int num3 = int.Parse(family.SheetNameToToken[(object) sortedSheetName].ToString().Replace("!", string.Empty));
              int num4 = int.Parse(strB.Replace("!", string.Empty));
              int num5 = int.Parse(str4.Replace("!", string.Empty));
              if (num3.CompareTo(num4) >= 0 && num3.CompareTo(num5) <= 0)
              {
                if (str6.Length > 0)
                  str6 += (string) (object) CalcEngine.ParseArgumentSeparator;
                str6 = str6 + sortedSheetName + (object) '\u0083' + str3;
              }
            }
            text = text.Substring(0, index + 1) + str6 + text.Substring(num2);
            startIndex = text.Length - num2;
          }
          else
            startIndex = length + startIndex;
        }
        else
          startIndex = length + startIndex;
      }
      else
        startIndex = length + startIndex;
    }
    text = text.Replace('\u0083', '!');
  }

  private bool NotInBlock(string text, int position)
  {
    int num = text.IndexOf('\u0092');
    bool flag = false;
    for (; num > -1 && num < position; num = text.IndexOf('\u0092', num + 1))
      flag = !flag;
    return !flag;
  }

  private void MarkLibraryFormulas(ref string formula)
  {
    int num1 = formula.IndexOf(')');
    if (num1 == -1)
    {
      this.MarkNamedRanges(ref formula);
    }
    else
    {
      for (; num1 > -1; num1 = formula.IndexOf(')'))
      {
        int num2 = 0;
        int num3;
        for (num3 = num1 - 1; num3 > -1 && (formula[num3] != '(' || num2 != 0); --num3)
        {
          if (formula[num3] == ')')
            ++num2;
          else if (formula[num3] == ')')
            --num2;
        }
        if (num3 == -1)
          throw new ArgumentException(this.FormulaErrorStrings[this.mismatched_parentheses]);
        int index1 = num3 - 1;
        while (index1 > -1 && (char.IsLetterOrDigit(formula[index1]) || this.validFunctionNameChars.IndexOf(formula[index1]) > -1 || formula[index1].Equals(CalcEngine.parseDecimalSeparator)))
          --index1;
        int length = num3 - index1 - 1;
        if (length > 0 && this.LibraryFunctions[(object) formula.Substring(index1 + 1, length)] != null)
        {
          this.ignoreBracet = formula.Substring(index1 + 1, length) == "AREAS";
          if (formula.Substring(index1 + 1, length) == "IFERROR" || formula.Substring(index1 + 1, length) == "ISERROR")
            this.errorFormula = true;
          string argList = formula.Substring(num3, num1 - num3 + 1);
          if (argList.Contains("({") && argList.Contains("})"))
          {
            string empty1 = string.Empty;
            string str1 = string.Empty;
            for (int index2 = 0; index2 < argList.Length; ++index2)
            {
              string empty2 = string.Empty;
              if (argList[index2].Equals('{'))
              {
                empty2 += (string) (object) argList[index2++];
                while (argList[index2] != '}')
                  str1 += (string) (object) argList[index2++];
              }
              if (str1.IndexOf("[") > -1 && str1.IndexOf("]") == -1)
              {
                for (str1 += (string) (object) argList[index2++]; argList[index2] != '}'; str1 += (string) (object) argList[index2++])
                {
                  if (argList[index2] == ']')
                    str1 = this.CheckForNamedRange(str1.Replace("{", "(").Replace("}", ")") + (object) argList[index2++]);
                }
              }
              string str2 = empty2 + str1 + (object) argList[index2];
              if (this.NamedRanges.Count > 0 && !string.IsNullOrEmpty(str1.Trim()))
              {
                this.CheckForNamedRange(str1.ToUpper());
                if (this.findNamedRange)
                  str2 = str2.Replace("{", string.Empty).Replace("}", string.Empty);
                this.findNamedRange = false;
              }
              str1 = string.Empty;
              empty1 += str2;
            }
            argList = empty1;
          }
          this.MarkNamedRanges(ref argList);
          formula = formula.Substring(0, index1 + 1) + (object) 'q' + formula.Substring(index1 + 1, length) + argList.Replace('(', this.LEFTBRACKET).Replace(')', this.RIGHTBRACKET) + formula.Substring(num1 + 1);
        }
        else if (length > 0)
        {
          if (this.UnknownFunction != null)
          {
            GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
            ICalcData grid = this.grid;
            string key1 = this.SheetToken(this.cell);
            string str = this.cell;
            if (key1.Length > 0)
            {
              grid = sheetFamilyItem.TokenToParentObject[(object) key1] as ICalcData;
              str = str.Substring(str.LastIndexOf('!') + 1);
            }
            foreach (string key2 in (IEnumerable) sheetFamilyItem.SheetNameToParentObject.Keys)
            {
              if (sheetFamilyItem.SheetNameToParentObject[(object) key2].Equals((object) grid))
              {
                str = key2 + (object) '!' + str;
                break;
              }
            }
            this.UnknownFunction((object) this, new UnknownFunctionEventArgs()
            {
              MissingFunctionName = formula.Substring(index1 + 1, length),
              CellLocation = str
            });
            this.ignoreBracet = formula.Substring(index1 + 1, length) == "AREAS";
          }
          if ((!formula.Contains("IFERROR") || !formula.Substring(0, formula.IndexOf(formula.Substring(index1 + 1, length)) - 1).EndsWith("IFERROR")) && (!formula.Contains("ISERROR") || !formula.Substring(0, formula.IndexOf(formula.Substring(index1 + 1, length)) - 1).EndsWith("ISERROR")))
            throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
          formula = formula.Replace(formula.Substring(index1 + 1, length), this.ErrorStrings[5].ToString());
          this.MarkLibraryFormulas(ref formula);
        }
        else
        {
          string argList = string.Empty;
          if (num3 > 0)
            argList = formula.Substring(0, num3);
          argList = argList + (object) '{' + formula.Substring(num3 + 1, num1 - num3 - 1) + (object) '}';
          if (num1 < formula.Length)
            argList += formula.Substring(num1 + 1);
          if (!argList.Contains("((") && !argList.Contains("))"))
            this.MarkNamedRanges(ref argList);
          formula = argList;
        }
      }
    }
    formula = formula.Replace('{', '(').Replace('}', ')');
  }

  internal Hashtable SaveStrings(ref string text)
  {
    Hashtable hashtable = (Hashtable) null;
    string oldValue = this.TIC + this.TIC;
    int num1 = 0;
    int num2;
    if ((num2 = text.IndexOf(this.TIC)) > -1)
    {
      while (num2 > -1 && num2 < text.Length)
      {
        if (hashtable == null)
          hashtable = new Hashtable();
        int num3 = num2 + 1 < text.Length ? text.IndexOf(this.TIC, num2 + 1) : -1;
        if (num3 > -1)
        {
          object[] objArray1 = new object[4]
          {
            (object) this.TIC,
            (object) this.UNIQUESTRINGMARKER,
            (object) num1.ToString(),
            (object) this.TIC
          };
          string key;
          object[] objArray2;
          for (key = string.Concat(objArray1); text.Contains(key); key = string.Concat(objArray2))
          {
            ++num1;
            objArray2 = new object[4]
            {
              (object) this.TIC,
              (object) this.UNIQUESTRINGMARKER,
              (object) num1.ToString(),
              (object) this.TIC
            };
          }
          if (num3 < text.Length - 2 && (int) text[num3 + 1] == (int) this.TIC[0])
          {
            num3 = text.IndexOf(this.TIC, num3 + 2);
            if (num3 == -1)
              throw new ArgumentException(this.FormulaErrorStrings[this.mismatched_tics]);
          }
          string str = text.Substring(num2, num3 - num2 + 1);
          hashtable.Add((object) key, (object) str);
          str.Replace(oldValue, this.TIC);
          ++num1;
          text = text.Substring(0, num2) + key + text.Substring(num3 + 1);
          num2 += key.Length;
          if (num2 < text.Length)
            num2 = text.IndexOf(this.TIC, num2);
        }
        else
        {
          if (num3 != -1 || text.IndexOf('!') <= -1 || num2 >= text.IndexOf('!', num2))
            throw new ArgumentException(this.FormulaErrorStrings[this.mismatched_tics]);
          string str = string.Empty;
          for (int index = text.IndexOf('!', num2) - 1; index > -1 && !this.ValidPrecedingChars.Contains(text[index].ToString()); --index)
            str = text[index].ToString() + str;
          if (!str.StartsWith("'") || !str.EndsWith("'"))
            throw new ArgumentException(this.FormulaErrorStrings[this.mismatched_tics]);
          if (str.StartsWith("'"))
            str = str.Remove(0, 1);
          if (str.EndsWith("'"))
            str = str.Remove(str.Length - 1, 1);
          if (!this.SortedSheetNames.Contains((object) str.ToUpper()))
            throw new ArgumentException(this.FormulaErrorStrings[this.missing_sheet]);
          if (num2 + 1 < text.Length)
            num2 = text.IndexOf(this.TIC, num2 + 1);
        }
      }
    }
    return hashtable;
  }

  internal void SetStrings(ref string retValue, Hashtable strings)
  {
    foreach (string key in (IEnumerable) strings.Keys)
      retValue = retValue.Replace(key, (string) strings[(object) key]);
  }

  private int FindLastNonQB(string text)
  {
    int lastNonQb = -1;
    if (text.IndexOf('\u0092') > -1)
    {
      int num = 0;
      for (int index = text.Length - 1; index >= 0; --index)
      {
        if ((int) text[index] == (int) this.RIGHTBRACKET)
          --num;
        else if ((int) text[index] == (int) this.LEFTBRACKET)
          ++num;
        else if (text[index] == '\u0092' && num == 0)
        {
          lastNonQb = index;
          break;
        }
      }
    }
    return lastNonQb;
  }

  private string GetCellFrom(string range)
  {
    string cellFrom = string.Empty;
    string[] cellsFromArgs = this.GetCellsFromArgs(range);
    if (cellsFromArgs.Length == 1)
      return cellsFromArgs[0];
    int index = cellsFromArgs.Length - 1;
    int num1 = this.RowIndex(cellsFromArgs[0]);
    if (num1 == this.RowIndex(cellsFromArgs[index]))
    {
      int num2 = this.ColIndex(cellsFromArgs[0]);
      int num3 = this.ColIndex(cellsFromArgs[index]);
      int col = this.ColIndex(this.cell);
      if (col >= num2 && col <= num3)
        cellFrom = $"{RangeInfo.GetAlphaLabel(col)}{num1}";
    }
    else
    {
      int col;
      if ((col = this.ColIndex(cellsFromArgs[0])) == this.ColIndex(cellsFromArgs[index]))
      {
        int num4 = 0;
        int num5 = this.RowIndex(cellsFromArgs[index]);
        if (this.cell != string.Empty)
          num4 = this.RowIndex(this.cell);
        return num4 >= num1 && num4 <= num5 ? $"{RangeInfo.GetAlphaLabel(col)}{num4}" : this.ErrorStrings[1].ToString();
      }
    }
    if (cellFrom.Equals(string.Empty) && this.IsRange(range))
      cellFrom = $"{RangeInfo.GetAlphaLabel(this.ColIndex(cellsFromArgs[0]))}{num1}";
    return cellFrom;
  }

  private int FindNonQB(string text)
  {
    int nonQb = -1;
    if (text.IndexOf('\u0092') > -1)
    {
      int num = 0;
      for (int index = 0; index < text.Length; ++index)
      {
        if ((int) text[index] == (int) this.RIGHTBRACKET)
          --num;
        else if ((int) text[index] == (int) this.LEFTBRACKET)
          ++num;
        else if (text[index] == '\u0092' && num == 0)
        {
          nonQb = index;
          break;
        }
      }
    }
    return nonQb;
  }

  private string ZapBlocks(string text)
  {
    if (text.IndexOf('\u0092') > -1)
    {
      int num = 0;
      for (int index = text.Length - 1; index > 0; --index)
      {
        if ((int) text[index] == (int) this.RIGHTBRACKET)
          --num;
        else if ((int) text[index] == (int) this.LEFTBRACKET)
          ++num;
        else if (text[index] == '\u0092' && num == 0)
          text.Remove(index, 1);
      }
    }
    return text;
  }

  public bool AddFunction(string name, CalcEngine.LibraryFunction func)
  {
    name = name.ToUpper(CultureInfo.InvariantCulture);
    if (this.LibraryFunctions[(object) name] != null)
      return false;
    this.LibraryFunctions.Add((object) name, (object) func);
    return true;
  }

  public bool RemoveFunction(string name)
  {
    if (this.LibraryFunctions[(object) name] == null)
      return false;
    this.LibraryFunctions.Remove((object) name);
    return true;
  }

  public virtual void InitLibraryFunctions()
  {
    this.libraryFunctions = new Hashtable();
    this.AddFunction("MAXIFS", new CalcEngine.LibraryFunction(this.ComputeMAXIFS));
    this.AddFunction("MINIFS", new CalcEngine.LibraryFunction(this.ComputeMINIFS));
    this.AddFunction("ifs", new CalcEngine.LibraryFunction(this.ComputeIFS));
    this.AddFunction("Switch", new CalcEngine.LibraryFunction(this.ComputeSwitch));
    this.AddFunction("TextJoin", new CalcEngine.LibraryFunction(this.ComputeTextJoin));
    this.AddFunction("Concat", new CalcEngine.LibraryFunction(this.ComputeConcat));
    this.AddFunction("Countifs", new CalcEngine.LibraryFunction(this.ComputeCOUNTIFS));
    this.AddFunction("Sum", new CalcEngine.LibraryFunction(this.ComputeSum));
    this.AddFunction("Avg", new CalcEngine.LibraryFunction(this.ComputeAvg));
    this.AddFunction("Max", new CalcEngine.LibraryFunction(this.ComputeMax));
    this.AddFunction("Min", new CalcEngine.LibraryFunction(this.ComputeMin));
    this.AddFunction("Pi", new CalcEngine.LibraryFunction(this.ComputePI));
    this.AddFunction("Sign", new CalcEngine.LibraryFunction(this.ComputeSign));
    this.AddFunction("Pow", new CalcEngine.LibraryFunction(this.ComputePow));
    this.AddFunction("Power", new CalcEngine.LibraryFunction(this.ComputePow));
    this.AddFunction("And", new CalcEngine.LibraryFunction(this.ComputeAnd));
    this.AddFunction("Or", new CalcEngine.LibraryFunction(this.ComputeOr));
    this.AddFunction("Xor", new CalcEngine.LibraryFunction(this.ComputeXor));
    this.AddFunction("If", new CalcEngine.LibraryFunction(this.ComputeIf));
    this.AddFunction("Not", new CalcEngine.LibraryFunction(this.ComputeNot));
    this.AddFunction("False", new CalcEngine.LibraryFunction(this.ComputeFalse));
    this.AddFunction("TRUE", new CalcEngine.LibraryFunction(this.ComputeTrue));
    this.AddFunction("IfNA", new CalcEngine.LibraryFunction(this.ComputeIfNA));
    this.AddFunction("HLookUp", new CalcEngine.LibraryFunction(this.ComputeHLookUp));
    this.AddFunction("VLookUp", new CalcEngine.LibraryFunction(this.ComputeVLookUp));
    this.AddFunction("LookUp", new CalcEngine.LibraryFunction(this.ComputeLookUp));
    this.AddFunction("Left", new CalcEngine.LibraryFunction(this.ComputeLeft));
    this.AddFunction("Right", new CalcEngine.LibraryFunction(this.ComputeRight));
    this.AddFunction("Len", new CalcEngine.LibraryFunction(this.ComputeLen));
    this.AddFunction("Mid", new CalcEngine.LibraryFunction(this.ComputeMid));
    this.AddFunction("Product", new CalcEngine.LibraryFunction(this.ComputeProduct));
    this.AddFunction("Value", new CalcEngine.LibraryFunction(this.ComputeValue));
    this.AddFunction("Mod", new CalcEngine.LibraryFunction(this.ComputeMod));
    this.AddFunction("Trunc", new CalcEngine.LibraryFunction(this.ComputeTrunc));
    this.AddFunction("SumProduct", new CalcEngine.LibraryFunction(this.ComputeSumProduct));
    this.AddFunction("Average", new CalcEngine.LibraryFunction(this.ComputeAvg));
    this.AddFunction("Int", new CalcEngine.LibraryFunction(this.ComputeInt));
    this.AddFunction("OffSet", new CalcEngine.LibraryFunction(this.ComputeOffSet));
    this.AddFunction("Index", new CalcEngine.LibraryFunction(this.ComputeIndex));
    this.AddFunction("Match", new CalcEngine.LibraryFunction(this.ComputeMatch));
    this.AddFunction("Exact", new CalcEngine.LibraryFunction(this.ComputeExact));
    this.AddFunction("Find", new CalcEngine.LibraryFunction(this.ComputeFind));
    this.AddFunction("Column", new CalcEngine.LibraryFunction(this.ComputeColumn));
    this.AddFunction("Choose", new CalcEngine.LibraryFunction(this.ComputeChoose));
    this.AddFunction("Clean", new CalcEngine.LibraryFunction(this.ComputeClean));
    this.AddFunction("Dollar", new CalcEngine.LibraryFunction(this.ComputeDollar));
    this.AddFunction("DollarDe", new CalcEngine.LibraryFunction(this.ComputeDollarDe));
    this.AddFunction("DollarFr", new CalcEngine.LibraryFunction(this.ComputeDollarFr));
    this.AddFunction("Duration", new CalcEngine.LibraryFunction(this.ComputeDuration));
    this.AddFunction("RRI", new CalcEngine.LibraryFunction(this.ComputeRRI));
    this.AddFunction("Received", new CalcEngine.LibraryFunction(this.ComputeReceived));
    this.AddFunction("Fvschedule", new CalcEngine.LibraryFunction(this.ComputeFvschedule));
    this.AddFunction("Disc", new CalcEngine.LibraryFunction(this.ComputeDisc));
    this.AddFunction("INTRATE", new CalcEngine.LibraryFunction(this.ComputeIntrate));
    this.AddFunction("CUMIPMT", new CalcEngine.LibraryFunction(this.ComputeCUMIPMT));
    this.AddFunction("CUMPRINC", new CalcEngine.LibraryFunction(this.ComputeCUMPRINC));
    this.AddFunction("DCount", new CalcEngine.LibraryFunction(this.ComputeDCount));
    this.AddFunction("DCountA", new CalcEngine.LibraryFunction(this.ComputeDCountA));
    this.AddFunction("DAverage", new CalcEngine.LibraryFunction(this.ComputeDAverage));
    this.AddFunction("DGet", new CalcEngine.LibraryFunction(this.ComputeDGet));
    this.AddFunction("DMax", new CalcEngine.LibraryFunction(this.ComputeDMax));
    this.AddFunction("DMin", new CalcEngine.LibraryFunction(this.ComputeDMin));
    this.AddFunction("DStdevp", new CalcEngine.LibraryFunction(this.ComputeDStdevp));
    this.AddFunction("DStdev", new CalcEngine.LibraryFunction(this.ComputeDStdev));
    this.AddFunction("DVarp", new CalcEngine.LibraryFunction(this.ComputeDVarp));
    this.AddFunction("DVar", new CalcEngine.LibraryFunction(this.ComputeDVar));
    this.AddFunction("DSum", new CalcEngine.LibraryFunction(this.ComputeDSum));
    this.AddFunction("DPRODUCT", new CalcEngine.LibraryFunction(this.ComputeDProduct));
    this.AddFunction("Fixed", new CalcEngine.LibraryFunction(this.ComputeFixed));
    this.AddFunction("Lower", new CalcEngine.LibraryFunction(this.ComputeLower));
    this.AddFunction("Upper", new CalcEngine.LibraryFunction(this.ComputeUpper));
    this.AddFunction("Trim", new CalcEngine.LibraryFunction(this.ComputeTrim));
    this.AddFunction("Text", new CalcEngine.LibraryFunction(this.ComputeText));
    this.AddFunction("Concatenate", new CalcEngine.LibraryFunction(this.ComputeConcatenate));
    this.AddFunction("Indirect", new CalcEngine.LibraryFunction(this.ComputeIndirect));
    this.AddFunction("Substitute", new CalcEngine.LibraryFunction(this.ComputeSubstitute));
    this.AddFunction("Char", new CalcEngine.LibraryFunction(this.ComputeChar));
    this.AddFunction("IsError", new CalcEngine.LibraryFunction(this.ComputeIsError));
    this.AddFunction("IsNumber", new CalcEngine.LibraryFunction(this.ComputeIsNumber));
    this.AddFunction("IsLogical", new CalcEngine.LibraryFunction(this.ComputeIsLogical));
    this.AddFunction("IsNA", new CalcEngine.LibraryFunction(this.ComputeIsNA));
    this.AddFunction("IsErr", new CalcEngine.LibraryFunction(this.ComputeIsErr));
    this.AddFunction("IsBlank", new CalcEngine.LibraryFunction(this.ComputeIsBlank));
    this.AddFunction("IsText", new CalcEngine.LibraryFunction(this.ComputeIsText));
    this.AddFunction("IsNonText", new CalcEngine.LibraryFunction(this.ComputeIsNonText));
    this.AddFunction("IsEven", new CalcEngine.LibraryFunction(this.ComputeIsEven));
    this.AddFunction("IsOdd", new CalcEngine.LibraryFunction(this.ComputeIsOdd));
    this.AddFunction("IsRef", new CalcEngine.LibraryFunction(this.ComputeIsRef));
    this.AddFunction("N", new CalcEngine.LibraryFunction(this.ComputeN));
    this.AddFunction("NA", new CalcEngine.LibraryFunction(this.ComputeNA));
    this.AddFunction("ERROR.TYPE", new CalcEngine.LibraryFunction(this.ComputeErrorType));
    this.AddFunction("IfError", new CalcEngine.LibraryFunction(this.ComputeIfError));
    this.AddFunction("T", new CalcEngine.LibraryFunction(this.ComputeT));
    this.AddFunction("Acos", new CalcEngine.LibraryFunction(this.ComputeAcos));
    this.AddFunction("Asin", new CalcEngine.LibraryFunction(this.ComputeAsin));
    this.AddFunction("Atan", new CalcEngine.LibraryFunction(this.ComputeAtan));
    this.AddFunction("Cos", new CalcEngine.LibraryFunction(this.ComputeCos));
    this.AddFunction("Sin", new CalcEngine.LibraryFunction(this.ComputeSin));
    this.AddFunction("Cosh", new CalcEngine.LibraryFunction(this.ComputeCosh));
    this.AddFunction("Sinh", new CalcEngine.LibraryFunction(this.ComputeSinh));
    this.AddFunction("Tanh", new CalcEngine.LibraryFunction(this.ComputeTanh));
    this.AddFunction("Round", new CalcEngine.LibraryFunction(this.ComputeRound));
    this.AddFunction("Ceiling", new CalcEngine.LibraryFunction(this.ComputeCeiling));
    this.AddFunction("Floor", new CalcEngine.LibraryFunction(this.ComputeFloor));
    this.AddFunction("Log", new CalcEngine.LibraryFunction(this.ComputeLog));
    this.AddFunction("Log10", new CalcEngine.LibraryFunction(this.ComputeLog10));
    this.AddFunction("Exp", new CalcEngine.LibraryFunction(this.ComputeExp));
    this.AddFunction("Sqrt", new CalcEngine.LibraryFunction(this.ComputeSqrt));
    this.AddFunction("Abs", new CalcEngine.LibraryFunction(this.ComputeAbs));
    this.AddFunction("Tan", new CalcEngine.LibraryFunction(this.ComputeTan));
    this.AddFunction("SUBTOTAL", new CalcEngine.LibraryFunction(this.ComputeSubTotal));
    this.AddFunction("Db", new CalcEngine.LibraryFunction(this.ComputeDb));
    this.AddFunction("Ddb", new CalcEngine.LibraryFunction(this.ComputeDdb));
    this.AddFunction("Fv", new CalcEngine.LibraryFunction(this.ComputeFv));
    this.AddFunction("Ipmt", new CalcEngine.LibraryFunction(this.ComputeIpmt));
    this.AddFunction("Irr", new CalcEngine.LibraryFunction(this.ComputeIrr));
    this.AddFunction("Xirr", new CalcEngine.LibraryFunction(this.ComputeXirr));
    this.AddFunction("Ispmt", new CalcEngine.LibraryFunction(this.ComputeIspmt));
    this.AddFunction("Mirr", new CalcEngine.LibraryFunction(this.ComputeMirr));
    this.AddFunction("Nper", new CalcEngine.LibraryFunction(this.ComputeNper));
    this.AddFunction("Npv", new CalcEngine.LibraryFunction(this.ComputeNpv));
    this.AddFunction("Pmt", new CalcEngine.LibraryFunction(this.ComputePmt));
    this.AddFunction("Ppmt", new CalcEngine.LibraryFunction(this.ComputePpmt));
    this.AddFunction("Pv", new CalcEngine.LibraryFunction(this.ComputePv));
    this.AddFunction("Rate", new CalcEngine.LibraryFunction(this.ComputeRate));
    this.AddFunction("Sln", new CalcEngine.LibraryFunction(this.ComputeSln));
    this.AddFunction("Syd", new CalcEngine.LibraryFunction(this.ComputeSyd));
    this.AddFunction("Vdb", new CalcEngine.LibraryFunction(this.ComputeVdb));
    this.AddFunction("ACCRINT", new CalcEngine.LibraryFunction(this.ComputeACCRINT));
    this.AddFunction("ACCRINTM", new CalcEngine.LibraryFunction(this.ComputeACCRINTM));
    this.AddFunction("EFFECT", new CalcEngine.LibraryFunction(this.ComputeEffect));
    this.AddFunction("Rand", new CalcEngine.LibraryFunction(this.ComputeRand));
    this.AddFunction("Acosh", new CalcEngine.LibraryFunction(this.ComputeAcosh));
    this.AddFunction("Asinh", new CalcEngine.LibraryFunction(this.ComputeAsinh));
    this.AddFunction("Atanh", new CalcEngine.LibraryFunction(this.ComputeAtanh));
    this.AddFunction("Atan2", new CalcEngine.LibraryFunction(this.ComputeAtan2));
    this.AddFunction("Combin", new CalcEngine.LibraryFunction(this.ComputeCombin));
    this.AddFunction("Degrees", new CalcEngine.LibraryFunction(this.ComputeDegrees));
    this.AddFunction("Even", new CalcEngine.LibraryFunction(this.ComputeEven));
    this.AddFunction("Fact", new CalcEngine.LibraryFunction(this.ComputeFact));
    this.AddFunction("Ln", new CalcEngine.LibraryFunction(this.ComputeLn));
    this.AddFunction("Odd", new CalcEngine.LibraryFunction(this.ComputeOdd));
    this.AddFunction("Radians", new CalcEngine.LibraryFunction(this.ComputeRadians));
    this.AddFunction("Round", new CalcEngine.LibraryFunction(this.ComputeRound));
    this.AddFunction("Rounddown", new CalcEngine.LibraryFunction(this.ComputeRounddown));
    this.AddFunction("Roundup", new CalcEngine.LibraryFunction(this.ComputeRoundup));
    this.AddFunction("Sumif", new CalcEngine.LibraryFunction(this.ComputeSumif));
    this.AddFunction("Sumsq", new CalcEngine.LibraryFunction(this.ComputeSumsq));
    this.AddFunction("Sumx2my2", new CalcEngine.LibraryFunction(this.ComputeSumx2my2));
    this.AddFunction("Sumx2py2", new CalcEngine.LibraryFunction(this.ComputeSumx2py2));
    this.AddFunction("Sumxmy2", new CalcEngine.LibraryFunction(this.ComputeSumxmy2));
    this.AddFunction("Date", new CalcEngine.LibraryFunction(this.ComputeDate));
    this.AddFunction("Datevalue", new CalcEngine.LibraryFunction(this.ComputeDatevalue));
    this.AddFunction("Day", new CalcEngine.LibraryFunction(this.ComputeDay));
    this.AddFunction("Days360", new CalcEngine.LibraryFunction(this.ComputeDays360));
    this.AddFunction("Hour", new CalcEngine.LibraryFunction(this.ComputeHour));
    this.AddFunction("Minute", new CalcEngine.LibraryFunction(this.ComputeMinute));
    this.AddFunction("Second", new CalcEngine.LibraryFunction(this.ComputeSecond));
    this.AddFunction("Month", new CalcEngine.LibraryFunction(this.ComputeMonth));
    this.AddFunction("Now", new CalcEngine.LibraryFunction(this.ComputeNow));
    this.AddFunction("Time", new CalcEngine.LibraryFunction(this.ComputeTime));
    this.AddFunction("Timevalue", new CalcEngine.LibraryFunction(this.ComputeTimevalue));
    this.AddFunction("Today", new CalcEngine.LibraryFunction(this.ComputeToday));
    this.AddFunction("Weekday", new CalcEngine.LibraryFunction(this.ComputeWeekday));
    this.AddFunction("Year", new CalcEngine.LibraryFunction(this.ComputeYear));
    this.AddFunction("Multinomial", new CalcEngine.LibraryFunction(this.ComputeMultinomial));
    this.AddFunction("Mround", new CalcEngine.LibraryFunction(this.ComputeMround));
    this.AddFunction("Randbetween", new CalcEngine.LibraryFunction(this.ComputeRandbetween));
    this.AddFunction("Sqrtpi", new CalcEngine.LibraryFunction(this.ComputeSqrtpi));
    this.AddFunction("Quotient", new CalcEngine.LibraryFunction(this.ComputeQuotient));
    this.AddFunction("Factdouble", new CalcEngine.LibraryFunction(this.ComputeFactdouble));
    this.AddFunction("Gcd", new CalcEngine.LibraryFunction(this.ComputeGcd));
    this.AddFunction("Lcm", new CalcEngine.LibraryFunction(this.ComputeLcm));
    this.AddFunction("Roman", new CalcEngine.LibraryFunction(this.ComputeRoman));
    this.AddFunction("Search", new CalcEngine.LibraryFunction(this.ComputeSearch));
    this.AddFunction("Avedev", new CalcEngine.LibraryFunction(this.ComputeAvedev));
    this.AddFunction("Averagea", new CalcEngine.LibraryFunction(this.ComputeAveragea));
    this.AddFunction("Gammaln", new CalcEngine.LibraryFunction(this.ComputeGammaln));
    this.AddFunction("Gammadist", new CalcEngine.LibraryFunction(this.ComputeGammadist));
    this.AddFunction("Gammainv", new CalcEngine.LibraryFunction(this.ComputeGammainv));
    this.AddFunction("Geomean", new CalcEngine.LibraryFunction(this.ComputeGeomean));
    this.AddFunction("Harmean", new CalcEngine.LibraryFunction(this.ComputeHarmean));
    this.AddFunction("Hypgeomdist", new CalcEngine.LibraryFunction(this.ComputeHypgeomdist));
    this.AddFunction("Intercept", new CalcEngine.LibraryFunction(this.ComputeIntercept));
    this.AddFunction("Binomdist", new CalcEngine.LibraryFunction(this.ComputeBinomdist));
    this.AddFunction("Chidist", new CalcEngine.LibraryFunction(this.ComputeChidist));
    this.AddFunction("Chiinv", new CalcEngine.LibraryFunction(this.ComputeChiinv));
    this.AddFunction("Chitest", new CalcEngine.LibraryFunction(this.ComputeChitest));
    this.AddFunction("Normdist", new CalcEngine.LibraryFunction(this.ComputeNormdist));
    this.AddFunction("Norminv", new CalcEngine.LibraryFunction(this.ComputeNorminv));
    this.AddFunction("NormsDist", new CalcEngine.LibraryFunction(this.ComputeNormsDist));
    this.AddFunction("NormsInv", new CalcEngine.LibraryFunction(this.ComputeNormsInv));
    this.AddFunction("Confidence", new CalcEngine.LibraryFunction(this.ComputeConfidence));
    this.AddFunction("Correl", new CalcEngine.LibraryFunction(this.ComputeCorrel));
    this.AddFunction("Count", new CalcEngine.LibraryFunction(this.ComputeCount));
    this.AddFunction("Counta", new CalcEngine.LibraryFunction(this.ComputeCounta));
    this.AddFunction("Countblank", new CalcEngine.LibraryFunction(this.ComputeCountblank));
    this.AddFunction("Countif", new CalcEngine.LibraryFunction(this.ComputeCountif));
    this.AddFunction("Covar", new CalcEngine.LibraryFunction(this.ComputeCovar));
    this.AddFunction("CritBinom", new CalcEngine.LibraryFunction(this.ComputeCritbinom));
    this.AddFunction("Devsq", new CalcEngine.LibraryFunction(this.ComputeDevsq));
    this.AddFunction("Expondist", new CalcEngine.LibraryFunction(this.ComputeExpondist));
    this.AddFunction("Fdist", new CalcEngine.LibraryFunction(this.ComputeFdist));
    this.AddFunction("Finv", new CalcEngine.LibraryFunction(this.ComputeFinv));
    this.AddFunction("Fisher", new CalcEngine.LibraryFunction(this.ComputeFisher));
    this.AddFunction("Fisherinv", new CalcEngine.LibraryFunction(this.ComputeFisherinv));
    this.AddFunction("Forecast", new CalcEngine.LibraryFunction(this.ComputeForecast));
    this.AddFunction("Growth", new CalcEngine.LibraryFunction(this.ComputeGrowth));
    this.AddFunction("Kurt", new CalcEngine.LibraryFunction(this.ComputeKurt));
    this.AddFunction("Large", new CalcEngine.LibraryFunction(this.ComputeLarge));
    this.AddFunction("Logest", new CalcEngine.LibraryFunction(this.ComputeLogest));
    this.AddFunction("Logestb", new CalcEngine.LibraryFunction(this.ComputeLogestb));
    this.AddFunction("Lognormdist", new CalcEngine.LibraryFunction(this.ComputeLognormdist));
    this.AddFunction("Loginv", new CalcEngine.LibraryFunction(this.ComputeLoginv));
    this.AddFunction("Maxa", new CalcEngine.LibraryFunction(this.ComputeMaxa));
    this.AddFunction("Median", new CalcEngine.LibraryFunction(this.ComputeMedian));
    this.AddFunction("Mina", new CalcEngine.LibraryFunction(this.ComputeMina));
    this.AddFunction("Mode", new CalcEngine.LibraryFunction(this.ComputeMode));
    this.AddFunction("Negbinomdist", new CalcEngine.LibraryFunction(this.ComputeNegbinomdist));
    this.AddFunction("Pearson", new CalcEngine.LibraryFunction(this.ComputePearson));
    this.AddFunction("Percentile", new CalcEngine.LibraryFunction(this.ComputePercentile));
    this.AddFunction("Percentrank", new CalcEngine.LibraryFunction(this.ComputePercentrank));
    this.AddFunction("Permut", new CalcEngine.LibraryFunction(this.ComputePermut));
    this.AddFunction("Poisson", new CalcEngine.LibraryFunction(this.ComputePoisson));
    this.AddFunction("Prob", new CalcEngine.LibraryFunction(this.ComputeProb));
    this.AddFunction("Quartile", new CalcEngine.LibraryFunction(this.ComputeQuartile));
    this.AddFunction("Rank", new CalcEngine.LibraryFunction(this.ComputeRank));
    this.AddFunction("Rsq", new CalcEngine.LibraryFunction(this.ComputeRsq));
    this.AddFunction("Skew", new CalcEngine.LibraryFunction(this.ComputeSkew));
    this.AddFunction("Slope", new CalcEngine.LibraryFunction(this.ComputeSlope));
    this.AddFunction("Small", new CalcEngine.LibraryFunction(this.ComputeSmall));
    this.AddFunction("Standardize", new CalcEngine.LibraryFunction(this.ComputeStandardize));
    this.AddFunction("Stdev", new CalcEngine.LibraryFunction(this.ComputeStdev));
    this.AddFunction("Stdeva", new CalcEngine.LibraryFunction(this.ComputeStdeva));
    this.AddFunction("Stdevp", new CalcEngine.LibraryFunction(this.ComputeStdevp));
    this.AddFunction("Stdevpa", new CalcEngine.LibraryFunction(this.ComputeStdevpa));
    this.AddFunction("Steyx", new CalcEngine.LibraryFunction(this.ComputeSteyx));
    this.AddFunction("Linest", new CalcEngine.LibraryFunction(this.ComputeLinest));
    this.AddFunction("Trimmean", new CalcEngine.LibraryFunction(this.ComputeTrimmean));
    this.AddFunction("Var", new CalcEngine.LibraryFunction(this.ComputeVar));
    this.AddFunction("Vara", new CalcEngine.LibraryFunction(this.ComputeVara));
    this.AddFunction("Varp", new CalcEngine.LibraryFunction(this.ComputeVarp));
    this.AddFunction("Varpa", new CalcEngine.LibraryFunction(this.ComputeVarpa));
    this.AddFunction("Weibull", new CalcEngine.LibraryFunction(this.ComputeWeibull));
    this.AddFunction("Ztest", new CalcEngine.LibraryFunction(this.ComputeZtest));
    this.AddFunction("Address", new CalcEngine.LibraryFunction(this.ComputeAddress));
    this.AddFunction("AverageIF", new CalcEngine.LibraryFunction(this.ComputeAverageIF));
    this.AddFunction("AverageIFS", new CalcEngine.LibraryFunction(this.ComputeAverageIFS));
    this.AddFunction("SumIFS", new CalcEngine.LibraryFunction(this.ComputeSumIFS));
    this.AddFunction("NetworkDays", new CalcEngine.LibraryFunction(this.ComputeNetworkDays));
    this.AddFunction("Sec", new CalcEngine.LibraryFunction(this.ComputeSecant));
    this.AddFunction("SecH", new CalcEngine.LibraryFunction(this.ComputeSecanth));
    this.AddFunction("Cot", new CalcEngine.LibraryFunction(this.ComputeCot));
    this.AddFunction("CotH", new CalcEngine.LibraryFunction(this.ComputeCoth));
    this.AddFunction("Csc", new CalcEngine.LibraryFunction(this.ComputeCsc));
    this.AddFunction("CscH", new CalcEngine.LibraryFunction(this.ComputeCsch));
    this.AddFunction("ACot", new CalcEngine.LibraryFunction(this.ComputeAcot));
    this.AddFunction("ACotH", new CalcEngine.LibraryFunction(this.ComputeAcoth));
    this.AddFunction("AsecH", new CalcEngine.LibraryFunction(this.ComputeAsech));
    this.AddFunction("AcscH", new CalcEngine.LibraryFunction(this.ComputeAcsch));
    this.AddFunction("BigMul", new CalcEngine.LibraryFunction(this.ComputeBigMul));
    this.AddFunction("DivRem", new CalcEngine.LibraryFunction(this.ComputeDivRem));
    this.AddFunction("IEEERemainder", new CalcEngine.LibraryFunction(this.ComputeIEEERemainder));
    this.AddFunction("Truncate", new CalcEngine.LibraryFunction(this.ComputeTruncate));
    this.AddFunction("Combina", new CalcEngine.LibraryFunction(this.ComputeCombinA));
    this.AddFunction("Confidence.T", new CalcEngine.LibraryFunction(this.ComputeConfidenceT));
    this.AddFunction("Skew.P", new CalcEngine.LibraryFunction(this.ComputeSkewP));
    this.AddFunction("Covariance.P", new CalcEngine.LibraryFunction(this.ComputeCovarianceP));
    this.AddFunction("Covariance.S", new CalcEngine.LibraryFunction(this.ComputeCovarianceS));
    this.AddFunction("Percentile.Exc", new CalcEngine.LibraryFunction(this.ComputePercentileExc));
    this.AddFunction("Percentile.Inc", new CalcEngine.LibraryFunction(this.ComputePercentileInc));
    this.AddFunction("PercentRank.Exc", new CalcEngine.LibraryFunction(this.ComputePercentrankExc));
    this.AddFunction("PercentRank.Inc", new CalcEngine.LibraryFunction(this.ComputePercentrankInc));
    this.AddFunction("Stdev.P", new CalcEngine.LibraryFunction(this.ComputeStdevaP));
    this.AddFunction("Stdev.S", new CalcEngine.LibraryFunction(this.ComputeStdevaS));
    this.AddFunction("PermutationA", new CalcEngine.LibraryFunction(this.ComputePermutationA));
    this.AddFunction("Norm.Dist", new CalcEngine.LibraryFunction(this.ComputeNormOdist));
    this.AddFunction("Norm.Inv", new CalcEngine.LibraryFunction(this.ComputeNormOinv));
    this.AddFunction("Norm.S.Dist", new CalcEngine.LibraryFunction(this.ComputeNormOsODist));
    this.AddFunction("Norm.S.Inv", new CalcEngine.LibraryFunction(this.ComputeNormOsOInv));
    this.AddFunction("WeiBull.Dist", new CalcEngine.LibraryFunction(this.ComputeWeiBullODist));
    this.AddFunction("Expon.Dist", new CalcEngine.LibraryFunction(this.ComputeExponODist));
    this.AddFunction("Gamma.Dist", new CalcEngine.LibraryFunction(this.ComputeGammaOdist));
    this.AddFunction("Gamma.Inv", new CalcEngine.LibraryFunction(this.ComputeGammaOinv));
    this.AddFunction("Gammaln.Precise", new CalcEngine.LibraryFunction(this.ComputeGammaln0Precise));
    this.AddFunction("F.Inv.Rt", new CalcEngine.LibraryFunction(this.ComputeFOinvORt));
    this.AddFunction("Binom.Inv", new CalcEngine.LibraryFunction(this.ComputeBinomOInv));
    this.AddFunction("Hypgeom.Dist", new CalcEngine.LibraryFunction(this.ComputeHypgeomOdist));
    this.AddFunction("Lognorm.Dist", new CalcEngine.LibraryFunction(this.ComputeLognormOdist));
    this.AddFunction("Lognorm.Inv", new CalcEngine.LibraryFunction(this.ComputeLognormOinv));
    this.AddFunction("Confidence.Norm", new CalcEngine.LibraryFunction(this.ComputeConfidenceOnorm));
    this.AddFunction("Chisq.Dist", new CalcEngine.LibraryFunction(this.ComputeChisqOdist));
    this.AddFunction("chisq.Dist.Rt", new CalcEngine.LibraryFunction(this.ComputeChisqOdistORt));
    this.AddFunction("F.Dist", new CalcEngine.LibraryFunction(this.ComputeFOdist));
    this.AddFunction("F.Dist.Rt", new CalcEngine.LibraryFunction(this.ComputeFOdistORt));
    this.AddFunction("Beta.Dist", new CalcEngine.LibraryFunction(this.ComputeBetaDist));
    this.AddFunction("CHISQ.TEST", new CalcEngine.LibraryFunction(this.ComputeChisqOTest));
    this.AddFunction("CHISQ.INV", new CalcEngine.LibraryFunction(this.ComputeChisqOinv));
    this.AddFunction("CHISQ.INV.RT", new CalcEngine.LibraryFunction(this.ComputeChisqOinvORt));
    this.AddFunction("BINOM.DIST", new CalcEngine.LibraryFunction(this.ComputeBinomOdist));
    this.AddFunction("Z.TEST", new CalcEngine.LibraryFunction(this.ComputeZOtest));
    this.AddFunction("RANK.AVG", new CalcEngine.LibraryFunction(this.ComputeRankOAvg));
    this.AddFunction("RANK.EQ", new CalcEngine.LibraryFunction(this.ComputeRankOEq));
    this.AddFunction("IHDIST", new CalcEngine.LibraryFunction(this.ComputeIHDIST));
    this.AddFunction("UNIDIST", new CalcEngine.LibraryFunction(this.ComputeUnidist));
    this.AddFunction("QUARTILE.EXC", new CalcEngine.LibraryFunction(this.ComputeQuartileOExc));
    this.AddFunction("QUARTILE.INC", new CalcEngine.LibraryFunction(this.ComputeQuartileOInc));
    this.AddFunction("NEGBINOM.DIST", new CalcEngine.LibraryFunction(this.ComputeNegbinomODist));
    this.AddFunction("MODE.SNGL", new CalcEngine.LibraryFunction(this.ComputeModeOsngl));
    this.AddFunction("MODE.MULT", new CalcEngine.LibraryFunction(this.ComputeModeOMult));
    this.AddFunction("POISSON.DIST", new CalcEngine.LibraryFunction(this.ComputePoissonODist));
    this.AddFunction("T.DIST", new CalcEngine.LibraryFunction(this.ComputeTOdist));
    this.AddFunction("T.INV", new CalcEngine.LibraryFunction(this.ComputeTOInv));
    this.AddFunction("Dec2Bin", new CalcEngine.LibraryFunction(this.ComputeDec2Bin));
    this.AddFunction("Dec2Oct", new CalcEngine.LibraryFunction(this.ComputeDec2Oct));
    this.AddFunction("Dec2Hex", new CalcEngine.LibraryFunction(this.ComputeDec2Hex));
    this.AddFunction("Bin2Dec", new CalcEngine.LibraryFunction(this.ComputeBin2Dec));
    this.AddFunction("Bin2Oct", new CalcEngine.LibraryFunction(this.ComputeBin2Oct));
    this.AddFunction("Bin2Hex", new CalcEngine.LibraryFunction(this.ComputeBin2Hex));
    this.AddFunction("Hex2Bin", new CalcEngine.LibraryFunction(this.ComputeHex2Bin));
    this.AddFunction("Hex2Oct", new CalcEngine.LibraryFunction(this.ComputeHex2Oct));
    this.AddFunction("Hex2Dec", new CalcEngine.LibraryFunction(this.ComputeHex2Dec));
    this.AddFunction("Oct2Bin", new CalcEngine.LibraryFunction(this.ComputeOct2Bin));
    this.AddFunction("Oct2Hex", new CalcEngine.LibraryFunction(this.ComputeOct2Hex));
    this.AddFunction("Oct2Dec", new CalcEngine.LibraryFunction(this.ComputeOct2Dec));
    this.AddFunction("IMABS", new CalcEngine.LibraryFunction(this.ComputeImABS));
    this.AddFunction("Imaginary", new CalcEngine.LibraryFunction(this.ComputeImaginary));
    this.AddFunction("ImaginaryDifference", new CalcEngine.LibraryFunction(this.ComputeImaginaryDifference));
    this.AddFunction("ImReal", new CalcEngine.LibraryFunction(this.ComputeReal));
    this.AddFunction("Complex", new CalcEngine.LibraryFunction(this.ComputeComplex));
    this.AddFunction("ImSum", new CalcEngine.LibraryFunction(this.ComputeImSum));
    this.AddFunction("ImSub", new CalcEngine.LibraryFunction(this.ComputeImSub));
    this.AddFunction("ImProduct", new CalcEngine.LibraryFunction(this.ComputeImProduct));
    this.AddFunction("ImDiv", new CalcEngine.LibraryFunction(this.ComputeImDiv));
    this.AddFunction("ImConjugate", new CalcEngine.LibraryFunction(this.ComputeImConjugate));
    this.AddFunction("IMSQRT", new CalcEngine.LibraryFunction(this.ComputeImSqrt));
    this.AddFunction("ImArgument", new CalcEngine.LibraryFunction(this.ComputeImArgument));
    this.AddFunction("ImSin", new CalcEngine.LibraryFunction(this.ComputeIMSin));
    this.AddFunction("ImCSC", new CalcEngine.LibraryFunction(this.ComputeIMCSC));
    this.AddFunction("ImCos", new CalcEngine.LibraryFunction(this.ComputeIMCos));
    this.AddFunction("ImSec", new CalcEngine.LibraryFunction(this.ComputeIMSEC));
    this.AddFunction("ImTan", new CalcEngine.LibraryFunction(this.ComputeIMTan));
    this.AddFunction("ImCot", new CalcEngine.LibraryFunction(this.ComputeImCot));
    this.AddFunction("ImSinH", new CalcEngine.LibraryFunction(this.ComputeImSinH));
    this.AddFunction("ImCSCH", new CalcEngine.LibraryFunction(this.ComputeIMCSCH));
    this.AddFunction("ImCosH", new CalcEngine.LibraryFunction(this.ComputeImCosH));
    this.AddFunction("ImSECH", new CalcEngine.LibraryFunction(this.ComputeIMSecH));
    this.AddFunction("ImTanH", new CalcEngine.LibraryFunction(this.ComputeIMTanH));
    this.AddFunction("ImCotH", new CalcEngine.LibraryFunction(this.ComputeIMCotH));
    this.AddFunction("IMLOG10", new CalcEngine.LibraryFunction(this.ComputeIMLOG10));
    this.AddFunction("IMLOG2", new CalcEngine.LibraryFunction(this.ComputeIMLOG2));
    this.AddFunction("IMLN", new CalcEngine.LibraryFunction(this.ComputeIMLN));
    this.AddFunction("IMEXP", new CalcEngine.LibraryFunction(this.ComputeImEXP));
    this.AddFunction("IMPOWER", new CalcEngine.LibraryFunction(this.ComputeImPower));
    this.AddFunction("Gestep", new CalcEngine.LibraryFunction(this.ComputeGestep));
    this.AddFunction("Delta", new CalcEngine.LibraryFunction(this.ComputeDelta));
    this.AddFunction("BitAnd", new CalcEngine.LibraryFunction(this.ComputeBitAnd));
    this.AddFunction("BitOr", new CalcEngine.LibraryFunction(this.ComputeBitOr));
    this.AddFunction("BitXor", new CalcEngine.LibraryFunction(this.ComputeBitXor));
    this.AddFunction("BitLShift", new CalcEngine.LibraryFunction(this.ComputeBitLShift));
    this.AddFunction("BitRShift", new CalcEngine.LibraryFunction(this.ComputeBitRShift));
    this.AddFunction("ERF", new CalcEngine.LibraryFunction(this.ComputeErf));
    this.AddFunction("ERF.PRECISE", new CalcEngine.LibraryFunction(this.ComputeErfPrecise));
    this.AddFunction("ERFC.PRECISE", new CalcEngine.LibraryFunction(this.ComputeErfCPrecise));
    this.AddFunction("ERFC", new CalcEngine.LibraryFunction(this.ComputeErfCPrecise));
    this.AddFunction("BESSELI", new CalcEngine.LibraryFunction(this.ComputeBesselI));
    this.AddFunction("BESSELJ", new CalcEngine.LibraryFunction(this.ComputeBesselJ));
    this.AddFunction("BESSELY", new CalcEngine.LibraryFunction(this.ComputeBesselY));
    this.AddFunction("BESSELK", new CalcEngine.LibraryFunction(this.ComputebesselK));
    this.AddFunction("CONVERT", new CalcEngine.LibraryFunction(this.ComputeConversion));
    this.AddFunction("Replace", new CalcEngine.LibraryFunction(this.ComputeReplace));
    this.AddFunction("Code", new CalcEngine.LibraryFunction(this.ComputeCode));
    this.AddFunction("NumberValue", new CalcEngine.LibraryFunction(this.ComputeNumberValue));
    this.AddFunction("Proper", new CalcEngine.LibraryFunction(this.ComputeProper));
    this.AddFunction("UniChar", new CalcEngine.LibraryFunction(this.ComputeUniChar));
    this.AddFunction("UniCode", new CalcEngine.LibraryFunction(this.ComputeUniCode));
    this.AddFunction("Rept", new CalcEngine.LibraryFunction(this.ComputeRept));
    this.AddFunction("FormulaText", new CalcEngine.LibraryFunction(this.ComputeFormulaText));
    this.AddFunction("IsFormula", new CalcEngine.LibraryFunction(this.ComputeIsFormula));
    this.AddFunction("Type", new CalcEngine.LibraryFunction(this.ComputeType));
    this.AddFunction("Sheet", new CalcEngine.LibraryFunction(this.ComputeSheet));
    this.AddFunction("_Xlfn.Sheet", new CalcEngine.LibraryFunction(this.ComputeSheet));
    this.AddFunction("Sheets", new CalcEngine.LibraryFunction(this.ComputeSheets));
    this.AddFunction("_Xlfn.Sheets", new CalcEngine.LibraryFunction(this.ComputeSheets));
    this.AddFunction("FINDB", new CalcEngine.LibraryFunction(this.ComputeFindB));
    this.AddFunction("LEFTB", new CalcEngine.LibraryFunction(this.ComputeLeftB));
    this.AddFunction("RightB", new CalcEngine.LibraryFunction(this.ComputeRightB));
    this.AddFunction("MidB", new CalcEngine.LibraryFunction(this.ComputeMidB));
    this.AddFunction("LenB", new CalcEngine.LibraryFunction(this.ComputeLenB));
    this.AddFunction("ReplaceB", new CalcEngine.LibraryFunction(this.ComputeReplaceB));
    this.AddFunction("ASC", new CalcEngine.LibraryFunction(this.ComputeAsc));
    this.AddFunction("JIS", new CalcEngine.LibraryFunction(this.ComputeJis));
    this.AddFunction("MDETERM", new CalcEngine.LibraryFunction(this.ComputeMdeterm));
    this.AddFunction("MMULT", new CalcEngine.LibraryFunction(this.ComputeMmult));
    this.AddFunction("MInverse", new CalcEngine.LibraryFunction(this.ComputeMInverse));
    this.AddFunction("MUnit", new CalcEngine.LibraryFunction(this.ComputeMUnit));
    this.AddFunction("_Xlfn.MUnit", new CalcEngine.LibraryFunction(this.ComputeMUnit));
    this.AddFunction("Base", new CalcEngine.LibraryFunction(this.ComputeBase));
    this.AddFunction("Decimal", new CalcEngine.LibraryFunction(this.ComputeDecimal));
    this.AddFunction("Intrate", new CalcEngine.LibraryFunction(this.ComputeIntrate));
    this.AddFunction("Seriessum", new CalcEngine.LibraryFunction(this.ComputeSeriessum));
    this.AddFunction("Arabic", new CalcEngine.LibraryFunction(this.ComputeArabic));
    this.AddFunction("Ceiling.Math", new CalcEngine.LibraryFunction(this.ComputeCeilingMath));
    this.AddFunction("NETWORKDAYS.INTL", new CalcEngine.LibraryFunction(this.ComputeNetworkDaysintl));
    this.AddFunction("WeekNum", new CalcEngine.LibraryFunction(this.ComputeWeeknum));
    this.AddFunction("ISOWeekNum", new CalcEngine.LibraryFunction(this.ComputeISOWeeknum));
    this.AddFunction("Days", new CalcEngine.LibraryFunction(this.ComputeDays));
    this.AddFunction("EDate", new CalcEngine.LibraryFunction(this.ComputeEDate));
    this.AddFunction("EOMonth", new CalcEngine.LibraryFunction(this.ComputeEOMonth));
    this.AddFunction("WorkDay.INTL", new CalcEngine.LibraryFunction(this.ComputeWorkDayintl));
    this.AddFunction("WorkDay", new CalcEngine.LibraryFunction(this.ComputeWorkDay));
    this.AddFunction("YearFrac", new CalcEngine.LibraryFunction(this.ComputeYearFrac));
    this.AddFunction("Hyperlink", new CalcEngine.LibraryFunction(this.ComputeHyperlink));
    this.AddFunction("Info", new CalcEngine.LibraryFunction(this.ComputeInfo));
    this.AddFunction("Row", new CalcEngine.LibraryFunction(this.ComputeRow));
    this.AddFunction("Rows", new CalcEngine.LibraryFunction(this.ComputeRows));
    this.AddFunction("Columns", new CalcEngine.LibraryFunction(this.ComputeColumns));
    this.AddFunction("Areas", new CalcEngine.LibraryFunction(this.ComputeAreas));
    this.AddFunction("Cell", new CalcEngine.LibraryFunction(this.ComputeCell));
    this.AddFunction("Transpose", new CalcEngine.LibraryFunction(this.ComputeTranspose));
    this.AddFunction("SearchB", new CalcEngine.LibraryFunction(this.ComputeSearchB));
    this.AddFunction("EncodeURl", new CalcEngine.LibraryFunction(this.ComputeEncodeURL));
    this.AddFunction("DatedIF", new CalcEngine.LibraryFunction(this.ComputeDatedIF));
    this.AddFunction("WebService", new CalcEngine.LibraryFunction(this.ComputeWebService));
    this.AddFunction("FilterXml", new CalcEngine.LibraryFunction(this.ComputeFilterXml));
  }

  public static int CreateSheetFamilyID()
  {
    if (CalcEngine.sheetFamilyID == int.MaxValue)
      CalcEngine.sheetFamilyID = int.MinValue;
    return CalcEngine.sheetFamilyID++;
  }

  public void RegisterGridAsSheet(string refName, ICalcData model, int sheetFamilyID)
  {
    if (CalcEngine.modelToSheetID != null)
    {
      model.WireParentObject();
      model.ValueChanged += new ValueChangedEventHandler(this.grid_ValueChanged);
    }
    refName = refName.Replace("'", "''");
    if (CalcEngine.modelToSheetID == null)
      CalcEngine.modelToSheetID = new Hashtable();
    if (CalcEngine.modelToSheetID[(object) model] == null)
      CalcEngine.modelToSheetID.Add((object) model, (object) sheetFamilyID);
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(model);
    sheetFamilyItem.isSheeted = true;
    string upper = refName.ToUpper();
    if (sheetFamilyItem.SheetNameToParentObject == null)
      sheetFamilyItem.SheetNameToParentObject = new Hashtable();
    if (sheetFamilyItem.TokenToParentObject == null)
      sheetFamilyItem.TokenToParentObject = new Hashtable();
    if (sheetFamilyItem.SheetNameToToken == null)
      sheetFamilyItem.SheetNameToToken = new Hashtable();
    if (sheetFamilyItem.ParentObjectToToken == null)
      sheetFamilyItem.ParentObjectToToken = new Hashtable();
    if (sheetFamilyItem.SheetNameToParentObject.ContainsKey((object) upper))
    {
      string key = (string) sheetFamilyItem.SheetNameToToken[(object) upper];
      sheetFamilyItem.TokenToParentObject[(object) key] = (object) model;
      sheetFamilyItem.ParentObjectToToken[(object) model] = (object) key;
    }
    else
    {
      string key = '!'.ToString() + CalcEngine.TokenCount.ToString() + (object) '!';
      ++CalcEngine.TokenCount;
      sheetFamilyItem.TokenToParentObject.Add((object) key, (object) model);
      sheetFamilyItem.SheetNameToToken.Add((object) upper, (object) key);
      sheetFamilyItem.SheetNameToParentObject.Add((object) upper, (object) model);
      sheetFamilyItem.ParentObjectToToken.Add((object) model, (object) key);
      this.sortedSheetNames = (ArrayList) null;
    }
  }

  public static void UnregisterGridAsSheet(string refName, ICalcData model)
  {
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(model);
    string upper = refName.ToUpper();
    if (sheetFamilyItem.SheetNameToParentObject == null || !sheetFamilyItem.SheetNameToParentObject.ContainsKey((object) upper))
      return;
    sheetFamilyItem.SheetNameToParentObject.Remove((object) upper);
    string key = (string) sheetFamilyItem.SheetNameToToken[(object) upper];
    sheetFamilyItem.SheetNameToToken.Remove((object) upper);
    sheetFamilyItem.TokenToParentObject.Remove((object) key);
    sheetFamilyItem.ParentObjectToToken.Remove((object) model);
  }

  public void RenameSheet(string sheetName, ICalcData model)
  {
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(model);
    string key1 = string.Empty;
    if (sheetName.Contains("/") || sheetName.Contains("?") || sheetName.Contains("*") || sheetName.Contains("[") || sheetName.Contains("]") || sheetName.Contains(":") || sheetName.Contains("\\"))
      throw new ArgumentException("The name does not contain any of following characters:  / ? *  [ ] : \\");
    foreach (string key2 in (IEnumerable) sheetFamilyItem.SheetNameToParentObject.Keys)
    {
      if (sheetFamilyItem.SheetNameToParentObject[(object) key2].Equals((object) model))
      {
        key1 = key2;
        break;
      }
    }
    object key3 = sheetFamilyItem.SheetNameToToken[(object) key1];
    if (sheetFamilyItem.SheetNameToParentObject.ContainsKey((object) key1))
    {
      sheetFamilyItem.SheetNameToParentObject.Remove((object) key1);
      sheetFamilyItem.SheetNameToParentObject.Add((object) sheetName, (object) model);
    }
    if (sheetFamilyItem.TokenToParentObject.ContainsKey(key3))
    {
      sheetFamilyItem.TokenToParentObject.Remove(key3);
      sheetFamilyItem.TokenToParentObject.Add(key3, (object) model);
    }
    if (sheetFamilyItem.SheetNameToToken.ContainsKey((object) key1))
    {
      sheetFamilyItem.SheetNameToToken.Remove((object) key1);
      sheetFamilyItem.SheetNameToToken.Add((object) sheetName, key3);
    }
    if (!sheetFamilyItem.ParentObjectToToken.ContainsKey((object) key1))
      return;
    sheetFamilyItem.ParentObjectToToken.Remove((object) key1);
    sheetFamilyItem.ParentObjectToToken.Add((object) sheetName, key3);
  }

  public Hashtable DependentCells
  {
    get
    {
      if (this.IsSheeted)
      {
        GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
        if (sheetFamilyItem.sheetDependentCells == null)
          sheetFamilyItem.sheetDependentCells = new Hashtable();
        return sheetFamilyItem.sheetDependentCells;
      }
      if (this.dependentCells == null)
        this.dependentCells = new Hashtable();
      return this.dependentCells;
    }
  }

  public Hashtable DependentFormulaCells
  {
    get
    {
      if (this.IsSheeted)
      {
        GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
        if (sheetFamilyItem.sheetDependentFormulaCells == null)
          sheetFamilyItem.sheetDependentFormulaCells = new Hashtable();
        return sheetFamilyItem.sheetDependentFormulaCells;
      }
      if (this.dependentFormulaCells == null)
        this.dependentFormulaCells = new Hashtable();
      return this.dependentFormulaCells;
    }
  }

  public void UpdateDependenciesAndCell(string cell1)
  {
    ICalcData grid = this.grid;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    string key1 = this.SheetToken(cell1);
    if (key1.Length > 0)
      this.grid = sheetFamilyItem.TokenToParentObject[(object) key1] as ICalcData;
    if (!this.FormulaInfoTable.ContainsKey((object) cell1))
      return;
    FormulaInfo formula = this.FormulaInfoTable[(object) cell1] as FormulaInfo;
    if (formula.calcID != this.calcID)
    {
      string cell = this.cell;
      this.cell = cell1;
      formula.ParsedFormula = this.ParseFormula(formula.FormulaText);
      if (this.iterationMaxCount > 0 && this.circCheckList.IndexOf((object) this.cell) > -1)
        this.HandleIterations(formula);
      else
        formula.FormulaValue = this.ComputeFormula(formula.ParsedFormula);
      if (this.DependentCells.ContainsKey((object) cell1))
      {
        foreach (string key2 in (ArrayList) this.DependentCells[(object) cell1])
        {
          if (this.FormulaInfoTable[(object) key2] is FormulaInfo formulaInfo)
            formulaInfo.calcID = int.MinValue;
        }
      }
      formula.calcID = this.calcID;
      this.cell = cell;
    }
    bool ignoreValueChanged = this.IgnoreValueChanged;
    this.IgnoreValueChanged = true;
    int row = this.RowIndex(cell1);
    int col = this.ColIndex(cell1);
    if (this.PreserveFormula)
      this.grid.SetValueRowCol((object) formula.FormulaText, row, col);
    this.IgnoreValueChanged = ignoreValueChanged;
    this.grid = grid;
    if (this.processedCells.Contains((object) cell1))
      return;
    this.processedCells.Add((object) cell1);
    this.grid.SetValueRowCol((object) formula.FormulaValue, row, col);
    if (!this.DependentFormulaCells.ContainsKey((object) cell1))
      return;
    foreach (string key3 in (IEnumerable) ((Hashtable) this.DependentFormulaCells[(object) cell1]).Keys)
      this.UpdateDependenciesAndCell(key3);
  }

  private void HandleIterations(FormulaInfo formula)
  {
    this.inHandleIterations = true;
    double oldValue = 0.0;
    double result = 0.0;
    int num = 1;
    for (bool flag = true; num < this.iterationMaxCount - 1 && (flag || !this.CheckUnderTolerance(result, oldValue)); ++num)
    {
      flag = false;
      if (!this.IterationValues.ContainsKey((object) this.cell))
        this.IterationValues.Add((object) this.cell, (object) "0");
      this.IterationValues[(object) this.cell] = formula.FormulaValue == string.Empty ? (object) "0" : (object) formula.FormulaValue;
      formula.FormulaValue = this.ComputeFormula(formula.ParsedFormula);
      oldValue = result;
      double.TryParse(formula.FormulaValue, NumberStyles.Any, (IFormatProvider) null, out result);
    }
    this.IterationValues[(object) this.cell] = formula.FormulaValue == string.Empty ? (object) "0" : (object) formula.FormulaValue;
    this.inHandleIterations = false;
  }

  private bool CheckUnderTolerance(double d, double oldValue)
  {
    return Math.Abs(oldValue) > this.ABSOLUTEZERO ? Math.Abs((d - oldValue) / oldValue) < this.iterationMaxTolerance : Math.Abs(d - oldValue) < this.iterationMaxTolerance;
  }

  internal void UpdateDependencies(string s)
  {
    if (this.lockDependencies || !this.UseDependencies)
      return;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    string key1 = this.cell;
    if (sheetFamilyItem.SheetNameToParentObject != null && key1.IndexOf('!') == -1)
      key1 = (sheetFamilyItem.ParentObjectToToken[(object) this.grid] as string) + key1;
    if (sheetFamilyItem.SheetNameToParentObject != null && s.IndexOf('!') == -1)
      s = (sheetFamilyItem.ParentObjectToToken[(object) this.grid] as string) + s;
    if (!this.DependentCells.ContainsKey((object) s))
    {
      ArrayList arrayList1 = new ArrayList();
      this.DependentCells.Add((object) s, (object) arrayList1);
      arrayList1.Add((object) key1);
      if (this.DependentFormulaCells.ContainsKey((object) s))
      {
        Hashtable dependentFormulaCell = (Hashtable) this.DependentFormulaCells[(object) s];
        if (dependentFormulaCell != null)
        {
          foreach (object key2 in (IEnumerable) dependentFormulaCell.Keys)
          {
            string key3 = key2 as string;
            ArrayList arrayList2 = (ArrayList) this.DependentCells[(object) key3];
            if (arrayList2 == null)
            {
              arrayList2 = new ArrayList();
              this.DependentCells.Add((object) key3, (object) arrayList2);
            }
            if (arrayList2.IndexOf((object) key1) == -1)
              arrayList2.Add((object) key1);
          }
        }
      }
      this.AddToFormulaDependentCells(s);
      if (!this.DependentCells.ContainsKey((object) key1))
        return;
      ArrayList dependentCell = (ArrayList) this.DependentCells[(object) key1];
      if (dependentCell == null || dependentCell == arrayList1)
        return;
      foreach (object obj in dependentCell)
      {
        string str = obj as string;
        arrayList1.Add((object) str);
      }
    }
    else
    {
      ArrayList dependentCell = (ArrayList) this.DependentCells[(object) s];
      if (dependentCell.IndexOf((object) key1) == -1)
        dependentCell.Add((object) key1);
      this.AddToFormulaDependentCells(s);
      if (!this.DependentFormulaCells.ContainsKey((object) s))
        return;
      Hashtable dependentFormulaCell = (Hashtable) this.DependentFormulaCells[(object) s];
      if (dependentFormulaCell == null)
        return;
      foreach (object key4 in (IEnumerable) dependentFormulaCell.Keys)
      {
        string key5 = key4 as string;
        ArrayList arrayList = (ArrayList) this.DependentCells[(object) key5];
        if (arrayList == null)
        {
          arrayList = new ArrayList();
          this.DependentCells.Add((object) key5, (object) arrayList);
        }
        if (arrayList.IndexOf((object) key1) == -1)
          arrayList.Add((object) key1);
      }
    }
  }

  internal void ClearFormulaDependentCells(string cell)
  {
    Hashtable dependentFormulaCell = (Hashtable) this.DependentFormulaCells[(object) cell];
    if (dependentFormulaCell == null)
      return;
    foreach (object key1 in (IEnumerable) dependentFormulaCell.Keys)
    {
      string key2 = key1 as string;
      ArrayList dependentCell = this.DependentCells[(object) key2] as ArrayList;
      dependentCell.Remove((object) cell);
      if (dependentCell.Count == 0)
        this.DependentCells.Remove((object) key2);
    }
    this.DependentFormulaCells.Remove((object) cell);
  }

  public static GridSheetFamilyItem GetSheetFamilyItem(ICalcData model)
  {
    if (model == null)
      return (GridSheetFamilyItem) null;
    if (CalcEngine.sheetFamilyID == 0)
    {
      if (CalcEngine.defaultFamilyItem == null)
        CalcEngine.defaultFamilyItem = new GridSheetFamilyItem();
      return CalcEngine.defaultFamilyItem;
    }
    if (CalcEngine.sheetFamiliesList == null)
      CalcEngine.sheetFamiliesList = new Hashtable();
    int key = CalcEngine.modelToSheetID[(object) model] != null ? (int) CalcEngine.modelToSheetID[(object) model] : 0;
    if (CalcEngine.sheetFamiliesList[(object) key] == null)
      CalcEngine.sheetFamiliesList.Add((object) key, (object) new GridSheetFamilyItem());
    return CalcEngine.sheetFamiliesList[(object) key] as GridSheetFamilyItem;
  }

  private void AddToFormulaDependentCells(string s)
  {
    string key = this.cell;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    if (sheetFamilyItem.SheetNameToParentObject != null && key.IndexOf('!') == -1)
      key = (sheetFamilyItem.ParentObjectToToken[(object) this.grid] as string) + key;
    if (!this.DependentFormulaCells.ContainsKey((object) key))
    {
      this.DependentFormulaCells.Add((object) key, (object) new Hashtable());
      ((Hashtable) this.DependentFormulaCells[(object) key]).Add((object) s, (object) s);
    }
    else
    {
      if (((Hashtable) this.DependentFormulaCells[(object) key]).ContainsKey((object) s))
        return;
      ((Hashtable) this.DependentFormulaCells[(object) key]).Add((object) s, (object) s);
    }
  }

  private string SheetToken(string s)
  {
    int index = 0;
    string str = string.Empty;
    if (index < s.Length && s[index] == '!')
    {
      ++index;
      while (index < s.Length && s[index] != '!')
        ++index;
      if (index < s.Length)
        str = s.Substring(0, index + 1);
    }
    if (index < s.Length)
      return str;
    throw new ArgumentException(this.FormulaErrorStrings[this.improper_formula]);
  }

  public void Dispose()
  {
    if (this._isDisposed)
      return;
    int key = 0;
    if (this._formulaInfoTable != null)
    {
      this._formulaInfoTable.Clear();
      this._formulaInfoTable = (Hashtable) null;
    }
    if (this.circCheckList != null)
    {
      this.circCheckList.Clear();
      this.circCheckList = (ArrayList) null;
    }
    if (this.dependentFormulaCells != null)
    {
      this.dependentFormulaCells.Clear();
      this.dependentFormulaCells = (Hashtable) null;
    }
    if (this.grid != null && CalcEngine.modelToSheetID != null && CalcEngine.modelToSheetID.ContainsKey((object) this.grid) && CalcEngine.modelToSheetID[(object) this.grid] != null)
    {
      key = (int) CalcEngine.modelToSheetID[(object) this.grid];
      this.grid.ValueChanged -= new ValueChangedEventHandler(this.grid_ValueChanged);
      this.grid.ValueChanged -= new ValueChangedEventHandler(this.grid_ValueChanged);
    }
    if (CalcEngine.sheetFamiliesList != null && CalcEngine.sheetFamiliesList.Count > 0 && CalcEngine.sheetFamiliesList.ContainsKey((object) key))
    {
      CalcEngine.sheetFamiliesList[(object) key] = (object) null;
      CalcEngine.sheetFamiliesList.Remove((object) key);
    }
    if (CalcEngine.modelToSheetID != null && CalcEngine.modelToSheetID.Count > 0 && this.grid != null && CalcEngine.modelToSheetID.ContainsKey((object) this.grid))
      CalcEngine.modelToSheetID.Remove((object) this.grid);
    if (this.dependentCells != null)
    {
      this.dependentCells.Clear();
      this.dependentCells = (Hashtable) null;
    }
    if (this.iterationValues != null)
    {
      this.iterationValues.Clear();
      this.iterationValues = (Hashtable) null;
    }
    if (this.libraryFunctions != null)
    {
      this.libraryFunctions.Clear();
      this.libraryFunctions = (Hashtable) null;
    }
    if (this.lookupTables != null)
    {
      this.lookupTables.Clear();
      this.lookupTables = (Dictionary<string, CalcEngine.LookUps>) null;
    }
    if (this.errorStrings != null)
      this.errorStrings.Clear();
    if (this.namedRanges != null)
      this.namedRanges.Clear();
    if (this.refreshedCells != null)
    {
      this.refreshedCells.Clear();
      this.refreshedCells = (Hashtable) null;
    }
    if (CalcEngine.TokenCount > 0)
      --CalcEngine.TokenCount;
    this.grid = (ICalcData) null;
    this._isDisposed = true;
  }

  private bool FindNextSeparator(string formula, ref int location)
  {
    int num = 0;
    bool nextSeparator = false;
    while (!nextSeparator && location < formula.Length)
    {
      if (formula[location] == 'q')
        ++num;
      else if ((int) formula[location] == (int) this.RIGHTBRACKET)
        --num;
      else if (num == 0 && (int) formula[location] == (int) CalcEngine.ParseArgumentSeparator)
      {
        nextSeparator = true;
        --location;
      }
      ++location;
    }
    return nextSeparator;
  }

  private void MarkupResultToIncludeInFormula(ref string s)
  {
    if (s.Length > 0 && s[0] == '-' && double.TryParse(s, out double _))
    {
      s = "nu" + s.Substring(1);
    }
    else
    {
      if (s.Length > 0 && ((int) s[0] == (int) this.TIC[0] || s[0] == '\u0092' || s[0] == '#') || s.StartsWith(this.TRUEVALUESTR) || s.StartsWith(this.FALSEVALUESTR))
        return;
      double result1 = 0.0;
      if (double.TryParse(s, out result1))
      {
        s = $"{s:d}";
        s = s.Replace(CalcEngine.ParseArgumentSeparator, ' ');
        s = 'n'.ToString() + s;
      }
      else if (!this.IsRange(s) && s.StartsWith(this.BRACELEFT) && s.EndsWith(this.BRACERIGHT))
      {
        s = s.Replace("{", "").Replace("}", "");
        string str = string.Empty;
        foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(s))
        {
          double result2 = 0.0;
          if (double.TryParse(preservingQuotedComma, out result2))
            str = str + (object) 'n' + preservingQuotedComma + (object) CalcEngine.ParseArgumentSeparator;
        }
        s = str.Remove(str.Length - 1);
      }
      else
      {
        if (this.IsRange(s))
          return;
        s = this.TIC + s + this.TIC;
      }
    }
  }

  public bool GetFormulaArrayBounds(
    string currentCell,
    int arrayHeight,
    int arrayWidth,
    out int firstRowIndex,
    out int firstColIndex,
    out int lastRowIndex,
    out int lastColIndex)
  {
    int col1 = this.ColIndex(this.cell);
    int row = this.RowIndex(this.cell);
    string empty1 = string.Empty;
    string str1 = !(this.FormulaInfoTable[(object) this.cell] is FormulaInfo formulaInfo1) ? this.grid.GetValueRowCol(row, col1).ToString() : formulaInfo1.FormulaText;
    int num = 1;
    int col2 = 1;
    for (int index = 1; index <= arrayHeight; ++index)
    {
      if (col1 - index > 0)
      {
        string key = this.GetSheetTokenFromReference(this.cell) + RangeInfo.GetAlphaLabel(col1 - index) + row.ToString();
        string empty2 = string.Empty;
        string str2 = !(this.FormulaInfoTable[(object) key] is FormulaInfo formulaInfo2) ? this.grid.GetValueRowCol(row, col1 - index).ToString() : formulaInfo2.FormulaText;
        col2 = col1 - index;
        if (!string.IsNullOrEmpty(str1) && str2 != str1)
        {
          ++col2;
          break;
        }
      }
    }
    for (int index = 1; index <= arrayWidth; ++index)
    {
      if (row - index > 0)
      {
        string key = this.GetSheetTokenFromReference(this.cell) + RangeInfo.GetAlphaLabel(col2) + (row - index).ToString();
        string empty3 = string.Empty;
        string str3 = !(this.FormulaInfoTable[(object) key] is FormulaInfo formulaInfo3) ? this.grid.GetValueRowCol(row - index, col2).ToString() : formulaInfo3.FormulaText;
        num = row - index;
        if (!string.IsNullOrEmpty(str1) && str3 != str1)
        {
          ++num;
          break;
        }
      }
    }
    firstRowIndex = num;
    firstColIndex = col2;
    lastRowIndex = num + arrayHeight;
    lastColIndex = col2 + arrayWidth;
    return true;
  }

  private string HandleEmbeddedEs(string text)
  {
    int num1;
    for (int startIndex = 0; startIndex > -1 && (num1 = text.IndexOf(this.STRING_EP, startIndex)) > -1; startIndex = num1 + 1)
    {
      if (this.NotInBlock(text, num1))
      {
        int num2 = num1;
        while (num2 > 0 && (char.IsDigit(text[num2 - 1]) || (int) text[num2 - 1] == (int) CalcEngine.ParseDecimalSeparator))
          --num2;
        if (num2 != num1 && (num2 == 0 || !char.IsUpper(text[num2 - 1])))
        {
          int index = num1 + this.STRING_EP.Length;
          while (index < text.Length && char.IsDigit(text[index]))
            ++index;
          if (index != num1 + this.STRING_EP.Length)
            text = text.Substring(0, num1) + (object) this.CHAR_EP + text.Substring(num1 + this.STRING_EP.Length);
        }
      }
    }
    int num3;
    for (int startIndex = 0; startIndex > -1 && (num3 = text.IndexOf(this.STRING_EM, startIndex)) > -1; startIndex = num3 + 1)
    {
      if (this.NotInBlock(text, num3))
      {
        int num4 = num3;
        while (num4 > 0 && (char.IsDigit(text[num4 - 1]) || (int) text[num4 - 1] == (int) CalcEngine.ParseDecimalSeparator))
          --num4;
        if (num4 != num3 && (num4 == 0 || !char.IsUpper(text[num4 - 1])))
        {
          int index = num3 + this.STRING_EM.Length;
          while (index < text.Length && char.IsDigit(text[index]))
            ++index;
          if (index != num3 + this.STRING_EM.Length)
            text = text.Substring(0, num3) + (object) this.CHAR_EM + text.Substring(num3 + this.STRING_EM.Length);
        }
      }
    }
    int num5;
    for (int startIndex = 0; startIndex > -1 && (num5 = text.IndexOf(this.STRING_E, startIndex)) > -1 && text[0] != '\u0092'; startIndex = num5 + 1)
    {
      if (this.NotInBlock(text, num5))
      {
        int index1 = num5;
        while (index1 > 0 && (char.IsDigit(text[index1 - 1]) || (int) text[index1 - 1] == (int) CalcEngine.ParseDecimalSeparator))
          --index1;
        if (index1 != num5 && (index1 == 0 || !char.IsUpper(text[index1 - 1])))
        {
          int index2 = num5 + this.STRING_E.Length;
          while (index2 < text.Length && char.IsDigit(text[index2]))
            ++index2;
          if (index2 != num5 + this.STRING_E.Length && (index1 == -1 || !char.IsUpper(text[index1])))
            text = text.Substring(0, num5) + (object) this.CHAR_EP + text.Substring(num5 + this.STRING_E.Length);
        }
      }
    }
    return text;
  }

  public int RowIndex(string s)
  {
    if (this.CurrentRowNotationEnabled && s.Length == 0)
      return 0;
    int num = 0;
    bool flag = false;
    if (num < s.Length && s[num] == '[')
    {
      int index = num + 1;
      while (index < s.Length && s[index] != ']')
        ++index;
      num = index + 1;
    }
    if (num < s.Length && s[num] == '!')
    {
      int index = num + 1;
      while (index < s.Length && s[index] != '!')
        ++index;
      num = index + 1;
    }
    for (; num < s.Length && char.IsLetter(s[num]); ++num)
      flag = true;
    int result;
    if (num < s.Length && int.TryParse(s.Substring(num), out result))
      return result;
    if (flag)
      return -1;
    throw new ArgumentException(this.FormulaErrorStrings[this.bad_index]);
  }

  public int ColIndex(string s)
  {
    int index1 = 0;
    int num = 0;
    s = s.ToUpper(CultureInfo.InvariantCulture);
    if (index1 < s.Length && s[index1] == '[')
    {
      int index2 = index1 + 1;
      while (index2 < s.Length && s[index2] != ']')
        ++index2;
      index1 = index2 + 1;
    }
    if (index1 < s.Length && s[index1] == '!')
    {
      int index3 = index1 + 1;
      while (index3 < s.Length && s[index3] != '!')
        ++index3;
      index1 = index3 + 1;
    }
    for (; index1 < s.Length && char.IsLetter(s[index1]); ++index1)
      num = num * 26 + (int) s[index1] - 65 + 1;
    return num == 0 ? -1 : num;
  }

  internal bool IsCellReference(string args)
  {
    if (string.IsNullOrEmpty(args))
      return false;
    this.PutTokensForSheets(ref args);
    string empty = string.Empty;
    if (args.Contains("!"))
    {
      string oldValue = this.ExternalBookToken(args);
      if (!string.IsNullOrEmpty(oldValue))
        args = args.Replace(oldValue, string.Empty);
    }
    string oldValue1 = this.SheetToken(args);
    bool flag1 = false;
    if (!string.IsNullOrEmpty(oldValue1))
      args = args.Replace(oldValue1, string.Empty);
    bool flag2 = false;
    bool flag3 = false;
    if (args.IndexOf(':') != args.LastIndexOf(':'))
      return false;
    foreach (char ch in args.ToCharArray())
    {
      if (char.IsLetter(ch))
        flag2 = true;
      else if (char.IsDigit(ch))
      {
        flag3 = true;
      }
      else
      {
        if (!object.Equals((object) ch, (object) ':'))
          return false;
        if (flag2 && flag3)
          flag1 = true;
        flag2 = false;
        flag3 = false;
      }
    }
    return args.Contains(":") && !args.Contains(this.TIC) ? flag1 && flag2 && flag3 || (flag2 && !flag3 || !flag2 && flag3) && !flag1 : flag2 && flag3 && !args.Contains(this.TIC);
  }

  private bool CanGetRowIndex(string s)
  {
    int index1 = 0;
    if (index1 < s.Length && s[index1] == '!')
    {
      int index2 = index1 + 1;
      while (index2 < s.Length && s[index2] != '!')
        ++index2;
      index1 = index2 + 1;
    }
    while (index1 < s.Length && char.IsLetter(s[index1]))
      ++index1;
    return index1 < s.Length && char.IsDigit(s[index1]);
  }

  private void MarkColonsInQuotes(ref string args)
  {
    bool flag = false;
    if (args.IndexOf(':') == -1)
      return;
    for (int index = 0; index < args.Length; ++index)
    {
      if ((int) args[index] == (int) this.TIC[0])
        flag = !flag;
      else if (args[index] == ':' && flag)
        args = args.Replace(':', this.MarkerChar);
    }
  }

  private int MatchingRightBracket(string formula)
  {
    int num1 = -1;
    int index = 1;
    int num2 = 0;
    string sheet = this.SheetToken(formula);
    for (; num1 == -1 && index < formula.Length; ++index)
    {
      if ((int) formula[index] == (int) this.RIGHTBRACKET)
      {
        if (num2 == 0)
          num1 = index;
        else
          --num2;
      }
      else if (formula[index] == 'q')
      {
        int i = index + 1;
        if (i < formula.Length)
        {
          string key = this.ProcessUpperCase(ref formula, ref i, ref sheet);
          if (key != string.Empty && this.LibraryFunctions.ContainsKey((object) key))
            ++num2;
        }
      }
    }
    return num1;
  }

  internal string[] SplitArguments(string args, char argSeperator)
  {
    ArrayList arrayList = new ArrayList();
    int startIndex = 0;
    int num = 0;
    for (int index = 0; index < args.Length; ++index)
    {
      if (args[index].Equals('"'))
      {
        if (num == 0)
          ++num;
        else
          num = 0;
      }
      if (args[index].Equals(argSeperator) && !num.Equals(1))
      {
        arrayList.Add((object) args.Substring(startIndex, index - startIndex));
        startIndex = index + 1;
      }
      if (index.Equals(args.Length - 1))
        arrayList.Add((object) args.Substring(startIndex, index - startIndex + 1));
    }
    string[] destinationArray = new string[arrayList.Count];
    Array.Copy((Array) arrayList.ToArray(), (Array) destinationArray, destinationArray.Length);
    return destinationArray;
  }

  private string StripTics0(string s)
  {
    if (s.Length > 1 && (int) s[0] == (int) this.TIC[0] && (int) s[s.Length - 1] == (int) this.TIC[0])
      s = s.Substring(1, s.Length - 2);
    return s;
  }

  public string StripTics(string s)
  {
    if (s.Length > 1 && (int) s[0] == (int) this.TIC[0] && (int) s[s.Length - 1] == (int) this.TIC[0])
    {
      if (s.Substring(1, s.Length - 2).IndexOf(this.TIC) == -1)
        s = s.Substring(1, s.Length - 2);
      else if (this.multiTick)
        s = s.Substring(1, s.Length - 2);
    }
    return s;
  }

  private string[] SplitArguments(string array)
  {
    return array.IndexOf(';') > -1 ? array.Split(';') : array.Split(CalcEngine.ParseArgumentSeparator);
  }

  public string[] SplitArgsPreservingQuotedCommas(string args)
  {
    if (args.IndexOf(this.TIC) == -1)
      return args.Split(CalcEngine.ParseArgumentSeparator);
    Hashtable strings = this.SaveStrings(ref args);
    string[] strArray = args.Split(CalcEngine.ParseArgumentSeparator);
    List<string> stringList = new List<string>();
    foreach (string retValue in strArray)
    {
      this.SetStrings(ref retValue, strings);
      stringList.Add(retValue);
    }
    return stringList.ToArray();
  }

  private static bool TextIsEmpty(string s) => s == null || s == string.Empty;

  private string PopString(Stack _stack)
  {
    object obj = _stack.Pop() ?? (object) string.Empty;
    double result;
    if (!this.GetValueFromArgPreserveLeadingZeros && double.TryParse(obj.ToString(), out result))
      return result.ToString();
    return this.ErrorStrings.Contains((object) obj.ToString().Replace(this.TIC, string.Empty)) ? obj.ToString() : obj.ToString();
  }

  private double Pop(Stack _stack)
  {
    object obj = _stack.Pop();
    string str1 = string.Empty;
    if (obj != null)
    {
      if (obj.ToString() == this.TIC + this.TIC || !this.ExcelLikeComputations && obj.ToString().ToUpper().Equals(double.NaN.ToString().ToUpper()))
        return double.NaN;
      str1 = obj.ToString().Replace(this.TIC, string.Empty);
      if (str1.Contains("i") || str1.Contains("j") || str1.Contains("I") || str1.Contains("J"))
      {
        string str2 = str1.Substring(str1.Length - 1, 1);
        if (str2 == "i" || str2 == "j" || str2 == "I" || str2 == "J")
          return double.NaN;
      }
      if (this.ErrorStrings.Contains((object) str1))
      {
        this.isErrorString = true;
        return (double) this.ErrorStrings.IndexOf((object) str1);
      }
      if (str1.StartsWith("#") || str1 == string.Empty)
        return 0.0;
      if (str1 == this.TRUEVALUESTR)
        return 1.0;
      if (str1 == this.FALSEVALUESTR)
        return 0.0;
      double result;
      if (double.TryParse(str1, NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentCulture, out result))
        return result;
      if (this.useDatesInCalcs)
      {
        DateTime dt;
        if (this.TryParseExactDateTime(str1, out dt))
          return this.GetSerialDateTimeFromDate(dt) - this.GetSerialDateTimeFromDate(DateTime.Today);
        if (this.IsDate((object) str1, out dt))
          return this.GetSerialDateTimeFromDate(dt);
      }
    }
    if (string.IsNullOrEmpty(str1) && this.treatStringsAsZero || obj == null || obj.ToString().Length <= 0)
      return 0.0;
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
    return double.NaN;
  }

  internal void GetFormulaText(ref string s)
  {
    if (this.FormulaParsing == null)
      return;
    FormulaParsingEventArgs e = new FormulaParsingEventArgs(s);
    this.FormulaParsing((object) this, e);
    s = e.Text;
  }

  public void AdjustRangeArg(ref string range)
  {
    if (range.Length > 1 && range[0] == '\u0092' && range[range.Length - 1] == '\u0092' && range.Substring(1, range.Length - 2).IndexOf('\u0092') == -1)
      range = this.ComputedValue(range);
    if (range.Length <= 1 || (int) range[0] != (int) this.TIC[0] || (int) range[range.Length - 1] != (int) this.TIC[0])
      return;
    range = range.Substring(1, range.Length - 2);
  }

  private double comb(int k, int n)
  {
    double num1 = 1.0;
    for (int index = k + 1; index <= n; ++index)
      num1 *= (double) index;
    double num2 = 1.0;
    for (int index = 2; index <= n - k; ++index)
      num2 *= (double) index;
    return num1 / num2;
  }

  public void ClearLibraryComputationException()
  {
    this.libraryComputationException = (Exception) null;
  }

  public string GetValueFromParentObject(string cell1, bool calculateFormula)
  {
    if (cell1 == this.TRUEVALUESTR || cell1 == this.FALSEVALUESTR)
      return cell1;
    int num = cell1.LastIndexOf('!');
    int row = 0;
    int col = 0;
    ICalcData grid = this.grid;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    if (num > -1 && sheetFamilyItem.TokenToParentObject != null)
    {
      if (cell1.Contains("!") && cell1.Contains("[") && cell1.Contains("]"))
      {
        QueryExternalWorksheetEventArgs e = new QueryExternalWorksheetEventArgs(cell1);
        this.QueryExternalWorksheet((object) this, e);
        if (e.IsWorksheetUpdated)
        {
          this.RegisterGridAsSheet(e.worksheetName, e.worksheet, CalcEngine.sheetFamilyID);
          this.grid = e.worksheet;
        }
        else
          this.grid = (ICalcData) sheetFamilyItem.TokenToParentObject[(object) cell1.Substring(0, num + 1)];
      }
      else
        this.grid = (ICalcData) sheetFamilyItem.TokenToParentObject[(object) cell1.Substring(0, num + 1)];
      row = this.RowIndex(cell1);
      if (row == -1 && this.grid is ISheetData)
        row = ((ISheetData) this.grid).GetFirstRow();
      col = this.ColIndex(cell1);
      if (col == -1 && this.grid is ISheetData)
        col = ((ISheetData) this.grid).GetFirstColumn();
    }
    else if (num == -1)
    {
      int index = 0;
      bool flag = false;
      for (; index < cell1.Length && char.IsLetterOrDigit(cell1[index]) | cell1[index] == '_' | cell1[index] == '.' | cell1[index] == '\\' | cell1[index] == ' '; ++index)
      {
        if (index > 0 && index < cell1.Length && char.IsLetter(cell1[index]) && (char.IsDigit(cell1[index - 1]) || index == 3))
          flag = true;
      }
      if (index == cell1.Length && (flag || !flag && !this.IsCellReference(cell1)))
      {
        cell1 = cell1.ToLower(CultureInfo.InvariantCulture);
        if (this.RethrowLibraryComputationExceptions)
        {
          this.libraryComputationException = new Exception(this.FormulaErrorStrings[this.invalid_arguments]);
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_arguments]);
        }
        return this.ErrorStrings[5].ToString();
      }
      row = this.RowIndex(cell1);
      if (row == -1 && this.grid is ISheetData)
        row = ((ISheetData) this.grid).GetFirstRow();
      col = this.ColIndex(cell1);
      if (col == -1 && this.grid is ISheetData)
        col = ((ISheetData) this.grid).GetFirstColumn();
      if (this.IsSheeted && sheetFamilyItem.ParentObjectToToken != null && sheetFamilyItem.ParentObjectToToken.ContainsKey((object) this.grid))
        cell1 = sheetFamilyItem.ParentObjectToToken[(object) this.grid].ToString() + cell1;
    }
    string cell = this.cell;
    this.cell = cell1;
    if (this.iterationMaxCount > 0)
    {
      if (this.circCheckList.IndexOf((object) this.cell) > -1 && this.computedValueLevel > 0)
      {
        this.grid = grid;
        this.cell = cell;
        if (!this.IterationValues.ContainsKey((object) this.cell))
          this.IterationValues.Add((object) this.cell, (object) "0");
        return this.IterationValues[(object) this.cell].ToString();
      }
      if (this.IterationValues.ContainsKey((object) this.cell) && this.computedValueLevel > 0)
        return this.IterationValues[(object) this.cell].ToString();
    }
    string empty = string.Empty;
    string fromParentObject;
    if (calculateFormula)
    {
      fromParentObject = this.GetValueComputeFormulaIfNecessary(row, col, this.grid);
    }
    else
    {
      object valueRowCol = this.grid.GetValueRowCol(row, col);
      fromParentObject = valueRowCol != null ? valueRowCol.ToString() : string.Empty;
    }
    this.grid = grid;
    this.cell = cell;
    return fromParentObject;
  }

  private int FindLastqNotInBrackets(string s)
  {
    int lastqNotInBrackets = -1;
    bool flag = false;
    for (int index = s.Length - 1; index > -1; --index)
    {
      if (s[index] == 'q' && flag)
      {
        lastqNotInBrackets = index;
        break;
      }
      if ((int) s[index] == (int) this.LEFTBRACKET)
        flag = true;
      else if ((int) s[index] == (int) this.RIGHTBRACKET)
        flag = false;
    }
    return lastqNotInBrackets;
  }

  public string GetValueFromGrid(int row, int col) => this.GetValueFromParentObject(row, col);

  private bool TryParseExactDateTime(string value, out DateTime result)
  {
    if (!Regex.IsMatch(value, $"^(\\d{{1,4}})(:(\\d{{1,2}}))?:(\\d{{1,2}})({NumberFormatInfo.CurrentInfo.NumberDecimalSeparator}[\\d]+){{0,1}}([\\s]+(AM|PM|am|pm)){{0,1}}[\\s]*$"))
      return DateTime.TryParseExact(value, "", (IFormatProvider) null, DateTimeStyles.None, out result);
    int int16 = (int) Convert.ToInt16(value.Substring(0, value.IndexOf(":")));
    int num1 = 0;
    if (!value.Contains(NumberFormatInfo.CurrentInfo.NumberDecimalSeparator) || value.Substring(0, value.IndexOf(":")).Contains(":"))
    {
      if (int16 >= 24)
      {
        num1 = int16 / 24;
        int num2 = int16 % 24;
        value = value.Substring(0, value.IndexOf(":")).Replace(value.Substring(0, value.IndexOf(":")), num2.ToString()) + value.Substring(value.IndexOf(":"));
      }
    }
    if (DateTime.TryParse(value, (IFormatProvider) null, DateTimeStyles.None, out result))
    {
      result = result.AddDays(Convert.ToDouble(num1));
      return true;
    }
    if (!DateTime.TryParseExact(value, $"mm:ss{NumberFormatInfo.CurrentInfo.NumberDecimalSeparator}0", (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.None, out result))
      return false;
    result = result.AddDays(Convert.ToDouble(num1));
    return true;
  }

  private string GetValueComputeFormulaIfNecessary(int row, int col, ICalcData grd)
  {
    try
    {
      bool flag1 = false;
      FormulaInfo formulaInfo = this.FormulaInfoTable[(object) this.cell] as FormulaInfo;
      this.matchType = false;
      object valueRowCol = grd.GetValueRowCol(row, col);
      string formulaIfNecessary = valueRowCol == null || !(valueRowCol.ToString() != string.Empty) ? string.Empty : valueRowCol.ToString();
      if (formulaIfNecessary != string.Empty)
        this.matchType = true;
      DateTime result;
      if (this.TryParseExactDateTime(formulaIfNecessary, out result))
        formulaIfNecessary = (this.GetSerialDateTimeFromDate(result) - this.GetSerialDateTimeFromDate(DateTime.Today)).ToString((IFormatProvider) CultureInfo.InvariantCulture);
      if (formulaIfNecessary != null && !double.TryParse(formulaIfNecessary.Replace(this.TIC, string.Empty), out double _) && DateTime.TryParse(formulaIfNecessary, (IFormatProvider) null, DateTimeStyles.None, out result))
      {
        if (this.grid is IWorksheet grid)
        {
          IRange range = grid[row, col];
          if (range != null && (range.HasDateTime || range.HasFormulaDateTime))
            formulaIfNecessary = this.GetSerialDateTimeFromDate(result).ToString();
        }
        else
          formulaIfNecessary = this.GetSerialDateTimeFromDate(result).ToString();
      }
      if (formulaIfNecessary.EndsWith("}") && formulaIfNecessary.StartsWith("{") && formulaInfo != null || formulaIfNecessary != string.Empty && formulaIfNecessary.EndsWith("}") && formulaIfNecessary.StartsWith("{") && formulaIfNecessary[1].Equals(CalcEngine.FormulaCharacter))
        this.IsArrayFormula = true;
      if (formulaIfNecessary == string.Empty && formulaInfo == null || formulaIfNecessary != string.Empty && (int) formulaIfNecessary[0] != (int) CalcEngine.FormulaCharacter && !formulaIfNecessary.EndsWith("%") && !formulaIfNecessary.EndsWith("}") && !formulaIfNecessary.StartsWith("{"))
        return formulaInfo != null && formulaIfNecessary == formulaInfo.FormulaValue ? formulaInfo.FormulaValue : formulaIfNecessary;
      if (formulaIfNecessary.Length > 0 && (int) formulaIfNecessary[0] == (int) CalcEngine.FormulaCharacter || this.IsArrayFormula)
      {
        if (formulaInfo != null)
        {
          if (this.UseFormulaValues && !this.IgnoreSubtotal)
            formulaInfo.calcID = this.calcID;
        }
        else
        {
          formulaInfo = new FormulaInfo();
          formulaInfo.FormulaText = valueRowCol.ToString();
          if (!this.DependentFormulaCells.ContainsKey((object) this.cell))
            this.DependentFormulaCells.Add((object) this.cell, (object) new Hashtable());
          bool flag2 = true;
          bool isArrayFormula = this.IsArrayFormula;
          try
          {
            formulaInfo.ParsedFormula = this.ParseFormula(formulaIfNecessary);
          }
          catch (Exception ex)
          {
            if (this.inAPull)
            {
              formulaIfNecessary = ex.Message;
              formulaInfo = (FormulaInfo) null;
            }
            else
              formulaInfo.FormulaValue = ex.Message;
            flag2 = false;
          }
          this.IsArrayFormula = isArrayFormula;
          bool ignoreSubtotal = this.IgnoreSubtotal;
          if (formulaInfo != null && !formulaInfo.ParsedFormula.Contains("SUBTOTAL"))
            this.IgnoreSubtotal = false;
          if (flag2)
          {
            formulaInfo.FormulaValue = this.ComputeFormula(formulaInfo.ParsedFormula);
            flag1 = true;
          }
          if (formulaInfo != null)
          {
            if (!this.IgnoreSubtotal)
              formulaInfo.calcID = this.calcID;
            if (!this.FormulaInfoTable.ContainsKey((object) this.cell))
              this.FormulaInfoTable.Add((object) this.cell, (object) formulaInfo);
            formulaIfNecessary = formulaInfo.FormulaValue != null ? formulaInfo.FormulaValue : string.Empty;
          }
          this.IgnoreSubtotal = ignoreSubtotal;
        }
      }
      if (formulaInfo != null)
      {
        if (this.UseFormulaValues || this.CalculatingSuspended && (!this.inAPull || flag1))
          formulaIfNecessary = formulaInfo.FormulaValue != null ? formulaInfo.FormulaValue : string.Empty;
        else if (!flag1)
        {
          if (this.calcID == formulaInfo.calcID)
          {
            formulaIfNecessary = formulaInfo.FormulaValue;
          }
          else
          {
            bool ignoreSubtotal = this.IgnoreSubtotal;
            if (!formulaInfo.ParsedFormula.Contains("SUBTOTAL"))
              this.IgnoreSubtotal = false;
            formulaIfNecessary = this.ComputeFormula(formulaInfo.ParsedFormula);
            formulaInfo.FormulaValue = formulaIfNecessary;
            if (!this.IgnoreSubtotal || ignoreSubtotal)
              formulaInfo.calcID = this.calcID;
            this.IgnoreSubtotal = ignoreSubtotal;
          }
        }
        if (this.treatStringsAsZero && string.IsNullOrEmpty(formulaIfNecessary) && this.computedValueLevel > 1 && !formulaInfo.ParsedFormula.StartsWith(this.IFMarker))
          return "0";
      }
      if (string.IsNullOrEmpty(formulaIfNecessary))
        formulaIfNecessary = string.Empty;
      return formulaIfNecessary;
    }
    finally
    {
      if (this.computedValueLevel <= 1)
        this.IsArrayFormula = false;
    }
  }

  public string GetValueFromParentObject(ICalcData grd, int row, int col)
  {
    return this.GetValueFromParentObject(grd, row, col, true);
  }

  public string GetValueFromParentObject(ICalcData grd, int row, int col, bool calculateFormula)
  {
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(grd);
    string str = (sheetFamilyItem.ParentObjectToToken == null || sheetFamilyItem.ParentObjectToToken.Count == 0 ? string.Empty : sheetFamilyItem.ParentObjectToToken[(object) grd].ToString()) + RangeInfo.GetAlphaLabel(col) + row.ToString();
    ICalcData grid = this.grid;
    string cell = this.cell;
    this.cell = str;
    this.grid = grd;
    string empty = string.Empty;
    string s;
    if (calculateFormula)
    {
      s = this.GetValueComputeFormulaIfNecessary(row, col, grd);
    }
    else
    {
      object valueRowCol = this.grid.GetValueRowCol(row, col);
      s = valueRowCol != null ? valueRowCol.ToString() : string.Empty;
    }
    DateTime result;
    if (this.ExcelLikeComputations && this.UseDatesInCalculations && !double.TryParse(s, out double _) && DateTime.TryParse(s, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result) && this.dateTime1900 <= result)
      s = result.ToOADate().ToString();
    this.grid = grid;
    this.cell = cell;
    return s;
  }

  public virtual string GetValueFromArg(string arg)
  {
    if (CalcEngine.TextIsEmpty(arg))
      return string.Empty;
    DateTime result1 = this.dateTime1900;
    if (arg.Contains(" ") && !arg.Replace('\u0092'.ToString(), string.Empty).StartsWith(this.TIC))
    {
      string finalValue;
      this.CheckIfNameRangesIntersect(arg, out finalValue);
      arg = finalValue != string.Empty ? finalValue : arg;
    }
    if ((int) arg[0] == (int) this.TIC[0] && !this.multiTick)
      return this.ExcelLikeComputations && this.UseDatesInCalculations && !double.TryParse(arg.Replace(this.TIC, string.Empty), out double _) && DateTime.TryParse(arg, (IFormatProvider) CultureInfo.CurrentCulture, DateTimeStyles.None, out result1) && this.dateTime1900 <= result1 ? result1.ToOADate().ToString() : arg;
    if (arg[0] == '\u0092' || arg[0] == 'q' || arg[0] == '!' && arg.Contains(":"))
    {
      if (arg.StartsWith("{") && arg.EndsWith("}"))
      {
        arg = arg.Replace('{', '(');
        arg = arg.Replace('}', ')');
      }
      return this.ComputedValue(arg);
    }
    if (arg.Length > 1 && arg.Substring(0, 2) == "ub")
    {
      arg = arg.Replace('{', '(');
      arg = arg.Replace('}', ')');
      string s = this.ComputedValue(arg.Substring(1));
      double result2 = 0.0;
      return double.TryParse(s, out result2) ? (-result2).ToString() : this.ComputedValue(arg);
    }
    if (arg.StartsWith("unu"))
      arg = "n" + arg.Substring(3);
    else if (arg.StartsWith("un", StringComparison.Ordinal))
      arg = "-" + arg.Substring(2);
    arg = arg.Replace('u', '-');
    arg = arg.Replace("~", this.TIC + this.TIC);
    double result3;
    if (!char.IsUpper(arg[0]) && (char.IsDigit(arg[0]) || (int) arg[0] == (int) CalcEngine.ParseDecimalSeparator || arg[0] == '+' || arg[0] == '-' || arg[0] == 'n' || arg.Length == 1 && (arg[0] == 'i' || arg[0] == 'j' || arg[0] == '∞')))
    {
      if (arg[0] == 'n')
        arg = arg.Substring(1);
      string str = arg.Substring(arg.Length - 1, 1);
      if (str == "i" || str == "j")
        return arg;
      if (double.TryParse(arg, NumberStyles.Number | NumberStyles.AllowExponent, (IFormatProvider) null, out result3))
        return !this.GetValueFromArgPreserveLeadingZeros ? result3.ToString() : arg;
      if (arg.StartsWith(this.TRUEVALUESTR) || arg.StartsWith(this.FALSEVALUESTR))
        return arg;
    }
    if (this.ignoreCellValue && !arg.StartsWith(this.TRUEVALUESTR) && !arg.StartsWith(this.FALSEVALUESTR))
    {
      this.ignoreCellValue = false;
      return arg;
    }
    if (arg.IndexOfAny(new char[7]
    {
      '+',
      '-',
      '/',
      '*',
      ')',
      ')',
      '{'
    }) == -1 && char.IsUpper(arg[0]) || arg[0] == '!')
    {
      if (arg == this.cell)
      {
        ArrayList dependentCell = (ArrayList) this.DependentCells[(object) arg];
        if (dependentCell != null && dependentCell.IndexOf((object) arg) > -1)
          dependentCell.Remove((object) arg);
        if (this.DependentFormulaCells.ContainsKey((object) this.cell))
          this.ClearFormulaDependentCells(this.cell);
        throw new ArgumentException(this.FormulaErrorStrings[this.circular_reference_] + arg);
      }
      if (!arg.StartsWith('!'.ToString()))
        this.PutTokensForSheets(ref arg);
      string fromParentObject = this.GetValueFromParentObject(arg);
      if (arg != this.TRUEVALUESTR && arg != this.FALSEVALUESTR)
      {
        if (!this.GetValueFromArgPreserveLeadingZeros && !this.IsCellReference(arg) && fromParentObject.Length > 0 && double.TryParse(fromParentObject.Replace(this.TIC, string.Empty), NumberStyles.Any, (IFormatProvider) null, out result3))
          fromParentObject = result3.ToString();
        this.UpdateDependencies(arg);
      }
      return fromParentObject;
    }
    arg = arg.Replace('{', '(');
    arg = arg.Replace('}', ')');
    arg = this.Parse(arg);
    if (arg.EndsWith("%") && double.TryParse(arg.Substring(0, arg.Length - 1), NumberStyles.Any, (IFormatProvider) null, out result3))
      arg = (result3 / 100.0).ToString();
    return this.ErrorStrings.Contains((object) arg) ? arg : this.ComputedValue(arg);
  }

  public string[] GetCellsFromArgs(string args) => this.GetCellsFromArgs(args, true);

  internal string[] GetCellsFromArgs(string args, bool findCellsFromRange)
  {
    this.MarkColonsInQuotes(ref args);
    int num1 = 0;
    int num2 = 0;
    int length1 = args.IndexOf(':');
    if (length1 > -1 && args.Contains(" ") && !args.Replace('\u0092'.ToString(), string.Empty).StartsWith(this.TIC))
    {
      int length2 = args.LastIndexOf(':');
      int length3 = args.IndexOf(':');
      string[] strArray;
      if (length3 < args.IndexOf(' '))
        strArray = new string[2]
        {
          args.Substring(0, length3),
          length3 < args.Length ? args.Substring(length3 + 1, args.Length - 1 - length3) : (string) null
        };
      else
        strArray = new string[2]
        {
          args.Substring(0, length2),
          length2 < args.Length ? args.Substring(length2 + 1, args.Length - 1 - length3) : (string) null
        };
      args = string.Empty;
      for (int index = 0; index < strArray.Length; ++index)
      {
        this.findRangeIfIntersect = true;
        if (strArray[index].Contains(" "))
        {
          string finalValue;
          this.CheckIfNameRangesIntersect(strArray[index], out finalValue);
          strArray[index] = finalValue != string.Empty ? finalValue : strArray[index];
        }
        args += index != strArray.Length - 1 ? strArray[index] + ":" : strArray[index];
      }
      this.findRangeIfIntersect = false;
    }
    if (length1 == -1)
    {
      args = args.Replace(this.MarkerChar, ':');
      if (args.IndexOf(CalcEngine.ParseArgumentSeparator) != -1)
        return this.SplitArgsPreservingQuotedCommas(args);
      num1 = this.RowIndex(args);
      num2 = this.ColIndex(args);
      return new string[1]{ args };
    }
    string str1 = string.Empty;
    string oldValue = string.Empty;
    if (args.Contains('!'.ToString()))
    {
      oldValue = this.ExternalBookToken(args);
      if (!string.IsNullOrEmpty(oldValue))
        args = args.Replace(oldValue, string.Empty);
    }
    string str2 = args;
    int startIndex = args.IndexOf('!');
    if (startIndex > -1)
    {
      int num3 = args.IndexOf('!', startIndex + 1);
      if (num3 > -1)
      {
        str1 = args.Substring(startIndex, num3 - startIndex + 1);
        args = args.Replace(str1, string.Empty);
        length1 = args.IndexOf(':');
      }
    }
    if (length1 > 0 && char.IsLetter(args[length1 - 1]))
    {
      int num4 = this.rowMaxCount > 0 ? this.rowMaxCount : 50;
      GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
      ISheetData sheetData = sheetFamilyItem.TokenToParentObject[(object) str1] as ISheetData;
      if (sheetFamilyItem.TokenToParentObject != null && sheetData != null)
        num4 = sheetData.GetLastRow();
      else if (this.grid is ISheetData)
        num4 = ((ISheetData) this.grid).GetLastRow();
      args = $"{args.Substring(0, length1)}1:{args.Substring(length1 + 1)}{num4.ToString()}";
      length1 = args.IndexOf(':');
    }
    else if (length1 > 0 && char.IsDigit(args[length1 - 1]))
    {
      int index = length1 - 2;
      while (index >= 0 && char.IsDigit(args[index]))
        --index;
      if (index == -1 || !char.IsLetter(args[index]))
      {
        int col = this.columnMaxCount > 0 ? this.columnMaxCount : 16384 /*0x4000*/;
        if (this.grid is ISheetData)
          col = ((ISheetData) this.grid).GetLastColumn();
        args = $"A{args.Substring(0, length1)}:{RangeInfo.GetAlphaLabel(col)}{args.Substring(length1 + 1)}";
        length1 = args.IndexOf(':');
      }
    }
    if (!findCellsFromRange)
      return new string[1]{ str1 + args };
    string[] strArray1 = args.Split(':');
    int num5;
    int num6;
    int num7;
    int num8;
    if (strArray1.Length > 2)
    {
      int val1_1;
      int val1_2 = val1_1 = int.MaxValue;
      int val1_3;
      int val1_4 = val1_3 = int.MinValue;
      foreach (string s in strArray1)
      {
        int val2_1 = this.RowIndex(s);
        val1_1 = Math.Min(val1_1, val2_1);
        val1_3 = Math.Max(val1_3, val2_1);
        int val2_2 = this.ColIndex(s);
        val1_2 = Math.Min(val1_2, val2_2);
        val1_4 = Math.Max(val1_4, val2_2);
      }
      num5 = val1_1;
      num6 = val1_3;
      num7 = val1_2;
      num8 = val1_4;
    }
    else
    {
      num5 = this.RowIndex(strArray1[0]);
      num7 = this.ColIndex(strArray1[0]);
      num6 = this.RowIndex(strArray1[1]);
      num8 = this.ColIndex(strArray1[1]);
    }
    if (!this.CanGetRowIndex(args.Substring(0, length1)))
    {
      this.ignoreCellValue = true;
      args = str2;
      return this.SplitArgsPreservingQuotedCommas(args);
    }
    if (!(!num5.Equals(-1) || num6.Equals(-1)).Equals(num5.Equals(-1) || !num6.Equals(-1)))
      throw new ArgumentException(this.ErrorStrings[5].ToString());
    if (num5 == -1 && this.grid is ISheetData)
      num5 = ((ISheetData) this.grid).GetFirstRow();
    if (num7 == -1 && this.grid is ISheetData)
      num7 = ((ISheetData) this.grid).GetFirstColumn();
    if (num6 == -1 && this.grid is ISheetData)
      num6 = ((ISheetData) this.grid).GetLastRow();
    if (num8 == -1 && this.grid is ISheetData)
      num8 = ((ISheetData) this.grid).GetLastColumn();
    if (num5 > num6)
    {
      int num9 = num6;
      num6 = num5;
      num5 = num9;
    }
    if (num7 > num8)
    {
      int num10 = num8;
      num8 = num7;
      num7 = num10;
    }
    string[] cellsFromArgs = new string[(num6 - num5 + 1) * (num8 - num7 + 1)];
    int num11 = 0;
    for (int index = num5; index <= num6; ++index)
    {
      for (int col = num7; col <= num8; ++col)
      {
        try
        {
          cellsFromArgs[num11++] = oldValue + str1 + RangeInfo.GetAlphaLabel(col) + index.ToString();
        }
        catch
        {
        }
      }
    }
    return cellsFromArgs;
  }

  public void RecalculateRange(RangeInfo range, ICalcData data)
  {
    this.inRecalculateRange = true;
    for (int top = range.Top; top <= range.Bottom; ++top)
    {
      for (int left = range.Left; left <= range.Right; ++left)
        data.SetValueRowCol(data.GetValueRowCol(top, left), top, left);
    }
    this.inRecalculateRange = false;
  }

  public override string ToString()
  {
    return $"CalcEngine {{ Cell: {(this.cell != null ? this.cell.ToString() : "null")} {(this.DependentCells != null ? this.DependentCells.Count : -1).ToString()}}}";
  }

  private bool FindRightBracket(string formula, ref int location)
  {
    int num = 0;
    bool rightBracket = false;
    while (!rightBracket && location < formula.Length)
    {
      if (formula[location] == 'q')
        ++num;
      else if (num == 0 && (int) formula[location] == (int) this.RIGHTBRACKET)
      {
        rightBracket = true;
        --location;
      }
      else if ((int) formula[location] == (int) this.RIGHTBRACKET)
        --num;
      ++location;
    }
    return rightBracket;
  }

  private string HandleEmbeddedIf(string formula)
  {
    int length = this.IFMarker.Length;
    int num1 = length + 1;
    double result = 0.0;
    if (this.EnsureIFCallDuringShortCircuit)
    {
      if (this.FindNextSeparator(formula, ref length))
      {
        int location = length + 1;
        this.FindRightBracket(formula, ref location);
        if (location > -1)
        {
          CalcEngine.LibraryFunction libraryFunction = (CalcEngine.LibraryFunction) this.LibraryFunctions[(object) "IF"];
          if (libraryFunction != null)
          {
            string args = formula.Substring(this.IFMarker.Length, location - this.IFMarker.Length);
            for (int index = args.IndexOf(this.IFMarker); index > -1; index = args.IndexOf(this.IFMarker))
            {
              int num2 = this.MatchingRightBracket(args.Substring(index));
              if (num2 > -1)
                args = args.Substring(0, index) + this.HandleEmbeddedIf(args.Substring(index)) + args.Substring(index + num2 + 1);
            }
            string s = libraryFunction(args);
            if (double.TryParse(s, out result))
              s = result >= 0.0 ? "n" + result.ToString() : "nu" + (-result).ToString();
            formula = s;
          }
        }
      }
      return formula;
    }
    if (this.FindNextSeparator(formula, ref length))
    {
      int location1 = length + 1;
      if (!this.FindNextSeparator(formula, ref location1))
      {
        location1 = formula.IndexOf(this.RIGHTBRACKET, length);
        if (location1 > -1)
          formula = formula.Substring(0, location1) + (object) CalcEngine.ParseArgumentSeparator + this.FALSEVALUESTR + formula.Substring(location1);
      }
      string s = this.ComputedValue(formula.Substring(this.IFMarker.Length, length - this.IFMarker.Length));
      if (s == this.TRUEVALUESTR || double.TryParse(s, NumberStyles.Any, (IFormatProvider) null, out result) && result != 0.0)
      {
        formula = formula.Substring(length + 1, location1 - length - 1);
      }
      else
      {
        int location2 = location1 + 1;
        if (this.FindRightBracket(formula, ref location2))
          formula = formula.Substring(location1 + 1, location2 - location1 - 1);
      }
      if (double.TryParse(formula, out result))
        formula = result >= 0.0 ? "n" + result.ToString() : "nu" + (-result).ToString();
    }
    return formula;
  }

  public string GetValueFromParentObject(string cell1)
  {
    return this.GetValueFromParentObject(cell1, true);
  }

  public string GetValueFromParentObject(int row, int col)
  {
    return this.GetValueComputeFormulaIfNecessary(row, col, this.grid);
  }

  public string ComputedValue(string formula)
  {
    this.ExceptionThrown = false;
    bool flag1 = false;
    if (CalcEngine.TextIsEmpty(formula))
      return formula;
    string finalValue;
    if (this.CheckIfNameRangesIntersect(formula, out finalValue))
      return finalValue;
    try
    {
      ++this.computedValueLevel;
      if (this.computedValueLevel > this.maximumRecursiveCalls)
      {
        this.computedValueLevel = 0;
        throw new ArgumentException(this.FormulaErrorStrings[this.too_complex]);
      }
      Stack stack1 = new Stack(CalcEngine.MaxStackDepth);
      stack1.Clear();
      string empty1 = string.Empty;
      string empty2 = string.Empty;
      if (this.AllowShortCircuitIFs && formula.Length > 0 && formula.IndexOf(this.IFMarker) > -1)
      {
        if (this.EnsureIFCallDuringShortCircuit)
          this.ComputeEnsureIFCall(ref formula);
        else
          this.ComputeShortCircuitIFFormula(ref formula);
        if (formula.StartsWith(this.TIC) && formula.EndsWith(this.TIC))
          return formula;
      }
      int i = 0;
      char ch;
      while (i < formula.Length)
      {
        if (formula[i] == '\u0092')
        {
          ++i;
        }
        else
        {
          bool flag2 = formula[i] == 'u';
          if (flag2)
          {
            ++i;
            if (i < formula.Length)
            {
              if (formula[i] == '\u0092')
                ++i;
              if (i >= formula.Length)
                continue;
            }
            else
              continue;
          }
          if (formula[i] == '%' && stack1.Count > 0)
          {
            double result;
            if (double.TryParse(stack1.Peek().ToString(), NumberStyles.Any, (IFormatProvider) null, out result))
            {
              stack1.Pop();
              stack1.Push((object) (result / 100.0));
            }
            ++i;
          }
          else
          {
            if (formula[i] == '[')
            {
              ch = formula[i];
              empty2 = ch.ToString();
              for (++i; i < formula.Length && formula[i] != ']'; ++i)
                empty2 += (string) (object) formula[i];
              if (i < formula.Length)
              {
                empty2 += (string) (object) formula[i];
                ++i;
              }
              else
                continue;
            }
            if (formula[i] == '!')
            {
              ch = formula[i];
              empty1 = ch.ToString();
              for (++i; i < formula.Length && formula[i] != '!'; ++i)
                empty1 += (string) (object) formula[i];
              if (i < formula.Length)
              {
                empty1 += (string) (object) formula[i];
                ++i;
              }
              else
                continue;
            }
            bool flag3;
            if (formula.Substring(i).StartsWith(this.TRUEVALUESTR))
            {
              stack1.Push((object) this.TRUEVALUESTR);
              i += this.TRUEVALUESTR.Length;
            }
            else if (formula.Substring(i).StartsWith(this.FALSEVALUESTR))
            {
              stack1.Push((object) this.FALSEVALUESTR);
              i += this.FALSEVALUESTR.Length;
            }
            else if ((int) formula[i] == (int) this.TIC[0] || formula[i] == '|')
            {
              if (stack1.Count == 3)
                stack1 = this.CombineStack(formula, i - 2, stack1);
              ch = formula[i];
              string str = ch.ToString();
              for (++i; i < formula.Length && (int) formula[i] != (int) this.TIC[0]; ++i)
                str += (string) (object) formula[i];
              if (this.multiTick)
                str = str.Replace("|", this.TIC);
              stack1.Push((object) (str + this.TIC));
              ++i;
            }
            else if (char.IsUpper(formula[i]))
            {
              string str1 = this.ProcessUpperCase(ref formula, ref i, ref empty1);
              if (this.ErrorStrings.Contains((object) str1))
                return str1;
              if (empty2 != string.Empty)
                str1 = empty2 + str1;
              if (flag2)
              {
                string fromParentObject = this.GetValueFromParentObject(str1);
                double result;
                if (double.TryParse(fromParentObject, out result))
                {
                  result = -result;
                  stack1.Push((object) result.ToString());
                }
                else
                  stack1.Push((object) fromParentObject);
              }
              else
              {
                if (this.UseFormulaValues && this.computedValueLevel > CalcEngine.MaxStackDepth)
                {
                  if (!this.breakedFormulaCells.Contains((object) str1) && this.UseFormulaValues)
                  {
                    CalcEngine.GetSheetFamilyItem(this.grid);
                    string str2 = str1;
                    ch = '!';
                    string str3 = ch.ToString();
                    if (!str2.StartsWith(str3))
                      str1 = '!'.ToString() + this.GetSheetID(this.grid).ToString() + (object) '!' + str1;
                    this.breakedFormulaCells.Add((object) str1);
                    this.tempBreakedFormulaCells.Add((object) str1);
                    break;
                  }
                  stack1.Push((object) "FALSE");
                }
                if (this.IsAreaCalculation && this.IsRange(str1) && str1.Contains(":"))
                  stack1.Push((object) str1);
                else
                  stack1.Push((object) this.GetValueFromParentObject(str1));
              }
            }
            else if (formula[i] == 'q')
            {
              formula = this.ComputeInteriorFunctions(formula);
              int length = formula.Substring(i + 1).IndexOf(this.LEFTBRACKET);
              if (length > 0)
              {
                int num1 = 0;
                bool flag4 = false;
                int num2 = length + i + 2;
                int index1;
                for (index1 = num2; index1 < formula.Length && ((int) formula[index1] != (int) this.RIGHTBRACKET || num1 > 0); ++index1)
                {
                  if ((int) formula[index1] == (int) this.LEFTBRACKET)
                  {
                    ++num1;
                    flag4 = true;
                  }
                  else if ((int) formula[index1] == (int) this.LEFTBRACKET)
                    --num1;
                }
                if (flag4)
                {
                  string args = formula.Substring(num2, index1 - num2 - 2);
                  string str = string.Empty;
                  foreach (string preservingQuotedComma in this.SplitArgsPreservingQuotedCommas(args))
                  {
                    if (str.Length > 0)
                      str += ",";
                    int lastqNotInBrackets = this.FindLastqNotInBrackets(preservingQuotedComma);
                    str = lastqNotInBrackets <= 0 ? str + this.ComputedValue(preservingQuotedComma) : str + preservingQuotedComma.Substring(0, lastqNotInBrackets) + this.ComputedValue(preservingQuotedComma.Substring(lastqNotInBrackets));
                  }
                  formula = formula.Substring(0, num2) + str + formula.Substring(index1 - 2);
                }
                string str4 = formula.Substring(i + 1, length);
                if (str4 == "AVG" && this.excelLikeComputations)
                  return this.FormulaErrorStrings[this.bad_index];
                if (this.LibraryFunctions[(object) str4] == null)
                  return this.FormulaErrorStrings[this.missing_formula];
                int num3 = formula.Substring(i + length + 1).IndexOf(this.RIGHTBRACKET);
                string args1 = formula.Substring(i + length + 2, num3 - 1);
                try
                {
                  CalcEngine.LibraryFunction libraryFunction = (CalcEngine.LibraryFunction) this.LibraryFunctions[(object) str4];
                  string[] strArray = this.SplitArgsPreservingQuotedCommas(args1);
                  StringBuilder stringBuilder = new StringBuilder();
                  bool flag5 = false;
                  for (int index2 = 0; index2 < strArray.Length; ++index2)
                  {
                    string str5 = strArray[index2];
                    this.findNamedRange = false;
                    if (this.NamedRanges.Count > 0 && !string.IsNullOrEmpty(str5.Trim()))
                      str5 = this.CheckForNamedRange(str5);
                    if (!this.findNamedRange && !str5.StartsWith("!") && str5.Contains("!") && str5.Contains("'[") && str5.Contains("]"))
                    {
                      UpdateExternalFormulaEventArgs e = new UpdateExternalFormulaEventArgs(str5);
                      this.UpdateExternalFormula((object) this, e);
                      if (e.IsFormulaUpdated)
                      {
                        str5 = e.parsedFormula;
                        flag5 = true;
                      }
                    }
                    if (index2 == strArray.Length - 1)
                      stringBuilder.Append(str5);
                    else
                      stringBuilder.Append(str5 + (object) CalcEngine.ParseArgumentSeparator);
                  }
                  if (flag5 || this.findNamedRange)
                    args1 = stringBuilder.ToString();
                  this.findNamedRange = false;
                  string computedValue = libraryFunction(args1);
                  if (this.FormulaComputed != null)
                  {
                    FormulaComputedEventArgs e = new FormulaComputedEventArgs(str4, computedValue, this.cell, this.computedValueLevel > 1);
                    this.FormulaComputed((object) this, e);
                    if (e.Handled)
                      computedValue = e.ComputedValue;
                  }
                  stack1.Push((object) computedValue);
                }
                catch (Exception ex)
                {
                  this.ExceptionThrown = true;
                  if (this.rethrowLibraryComputationExceptions)
                  {
                    this.libraryComputationException = ex;
                    throw ex;
                  }
                  return this.ErrorStrings.Contains((object) ex.Message) ? ex.Message : this.ErrorStrings[1].ToString();
                }
                i += num3 + length + 2;
              }
              else if (formula[0] == '\u0092' && formula[formula.Length - 1] == '\u0092')
              {
                i = 0;
                stack1.Clear();
              }
              else
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new Exception(this.FormulaErrorStrings[this.improper_formula]);
                return this.FormulaErrorStrings[this.improper_formula];
              }
            }
            else if (char.IsDigit(formula[i]) || formula[i] == 'u')
            {
              string str = string.Empty;
              if (formula[i] == 'u' || flag2)
              {
                str = "-";
                if (!flag2)
                  ++i;
                else
                  flag3 = false;
              }
              if (i < formula.Length && char.IsUpper(formula[i]))
              {
                str += this.GetValueFromParentObject(this.ProcessUpperCase(ref formula, ref i, ref empty1));
              }
              else
              {
                for (; i < formula.Length; ++i)
                {
                  if (!char.IsDigit(formula[i]) && (int) formula[i] != (int) CalcEngine.ParseDecimalSeparator)
                    goto label_126;
label_123:
                  str += (string) (object) formula[i];
                  continue;
label_126:
                  ch = formula[i];
                  if (ch.Equals(':'))
                    goto label_123;
                  break;
                }
              }
              stack1.Push((object) str);
            }
            else if ((int) formula[i] == (int) CalcEngine.ParseDateTimeSeparator)
            {
              string str = "";
              for (; i < formula.Length && (int) formula[i] == (int) CalcEngine.ParseDateTimeSeparator; ++i)
                str += (string) (object) formula[i];
              while (stack1.Count > 0)
                str = stack1.Pop().ToString() + str;
              stack1.Push((object) str);
            }
            else if ((int) formula[i] == (int) CalcEngine.ParseArgumentSeparator)
            {
              ++i;
            }
            else
            {
              ch = formula[i];
              double num4;
              switch (ch)
              {
                case '#':
                  int num5;
                  if (formula.Substring(i).Contains("#N/A") || formula.Substring(i).Contains("#VALUE!") || formula.Substring(i).Contains("#REF!") || formula.Substring(i).Contains("#DIV/0!") || formula.Substring(i).Contains("#NUM!") || formula.Substring(i).Contains("#NAME?") || formula.Substring(i).Contains("#NULL!"))
                  {
                    num5 = formula.IndexOf('!') == -1 || formula.Substring(i).IndexOf('!') == -1 ? (formula.Substring(i).IndexOf("#N/A") > -1 ? formula.Substring(i).IndexOf("#N/A") + 4 + i : formula.Substring(i).IndexOf('?') + 1 + i) : formula.Substring(i).IndexOf('!') + 1 + i;
                    stack1.Push((object) formula.Substring(i, num5 - i));
                  }
                  else
                  {
                    num5 = i + 1;
                    stack1.Push((object) formula.Substring(i, num5 - i));
                  }
                  i = num5;
                  continue;
                case 'a':
                  double num6 = this.Pop(stack1);
                  int result1;
                  if (int.TryParse(num6.ToString(), out result1) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result1].ToString();
                  }
                  double num7 = this.Pop(stack1);
                  if (int.TryParse(num7.ToString(), out result1) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result1].ToString();
                  }
                  if (num6.Equals(double.NaN) || num7.Equals(double.NaN) || num6.Equals((object) "#VALUE!") || num7.Equals((object) "#VALUE!"))
                  {
                    if (this.excelLikeComputations)
                      stack1.Push((object) "#VALUE!");
                    else if (num6.Equals(double.NaN) || num7.Equals(double.NaN))
                    {
                      Stack stack2 = stack1;
                      num4 = double.NaN;
                      string str = num4.ToString();
                      stack2.Push((object) str);
                    }
                  }
                  else
                  {
                    Stack stack3 = stack1;
                    num4 = num7 + num6;
                    string str = num4.ToString();
                    stack3.Push((object) str);
                  }
                  ++i;
                  continue;
                case 'c':
                  string str6 = this.PopString(stack1);
                  if (str6.Length > 0 && (int) str6[0] == (int) this.TIC[0] && str6.Length > 1 && (int) str6[str6.Length - 1] == (int) this.TIC[0])
                    str6 = str6.Substring(1, str6.Length - 2);
                  string str7 = string.Empty;
                  if (stack1.Count > 0)
                    str7 = this.PopString(stack1);
                  if (str7.Length > 0 && (int) str7[0] == (int) this.TIC[0] && str7.Length > 1 && (int) str7[str7.Length - 1] == (int) this.TIC[0])
                    str7 = str7.Substring(1, str7.Length - 2);
                  if (str6 == string.Empty && str7 == string.Empty)
                    flag1 = true;
                  if (str6.Length > 0 && str6[0] == '#' && this.ErrorStrings.IndexOf((object) str6) > -1)
                    stack1.Push((object) str6);
                  else if (str7.Length > 0 && str7[0] == '#' && this.ErrorStrings.IndexOf((object) str7) > -1)
                    stack1.Push((object) str7);
                  else
                    stack1.Push((object) (this.TIC + str7 + str6 + this.TIC));
                  ++i;
                  continue;
                case 'd':
                  double num8 = this.Pop(stack1);
                  int result2;
                  if (int.TryParse(num8.ToString(), out result2) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result2].ToString();
                  }
                  double num9 = this.Pop(stack1);
                  if (int.TryParse(num9.ToString(), out result2) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result2].ToString();
                  }
                  if (num8.Equals(double.NaN) || num9.Equals(double.NaN) || num8.Equals((object) "#VALUE!") || num9.Equals((object) "#VALUE!"))
                  {
                    if (this.ExcelLikeComputations)
                    {
                      stack1.Push((object) "#VALUE!");
                    }
                    else
                    {
                      Stack stack4 = stack1;
                      num4 = double.NaN;
                      string str8 = num4.ToString();
                      stack4.Push((object) str8);
                    }
                  }
                  else if (num8.Equals(0.0))
                  {
                    if (this.ExcelLikeComputations)
                      stack1.Push((object) this.ErrorStrings[3].ToString());
                    else if (num9 == 0.0)
                    {
                      Stack stack5 = stack1;
                      num4 = double.NaN;
                      string str9 = num4.ToString();
                      stack5.Push((object) str9);
                    }
                    else if (num9 > 0.0)
                    {
                      Stack stack6 = stack1;
                      num4 = double.PositiveInfinity;
                      string str10 = num4.ToString();
                      stack6.Push((object) str10);
                    }
                    else
                    {
                      Stack stack7 = stack1;
                      num4 = double.NegativeInfinity;
                      string str11 = num4.ToString();
                      stack7.Push((object) str11);
                    }
                  }
                  else
                  {
                    Stack stack8 = stack1;
                    num4 = num9 / num8;
                    string str12 = num4.ToString();
                    stack8.Push((object) str12);
                  }
                  ++i;
                  continue;
                case 'e':
                  string str13 = this.PopString(stack1);
                  string str14 = this.PopString(stack1);
                  string str15 = string.Empty;
                  if (this.TreatStringsAsZero && (str13 == string.Empty || str13.Replace(this.TIC, string.Empty) == string.Empty && str14 == string.Empty))
                    str13 = "0";
                  if (this.TreatStringsAsZero && (str14 == string.Empty || str14.Replace(this.TIC, string.Empty) == string.Empty && str13 == string.Empty))
                    str14 = "0";
                  if (str15 == string.Empty)
                    str15 = str13.Length <= 0 || str13[0] != '#' || this.ErrorStrings.IndexOf((object) str13) <= -1 ? (str14.Length <= 0 || str14[0] != '#' || this.ErrorStrings.IndexOf((object) str14) <= -1 ? (str13.Length > 0 && this.formulaErrorStrings.IndexOf((object) str13) > -1 || str14.Length > 0 && this.formulaErrorStrings.IndexOf((object) str14) > -1 ? "#VALUE!" : (str13.StartsWith(this.TIC) && str14.IndexOf(this.TIC) == -1 || str14.StartsWith(this.TIC) && str13.IndexOf(this.TIC) == -1 ? (double.TryParse(str13.Replace(this.TIC, string.Empty), out double _) || double.TryParse(str14.Replace(this.TIC, string.Empty), out double _) ? this.FALSEVALUESTR : (str13.Replace(this.TIC, string.Empty).ToUpper() == str14.Replace(this.TIC, string.Empty).ToUpper() ? this.TRUEVALUESTR : this.FALSEVALUESTR)) : (str13.ToUpper() == str14.ToUpper() ? this.TRUEVALUESTR : this.FALSEVALUESTR))) : str14) : str13;
                  stack1.Push((object) str15);
                  ++i;
                  continue;
                case 'g':
                  string s1 = this.PopString(stack1);
                  string s2 = this.PopString(stack1);
                  if (s1.Replace(this.TIC, string.Empty) == string.Empty)
                    s1 = !this.TreatStringsAsZero ? s2 + (object) 1 : "0";
                  if (s2.Replace(this.TIC, string.Empty) == string.Empty)
                    s2 = !this.TreatStringsAsZero ? s1 + (object) 1 : "0";
                  string str16 = string.Empty;
                  double result3;
                  double result4;
                  if (double.TryParse(s1, NumberStyles.Any, (IFormatProvider) null, out result3) && double.TryParse(s2, NumberStyles.Any, (IFormatProvider) null, out result4))
                    str16 = result4 > result3 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  if (str16 == string.Empty)
                  {
                    if (s1.Length > 0 && s1[0] == '#' && this.ErrorStrings.IndexOf((object) s1) > -1)
                      str16 = s1;
                    else if (s2.Length > 0 && s2[0] == '#' && this.ErrorStrings.IndexOf((object) s2) > -1)
                      str16 = s2;
                    else if ((s1.Contains(this.TIC) || s2.Contains(this.TIC)) && (double.TryParse(s1.Replace(this.TIC, string.Empty), out result3) || double.TryParse(s2.Replace(this.TIC, string.Empty), out result4)))
                    {
                      if (s1.StartsWith(this.TIC) && s2.IndexOf(this.TIC) == -1)
                        str16 = this.FALSEVALUESTR;
                      else if (s2.StartsWith(this.TIC) && s1.IndexOf(this.TIC) == -1)
                        str16 = this.TRUEVALUESTR;
                    }
                    else
                      str16 = s2.ToUpper().Replace(this.TIC, string.Empty).CompareTo(s1.ToUpper().Replace(this.TIC, string.Empty)) > 0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  }
                  stack1.Push((object) str16);
                  ++i;
                  continue;
                case 'j':
                  string s3 = this.PopString(stack1);
                  string s4 = this.PopString(stack1);
                  string str17 = string.Empty;
                  if (s3.Replace(this.TIC, string.Empty) == string.Empty && this.TreatStringsAsZero)
                    s3 = "0";
                  if (s4.Replace(this.TIC, string.Empty) == string.Empty && this.TreatStringsAsZero)
                    s4 = "0";
                  double result5;
                  double result6;
                  if (double.TryParse(s3, NumberStyles.Any, (IFormatProvider) null, out result5) && double.TryParse(s4, NumberStyles.Any, (IFormatProvider) null, out result6))
                    str17 = result6 >= result5 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  else if (s3.Length > 0 && s3[0] == '#' && this.ErrorStrings.IndexOf((object) s3) > -1)
                    str17 = s3;
                  else if (s4.Length > 0 && s4[0] == '#' && this.ErrorStrings.IndexOf((object) s4) > -1)
                    str17 = s4;
                  else if ((s3.Contains(this.TIC) || s4.Contains(this.TIC)) && (double.TryParse(s3.Replace(this.TIC, string.Empty), out result5) || double.TryParse(s4.Replace(this.TIC, string.Empty), out result6)))
                  {
                    if (s3.StartsWith(this.TIC) && s4.IndexOf(this.TIC) == -1)
                      str17 = this.FALSEVALUESTR;
                    else if (s4.StartsWith(this.TIC) && s3.IndexOf(this.TIC) == -1)
                      str17 = this.TRUEVALUESTR;
                  }
                  else
                    str17 = s4.ToUpper().Replace(this.TIC, string.Empty).CompareTo(s3.ToUpper().Replace(this.TIC, string.Empty)) >= 0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  stack1.Push((object) str17);
                  ++i;
                  continue;
                case 'k':
                  string s5 = this.PopString(stack1);
                  string s6 = this.PopString(stack1);
                  string str18 = string.Empty;
                  if (s5.Replace(this.TIC, string.Empty) == string.Empty && this.TreatStringsAsZero)
                    s5 = "0";
                  if (s6.Replace(this.TIC, string.Empty) == string.Empty && this.TreatStringsAsZero)
                    s6 = "0";
                  double result7;
                  double result8;
                  if (double.TryParse(s5, NumberStyles.Any, (IFormatProvider) null, out result7) && double.TryParse(s6, NumberStyles.Any, (IFormatProvider) null, out result8))
                    str18 = result8 <= result7 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  else if (s5.Length > 0 && s5[0] == '#' && this.ErrorStrings.IndexOf((object) s5) > -1)
                    str18 = s5;
                  else if (s6.Length > 0 && s6[0] == '#' && this.ErrorStrings.IndexOf((object) s6) > -1)
                    str18 = s6;
                  else if ((s5.Contains(this.TIC) || s6.Contains(this.TIC)) && (double.TryParse(s5.Replace(this.TIC, string.Empty), out result7) || double.TryParse(s6.Replace(this.TIC, string.Empty), out result8)))
                  {
                    if (s5.StartsWith(this.TIC) && s6.IndexOf(this.TIC) == -1)
                      str18 = this.TRUEVALUESTR;
                    else if (s6.StartsWith(this.TIC) && s5.IndexOf(this.TIC) == -1)
                      str18 = this.FALSEVALUESTR;
                  }
                  else
                    str18 = s5.ToUpper().Replace(this.TIC, string.Empty).CompareTo(s6.ToUpper().Replace(this.TIC, string.Empty)) <= 0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  stack1.Push((object) str18);
                  ++i;
                  continue;
                case 'l':
                  string s7 = this.PopString(stack1);
                  string s8 = this.PopString(stack1);
                  string str19 = string.Empty;
                  if (s7.Replace(this.TIC, string.Empty) == string.Empty && this.treatStringsAsZero)
                    s7 = "0";
                  if (s8.Replace(this.TIC, string.Empty) == string.Empty && this.treatStringsAsZero)
                    s8 = "0";
                  double result9;
                  double result10;
                  if (double.TryParse(s7, NumberStyles.Any, (IFormatProvider) null, out result9) && double.TryParse(s8, NumberStyles.Any, (IFormatProvider) null, out result10))
                    str19 = result10 < result9 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  else if (s7.Length > 0 && s7[0] == '#' && this.ErrorStrings.IndexOf((object) s7) > -1)
                    str19 = s7;
                  else if (s8.Length > 0 && s8[0] == '#' && this.ErrorStrings.IndexOf((object) s8) > -1)
                    str19 = s8;
                  else if ((s7.Contains(this.TIC) || s8.Contains(this.TIC)) && (double.TryParse(s7.Replace(this.TIC, string.Empty), out result9) || double.TryParse(s8.Replace(this.TIC, string.Empty), out result10)))
                  {
                    if (s7.StartsWith(this.TIC) && s8.IndexOf(this.TIC) == -1)
                      str19 = this.TRUEVALUESTR;
                    else if (s8.StartsWith(this.TIC) && s7.IndexOf(this.TIC) == -1)
                      str19 = this.FALSEVALUESTR;
                  }
                  else
                    str19 = s8.ToUpper().Replace(this.TIC, string.Empty).CompareTo(s7.ToUpper().Replace(this.TIC, string.Empty)) < 0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  stack1.Push((object) str19);
                  ++i;
                  continue;
                case 'm':
                  double num10 = this.Pop(stack1);
                  int result11;
                  if (int.TryParse(num10.ToString(), out result11) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result11].ToString();
                  }
                  double num11 = this.Pop(stack1);
                  if (int.TryParse(num11.ToString(), out result11) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result11].ToString();
                  }
                  if (num10.Equals(double.NaN) || num11.Equals(double.NaN) || num10.Equals((object) "#VALUE!") || num11.Equals((object) "#VALUE!"))
                  {
                    if (this.excelLikeComputations)
                      stack1.Push((object) "#VALUE!");
                    else if (num10.Equals(double.NaN) || num11.Equals(double.NaN))
                    {
                      Stack stack9 = stack1;
                      num4 = double.NaN;
                      string str20 = num4.ToString();
                      stack9.Push((object) str20);
                    }
                  }
                  else if (num10.Equals(double.PositiveInfinity) || num10.Equals(double.NegativeInfinity) || num11.Equals(double.PositiveInfinity) || num11.Equals(double.NegativeInfinity))
                  {
                    Stack stack10 = stack1;
                    num4 = double.NaN;
                    string str21 = num4.ToString();
                    stack10.Push((object) str21);
                  }
                  else
                  {
                    Stack stack11 = stack1;
                    num4 = num11 * num10;
                    string str22 = num4.ToString();
                    stack11.Push((object) str22);
                  }
                  ++i;
                  continue;
                case 'n':
                  ++i;
                  string s9 = string.Empty;
                  if (!formula.Substring(i).StartsWith("Infinity"))
                  {
                    string str23 = formula.Substring(i);
                    num4 = double.PositiveInfinity;
                    string str24 = num4.ToString();
                    if (!str23.StartsWith(str24))
                    {
                      if (!formula.Substring(i).StartsWith("uInfinity"))
                      {
                        string str25 = formula.Substring(i);
                        num4 = double.NegativeInfinity;
                        string str26 = num4.ToString();
                        if (!str25.StartsWith(str26))
                        {
                          if (formula.Substring(i).StartsWith(this.TRUEVALUESTR))
                          {
                            s9 = this.TRUEVALUESTR;
                            i += s9.Length;
                            goto label_167;
                          }
                          if (formula.Substring(i).StartsWith(this.FALSEVALUESTR))
                          {
                            s9 = this.FALSEVALUESTR;
                            i += s9.Length;
                            goto label_167;
                          }
                          if (i <= formula.Length - 3 && formula.Substring(i, 3).ToUpper() == Convert.ToString(double.NaN).ToUpper())
                          {
                            i += 3;
                            s9 = !this.ExcelLikeComputations ? Convert.ToString(double.NaN) : this.ErrorStrings[1].ToString();
                            goto label_167;
                          }
                          if (formula[i] == 'u' || flag2)
                          {
                            s9 = "-";
                            if (!flag2)
                              ++i;
                            else
                              flag3 = false;
                          }
                          for (; i < formula.Length && (char.IsDigit(formula[i]) || (int) formula[i] == (int) CalcEngine.ParseDecimalSeparator); ++i)
                            s9 += (string) (object) formula[i];
                          if (i < formula.Length && formula[i] == '%')
                          {
                            ++i;
                            if (s9 == string.Empty)
                            {
                              double result12;
                              if (stack1.Count > 0 && double.TryParse(stack1.Peek().ToString(), NumberStyles.Any, (IFormatProvider) null, out result12))
                              {
                                stack1.Pop();
                                num4 = result12 / 100.0;
                                s9 = num4.ToString();
                                goto label_167;
                              }
                              goto label_167;
                            }
                            num4 = double.Parse(s9) / 100.0;
                            s9 = num4.ToString();
                            goto label_167;
                          }
                          if (i < formula.Length - 2 && formula[i] == 'E' && (formula[i + 1] == '+' || formula[i + 1] == '-'))
                          {
                            s9 += formula.Substring(i, 4);
                            i += 4;
                            goto label_167;
                          }
                          goto label_167;
                        }
                      }
                      num4 = double.NegativeInfinity;
                      s9 = num4.ToString();
                      i += s9.Length + 1;
                      goto label_167;
                    }
                  }
                  num4 = double.PositiveInfinity;
                  s9 = num4.ToString();
                  i += s9.Length;
label_167:
                  stack1.Push((object) s9);
                  continue;
                case 'o':
                  string s10 = this.PopString(stack1);
                  string s11 = this.PopString(stack1);
                  if (this.TreatStringsAsZero && (s10 == string.Empty || s10.Replace(this.TIC, string.Empty) == string.Empty && s11 == string.Empty))
                    s10 = "0";
                  if (this.TreatStringsAsZero && (s11 == string.Empty || s11.Replace(this.TIC, string.Empty) == string.Empty && s10 == string.Empty))
                    s11 = "0";
                  double result13;
                  double result14;
                  string str27 = !double.TryParse(s10, NumberStyles.Any, (IFormatProvider) null, out result13) || !double.TryParse(s11, NumberStyles.Any, (IFormatProvider) null, out result14) ? (s10.Length <= 0 || s10[0] != '#' || this.ErrorStrings.IndexOf((object) s10) <= -1 ? (s11.Length <= 0 || s11[0] != '#' || this.ErrorStrings.IndexOf((object) s11) <= -1 ? (s10.StartsWith(this.TIC) && s11.IndexOf(this.TIC) == -1 || s11.StartsWith(this.TIC) && s10.IndexOf(this.TIC) == -1 ? (double.TryParse(s10.Replace(this.TIC, string.Empty), out result13) || double.TryParse(s11.Replace(this.TIC, string.Empty), out result14) ? this.TRUEVALUESTR : (s10.Replace(this.TIC, string.Empty).ToUpper() != s11.Replace(this.TIC, string.Empty).ToUpper() ? this.TRUEVALUESTR : this.FALSEVALUESTR)) : (s10.ToUpper().Replace(this.TIC, string.Empty) != s11.ToUpper().Replace(this.TIC, string.Empty) ? this.TRUEVALUESTR : this.FALSEVALUESTR)) : s11) : s10) : (result14 != result13 ? this.TRUEVALUESTR : this.FALSEVALUESTR);
                  stack1.Push((object) str27);
                  ++i;
                  continue;
                case 's':
                  double num12 = this.Pop(stack1);
                  int result15;
                  if (int.TryParse(num12.ToString(), out result15) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result15].ToString();
                  }
                  double num13 = this.Pop(stack1);
                  if (int.TryParse(num13.ToString(), out result15) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result15].ToString();
                  }
                  if (num12.Equals(double.NaN) || num13.Equals(double.NaN) || num12.Equals((object) "#VALUE!") || num13.Equals((object) "#VALUE!"))
                  {
                    if (this.excelLikeComputations)
                      stack1.Push((object) "#VALUE!");
                    else if (num12.Equals(double.NaN) || num13.Equals(double.NaN))
                    {
                      Stack stack12 = stack1;
                      num4 = double.NaN;
                      string str28 = num4.ToString();
                      stack12.Push((object) str28);
                    }
                  }
                  else
                  {
                    Stack stack13 = stack1;
                    num4 = num13 - num12;
                    string str29 = num4.ToString();
                    stack13.Push((object) str29);
                  }
                  ++i;
                  continue;
                case 't':
                  double y1 = this.Pop(stack1);
                  int result16;
                  if (int.TryParse(y1.ToString(), out result16) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result16].ToString();
                  }
                  double num14 = this.Pop(stack1);
                  if (int.TryParse(num14.ToString(), out result16) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result16].ToString();
                  }
                  Stack stack14 = stack1;
                  num4 = num14 * Math.Pow(10.0, y1);
                  string str30 = num4.ToString("R");
                  stack14.Push((object) str30);
                  ++i;
                  continue;
                case 'v':
                  double num15 = this.Pop(stack1);
                  int result17;
                  if (int.TryParse(num15.ToString(), out result17) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result17].ToString();
                  }
                  double num16 = this.Pop(stack1);
                  if (int.TryParse(num16.ToString(), out result17) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result17].ToString();
                  }
                  Stack stack15 = stack1;
                  num4 = num16 * Math.Pow(10.0, -num15);
                  string str31 = num4.ToString("R");
                  stack15.Push((object) str31);
                  ++i;
                  continue;
                case '~':
                  double y2 = this.Pop(stack1);
                  int result18;
                  if (int.TryParse(y2.ToString(), out result18) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result18].ToString();
                  }
                  double x = this.Pop(stack1);
                  if (int.TryParse(x.ToString(), out result18) && this.isErrorString)
                  {
                    this.isErrorString = false;
                    return this.ErrorStrings[result18].ToString();
                  }
                  Stack stack16 = stack1;
                  num4 = Math.Pow(x, y2);
                  string str32 = num4.ToString("R");
                  stack16.Push((object) str32);
                  ++i;
                  continue;
                case '\u0084':
                  string s12 = this.PopString(stack1);
                  string s13 = this.PopString(stack1);
                  double result19;
                  if (s12 == string.Empty)
                    s12 = this.FALSEVALUESTR;
                  else if (double.TryParse(s12, NumberStyles.Any, (IFormatProvider) null, out result19))
                    s12 = result19 != 0.0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  if (s13 == string.Empty)
                    s13 = this.FALSEVALUESTR;
                  else if (double.TryParse(s13, NumberStyles.Any, (IFormatProvider) null, out result19))
                    s13 = result19 != 0.0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  string str33 = s12.Length <= 0 || s12[0] != '#' || this.ErrorStrings.IndexOf((object) s12) <= -1 ? (s13.Length <= 0 || s13[0] != '#' || this.ErrorStrings.IndexOf((object) s13) <= -1 ? (s12.ToUpper().Replace(this.TIC, string.Empty) == this.TRUEVALUESTR || s13.ToUpper().Replace(this.TIC, string.Empty) == this.TRUEVALUESTR ? this.TRUEVALUESTR : this.FALSEVALUESTR) : s13) : s12;
                  stack1.Push((object) str33);
                  ++i;
                  continue;
                case '\u0085':
                  string s14 = this.PopString(stack1);
                  string s15 = this.PopString(stack1);
                  double result20;
                  if (s14 == string.Empty)
                    s14 = this.FALSEVALUESTR;
                  else if (double.TryParse(s14, NumberStyles.Any, (IFormatProvider) null, out result20))
                    s14 = result20 != 0.0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  if (s15 == string.Empty)
                    s15 = this.FALSEVALUESTR;
                  else if (double.TryParse(s15, NumberStyles.Any, (IFormatProvider) null, out result20))
                    s15 = result20 != 0.0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  string str34 = s14.Length <= 0 || s14[0] != '#' || this.ErrorStrings.IndexOf((object) s14) <= -1 ? (s15.Length <= 0 || s15[0] != '#' || this.ErrorStrings.IndexOf((object) s15) <= -1 ? (!(s14.ToUpper().Replace(this.TIC, string.Empty) == this.TRUEVALUESTR) || !(s15.ToUpper().Replace(this.TIC, string.Empty) == this.TRUEVALUESTR) ? this.FALSEVALUESTR : this.TRUEVALUESTR) : s15) : s14;
                  stack1.Push((object) str34);
                  ++i;
                  continue;
                case '\u0086':
                  string s16 = this.PopString(stack1);
                  string s17 = this.PopString(stack1);
                  double result21;
                  if (s16 == string.Empty)
                    s16 = this.FALSEVALUESTR;
                  else if (double.TryParse(s16, NumberStyles.Any, (IFormatProvider) null, out result21))
                    s16 = result21 != 0.0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  if (s17 == string.Empty)
                    s17 = this.FALSEVALUESTR;
                  else if (double.TryParse(s17, NumberStyles.Any, (IFormatProvider) null, out result21))
                    s17 = result21 != 0.0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  string str35 = s16.Length <= 0 || s16[0] != '#' || this.ErrorStrings.IndexOf((object) s16) <= -1 ? (s17.Length <= 0 || s17[0] != '#' || this.ErrorStrings.IndexOf((object) s17) <= -1 ? (s16.ToUpper().Replace(this.TIC, string.Empty) == this.TRUEVALUESTR && s17.ToUpper().Replace(this.TIC, string.Empty) != this.TRUEVALUESTR || s17.ToUpper().Replace(this.TIC, string.Empty) == this.TRUEVALUESTR && s16.ToUpper().Replace(this.TIC, string.Empty) != this.TRUEVALUESTR ? this.TRUEVALUESTR : this.FALSEVALUESTR) : s17) : s16;
                  stack1.Push((object) str35);
                  ++i;
                  continue;
                case '\u008A':
                  string s18 = this.PopString(stack1);
                  if (s18 == string.Empty)
                  {
                    s18 = this.FALSEVALUESTR;
                  }
                  else
                  {
                    double result22;
                    if (double.TryParse(s18, NumberStyles.Any, (IFormatProvider) null, out result22))
                      s18 = result22 != 0.0 ? this.TRUEVALUESTR : this.FALSEVALUESTR;
                  }
                  string str36 = s18.Length <= 0 || s18[0] != '#' || this.ErrorStrings.IndexOf((object) s18) <= -1 ? (s18.ToUpper().Replace(this.TIC, string.Empty) == this.FALSEVALUESTR ? this.TRUEVALUESTR : this.FALSEVALUESTR) : s18;
                  stack1.Push((object) str36);
                  ++i;
                  continue;
                default:
                  this.computedValueLevel = 0;
                  if (this.RethrowLibraryComputationExceptions)
                    throw new ArgumentException(this.FormulaErrorStrings[this.invalid_expression]);
                  return this.ErrorStrings[1].ToString();
              }
            }
          }
        }
      }
      if (this.checkDanglingStack && stack1.Count > 1 && formula.Length > 1)
      {
        string str37 = formula;
        ch = '\u0092';
        string str38 = ch.ToString();
        if (str37.StartsWith(str38))
        {
          string str39 = formula;
          ch = '\u0092';
          string str40 = ch.ToString();
          if (str39.EndsWith(str40) && formula.IndexOf(this.BMARKER2) <= -1)
            goto label_373;
        }
        this.computedValueLevel = 0;
        if (this.RethrowLibraryComputationExceptions)
          throw new Exception(this.FormulaErrorStrings[this.improper_formula]);
        return this.FormulaErrorStrings[this.improper_formula];
      }
label_373:
      if (stack1.Count == 0)
        return string.Empty;
      string s = string.Empty;
      int count = stack1.Count;
      do
      {
        if (stack1.Count > 1 && this.IsAreaCalculation)
        {
          s = CalcEngine.parseArgumentSeparator.ToString() + stack1.Pop().ToString() + s;
        }
        else
        {
          string str = stack1.Pop().ToString();
          if (this.ErrorStrings.Contains((object) str))
          {
            s = str;
            break;
          }
          s = str + s;
        }
        if (s == string.Empty && this.IsCellReference(formula) && this.treatStringsAsZero && !flag1)
          s = "0";
        if (!this.checkDanglingStack && double.TryParse(s, out double _))
          return s;
        if (s.Contains("~") && this.isDoubleQuotes)
        {
          s = s.Replace("~", this.TIC + this.TIC);
          this.isDoubleQuotes = false;
        }
        --count;
      }
      while (count > 0 && !s.Contains(this.FALSEVALUESTR) && !s.Contains(this.TRUEVALUESTR));
      if (s.Contains(this.TIC + this.TIC) && !s.Equals(this.TIC + this.TIC) && !this.multiTick)
        s = s.Replace(this.TIC + this.TIC, this.TIC);
      if (this.ErrorStrings.Contains((object) s) && this.RethrowLibraryComputationExceptions)
        throw new ArgumentException("bad formula");
      return s;
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      this.computedValueLevel = 0;
      if (ex.Message.IndexOf(this.FormulaErrorStrings[this.circular_reference_]) > -1 || this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
      {
        if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
          throw this.LibraryComputationException;
        throw ex;
      }
      if (ex.Message.IndexOf(this.FormulaErrorStrings[this.cell_empty]) > -1)
        return string.Empty;
      if (this.RethrowLibraryComputationExceptions)
      {
        this.libraryComputationException = ex;
        throw ex;
      }
      return ex.Message;
    }
    finally
    {
      --this.computedValueLevel;
      if (this.computedValueLevel < 0)
        this.computedValueLevel = 0;
    }
  }

  private string ProcessUpperCase(ref string formula, ref int i, ref string sheet)
  {
    string empty = string.Empty;
    while (i < formula.Length && (char.IsUpper(formula[i]) || formula[i] == ' '))
    {
      empty += (string) (object) formula[i];
      ++i;
    }
    while (i < formula.Length && char.IsDigit(formula[i]))
    {
      empty += (string) (object) formula[i];
      ++i;
    }
    string str;
    if (this.supportRangeOperands && i < formula.Length && formula[i] == ':')
    {
      string range = empty + (object) formula[i];
      ++i;
      if (i < formula.Length && formula[i] == '!')
      {
        range += (string) (object) formula[i];
        ++i;
        while (i < formula.Length && formula[i] != '!')
        {
          range += (string) (object) formula[i];
          ++i;
        }
      }
      while (i < formula.Length && char.IsUpper(formula[i]))
      {
        range += (string) (object) formula[i];
        ++i;
      }
      while (i < formula.Length && char.IsDigit(formula[i]))
      {
        range += (string) (object) formula[i];
        ++i;
      }
      str = !this.IsAreaCalculation ? (!this.ErrorStrings.Contains((object) this.GetCellFrom(range)) ? sheet + this.GetCellFrom(range) : this.GetCellFrom(range)) : sheet + range;
      sheet = string.Empty;
    }
    else
    {
      str = sheet + empty;
      sheet = string.Empty;
    }
    return str;
  }

  private void ComputeEnsureIFCall(ref string formula)
  {
    int num1 = 0;
    int num2 = -1;
    do
    {
      if (num1 < formula.Length && (num1 = formula.IndexOf(this.IFMarker, num1)) > -1)
      {
        num2 = this.MatchingRightBracket(formula.Substring(num1));
        if (num2 > -1)
        {
          CalcEngine.LibraryFunction libraryFunction = (CalcEngine.LibraryFunction) this.LibraryFunctions[(object) "IF"];
          string s = string.Empty;
          try
          {
            s = libraryFunction(formula.Substring(num1 + this.IFMarker.Length, num2 - this.IFMarker.Length));
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.RethrowLibraryComputationExceptions)
            {
              this.libraryComputationException = ex;
              throw ex;
            }
          }
          this.MarkupResultToIncludeInFormula(ref s);
          string str = string.Empty;
          if (num1 + num2 + 1 < formula.Length)
            str = formula.Substring(num1 + num2 + 1);
          formula = formula.Substring(0, num1) + s + str;
        }
      }
    }
    while (formula.Contains(this.IFMarker) && num2 > -1);
  }

  private void ComputeShortCircuitIFFormula(ref string formula)
  {
    int num1 = 0;
    int location1 = -1;
    do
    {
      if (num1 < formula.Length && (num1 = formula.IndexOf(this.IFMarker, num1)) > -1)
      {
        if (num1 != 0)
          this.ComputeInteriorFunctions(formula);
        else
          location1 = this.MatchingRightBracket(formula.Substring(num1));
        if (location1 > -1)
        {
          string s = string.Empty;
          formula.IndexOf(this.IFMarker, location1);
          try
          {
            int num2;
            do
            {
              location1 = num1;
              Hashtable strings = this.SaveStrings(ref formula);
              this.FindNextSeparator(formula, ref location1);
              string formula1 = formula.Substring(num1 + this.IFMarker.Length, location1 - this.IFMarker.Length - 1);
              List<string> stringList1 = new List<string>();
              int location2 = 0;
              while (location2 < formula1.Length)
              {
                if (this.FindNextSeparator(formula1, ref location2))
                {
                  stringList1.Add(formula1.Substring(0, location2));
                  formula1 = formula1.Substring(location2 + 1);
                  location2 = 0;
                }
                else if (location2 > 0)
                  stringList1.Add(formula1.Substring(0, location2));
              }
              string str = string.Empty;
              if (strings != null && strings.Count > 0)
              {
                List<string> stringList2 = new List<string>();
                int num3 = 0;
                foreach (string retValue in stringList1)
                {
                  this.SetStrings(ref retValue, strings);
                  if (this.IsArrayFormula)
                  {
                    str = num3 >= stringList1.Count - 1 ? str + retValue : $"{str}{retValue},";
                    ++num3;
                  }
                  stringList2.Add(retValue);
                }
                stringList1 = stringList2;
              }
              double result = 0.0;
              if (stringList1.Count == 0 && (stringList1.IndexOf(":") == -1 || stringList1.IndexOf(CalcEngine.parseArgumentSeparator.ToString()) == -1))
              {
                if (this.RethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.requires_3_args]);
                s = this.FormulaErrorStrings[this.requires_3_args];
              }
              if (!double.TryParse(stringList1[0], out result))
              {
                if (this.ErrorStrings.Contains((object) stringList1[0]))
                {
                  if (this.RethrowLibraryComputationExceptions)
                    throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                  s = stringList1[0];
                }
                if (!this.IsCellReference(stringList1[0]) && !bool.TryParse(stringList1[0].Replace(this.TIC, string.Empty), out bool _) && stringList1[0].StartsWith(this.TIC) || this.IsCellReference(stringList1[0]) && stringList1[0].StartsWith(this.TIC))
                {
                  if (this.RethrowLibraryComputationExceptions)
                    throw new ArgumentException(this.FormulaErrorStrings[this.bad_formula]);
                  s = this.ErrorStrings[1].ToString();
                }
              }
              if (this.IsArrayFormula && stringList1[0].IndexOf(':') > -1 && this.IsRange(stringList1[0]))
                s = this.ArrayParser.ComputeInteriorFunction(str, "IF", this.computeFunctionLevel);
              else if (stringList1.Count == 2 || stringList1.Count == 3)
              {
                if (stringList1[0].Contains("qINDEX"))
                {
                  this.isIndexInteriorFormula = true;
                  this.hitCount = this.computedValueLevel;
                }
                string valueFromArg = this.GetValueFromArg(stringList1[0]);
                if (this.hitCount == this.computedValueLevel)
                  this.isIndexInteriorFormula = false;
                if (valueFromArg == this.TRUEVALUESTR || double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result) && result != 0.0)
                {
                  s = this.GetValueFromArg(stringList1[1]);
                  if (string.IsNullOrEmpty(s) && this.TreatStringsAsZero)
                    s = "0";
                  else if (!string.IsNullOrEmpty(s) && (int) s[0] == (int) this.TIC[0] && !this.IsCellReference(stringList1[1]))
                    s = Regex.Replace(s, "^\"|\"$", "");
                }
                else if (stringList1.Count == 2 && (valueFromArg.Replace(this.TIC, string.Empty).ToUpper().Equals(this.FALSEVALUESTR) || double.TryParse(valueFromArg, NumberStyles.Any, (IFormatProvider) null, out result) && result == 0.0))
                {
                  s = this.FALSEVALUESTR;
                }
                else
                {
                  s = this.GetValueFromArg(stringList1[2]);
                  if (string.IsNullOrEmpty(s) && this.TreatStringsAsZero && this.computedValueLevel > 1)
                    s = "0";
                  else if (!string.IsNullOrEmpty(s) && (int) s[0] == (int) this.TIC[0] && !this.IsCellReference(stringList1[2]))
                  {
                    s = stringList1.Count == 3 ? s : this.FALSEVALUESTR;
                    s = Regex.Replace(s, "^\"|\"$", "");
                  }
                }
              }
              else
              {
                if (this.rethrowLibraryComputationExceptions)
                  throw new ArgumentException(this.FormulaErrorStrings[this.requires_3_args]);
                s = this.FormulaErrorStrings[this.requires_3_args];
              }
              num2 = formula.IndexOf(this.IFMarker, location1);
              if (!formula.Contains(this.IFMarker))
                break;
            }
            while (num2 > -1);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            if (this.RethrowLibraryComputationExceptions)
            {
              this.libraryComputationException = ex;
              throw ex;
            }
          }
          this.MarkupResultToIncludeInFormula(ref s);
          string str1 = string.Empty;
          if (num1 + location1 + 1 < formula.Length)
            str1 = formula.Substring(num1 + location1 + 1);
          formula = formula.Substring(0, num1) + s + str1;
        }
      }
    }
    while (formula.Contains(this.IFMarker) && location1 > -1);
  }

  internal string ComputeInteriorFunctions(string formula)
  {
    try
    {
      if (CalcEngine.TextIsEmpty(formula))
        return formula;
      ++this.computeFunctionLevel;
      for (int lastqNotInBrackets1 = this.FindLastqNotInBrackets(formula); lastqNotInBrackets1 > 0; lastqNotInBrackets1 = this.FindLastqNotInBrackets(formula))
      {
        int num = formula.Substring(lastqNotInBrackets1).IndexOf(this.RIGHTBRACKET);
        if (num == -1)
          return this.FormulaErrorStrings[this.bad_formula];
        string formula1 = formula.Substring(lastqNotInBrackets1, num + 1);
        int lastqNotInBrackets2 = this.FindLastqNotInBrackets(formula.Substring(0, lastqNotInBrackets1));
        string str1 = lastqNotInBrackets2 >= 0 ? formula.Substring(lastqNotInBrackets2, formula.Substring(lastqNotInBrackets2).IndexOf(this.RIGHTBRACKET)) : string.Empty;
        if ((formula1.Contains("qVALUE") || formula1.Contains("qINT") || formula1.Contains("qROW")) && str1.Contains("SUMPRODUCT"))
          this.exteriorFormula = true;
        if (str1.Contains("qINDEX") && (str1.Contains("qCELL") || str1.Contains("qCOUNT") || str1.Contains("qOFFSET")))
        {
          this.isIndexInteriorFormula = true;
          if (formula1.StartsWith("qINDEX"))
            this.hitCount = this.computedValueLevel + 1;
        }
        string s = this.ComputedValue(formula1);
        if (!string.IsNullOrEmpty(s) && (int) s[0] == (int) this.TIC[0] && (int) s[s.Length - 1] == (int) this.TIC[0])
        {
          string str2 = s.Substring(1, s.Length - 2);
          if (str2.IndexOf(this.TIC) != -1)
          {
            this.multiTick = true;
            str2 = str2.Replace(this.TIC, "|");
          }
          s = this.TIC + str2 + this.TIC;
        }
        if (!this.isInteriorFunction)
          this.MarkupResultToIncludeInFormula(ref s);
        this.isInteriorFunction = false;
        formula = formula.Substring(0, lastqNotInBrackets1) + s + formula.Substring(lastqNotInBrackets1 + num + 1);
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions && this.LibraryComputationException != null)
        throw this.LibraryComputationException;
      return ex.Message;
    }
    finally
    {
      --this.computeFunctionLevel;
    }
    return formula;
  }

  public string ComputeFormula(string parsedFormula)
  {
    if (this.throwCircularException)
    {
      if (this.iterationMaxCount > 0)
      {
        if (this.computedValueLevel == 0)
        {
          this.circCheckList.Clear();
          this.circCheckList.Add((object) this.cell);
        }
        else if (this.circCheckList.IndexOf((object) this.cell) > -1)
        {
          if (!this.IterationValues.ContainsKey((object) this.cell))
            this.IterationValues.Add((object) this.cell, (object) "0");
          return this.IterationValues[(object) this.cell].ToString();
        }
      }
      else
      {
        if (this.computedValueLevel == 0)
          this.circCheckList.Clear();
        else if (this.circCheckList.IndexOf((object) this.cell) > -1)
        {
          this.computedValueLevel = 0;
          this.circCheckList.Clear();
          throw new ArgumentException(this.FormulaErrorStrings[this.circular_reference_]);
        }
        this.circCheckList.Add((object) this.cell);
      }
    }
    string formula = this.ComputedValue(parsedFormula);
    if (this.UseNoAmpersandQuotes && formula.Length > 1 && (int) formula[0] == (int) this.TIC[0] && (int) formula[formula.Length - 1] == (int) this.TIC[0])
      formula = formula.Substring(1, formula.Length - 2);
    return formula;
  }

  public string PullUpdatedValue(string cellRef)
  {
    bool flag = false;
    this.inAPull = true;
    this.multiTick = false;
    ICalcData grid = this.grid;
    string cell = this.cell;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    string str = cellRef.ToUpper();
    int length;
    if ((length = str.IndexOf('!')) == -1 && this.cell != string.Empty)
    {
      int num = this.cell.IndexOf('!', 1);
      if (num > -1 && sheetFamilyItem.TokenToParentObject != null)
      {
        str = this.cell.Substring(0, num + 1) + str;
        this.grid = (ICalcData) sheetFamilyItem.TokenToParentObject[(object) this.cell.Substring(0, num + 1)];
      }
    }
    else if (length > 0 && sheetFamilyItem.SheetNameToToken != null && sheetFamilyItem.TokenToParentObject != null)
    {
      string key = sheetFamilyItem.SheetNameToToken[(object) str.Substring(0, length)] as string;
      str = key + str.Substring(length + 1);
      this.grid = (ICalcData) sheetFamilyItem.TokenToParentObject[(object) key];
      this.cell = str;
    }
    this.UpdateCalcID();
    string fromParentObject;
    if (!this.DependentFormulaCells.ContainsKey((object) str) && !this.FormulaInfoTable.ContainsKey((object) str))
    {
      fromParentObject = this.GetValueFromParentObject(str);
      while (this.breakedFormulaCells.Count == 1)
      {
        this.UpdateCalcID();
        fromParentObject = this.GetValueFromParentObject(this.breakedFormulaCells[0].ToString());
        this.breakedFormulaCells.RemoveAt(0);
        this.UseFormulaValues = true;
      }
      if (this.UseFormulaValues)
      {
        flag = true;
        this.UseFormulaValues = false;
      }
      if (this.tempBreakedFormulaCells.Count > 0)
      {
        for (int index = 1; index <= this.tempBreakedFormulaCells.Count; ++index)
          this.GetValueFromParentObject(this.tempBreakedFormulaCells[this.tempBreakedFormulaCells.Count - index].ToString());
        this.tempBreakedFormulaCells.Clear();
        fromParentObject = this.GetValueFromParentObject(str);
      }
      this.UseFormulaValues = flag;
      bool ignoreValueChanged = this.IgnoreValueChanged;
      this.IgnoreValueChanged = true;
      int row = this.RowIndex(str);
      int col = this.ColIndex(str);
      if (this.PreserveFormula)
      {
        if (this.SheetToken(cellRef).Equals(string.Empty))
        {
          if (this.FormulaInfoTable[(object) ($"!{(object) this.GetSheetID(this.grid)}!" + str)] is FormulaInfo formulaInfo)
            this.grid.SetValueRowCol((object) formulaInfo.FormulaText, row, col);
        }
        else
          this.grid.SetValueRowCol((object) fromParentObject, row, col);
      }
      else
        this.grid.SetValueRowCol((object) fromParentObject, row, col);
      this.IgnoreValueChanged = ignoreValueChanged;
    }
    else
    {
      this.processedCells.Clear();
      this.UpdateDependenciesAndCell(str);
      this.processedCells.Clear();
      fromParentObject = this.GetValueFromParentObject(str);
    }
    this.grid = grid;
    this.cell = cell;
    this.inAPull = false;
    return fromParentObject;
  }

  public void PullUpdatedValue(int targetSheetID, int row, int col)
  {
    ICalcData grid = this.grid;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
    string key = '!'.ToString() + targetSheetID.ToString() + (object) '!';
    this.grid = sheetFamilyItem.TokenToParentObject[(object) key] as ICalcData;
    this.inAPull = true;
    string str = key + RangeInfo.GetAlphaLabel(col) + row.ToString();
    this.UpdateCalcID();
    if (!this.DependentFormulaCells.ContainsKey((object) str) && !this.FormulaInfoTable.ContainsKey((object) str))
    {
      string fromParentObject = this.GetValueFromParentObject(str);
      bool ignoreValueChanged = this.IgnoreValueChanged;
      this.IgnoreValueChanged = true;
      this.grid.SetValueRowCol((object) fromParentObject, row, col);
      this.IgnoreValueChanged = ignoreValueChanged;
    }
    else
    {
      this.processedCells.Clear();
      this.UpdateDependenciesAndCell(str);
      this.processedCells.Clear();
    }
    this.grid = grid;
    this.inAPull = false;
  }

  internal void grid_ValueChanged(object sender, ValueChangedEventArgs e)
  {
    this.ExceptionThrown = false;
    if (this.IgnoreValueChanged)
      return;
    ICalcData calcData = sender as ICalcData;
    this.grid = sender as ICalcData;
    bool flag1 = true;
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(calcData);
    string str = RangeInfo.GetAlphaLabel(e.ColIndex) + e.RowIndex.ToString();
    if (sheetFamilyItem.SheetNameToParentObject != null && sheetFamilyItem.SheetNameToParentObject.Count > 0)
      str = (sheetFamilyItem.ParentObjectToToken[(object) calcData] as string) + str;
    if (e.Value.Length > 0 && (int) e.Value[0] == (int) CalcEngine.FormulaCharacter)
    {
      this.cell = str;
      bool flag2 = true;
      FormulaInfo formula1;
      if (this.FormulaInfoTable.ContainsKey((object) str))
      {
        formula1 = this.FormulaInfoTable[(object) str] as FormulaInfo;
        if (e.Value != formula1.FormulaText || formula1.ParsedFormula == null)
        {
          formula1.FormulaText = e.Value;
          if (this.DependentFormulaCells.ContainsKey((object) this.cell))
            this.ClearFormulaDependentCells(this.cell);
          try
          {
            formula1.ParsedFormula = this.ParseFormula(e.Value);
          }
          catch (Exception ex)
          {
            this.ExceptionThrown = true;
            formula1.FormulaValue = ex.Message;
            flag2 = false;
          }
        }
        if (flag2)
        {
          string formula2 = this.ComputeFormula(formula1.ParsedFormula);
          flag1 = formula2 != formula1.FormulaValue || this.forceRefreshCall;
          formula1.FormulaValue = formula2;
        }
        formula1.calcID = this.calcID;
      }
      else
      {
        formula1 = new FormulaInfo();
        formula1.FormulaText = e.Value;
        if (!this.DependentFormulaCells.ContainsKey((object) str))
          this.DependentFormulaCells.Add((object) str, (object) new Hashtable());
        try
        {
          formula1.ParsedFormula = this.ParseFormula(e.Value);
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          formula1.FormulaValue = ex.Message;
          flag2 = false;
        }
        if (flag2)
          formula1.FormulaValue = this.ComputeFormula(formula1.ParsedFormula);
        formula1.calcID = this.calcID;
        if (this.FormulaInfoTable.ContainsKey((object) str))
          this.FormulaInfoTable[(object) str] = (object) formula1;
        else
          this.FormulaInfoTable.Add((object) str, (object) formula1);
      }
      if (this.iterationMaxCount > 0 && flag2 && !this.inHandleIterations && str == this.cell)
        this.HandleIterations(formula1);
      bool ignoreValueChanged = this.IgnoreValueChanged;
      this.IgnoreValueChanged = true;
      calcData.SetValueRowCol((object) formula1.FormulaValue, e.RowIndex, e.ColIndex);
      this.IgnoreValueChanged = ignoreValueChanged;
    }
    else if (!this.inRecalculateRange && this.FormulaInfoTable.ContainsKey((object) str))
    {
      this.FormulaInfoTable.Remove((object) str);
      if (this.DependentFormulaCells.ContainsKey((object) str))
        this.ClearFormulaDependentCells(str);
    }
    if (!flag1 || !this.DependentCells.ContainsKey((object) str))
      return;
    this.dependencyLevel = 0;
    this.Refresh(str);
  }

  public void UpdateCalcID()
  {
    ++this.calcID;
    if (this.calcID != int.MaxValue)
      return;
    this.calcID = -2147483647 /*0x80000001*/;
  }

  public void Refresh(string s)
  {
    if (this.CalculatingSuspended)
      return;
    if (this.dependencyLevel == 0)
      this.refreshedCells.Clear();
    if (!this.DependentCells.ContainsKey((object) s) || this.DependentCells[(object) s] == null)
      return;
    ++this.dependencyLevel;
    try
    {
      GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
      ArrayList dependentCell = (ArrayList) this.DependentCells[(object) s];
      bool lockDependencies = this.lockDependencies;
      this.lockDependencies = true;
      foreach (object obj in dependentCell)
      {
        if (obj is string str)
        {
          ICalcData grid = this.grid;
          string key = this.SheetToken(str);
          if (key.Length > 0)
            this.grid = sheetFamilyItem.TokenToParentObject[(object) key] as ICalcData;
          try
          {
            int row = this.RowIndex(str);
            int col = this.ColIndex(str);
            if (this.FormulaInfoTable[(object) str] is FormulaInfo formulaInfo)
            {
              string cell = this.cell;
              this.cell = str;
              if (this.AlwaysComputeDuringRefresh || formulaInfo.calcID != this.calcID || formulaInfo.FormulaValue == string.Empty)
              {
                string formula = this.ComputeFormula(formulaInfo.ParsedFormula);
                if (formula != formulaInfo.FormulaValue && this.refreshedCells.ContainsKey((object) str))
                  this.refreshedCells.Remove((object) str);
                formulaInfo.FormulaValue = formula;
              }
              formulaInfo.calcID = this.calcID;
              this.cell = cell;
              bool ignoreValueChanged = this.IgnoreValueChanged;
              this.IgnoreValueChanged = true;
              this.grid.SetValueRowCol((object) formulaInfo.FormulaValue, row, col);
              this.IgnoreValueChanged = ignoreValueChanged;
              if (!this.refreshedCells.ContainsKey((object) str))
              {
                this.refreshedCells.Add((object) str, (object) 0);
                this.Refresh(str);
              }
            }
          }
          catch
          {
            continue;
          }
          this.grid = grid;
        }
      }
      this.lockDependencies = lockDependencies;
    }
    finally
    {
      if (!this.refreshedCells.ContainsKey((object) s))
        this.refreshedCells.Add((object) s, (object) 0);
      --this.dependencyLevel;
      if (this.dependencyLevel == 0)
        this.refreshedCells.Clear();
    }
  }

  public string ComputeDCount(string args)
  {
    int num = 0;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string str = strArray[1];
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][str.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            ++num;
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return num.ToString();
  }

  public string ComputeDCountA(string args)
  {
    int count;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      this.GetColumnName(strArray[1], dataFromArgs);
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable = new DataTable();
      count = this.BindResultTable(creteriaList, dataFromArgs).Rows.Count;
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return count.ToString();
  }

  public string ComputeDAverage(string args)
  {
    double num1;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string columnName = this.GetColumnName(strArray[1], dataFromArgs);
      if (strArray[0].Equals(strArray[2]))
      {
        string[] cellsFromArgs = this.GetCellsFromArgs(strArray[2]);
        int num2 = this.RowIndex(cellsFromArgs[0]);
        string alphaLabel = RangeInfo.GetAlphaLabel(this.ColIndex(cellsFromArgs[cellsFromArgs.Length - 1]));
        string str = $"{RangeInfo.GetAlphaLabel(1)}{num2 - 2}:{alphaLabel}{num2 - 2}";
        strArray[2] = str;
      }
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      int count = dataTable2.Rows.Count;
      double num3 = 0.0;
      for (int index = 0; index < dataTable2.Rows.Count; ++index)
      {
        double result = 0.0;
        if (double.TryParse(dataTable2.Rows[index][columnName.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
          num3 += result;
      }
      num1 = num3 / (double) count;
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return num1.ToString();
  }

  public string ComputeDGet(string args)
  {
    string empty = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string columnName = this.GetColumnName(strArray[1], dataFromArgs);
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      if (dataTable2.Rows.Count > 1)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.ErrorStrings[4].ToString());
        return this.ErrorStrings[4].ToString();
      }
      if (dataTable2.Rows.Count == 1)
        empty = dataTable2.Rows[0][columnName.Replace(this.TIC, string.Empty)].ToString();
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return empty;
  }

  public string ComputeDMax(string args)
  {
    string empty = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string str = strArray[1];
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      string range = "";
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][str.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            range = range + result.ToString() + (object) CalcEngine.ParseArgumentSeparator;
        }
        range = range.Remove(range.Length - 1);
      }
      return this.ComputeMax(range);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
  }

  public string ComputeDMin(string args)
  {
    string empty = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string str = strArray[1];
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      string range = "";
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][str.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            range = range + result.ToString() + (object) CalcEngine.ParseArgumentSeparator;
        }
        range = range.Remove(range.Length - 1);
      }
      return this.ComputeMin(range);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
  }

  public string ComputeDProduct(string args)
  {
    double num = 1.0;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string str = strArray[1];
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][str.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            num *= result;
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return num.ToString();
  }

  public string ComputeDVar(string args)
  {
    string empty = string.Empty;
    string range = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string str = strArray[1];
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][str.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            range = range + result.ToString() + (object) CalcEngine.ParseArgumentSeparator;
        }
        range = range.Remove(range.Length - 1);
      }
      return this.ComputeVar(range);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
  }

  public string ComputeDVarp(string args)
  {
    string empty = string.Empty;
    string range = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string str = strArray[1];
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][str.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            range = range + result.ToString() + (object) CalcEngine.ParseArgumentSeparator;
        }
        range = range.Remove(range.Length - 1);
      }
      return this.ComputeVarp(range);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
  }

  public string ComputeDStdev(string args)
  {
    string empty = string.Empty;
    string range = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string columnName = this.GetColumnName(strArray[1], dataFromArgs);
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][columnName.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            range = range + result.ToString() + (object) CalcEngine.ParseArgumentSeparator;
        }
        range = range.Remove(range.Length - 1);
      }
      return this.ComputeStdev(range);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
  }

  public string ComputeDStdevp(string args)
  {
    string empty = string.Empty;
    string range = string.Empty;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string str = strArray[1];
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][str.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            range = range + result.ToString() + (object) CalcEngine.ParseArgumentSeparator;
        }
        range = range.Remove(range.Length - 1);
      }
      return this.ComputeStdevp(range);
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
  }

  public string ComputeDSum(string args)
  {
    double num = 0.0;
    try
    {
      string[] strArray = this.SplitArgsPreservingQuotedCommas(args);
      if (strArray.Length < 3)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
        return this.FormulaErrorStrings[this.wrong_number_arguments];
      }
      DataTable dataFromArgs = this.GetDataFromArgs(strArray[0]);
      string str = strArray[1];
      StringBuilder stringBuilder = new StringBuilder();
      StringBuilder creteriaList = this.GenerateCreteriaList(strArray[2]);
      DataTable dataTable1 = new DataTable();
      DataTable dataTable2 = this.BindResultTable(creteriaList, dataFromArgs);
      if (dataTable2.Rows.Count > 0)
      {
        double result = 0.0;
        for (int index = 0; index < dataTable2.Rows.Count; ++index)
        {
          if (double.TryParse(dataTable2.Rows[index][str.Replace(this.TIC, string.Empty)].ToString(), NumberStyles.Any, (IFormatProvider) CultureInfo.CurrentUICulture, out result))
            num += result;
        }
      }
    }
    catch (Exception ex)
    {
      this.ExceptionThrown = true;
      if (this.rethrowLibraryComputationExceptions)
        throw ex;
      return ex.Message;
    }
    return num.ToString();
  }

  private string GetColumnName(string Field, DataTable dt)
  {
    int result = 0;
    if (int.TryParse(Field, out result))
      Field = dt.Columns[result - 1].ColumnName;
    return Field;
  }

  private DataTable BindResultTable(StringBuilder sb, DataTable dt)
  {
    DataTable dataTable1 = new DataTable();
    DataTable dataTable2 = dt.Clone();
    DataTable dataTable3 = new DataTable();
    DataTable dataTable4 = dt.Clone();
    double result = 0.0;
    if (this.isCriteriaIsNumber)
    {
      this.isCriteriaIsNumber = false;
      dataTable4.Columns[0].DataType = typeof (double);
    }
    foreach (DataRow row1 in (InternalDataCollectionBase) dt.Rows)
    {
      DataRow row2 = dataTable4.NewRow();
      if (double.TryParse(row1.ItemArray[0].ToString(), out result))
      {
        row2[0] = (object) result;
        dataTable4.Rows.Add(row2);
      }
    }
    if (dataTable4.Rows.Count > 0)
      dt = dataTable4;
    foreach (DataRow dataRow in dt.Select($"{sb}"))
    {
      object[] itemArray = dataRow.ItemArray;
      dataTable2.Rows.Add(itemArray);
    }
    return dataTable2;
  }

  private bool CheckOperands(string data)
  {
    string[] strArray = new string[3]{ "<", ">", "=" };
    for (int index = strArray.Length - 1; index >= 0; --index)
    {
      if (data.Substring(0, 1).IndexOf(strArray[index]) != -1)
        return true;
    }
    return false;
  }

  public DataTable GetDataFromArgs(string args)
  {
    DataTable dt = new DataTable("Table");
    this.MarkColonsInQuotes(ref args);
    int length = args.IndexOf(':');
    string oldValue = string.Empty;
    int startIndex = args.IndexOf('!');
    if (startIndex > -1)
    {
      int num = args.IndexOf('!', startIndex + 1);
      if (num > -1)
      {
        oldValue = args.Substring(startIndex, num - startIndex + 1);
        args = args.Replace(oldValue, string.Empty);
        length = args.IndexOf(':');
      }
    }
    if (length > 0 && char.IsLetter(args[length - 1]))
    {
      int num = this.rowMaxCount > 0 ? this.rowMaxCount : 50;
      if (this.grid is ISheetData)
        num = ((ISheetData) this.grid).GetLastRow();
      args = $"{args.Substring(0, length)}1:{args.Substring(length + 1)}{num.ToString()}";
      length = args.IndexOf(':');
    }
    else if (length > 0 && char.IsDigit(args[length - 1]))
    {
      int index = length - 2;
      while (index >= 0 && char.IsDigit(args[index]))
        --index;
      if (index == -1 || !char.IsLetter(args[index]))
      {
        int col = this.columnMaxCount > 0 ? this.columnMaxCount : 50;
        if (this.grid is ISheetData)
          col = ((ISheetData) this.grid).GetLastColumn();
        args = $"A{args.Substring(0, length)}:{RangeInfo.GetAlphaLabel(col)}{args.Substring(length + 1)}";
        length = args.IndexOf(':');
      }
    }
    this.CanGetRowIndex(args.Substring(0, length));
    int num1 = this.RowIndex(args.Substring(0, length));
    int num2 = this.RowIndex(args.Substring(length + 1, args.Length - length - 1));
    if (!(!num1.Equals(-1) || num2.Equals(-1)).Equals(num1.Equals(-1) || !num2.Equals(-1)))
      throw new ArgumentException(this.ErrorStrings[5].ToString());
    if (num1 == -1 && this.grid is ISheetData)
      num1 = ((ISheetData) this.grid).GetFirstRow();
    int num3 = this.ColIndex(args.Substring(0, length));
    if (num3 == -1 && this.grid is ISheetData)
      num3 = ((ISheetData) this.grid).GetFirstColumn();
    if (num2 == -1 && this.grid is ISheetData)
      num2 = ((ISheetData) this.grid).GetLastRow();
    int num4 = this.ColIndex(args.Substring(length + 1, args.Length - length - 1));
    if (num4 == -1 && this.grid is ISheetData)
      num4 = ((ISheetData) this.grid).GetLastColumn();
    if (num1 > num2)
    {
      int num5 = num2;
      num2 = num1;
      num1 = num5;
    }
    if (num3 > num4)
    {
      int num6 = num4;
      num4 = num3;
      num3 = num6;
    }
    string[] strArray = new string[(num2 - num1 + 1) * (num4 - num3 + 1)];
    int num7 = 0;
    for (int col = num3; col <= num4; ++col)
    {
      string valueFromArg = this.GetValueFromArg(oldValue + RangeInfo.GetAlphaLabel(col) + num1.ToString());
      if (string.IsNullOrEmpty(valueFromArg))
        valueFromArg = this.GetValueFromArg(oldValue + RangeInfo.GetAlphaLabel(col) + (num1 + 1).ToString());
      if (!dt.Columns.Contains(valueFromArg))
        dt.Columns.Add(valueFromArg);
    }
    for (int index = num1; index <= num2; ++index)
    {
      for (int col = num3; col <= num4; ++col)
      {
        try
        {
          strArray[num7++] = oldValue + RangeInfo.GetAlphaLabel(col) + index.ToString();
        }
        catch
        {
        }
      }
    }
    int index1 = num4;
    if (num3 != num4)
    {
      for (int index2 = 0; index2 < num2 - num1; ++index2)
      {
        DataRow row = dt.NewRow();
        dt.Rows.Add(row);
        for (int columnIndex = 0; columnIndex < num4; ++columnIndex)
        {
          dt.Rows[index2][columnIndex] = (object) this.GetValueFromArg(strArray[index1]).Trim();
          ++index1;
        }
      }
    }
    else if (num3 == num4)
    {
      int columnIndex = 0;
      int index3 = 0;
      for (int index4 = 0; index4 <= num2 - num1; ++index4)
      {
        DataRow row = dt.NewRow();
        dt.Rows.Add(row);
        dt.Rows[index4][columnIndex] = (object) this.GetValueFromArg(strArray[index3]).Trim();
        ++index3;
      }
    }
    DataTable dataTable = new DataTable();
    return this.ClonedTable(dt);
  }

  private DataTable ClonedTable(DataTable dt)
  {
    DataTable dataTable = new DataTable();
    for (int index1 = 0; index1 < dt.Columns.Count; ++index1)
    {
      bool flag1 = false;
      bool flag2 = false;
      bool flag3 = false;
      bool flag4 = false;
      bool flag5 = false;
      bool flag6 = false;
      for (int index2 = 0; index2 < dt.Rows.Count; ++index2)
      {
        string s = dt.Rows[index2][index1].ToString();
        if (int.TryParse(s, out int _) && !flag5 && !flag6 && !flag3 && !flag4 && !flag1)
          flag2 = true;
        else if (TimeSpan.TryParse(s, out TimeSpan _) && !flag5 && !flag2 && !flag3 && !flag4 && !flag1)
          flag6 = true;
        else if (DateTime.TryParse(s, out DateTime _) && !flag6 && !flag2 && !flag3 && !flag4 && !flag1)
        {
          flag6 = false;
          flag5 = true;
        }
        else if (double.TryParse(s, out double _) && !flag5 && !flag2 && !flag6 && !flag4 && !flag1)
        {
          flag2 = false;
          flag3 = true;
        }
        else if (Decimal.TryParse(s, out Decimal _) && !flag5 && !flag2 && !flag3 && !flag6 && !flag1)
        {
          flag2 = false;
          flag4 = true;
        }
        else
        {
          flag5 = false;
          flag2 = false;
          flag3 = false;
          flag6 = false;
          flag4 = false;
          flag1 = true;
        }
      }
      if (flag2 && !flag1)
        dataTable.Columns.Add(dt.Columns[index1].ColumnName, typeof (int));
      else if (flag6 && !flag1)
        dataTable.Columns.Add(dt.Columns[index1].ColumnName, typeof (TimeSpan));
      else if (flag5 && !flag1)
        dataTable.Columns.Add(dt.Columns[index1].ColumnName, typeof (DateTime));
      else if (flag3 && !flag1)
        dataTable.Columns.Add(dt.Columns[index1].ColumnName, typeof (double));
      else if (flag4 && !flag1)
        dataTable.Columns.Add(dt.Columns[index1].ColumnName, typeof (Decimal));
      else
        dataTable.Columns.Add(dt.Columns[index1].ColumnName, typeof (string));
    }
    foreach (DataRow row in (InternalDataCollectionBase) dt.Rows)
      dataTable.ImportRow(row);
    return dataTable;
  }

  private StringBuilder GenerateCreteriaList(string args)
  {
    this.MarkColonsInQuotes(ref args);
    int length = args.IndexOf(':');
    string str = string.Empty;
    int startIndex = args.IndexOf('!');
    if (startIndex > -1)
    {
      int num = args.IndexOf('!', startIndex + 1);
      if (num > -1)
      {
        str = args.Substring(startIndex, num - startIndex + 1);
        args = args.Replace(str, string.Empty);
        length = args.IndexOf(':');
      }
    }
    this.CanGetRowIndex(args.Substring(0, length));
    int row1 = this.RowIndex(args.Substring(0, length));
    int row2 = this.RowIndex(args.Substring(length + 1, args.Length - length - 1));
    if (!(!row1.Equals(-1) || row2.Equals(-1)).Equals(row1.Equals(-1) || !row2.Equals(-1)))
      throw new ArgumentException(this.ErrorStrings[5].ToString());
    if (row1 == -1 && this.grid is ISheetData)
      row1 = ((ISheetData) this.grid).GetFirstColumn();
    int col1 = this.ColIndex(args.Substring(0, length));
    if (col1 == -1 && this.grid is ISheetData)
      col1 = ((ISheetData) this.grid).GetFirstColumn();
    if (row2 == -1 && this.grid is ISheetData)
      row2 = ((ISheetData) this.grid).GetLastRow();
    int col2 = this.ColIndex(args.Substring(length + 1, args.Length - length - 1));
    if (col2 == -1 && this.grid is ISheetData)
      col2 = ((ISheetData) this.grid).GetLastColumn();
    if (row1 > row2)
    {
      int num = row2;
      row2 = row1;
      row1 = num;
    }
    if (col1 > col2)
    {
      int num = col2;
      col2 = col1;
      col1 = num;
    }
    int num1 = (row2 - row1 + 1) * (col2 - col1 + 1);
    return this.getCreteriaList_new(row1, row2, col1, col2, str);
  }

  internal StringBuilder getCreteriaList_new(
    int row1,
    int row2,
    int col1,
    int col2,
    string sheet)
  {
    StringBuilder creteriaListNew = new StringBuilder();
    for (int index = row1 + 1; index <= row2; ++index)
    {
      if (creteriaListNew.Length > 0)
        creteriaListNew.Append(" OR ");
      for (int col = col1; col <= col2; ++col)
      {
        string valueFromArg = this.GetValueFromArg(sheet + RangeInfo.GetAlphaLabel(col) + row1.ToString());
        string data = this.GetValueFromArg(sheet + RangeInfo.GetAlphaLabel(col) + index.ToString());
        if (!string.IsNullOrEmpty(data))
        {
          if (col > col1)
            creteriaListNew.Append(" AND ");
          if (!this.CheckOperands(data))
          {
            string s1 = data;
            if (data.Contains("="))
              s1 = s1.Replace("=", string.Empty);
            if (data.Contains(this.TIC))
              s1 = s1.Replace(this.TIC, string.Empty);
            double result = 0.0;
            if (double.TryParse(s1, out result))
              creteriaListNew.Append($"{valueFromArg}={data}");
            else if (s1.Contains("<") || s1.Contains(">"))
            {
              string s2 = s1.Substring(1);
              if (double.TryParse(s2, out result))
                this.isCriteriaIsNumber = true;
              string str = $"{(object) s1[0]}'{s2}'";
              creteriaListNew.Append($"{valueFromArg} {str}");
            }
            else
              creteriaListNew.Append($"{valueFromArg}='{s1.Replace("=", string.Empty)}'");
          }
          else
          {
            if (data.StartsWith("<") | data.StartsWith(">"))
            {
              double result = 0.0;
              string s = data.Substring(1);
              if (double.TryParse(s, out result))
                this.isCriteriaIsNumber = true;
              data = $"{(object) data[0]}'{s}'";
            }
            creteriaListNew.Append($"[{valueFromArg}] {data}");
          }
        }
      }
    }
    return creteriaListNew;
  }

  public string ComputeAcsch(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    if (strArray.GetLength(0) != 1)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (argList.StartsWith(this.TIC) && argList.EndsWith(this.TIC))
      argList = argList.Replace(this.TIC, string.Empty);
    if (argList == string.Empty)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
      return this.ErrorStrings[4].ToString();
    }
    if (this.ComputeIsNumber(argList) == this.TRUEVALUESTR)
    {
      string str = argList;
      if (Convert.ToDouble(str.Contains("u") ? str.Replace("u", string.Empty) : str) >= 134217728.0)
      {
        if (this.RethrowLibraryComputationExceptions)
          throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
        return this.ErrorStrings[4].ToString();
      }
      double result;
      if (double.TryParse(argList, out result))
        return Math.Log(((double) Math.Sign(result) * Math.Sqrt(result * result + 1.0) + 1.0) / result).ToString();
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
      return this.ErrorStrings[5].ToString();
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.invalid_Math_argument]);
    return this.ErrorStrings[5].ToString();
  }

  public string ComputeBigMul(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    argList = this.GetValueFromArg(argList);
    if (strArray.GetLength(0) != 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (argList.Contains(this.TIC))
      argList = argList.Replace(this.TIC, string.Empty);
    if (this.ComputeIsNumber(argList[0].ToString()) != this.TRUEVALUESTR && this.ComputeIsNumber(argList[1].ToString()) != this.TRUEVALUESTR)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[5].ToString();
    }
    if (argList.Length <= 150)
      return Math.BigMul(Convert.ToInt32(this.GetValueFromArg(strArray[0])), Convert.ToInt32(this.GetValueFromArg(strArray[1]))).ToString().ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[4].ToString());
    return this.ErrorStrings[4].ToString();
  }

  private long DivRem(long a, long b, out long divRem)
  {
    long num = a / b;
    divRem = a - b * num;
    return num;
  }

  public string ComputeDivRem(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (argList.Length > 15)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.ErrorStrings[4].ToString());
      return this.ErrorStrings[4].ToString();
    }
    int int32_1 = Convert.ToInt32(this.GetValueFromArg(strArray[0]));
    int int32_2 = Convert.ToInt32(this.GetValueFromArg(strArray[1]));
    long result = 0;
    result = Math.DivRem((long) int32_1, (long) int32_2, out result);
    return result.ToString();
  }

  public string ComputeIEEERemainder(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    if (strArray.GetLength(0) != 2)
    {
      if (this.RethrowLibraryComputationExceptions)
        throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    if (argList.Length <= 15)
      return Math.IEEERemainder(Convert.ToDouble(this.GetValueFromArg(strArray[0])), Convert.ToDouble(this.GetValueFromArg(strArray[1]))).ToString();
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[27].ToString());
    return this.ErrorStrings[4].ToString();
  }

  private double NormalCumulativeDistribution(double x, double mean, double standardDeviation)
  {
    return this.StandardNormalCumulativeDistribution((x - mean) / standardDeviation);
  }

  private double FCumulativeDistributionInverse(double p, int k1, int k2)
  {
    if (k1 <= 4 || k2 <= 4)
      throw new ArgumentException("k1 and k2 must be greater than 4.");
    if (p < 0.0 || p > 1.0)
      throw new ArgumentException("Probability must be between 0 and 1");
    if (p == 0.0)
      return 0.0;
    if (p == 1.0)
      return double.PositiveInfinity;
    double mean = (double) k2 / ((double) k2 - 2.0);
    double standardDeviation = (double) (2 * k2 * k2) * ((double) (k1 + k2) - 2.0) / ((double) k1 * ((double) k2 - 2.0) * ((double) k2 - 2.0) * ((double) k2 - 4.0));
    double num1 = Math.Max(0.0, this.NormalCumulativeDistributionInverse(p, mean, standardDeviation));
    double x = Math.Max(1E-05, k1 >= 10 || k2 >= 10 ? (k1 >= 10 ? (k2 >= 10 ? 0.8717865 * num1 + 0.9139534 * Math.Log(p) / Math.Sqrt((double) (k1 + k2)) - 0.0864391 / Math.Sqrt((double) (k1 + k2)) - 1.5438103 * Math.Log(p) / (double) k2 - 0.1495274 * Math.Log(p) / (double) k1 + 0.0004922 * (double) k2 - 0.0003965 * (double) k1 - 0.6362346 * p + 1.1776505 * p * p + 0.1039345 : 0.1944974 * num1 + 5.5846823 * Math.Log(p) / Math.Sqrt((double) (k1 + k2)) - 2.6254457 / Math.Sqrt((double) (k1 + k2)) - 0.7057866 * Math.Log(p) / (double) k2 - 6.4964935 * Math.Log(p) / (double) k1 + 0.0048548 * (double) k2 - 0.0088253 * (double) k1 - 6.523519381 * p + 6.710305803 * p * p + 3.305158009) : 0.8100214 * num1 + 3.1485113 * Math.Log(p) / Math.Sqrt((double) (k1 + k2)) - 5.6399235 / Math.Sqrt((double) (k1 + k2)) - 6.8494933 * Math.Log(p) / (double) k2 - 0.5725057 * Math.Log(p) / (double) k1 - 0.0102242 * (double) k2 - 0.0099565 * (double) k1 - 2.8208596 * p + 3.0360586 * p * p + 2.103689) : (p >= 0.03 ? 0.1819022 * num1 + 6.0340494 * Math.Log(p) / Math.Sqrt((double) (k1 + k2)) - 10.4102348 / Math.Sqrt((double) (k1 + k2)) - 3.8062818 * Math.Log(p) / (double) k2 - 2.1284338 * Math.Log(p) / (double) k1 - 0.0446516 * (double) k2 - 0.1014539 * (double) k1 - 7.980049829 * p + 7.988783845 * p * p + 6.864968931 : 0.1592355));
    double num2 = double.MaxValue;
    double num3 = 0.0;
    for (int index = 0; index < 16 /*0x10*/; ++index)
    {
      double num4 = this.FCumulativeDensity(x, k1, k2);
      double num5 = Math.Abs(p - num4);
      if (num5 < 0.0001)
        return x;
      if (num5 > num2)
      {
        x -= 0.5 * num3;
        num4 = this.FCumulativeDensity(x, k1, k2);
        num5 = Math.Abs(p - num4);
      }
      num2 = num5;
      double num6 = x;
      double num7 = this.FProbabilityDensity(x, k1, k2);
      num3 = (p - num4) / num7;
      if (num3 < -x)
        num3 = -0.5 * x;
      if (num3 > 1.0)
        num3 = 1.0;
      x += num3;
      if (x < 0.0)
        x = 0.5 * num6;
    }
    throw new Exception("Solution did not converge");
  }

  private double DerivativeOfFProbabilityDensity(double x, double k1, double k2, double pdf)
  {
    double num = k1 * k2 * (1.0 - x) / (k1 * x + k2);
    return pdf * (1.0 / x) * (0.5 * num - 1.0);
  }

  private double NormalCumulativeDistributionInverse(
    double p,
    double mean,
    double standardDeviation)
  {
    double num = this.StandardNormalCumulativeDistributionInverse(p);
    return standardDeviation * num + mean;
  }

  public string ComputeReplaceB(string argList)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(argList);
    int length = strArray.GetLength(0);
    int result1 = 0;
    int result2 = 0;
    if (length != 4)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    string str = this.StripTics0(this.GetValueFromArg(strArray[0]));
    string newValue = this.StripTics0(this.GetValueFromArg(strArray[3]));
    string empty1 = string.Empty;
    if (int.TryParse(this.GetValueFromArg(strArray[1]), out result1))
    {
      if (int.TryParse(this.GetValueFromArg(strArray[2]), out result2))
      {
        string replaceB;
        try
        {
          string empty2 = string.Empty;
          if (string.IsNullOrEmpty(str))
            return newValue;
          if (str.Length <= result1 && result1 > result2)
            replaceB = str + newValue;
          else if (str.Length <= result1)
          {
            string oldValue = str;
            replaceB = str.Replace(oldValue, newValue);
          }
          else
          {
            string oldValue = str.Substring(result1, result2);
            replaceB = str.Replace(oldValue, newValue);
          }
        }
        catch (Exception ex)
        {
          this.ExceptionThrown = true;
          if (this.RethrowLibraryComputationExceptions)
            throw ex;
          return this.ErrorStrings[1].ToString();
        }
        return replaceB;
      }
    }
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.FormulaErrorStrings[this.wrong_number_arguments]);
    return this.ErrorStrings[1].ToString();
  }

  public string ComputeBahtText(string arg)
  {
    string[] strArray = this.SplitArgsPreservingQuotedCommas(arg);
    if (strArray.Length > 1)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    double result = 0.0;
    if (double.TryParse(this.GetValueFromArg(strArray[0]), out result))
      return this.TranslateText(CalcEngine.Spell((int) result) + " baht", "en|th");
    if (this.RethrowLibraryComputationExceptions)
      throw new ArgumentException(this.ErrorStrings[3].ToString());
    return this.ErrorStrings[5].ToString();
  }

  public string ComputeLogest(string range)
  {
    string[] strArray1 = range.Split(CalcEngine.ParseArgumentSeparator);
    int length1 = strArray1.GetLength(0);
    bool flag = length1 == 1;
    if (length1 == 0 || length1 > 4)
    {
      string[] strArray2 = range.Split(this.TIC[0]);
      List<string> stringList = new List<string>();
      for (int index = 0; index < strArray2.Length; ++index)
      {
        if (index % 2 != 0)
          stringList.Add(strArray2[index]);
      }
      strArray1 = stringList.ToArray();
      length1 = strArray1.GetLength(0);
      flag = length1 == 1;
      if (length1 == 0 || length1 > 4)
        return this.FormulaErrorStrings[this.wrong_number_arguments];
    }
    double[] doubleArray = this.GetDoubleArray(strArray1[0]);
    double[] x = length1 <= 1 || !(strArray1[1] == string.Empty) ? (flag ? new double[doubleArray.GetLength(0)] : this.GetDoubleArray(strArray1[1])) : doubleArray;
    int length2 = x.GetLength(0);
    if (length2 <= 1)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    if (flag)
    {
      for (int index = 0; index < length2; ++index)
        x[index] = (double) (index + 1);
    }
    for (int index = 0; index < length2; ++index)
      doubleArray[index] = Math.Log10(doubleArray[index]);
    double m = 0.0;
    double b = 1.0;
    this.ComputeLogestMB(doubleArray, x, out m, out b);
    return m.ToString();
  }

  public string ComputeLogestb(string range)
  {
    string[] strArray = range.Split(CalcEngine.ParseArgumentSeparator);
    int length1 = strArray.GetLength(0);
    bool flag = length1 == 1;
    if (length1 == 0 || length1 > 4)
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    double[] doubleArray = this.GetDoubleArray(strArray[0]);
    double[] x = flag ? new double[doubleArray.GetLength(0)] : this.GetDoubleArray(strArray[1]);
    int length2 = x.GetLength(0);
    if (length2 <= 2 || length2 != doubleArray.GetLength(0))
      return this.FormulaErrorStrings[this.wrong_number_arguments];
    if (flag)
    {
      for (int index = 0; index < length2; ++index)
        x[index] = (double) (index + 1);
    }
    for (int index = 0; index < length2; ++index)
      doubleArray[index] = Math.Log10(doubleArray[index]);
    double m = 0.0;
    double b = 1.0;
    this.ComputeLogestMB(doubleArray, x, out m, out b);
    return b.ToString();
  }

  public static double[] MostRecentValues(double[] inArray, int length)
  {
    if (inArray.Length == length)
      return inArray;
    if (inArray.Length < length)
      throw new ArgumentException("length of inArray must be greater than or equal to length");
    double[] destinationArray = new double[length];
    Array.Copy((Array) inArray, (Array) destinationArray, length);
    return destinationArray;
  }

  public double Mean(double[] array, double decayFactor, int length)
  {
    return CalcEngine.Mean(CalcEngine.MostRecentValues(array, length), decayFactor);
  }

  public double WeightedMean(double[] valueArray, double[] weightArray)
  {
    if (valueArray.Length != weightArray.Length)
      throw new ArgumentException("valueArray and weightArray must have the same number of elements");
    double num1 = 0.0;
    double num2 = 0.0;
    for (int index = 0; index < valueArray.Length; ++index)
    {
      num1 += valueArray[index] * weightArray[index];
      num2 += weightArray[index];
    }
    return num1 / num2;
  }

  public static double UniformCumulativeDensityFunction(double x, double min, double max)
  {
    if (max <= min)
      throw new ArgumentException("max must be greater than min");
    return (x - min) / (max - min);
  }

  public static double HalfLifeOfGeometricSeries(double decayFactor, int length)
  {
    return length < 1 ? double.NaN : Math.Log(0.5 + 0.5 * Math.Pow(decayFactor, (double) length)) / Math.Log(decayFactor);
  }

  public static double SumOfGeometricSeries(double decayFactor, int length)
  {
    if (length < 1)
      return double.NaN;
    return decayFactor == 1.0 ? (double) length : (1.0 - Math.Pow(decayFactor, (double) length)) / (1.0 - decayFactor);
  }

  public static double SumOfInfiniteGeometricSeries(double decayFactor)
  {
    if (decayFactor >= 1.0)
      return double.PositiveInfinity;
    return decayFactor <= 1.0 ? double.NaN : 1.0 / (1.0 - decayFactor);
  }

  public double Covariance(double[] array1, double[] array2, double decayFactor)
  {
    if (array1.Length != array2.Length)
      throw new ArgumentException("Arrays must be the same length");
    int length = array1.Length;
    if (length == 1)
      return double.NaN;
    double num1 = 0.0;
    double num2 = 1.0;
    for (int index = 0; index < length; ++index)
    {
      num1 += num2 * array1[length - 1 - index] * array2[length - 1 - index];
      num2 *= decayFactor;
    }
    double num3 = CalcEngine.Mean(array1, decayFactor);
    double num4 = CalcEngine.Mean(array2, decayFactor);
    double num5 = CalcEngine.SumOfGeometricSeries(decayFactor, length);
    double num6 = CalcEngine.SumOfGeometricSeries(decayFactor * decayFactor, length);
    double num7 = num5 / (num5 * num5 - num6);
    double num8 = num5 * num7;
    return num7 * num1 - num8 * num3 * num4;
  }

  public void RefreshRange(RangeInfo range)
  {
    for (int top = range.Top; top <= range.Bottom; ++top)
    {
      for (int left = range.Left; left <= range.Right; ++left)
      {
        string str = RangeInfo.GetAlphaLabel(left) + top.ToString();
        this.dependencyLevel = 0;
        GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(this.grid);
        string key = '!'.ToString() + this.GetSheetID(this.grid).ToString() + (object) '!';
        if (sheetFamilyItem.TokenToParentObject != null && sheetFamilyItem.TokenToParentObject.Contains((object) key))
          this.grid = sheetFamilyItem.TokenToParentObject[(object) key] as ICalcData;
        this.Refresh(key + str);
      }
    }
  }

  public void ResetVariableNames()
  {
    if (this.variableNamesToTokens == null)
      return;
    this.variableNamesToTokens.Clear();
    this.variableNamesToTokens = (Hashtable) null;
    this.variableTokensToNames.Clear();
    this.variableTokensToNames = (Hashtable) null;
  }

  public void RegisterVariableNames(string[] list)
  {
    if (this.variableNamesToTokens == null)
    {
      this.variableNamesToTokens = new Hashtable();
      this.variableTokensToNames = new Hashtable();
    }
    foreach (string str in list)
    {
      string lower = str.Trim().ToLower();
      if (!this.variableNamesToTokens.ContainsKey((object) lower))
      {
        string key = "A" + (this.variableNamesToTokens.Count + 1).ToString();
        this.variableNamesToTokens.Add((object) lower, (object) key);
        this.variableTokensToNames.Add((object) key, (object) str);
      }
    }
  }

  private string ZapQuotedColons(string s)
  {
    int num;
    for (int index1 = s.IndexOf(this.TIC); index1 > -1; index1 = num)
    {
      num = s.Substring(index1 + 1).IndexOf(this.TIC);
      if (num > -1)
      {
        for (int index2 = s.Substring(index1 + 1).IndexOf(':'); index2 > -1 && index2 < num; index2 = s.Substring(index1 + 1).IndexOf(':'))
          s = $"{s.Substring(index2 + index1)} {s.Substring(index2 + index1 + 1)}";
      }
    }
    return s;
  }

  public string PlaceVariablenameTokensIntoFormula(string formula)
  {
    for (int index = formula.IndexOf(this.LEFTBRACKET); index > -1; index = formula.IndexOf(this.LEFTBRACKET))
    {
      int num = formula.IndexOf(this.RIGHTBRACKET, index);
      if (num <= -1)
        return string.Empty;
      string str1 = this.variableNamesToTokens[(object) formula.Substring(index + 1, num - 1).ToLower().Trim()].ToString();
      if (str1 == null)
        return string.Empty;
      string str2 = string.Empty;
      if (num < formula.Length - 1)
        str2 = formula.Substring(num + 1);
      formula = index <= 0 ? str1 + str2 : formula.Substring(0, index) + str1 + str2;
    }
    return formula;
  }

  private bool IsEqual(double d1, double d2) => Math.Abs(d1 - d2) < this.ABSOLUTEZERO;

  private string IsBlankOrVal(string args)
  {
    string valueFromArg = this.GetValueFromArg(args);
    return !valueFromArg.Equals(string.Empty) ? valueFromArg : this.TRUEVALUESTR;
  }

  public static double besseli1(double x)
  {
    double b0 = 0.0;
    double b1 = 0.0;
    double b2 = 0.0;
    double d = Math.Abs(x);
    double num;
    if (d <= 8.0)
    {
      double x1 = d / 2.0 - 2.0;
      CalcEngine.besselm1firstcheb(2.7779141127610464E-18, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -2.111421214358166E-17, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 1.5536319577362005E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -1.1055969477353862E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 7.6006842947354077E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -5.0421855047279118E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 3.2237933659455748E-13, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -1.9839743977649436E-12, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 1.1736186298890901E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -6.6634897235020271E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 3.6255902815521172E-10, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -1.8872497517228294E-09, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 9.3815373864957726E-09, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -4.4450591287963281E-08, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 2.0032947535521353E-07, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -8.5687202646954547E-07, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 3.4702513081376785E-06, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -1.3273163656039436E-05, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 4.7815651075500542E-05, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.00016176081582589674, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 0.00051228595616857576, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.0015135724506312532, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 0.0041564229443128882, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.010564084894626197, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 0.024726449030626516, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.052945981208094989, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 0.10264365868984709, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.17641651835783406, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 0.25258718644363365, ref b0, ref b1, ref b2);
      num = 0.5 * (b0 - b2) * d * Math.Exp(d);
    }
    else
    {
      double x2 = 32.0 / d - 2.0;
      CalcEngine.besselm1firstcheb(7.5172963108421052E-18, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 4.4143483230717077E-18, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -4.6503053684893586E-17, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -3.2095259219934238E-17, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 2.96262899764595E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 3.3082023109209285E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -1.8803547755107825E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -3.8144030724370075E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 1.0420276984128802E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 4.272440016711951E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -2.1015418427726643E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -4.0835511110921974E-13, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -7.1985517762459084E-13, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 2.0356285441470896E-12, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 1.4125807436613782E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 3.2526035830154884E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -1.8974958123505413E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -5.5897434621965838E-10, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -3.835380385964237E-09, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -2.6314688468895196E-08, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -2.5122362378702088E-07, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -3.8825648088776906E-06, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -0.00011058893876262371, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -0.0097610974913614687, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 0.77857623501828011, ref b0, ref b1, ref b2);
      num = 0.5 * (b0 - b2) * Math.Exp(d) / Math.Sqrt(d);
    }
    if (x < 0.0)
      num = -num;
    return num;
  }

  public static double besselk1(double x)
  {
    double b0 = 0.0;
    double b1 = 0.0;
    double b2 = 0.0;
    double d = 0.5 * x;
    double num1;
    if (x <= 2.0)
    {
      double x1 = x * x - 2.0;
      CalcEngine.besselm1firstcheb(-7.0238634793862882E-18, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -2.427449850519366E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -6.6669016941993295E-13, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -1.4114883926335278E-10, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -2.213387630734726E-08, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -2.4334061415659684E-06, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.0001730288957513052, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.0069757238596398641, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.12261118082265715, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, -0.35315596077654487, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x1, 1.5253002273389478, ref b0, ref b1, ref b2);
      double num2 = 0.5 * (b0 - b2);
      num1 = Math.Log(d) * CalcEngine.besseli1(x) + num2 / x;
    }
    else
    {
      double x2 = 8.0 / x - 2.0;
      CalcEngine.besselm1firstcheb(-5.7567444836650174E-18, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 1.7940508731475592E-17, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -5.6894625584428592E-17, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 1.8380935443666389E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -6.0570472483733185E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 2.0387031656243341E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -7.0198370904183138E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 2.4771544244813043E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -8.9767051823249939E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 3.3484196660784293E-13, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -1.2891739609510289E-12, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 5.13963967348173E-12, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -2.1299678384275683E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 9.2183151876050057E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -4.1903547593418965E-10, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 2.015049755197033E-09, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -1.0345762465678097E-08, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 5.7410841254500495E-08, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -3.5019606030878126E-07, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 2.406484947837217E-06, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -1.936197974166083E-05, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 0.00019521551847135162, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, -0.0028578168596227792, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 0.10392373657681724, ref b0, ref b1, ref b2);
      CalcEngine.besselm1nextcheb(x2, 2.7206261904844427, ref b0, ref b1, ref b2);
      double num3 = 0.5 * (b0 - b2);
      num1 = Math.Exp(-x) * num3 / Math.Sqrt(x);
    }
    return num1;
  }

  public static double besselk0(double x)
  {
    double b0 = 0.0;
    double b1 = 0.0;
    double b2 = 0.0;
    double num;
    if (x <= 2.0)
    {
      double x1 = x * x - 2.0;
      CalcEngine.besselmfirstcheb(1.374465435613523E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 4.25981614279661E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 1.0349695257633842E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 1.9045163772202091E-09, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 2.5347910790261494E-07, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 2.2862121031194519E-05, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.001264615411446926, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.0359799365153615, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, 0.3442898999246285, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x1, -0.53532739323390277, ref b0, ref b1, ref b2);
      num = 0.5 * (b0 - b2) - Math.Log(0.5 * x) * CalcEngine.besseli0(x);
    }
    else
    {
      double x2 = 8.0 / x - 2.0;
      CalcEngine.besselmfirstcheb(5.300433772686263E-18, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -1.6475804301524212E-17, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 5.2103915050390274E-17, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -1.678231096805412E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 5.5120559785243193E-16, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -1.8485933773437788E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 6.3400764774050706E-15, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -2.2275133269916698E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 8.0328907753635752E-14, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -2.9800969231727303E-13, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 1.140340588208475E-12, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -4.5145978833739441E-12, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 1.8559491149547177E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -7.957489244477107E-11, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 3.5773972814003009E-10, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -1.69753450938906E-09, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 8.5740340174142253E-09, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -4.6604898976879478E-08, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 2.7668136394450149E-07, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -1.8317555227191195E-06, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 1.39498137188765E-05, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -0.00012849549581627802, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 0.0015698838857300533, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, -0.0314481013119645, ref b0, ref b1, ref b2);
      CalcEngine.besselmnextcheb(x2, 2.4403030820659555, ref b0, ref b1, ref b2);
      num = 0.5 * (b0 - b2) * Math.Exp(-x) / Math.Sqrt(x);
    }
    return num;
  }

  private double[,] generateSubArray(double[,] a, int N, int j1)
  {
    double[,] subArray = new double[N - 1, 3];
    for (int index1 = 1; index1 < N; ++index1)
    {
      int index2 = 0;
      for (int index3 = 0; index3 < N; ++index3)
      {
        if (index3 != j1)
        {
          subArray[index1 - 1, index2] = a[index1, index3];
          ++index2;
        }
      }
    }
    return subArray;
  }

  public static string getBetween(string strSource, string strStart, string strEnd)
  {
    if (!strSource.Contains(strStart) || !strSource.Contains(strEnd))
      return "";
    int startIndex = strSource.IndexOf(strStart, 0) + strStart.Length;
    int num = strSource.IndexOf(strEnd, startIndex);
    return strSource.Substring(startIndex, num - startIndex);
  }

  public string GetFormulaRowCol(ICalcData grd, int row, int col)
  {
    GridSheetFamilyItem sheetFamilyItem = CalcEngine.GetSheetFamilyItem(grd);
    string key = RangeInfo.GetAlphaLabel(col) + row.ToString();
    if (sheetFamilyItem.SheetNameToParentObject != null)
      key = (sheetFamilyItem.ParentObjectToToken[(object) grd] as string) + key;
    if (!this.FormulaInfoTable.ContainsKey((object) key))
      return string.Empty;
    string formulaText = (this.FormulaInfoTable[(object) key] as FormulaInfo).FormulaText;
    this.GetFormulaText(ref formulaText);
    return formulaText;
  }

  public int GetCalcID() => this.calcID;

  private void Mark(
    ref string copy,
    ref string text,
    string op,
    char token,
    bool checkPrecedingChar)
  {
    int loc = 0;
    int num = checkPrecedingChar ? this.FindAndCheckPrecedingChar(ref copy, op, loc) : copy.IndexOf(op);
    int length = op.Length;
    for (; num > -1; num = checkPrecedingChar ? this.FindAndCheckPrecedingChar(ref copy, op, num) : copy.IndexOf(op, num))
    {
      copy = copy.Substring(0, num) + (object) token + copy.Substring(num + length);
      text = text.Substring(0, num) + (object) token + text.Substring(num + length);
    }
  }

  private void MarkIF(ref string copy, ref string text)
  {
    copy.IndexOf(this.ReservedWordOperators[this.reservedWord_IF]);
    int num1 = copy.IndexOf(this.ReservedWordOperators[this.reservedWord_THEN]);
    int num2 = copy.IndexOf(this.ReservedWordOperators[this.reservedWord_ELSE]);
    if (num2 > -1 && num1 > -1)
    {
      int length1 = this.ReservedWordOperators[this.reservedWord_IF].Length;
      int length2 = num1 - length1;
      int startIndex1 = num1 + this.ReservedWordOperators[this.reservedWord_THEN].Length;
      int length3 = num2 - startIndex1;
      int startIndex2 = num2 + this.ReservedWordOperators[this.reservedWord_ELSE].Length;
      int length4 = text.Length - startIndex2;
      text = string.Format("IF(({0}){3}({1}){3}({2}))", (object) text.Substring(length1, length2), (object) text.Substring(startIndex1, length3), (object) text.Substring(startIndex2, length4), (object) CalcEngine.ParseArgumentSeparator);
      copy = string.Format("IF(({0}){3}({1}){3}({2}))", (object) copy.Substring(length1, length2), (object) copy.Substring(startIndex1, length3), (object) copy.Substring(startIndex2, length4), (object) CalcEngine.ParseArgumentSeparator);
    }
    else
    {
      if (num1 <= -1)
        return;
      int startIndex3 = 0;
      int length5 = num1;
      int startIndex4 = num1 + this.ReservedWordOperators[this.reservedWord_THEN].Length;
      int length6 = text.Length - startIndex4 + 1;
      text = string.Format("IF(({0}){2}({1}))", (object) text.Substring(startIndex3, length5), (object) text.Substring(startIndex4, length6), (object) CalcEngine.ParseArgumentSeparator);
      copy = string.Format("IF(({0}){2}({1}))", (object) copy.Substring(startIndex3, length5), (object) copy.Substring(startIndex4, length6), (object) CalcEngine.ParseArgumentSeparator);
    }
  }

  private void MarkReserveWords(ref string text)
  {
    string lower = text.ToLower();
    if (lower.TrimStart().StartsWith(this.ReservedWordOperators[this.reservedWord_IF]))
      this.MarkIF(ref lower, ref text);
    this.Mark(ref lower, ref text, this.ReservedWordOperators[this.reservedWord_NOT], '\u0091', true);
    this.Mark(ref lower, ref text, this.ReservedWordOperators[this.reservedWord_OR], '\u008B', false);
    this.Mark(ref lower, ref text, this.ReservedWordOperators[this.reservedWord_AND], '\u008C', false);
    this.Mark(ref lower, ref text, this.ReservedWordOperators[this.reservedWord_XOR], '\u008D', false);
  }

  private int FindAndCheckPrecedingChar(ref string copy, string op, int loc)
  {
    int checkPrecedingChar = copy.IndexOf(op, loc);
    if (checkPrecedingChar > 0)
    {
      while (checkPrecedingChar > -1 && this.ValidPrecedingChars.IndexOf(copy[checkPrecedingChar - 1]) == -1)
        checkPrecedingChar = copy.IndexOf(op, checkPrecedingChar + 1);
    }
    return checkPrecedingChar;
  }

  private Stack CombineStack(string formula, int i, Stack _tempStack)
  {
    string str1 = string.Empty;
    if (_tempStack.Count == 2)
    {
      int num = 3;
      string str2 = formula.Substring(i);
      for (; num > 1; --num)
      {
        string str3 = _tempStack.Pop().ToString();
        str1 = str3.Equals(this.TIC + this.TIC) ? str1 + this.TIC : str3 + str1;
        str2 = num == 3 ? str3 : str2;
      }
      if (_tempStack.Peek().Equals((object) (this.TIC + this.TIC)))
        _tempStack.Pop();
      string str4 = formula.Length != i || !string.IsNullOrEmpty(str2.Replace(this.TIC, string.Empty)) ? str1 : str1 + str2;
      _tempStack.Push((object) str4);
    }
    return _tempStack;
  }

  public static void ResetSheetFamilyID()
  {
    CalcEngine.sheetFamilyID = 0;
    if (CalcEngine.modelToSheetID != null)
    {
      CalcEngine.modelToSheetID.Clear();
      CalcEngine.modelToSheetID = (Hashtable) null;
    }
    if (CalcEngine.sheetFamiliesList == null)
      return;
    CalcEngine.sheetFamiliesList.Clear();
    CalcEngine.sheetFamiliesList = (Hashtable) null;
    CalcEngine.ResetSheetIDs();
  }

  public static void ResetSheetIDs() => CalcEngine.TokenCount = 0;

  public string HandleIteration(string s, FormulaInfo formula)
  {
    if (this.FormulaInfoTable.ContainsKey((object) s))
      this.FormulaInfoTable[(object) s] = (object) formula;
    else
      this.FormulaInfoTable.Add((object) s, (object) formula);
    if (this.iterationMaxCount > 0 && s == this.cell)
      this.HandleIterations(formula);
    return formula.FormulaValue;
  }

  public Hashtable NamedRanges
  {
    get
    {
      if (this.namedRanges == null)
      {
        this.namedRanges = new Hashtable();
        this.namedRangesNonScoped = new Hashtable();
      }
      return this.namedRanges;
    }
    set
    {
      this.namedRanges = value;
      this.PopulateNamedRangesNonScoped();
    }
  }

  private void PopulateNamedRangesNonScoped()
  {
    if (this.namedRangesNonScoped == null)
      this.namedRangesNonScoped = new Hashtable();
    this.namedRangesNonScoped.Clear();
    foreach (string key in (IEnumerable) this.NamedRanges.Keys)
      this.CheckAddNonScopedNamedRange(key);
  }

  private void CheckAddNonScopedNamedRange(string key)
  {
    int num;
    if ((num = key.IndexOf('!')) <= -1)
      return;
    string key1 = key.Substring(num + 1);
    if (this.namedRangesNonScoped.ContainsKey((object) key1))
      return;
    this.namedRangesNonScoped.Add((object) key1, this.NamedRanges[(object) key]);
  }

  public bool AddNamedRange(string name, string range)
  {
    name = name.ToUpper(CultureInfo.InvariantCulture);
    if (this.NamedRanges[(object) name] != null)
      return false;
    this.NamedRanges.Add((object) name, (object) range);
    this.CheckAddNonScopedNamedRange(name);
    return true;
  }

  public bool RemoveNamedRange(string name)
  {
    name = name.ToUpper(CultureInfo.InvariantCulture);
    if (this.NamedRanges[(object) name] == null)
      return false;
    this.NamedRanges.Remove((object) name);
    this.PopulateNamedRangesNonScoped();
    return true;
  }

  internal void MarkNamedRanges(ref string argList)
  {
    argList.IndexOf(')');
    char[] anyOf = new char[13]
    {
      ')',
      CalcEngine.ParseArgumentSeparator,
      '}',
      '+',
      '-',
      '*',
      '/',
      '<',
      '>',
      '=',
      '&',
      ':',
      '%'
    };
    int num1 = 0;
    while (num1 < argList.Length - 1 && (argList[num1] == '(' || argList[num1] == '{'))
      ++num1;
    if (argList.IndexOf("#N/A") > -1)
      argList = argList.Replace("#N/A", "#N~A");
    if (argList.IndexOf("#DIV/0!") > -1)
      argList = argList.Replace("#DIV/0!", "#DIV~0!");
    int location = num1;
    if (argList.IndexOf("[") == -1 && !argList.StartsWith('!'.ToString()) || argList.Substring(num1).IndexOf("[") > argList.Substring(num1).IndexOfAny(anyOf))
      location = argList.Substring(num1).IndexOfAny(anyOf);
    else
      this.FindNextEndIndex(argList, ref location);
    while (location > -1 && location + num1 < argList.Length)
    {
      string formula = (string) null;
      string scopedRange = string.Empty;
      formula = this.CheckForNamedRange(argList.Substring(num1, location));
      if ((string.IsNullOrEmpty(formula) || !this.findNamedRange) && argList.Substring(num1, location).StartsWith('!'.ToString()))
      {
        int num2 = argList.Substring(num1, location).IndexOf('!', 1);
        if (num2 > 1 && !argList.Substring(num1, location + 1).Contains(":") && this.TryGetNamedRange(argList.Substring(num1).Substring(num2 + 1, location - num2 - 1), out scopedRange))
        {
          this.findNamedRange = true;
          formula = Convert.ToString(scopedRange);
        }
      }
      if (!string.IsNullOrEmpty(formula) && this.findNamedRange)
      {
        formula = this.CheckForNamedRange(formula);
        if (formula.Contains(CalcEngine.parseArgumentSeparator.ToString()) && this.errorFormula)
        {
          formula = formula.Replace(CalcEngine.parseArgumentSeparator, ':');
          this.errorFormula = false;
        }
        if (formula.StartsWith(this.BRACELEFT) && formula.EndsWith(this.BRACERIGHT))
        {
          formula = formula.Replace(this.BRACELEFT, this.TIC);
          formula = formula.Replace(this.BRACERIGHT, this.TIC);
        }
        this.MarkLibraryFormulas(ref formula);
      }
      if (!string.IsNullOrEmpty(formula))
      {
        argList = argList.Substring(0, num1) + formula + argList.Substring(num1 + location);
        num1 += formula.Length + 1;
      }
      else
      {
        num1 += location + 1;
        while (num1 < argList.Length && char.IsDigit(argList[num1]) && argList[num1] != '!')
          ++num1;
      }
      this.findNamedRange = false;
      if (num1 < argList.Length - 1 && (argList[num1] == '{' || argList[num1] == '('))
        ++num1;
      location = num1;
      if (argList.IndexOf("[") == -1 || argList.Substring(num1).IndexOf("[") > argList.Substring(num1).IndexOfAny(anyOf))
        location = argList.Substring(num1).IndexOfAny(anyOf);
      else
        this.FindNextEndIndex(argList, ref location);
      for (; location == 0 && num1 < argList.Length - 1; location = argList.Substring(num1).IndexOfAny(anyOf))
      {
        int startIndex = num1 + 1;
        num1 = startIndex + (argList.Substring(startIndex)[0] == '(' || argList.Substring(startIndex)[0] == '{' ? 1 : 0);
      }
      if ((location == -1 || argList.Substring(num1).Contains("[")) && num1 < argList.Length)
      {
        formula = this.CheckForNamedRange(argList.Substring(num1));
        if (!string.IsNullOrEmpty(formula) && this.findNamedRange)
        {
          this.findNamedRange = false;
          this.MarkLibraryFormulas(ref formula);
          if (formula != null)
          {
            argList = !argList.Substring(num1).EndsWith(")") ? argList.Substring(0, num1) + formula : $"{argList.Substring(0, num1)}{formula})";
            num1 += formula.ToString().Length + 1;
          }
        }
      }
    }
    if (this.errorFormula)
      this.errorFormula = false;
    if (argList.IndexOf("#N~A") > -1)
      argList = argList.Replace("#N~A", "#N/A");
    if (argList.IndexOf("#DIV~0!") <= -1)
      return;
    argList = argList.Replace("#DIV~0!", "#DIV/0!");
  }

  internal string GetTableRange(string text)
  {
    string tableRange = (string) null;
    string key = text.Replace("[#Data]", "");
    string scopedRange = string.Empty;
    string empty1 = string.Empty;
    if (key.IndexOf(CalcEngine.ParseArgumentSeparator) > -1 && !this.NamedRanges.ContainsKey((object) key))
    {
      key.Substring(0, key.IndexOf(CalcEngine.ParseArgumentSeparator));
      key = key.Replace(CalcEngine.ParseArgumentSeparator.ToString(), "");
    }
    string str1 = "";
    if (text.ToUpper().Contains("[#THIS ROW]"))
    {
      string str2 = key.EndsWith(")") ? key.Replace(")", "") : key;
      if (str2.Contains(":"))
      {
        string str3 = string.Empty;
        string[] strArray1 = str2.ToUpper().Split(new string[1]
        {
          "[#THIS ROW]"
        }, StringSplitOptions.None);
        string[] strArray2 = this.SplitArguments(strArray1[1], ':');
        for (int index = 0; index <= strArray2.Length - 1; ++index)
        {
          strArray2[index] = strArray1[0] + strArray2[index];
          if (this.TryGetNamedRange(strArray2[index].ToUpper().Replace("[#THIS ROW]", "").Replace("[[", "[").Replace("]]", "]"), out scopedRange))
          {
            this.findNamedRange = true;
            tableRange = Convert.ToString(scopedRange);
          }
          if (tableRange == null)
          {
            this.findNamedRange = false;
            return tableRange;
          }
          string upper = tableRange.ToUpper();
          this.PutTokensForSheets(ref upper);
          tableRange = upper.Replace("$", "");
          str3 = this.SheetToken(tableRange.Replace(this.TIC, string.Empty));
          str1 = index != strArray2.Length - 1 ? $"{str1}{this.GetCellFrom(tableRange)}:" : str1 + this.GetCellFrom(tableRange);
        }
        str1 = str3 + str1;
      }
      else
      {
        if (this.TryGetNamedRange(str2.ToUpper().Replace("[#THIS ROW]", "").Replace("[[", "[").Replace("]]", "]"), out scopedRange))
        {
          this.findNamedRange = true;
          tableRange = Convert.ToString(scopedRange);
        }
        if (tableRange == null)
        {
          this.findNamedRange = false;
          return tableRange;
        }
        string upper = tableRange.ToUpper();
        int num = this.RowIndex(this.cell);
        string text1 = upper.Replace("$", "");
        this.PutTokensForSheets(ref text1);
        int rowIndexFromRange = this.GetTopRowIndexFromRange(text1);
        str1 = this.GetCellsFromArgs(text1)[num - rowIndexFromRange];
      }
    }
    else
    {
      if (key.EndsWith("["))
        key = key.Replace("[", "");
      string str4 = key.EndsWith(")") ? key.Replace(")", "") : key;
      if (str4.Contains("[#Totals]") || str4.Contains("#ALL") || str4.Contains("[#Headers]") || str4.Contains("[#Data]"))
        str4 = str4.Replace("#", "");
      if (this.TryGetNamedRange(str4.ToUpper(), out scopedRange))
      {
        this.findNamedRange = true;
        str1 = Convert.ToString(scopedRange);
      }
      if (str4.Contains(":") && str4.EndsWith("]") && string.IsNullOrEmpty(str1))
      {
        string str5 = string.Empty;
        string empty2 = string.Empty;
        int index1 = 0;
        if (!str4[index1].Equals('['))
        {
          for (; !str4[index1].Equals('['); ++index1)
            empty2 += (string) (object) text[index1];
        }
        if (this.NamedRanges.ContainsKey((object) empty2))
        {
          string str6 = empty2 + "[";
          string[] strArray = this.SplitArguments(str4.Substring(index1 + 1), ':');
          for (int index2 = 0; index2 <= strArray.Length - 1; ++index2)
          {
            strArray[index2] = str6 + strArray[index2];
            if (this.TryGetNamedRange(strArray[index2].ToUpper().Replace("[[", "[").Replace("]]", "]"), out scopedRange))
            {
              this.findNamedRange = true;
              tableRange = Convert.ToString(scopedRange);
            }
            if (tableRange == null)
            {
              this.findNamedRange = false;
              return tableRange;
            }
            string upper = tableRange.ToUpper();
            this.PutTokensForSheets(ref upper);
            tableRange = upper.Replace("$", "");
            str5 = this.SheetToken(tableRange.Replace(this.TIC, string.Empty));
            string[] cellsFromArgs = this.GetCellsFromArgs(tableRange);
            str1 = index2 != strArray.Length - 1 ? $"{str1}{$"{RangeInfo.GetAlphaLabel(this.ColIndex(cellsFromArgs[0]))}{this.RowIndex(cellsFromArgs[0])}"}:" : str1 + $"{RangeInfo.GetAlphaLabel(this.ColIndex(cellsFromArgs[cellsFromArgs.Length - 1]))}{this.RowIndex(cellsFromArgs[cellsFromArgs.Length - 1])}";
          }
          str1 = str5 + str1;
        }
      }
      if (string.IsNullOrEmpty(str1))
      {
        this.findNamedRange = false;
        return (string) null;
      }
    }
    return str1.ToUpper();
  }

  internal int GetTopRowIndexFromRange(string range)
  {
    this.MarkColonsInQuotes(ref range);
    int length = range.IndexOf(':');
    if (length == -1)
      return this.RowIndex(range);
    string empty = string.Empty;
    int startIndex = range.IndexOf('!');
    if (startIndex > -1)
    {
      int num = range.IndexOf('!', startIndex + 1);
      if (num > -1)
      {
        string oldValue = range.Substring(startIndex, num - startIndex + 1);
        range = range.Replace(oldValue, string.Empty);
        length = range.IndexOf(':');
      }
    }
    return this.RowIndex(range.Substring(0, length));
  }

  internal string CheckForNamedRange(string text)
  {
    string scopedRange = string.Empty;
    bool flag = false;
    if (text.Contains("!") && (text.Contains("[") && text.Contains("]") || this.CheckHasExternalWorkbook(text)) && this.UpdateExternalFormula != null)
    {
      UpdateExternalFormulaEventArgs e = new UpdateExternalFormulaEventArgs(text);
      this.UpdateExternalFormula((object) this, e);
      if (e.IsFormulaUpdated)
      {
        text = e.parsedFormula;
        this.findNamedRange = true;
        flag = true;
      }
    }
    if (text.Contains("[") && (!text.Contains("]") || !text.Contains("!")))
    {
      string tableRange = this.GetTableRange(text);
      if (tableRange != null)
      {
        this.findNamedRange = true;
        flag = true;
        text = tableRange;
      }
    }
    else if (this.TryGetNamedRange(text.ToUpper().Replace("'", string.Empty), out scopedRange))
    {
      this.findNamedRange = true;
      flag = true;
      text = scopedRange;
    }
    else if (this.NamedRanges.Count > 0 && !string.IsNullOrEmpty(text.Trim()) && this.UpdateNamedRange != null)
    {
      UpdateNamedRangeEventArgs e = new UpdateNamedRangeEventArgs(text);
      this.UpdateNamedRange((object) this, e);
      if (e.IsFormulaUpdated)
      {
        this.findNamedRange = true;
        flag = true;
        text = e.Address;
        text = text.ToUpper();
      }
    }
    if (!flag && this.findNamedRange)
      this.findNamedRange = false;
    if (this.findNamedRange)
    {
      if (!text.StartsWith('!'.ToString()) && !text.StartsWith("q") && !text.StartsWith("bq"))
        this.PutTokensForSheets(ref text);
      if (text.Contains("$"))
      {
        if (this.IsCellReference(text.Replace("$", "")) && !text.Contains(":"))
        {
          string str1 = string.Empty;
          string oldValue = this.SheetToken(text.Replace(this.TIC, string.Empty));
          if (!string.IsNullOrEmpty(oldValue))
            text = text.Replace(oldValue, string.Empty);
          if (text.Split('$').Length > 2)
            return oldValue + text.Replace("$", "");
          string empty = string.Empty;
          int num = 0;
          int col = 0;
          if (this.cell != string.Empty)
          {
            num = this.RowIndex(this.cell);
            col = this.ColIndex(this.cell);
          }
          if (text.StartsWith("$"))
          {
            string str2 = str1 + (object) text[0];
            for (int index = 1; index < text.Length; ++index)
            {
              if (index < text.Length && char.IsLetter(text[index]))
                str2 += (string) (object) text[index];
              else if (index < text.Length && char.IsDigit(text[index]))
                empty += (string) (object) text[index];
            }
            string str3 = num.ToString();
            str1 = str2 + str3;
          }
          else
          {
            for (int index = 0; index < text.Length; ++index)
            {
              if (index < text.Length && char.IsLetter(text[index]))
              {
                empty += (string) (object) text[index];
              }
              else
              {
                if (index < text.Length && text[index] == '$')
                {
                  empty = RangeInfo.GetAlphaLabel(col).ToString();
                  str1 = str1 + empty + (object) text[index];
                }
                if (index < text.Length && char.IsDigit(text[index]))
                  str1 += (string) (object) text[index];
              }
            }
          }
          text = oldValue + str1;
        }
        text = text.Replace("$", "");
      }
    }
    return text;
  }

  private bool CheckIfNameRangesIntersect(string formula, out string finalValue)
  {
    string str = string.Empty;
    string scopedRange = string.Empty;
    if (this.NamedRanges != null && formula.Contains(" ") && this.NamedRanges.Count > 0 && !formula.Contains("[") && !formula.Contains(this.TIC + this.TIC))
    {
      bool flag = false;
      if (formula.Contains(this.TIC))
      {
        flag = true;
        string[] strArray = formula.Split(new string[1]
        {
          this.TIC
        }, StringSplitOptions.RemoveEmptyEntries);
        for (int index = 0; index < strArray.Length; ++index)
        {
          if (this.TryGetNamedRange(strArray[index].ToUpper(), out scopedRange))
            flag = false;
          str = index != strArray.Length - 1 ? str + strArray[index] + this.TIC : str + strArray[index];
        }
        finalValue = str;
      }
      if (!flag)
      {
        string Name = string.Empty;
        string empty1 = string.Empty;
        string empty2 = string.Empty;
        string[] strArray = formula.Split(new string[1]
        {
          " "
        }, StringSplitOptions.RemoveEmptyEntries);
        for (int index1 = 0; index1 < strArray.Length; ++index1)
        {
          if (this.TryGetNamedRange(strArray[index1].ToUpper(), out scopedRange))
            strArray[index1] = scopedRange.ToUpper();
          else if (strArray[index1].StartsWith("q") && strArray[index1].EndsWith(this.RIGHTBRACKET.ToString()))
            strArray[index1] = this.ComputedValue(strArray[index1]);
          else if (strArray[index1].Contains(":") && strArray[index1].IndexOfAny(this.tokens) == -1)
          {
            strArray[index1] = strArray[index1];
          }
          else
          {
            int index2 = 0;
            strArray[index1] = strArray[index1].Replace('\u0092'.ToString(), string.Empty);
            string oldValue = this.SheetToken(strArray[index1]);
            if (oldValue != string.Empty)
              strArray[index1] = strArray[index1].Replace(oldValue, string.Empty);
            while (index2 < strArray[index1].Length && ((char.IsDigit(strArray[index1][index2]) | strArray[index1][index2] == ':' ? 1 : 0) | (index2 == 0 || !this.IsUpper(strArray[index1][index2]) ? 0 : (!char.IsDigit(strArray[index1][index2 - 1]) ? 1 : 0)) | (index2 == 0 || strArray[index1][index2] != '!' ? 0 : (!char.IsDigit(strArray[index1][index2 - 1]) ? 1 : 0)) | (index2 != 0 ? 0 : (this.IsUpper(strArray[index1][index2]) ? 1 : 0))) != 0)
              empty2 += (string) (object) strArray[index1][index2++];
            while (index2 != strArray[index1].Length && strArray[index1][index2] == '"' | char.IsLetter(strArray[index1][index2]) | char.IsDigit(strArray[index1][index2]))
              empty1 += (string) (object) strArray[index1][index2++];
            strArray[index1] = oldValue + empty2;
          }
          Name = index1 != strArray.Length - 1 ? $"{Name}{strArray[index1]} " : Name + strArray[index1];
        }
        UpdateNamedRangeEventArgs e = new UpdateNamedRangeEventArgs(Name);
        if (this.UpdateNamedRange != null)
        {
          this.UpdateNamedRange((object) this, e);
          if (e.IsFormulaUpdated)
          {
            string text = e.Address.Replace("$", "").ToUpper();
            this.PutTokensForSheets(ref text);
            if (!this.findRangeIfIntersect)
            {
              text = this.GetValueFromParentObject(text);
              finalValue = !(empty1 != string.Empty) || !(text == string.Empty) ? (!(empty1 != string.Empty) ? (!(text == string.Empty) ? text : "0") : this.ComputedValue(text + empty1)) : this.ComputedValue("0" + empty1);
            }
            else
              finalValue = text;
            return true;
          }
        }
      }
    }
    finalValue = string.Empty;
    return false;
  }

  private bool FindNextEndIndex(string formula, ref int location)
  {
    int num = 0;
    char[] anyOf = new char[13]
    {
      ')',
      CalcEngine.ParseArgumentSeparator,
      '}',
      '+',
      '-',
      '*',
      '/',
      '<',
      '>',
      '=',
      '&',
      ':',
      '%'
    };
    int startIndex = location;
    bool nextEndIndex = false;
    if (formula.Substring(startIndex).IndexOf('[') > -1 && formula.Substring(startIndex).IndexOf(']') > -1)
    {
      while (!nextEndIndex && location < formula.Length)
      {
        if (formula[location] == '[')
          ++num;
        else if (formula[location] == ']')
        {
          --num;
          if (num == 0)
          {
            nextEndIndex = true;
            if (this.UpdateExternalFormula != null && location + 1 < formula.Length && formula[location + 1].Equals('!'))
              location += formula.Substring(location + 1).IndexOfAny(anyOf);
          }
        }
        ++location;
      }
    }
    else
      location += formula.Substring(startIndex).IndexOfAny(anyOf);
    location -= startIndex;
    return nextEndIndex;
  }

  private class LookUps
  {
    private List<string> _linearLookUpList;
    private Dictionary<string, int> _matchLookUpList;

    public List<string> LinearLookUpList
    {
      get => this._linearLookUpList;
      set => this._linearLookUpList = value;
    }

    public Dictionary<string, int> MatchLookUpList
    {
      get => this._matchLookUpList;
      set => this._matchLookUpList = value;
    }
  }

  private delegate double MathFunc(double d);

  public delegate string LibraryFunction(string args);

  [Flags]
  private enum FormulaArgumentType
  {
    None = 0,
    Range = 1,
    TwoTextWithNumber = 2,
    TextWithNumber = TwoTextWithNumber | Range, // 0x00000003
    Numbers = 4,
    Text = Numbers | Range, // 0x00000005
    Date = Numbers | TwoTextWithNumber, // 0x00000006
  }

  private class LenComparer : IComparer
  {
    public int Compare(object x, object y) => y.ToString().Length - x.ToString().Length;
  }
}
