// Decompiled with JetBrains decompiler
// Type: Patagames.Pdf.Pdfium
// Assembly: Patagames.Pdf, Version=9.68.38.462, Culture=neutral, PublicKeyToken=60fd6cf9b15941cf
// MVID: 6A4C4B5C-8C74-4D04-A848-779C64CD849D
// Assembly location: D:\PDFGear\bin\Patagames.Pdf.dll
// XML documentation location: D:\PDFGear\bin\Patagames.Pdf.xml

using Patagames.Activation;
using Patagames.Pdf.Enums;
using Patagames.Pdf.Net.Exceptions;
using Patagames.Pdf.Properties;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Reflection;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

#nullable disable
namespace Patagames.Pdf;

/// <summary>
/// Represents low level API to get access to Pdfium engine.
/// </summary>
public static class Pdfium
{
  internal const string PdfiumModuleName = "pdfium";
  private static PointerManagerItem<UNSUPPORT_INFO> _unsupportedHandler = (PointerManagerItem<UNSUPPORT_INFO>) null;
  private static PointerManagerItem<FPDF_SYSFONTINFO> _setfontStructure = (PointerManagerItem<FPDF_SYSFONTINFO>) null;
  private static object _syncInit = new object();
  private static object _syncDefEnc = new object();
  private static volatile bool _isInitializes = false;
  private static volatile Assembly _licensedAssembly = (Assembly) null;
  private static Encoding _defEnc = Encoding.Default;
  private static Dictionary<IntPtr, IntPtr> _interforms = new Dictionary<IntPtr, IntPtr>();
  private static Pdfium.ManagedCallbackDelegate ManagedCallback = (Pdfium.ManagedCallbackDelegate) null;
  private static NoLicenseException _noLicense = (NoLicenseException) null;

  private static bool _isx64 => IntPtr.Size == 8;

  internal static Exception ProcessLastError(uint code)
  {
    switch (code)
    {
      case 1:
        return (Exception) new UnknownErrorException();
      case 2:
        return (Exception) new PdfFileNotFoundException();
      case 3:
        return (Exception) new BadFormatException();
      case 4:
        return (Exception) new InvalidPasswordException();
      case 5:
        return (Exception) new UnsupportedSecuritySchemeException();
      case 6:
        return (Exception) new PageNotFoundException();
      case 126:
        return (Exception) new PageNotFoundException();
      case 536870913 /*0x20000001*/:
        return (Exception) new ImageObjectIsEmptyException();
      case 536870914 /*0x20000002*/:
        return (Exception) new NoLicenseException(code, Error.TrialLoadDocument);
      case 536870915 /*0x20000003*/:
        return (Exception) new NoLicenseException(code, Error.errLicense1);
      case 536870916 /*0x20000004*/:
        return (Exception) new NoLicenseException(code, Error.errLicense2);
      case 536870917 /*0x20000005*/:
        return (Exception) new NoLicenseException(code, Error.errLicense3);
      case 536871168 /*0x20000100*/:
        return (Exception) new InvalidLicenseKeyException();
      case 536871169 /*0x20000101*/:
        return (Exception) new LicenseKeyIsExpiredException();
      case 536871170 /*0x20000102*/:
        return (Exception) new LicenseKeyIsOutOfDateException();
      case 536871171 /*0x20000103*/:
        return (Exception) new NoLicenseException(code, Error.errLicensePlatform);
      case 536871424 /*0x20000200*/:
        return (Exception) new UnknownFunctionTypeException();
      case 536871425 /*0x20000201*/:
        return (Exception) new InvalidFunctionException();
      case 536871427 /*0x20000203*/:
        return (Exception) new RequiredDataIsAbsentException();
      default:
        return (Exception) new PdfiumException(code, Error.err0019);
    }
  }

  internal static Exception ProcessLastError()
  {
    throw Pdfium.ProcessLastError(Pdfium.FPDF_GetLastError());
  }

  static Pdfium()
  {
    Pdfium.ManagedCallback = new Pdfium.ManagedCallbackDelegate(Pdfium.ManagedCallbackFunc);
  }

  [MonoPInvokeCallback(typeof (Pdfium.ManagedCallbackDelegate))]
  private static void ManagedCallbackFunc(int level, string pcode)
  {
    Exception exception = Pdfium.ProcessLastError(Pdfium.FPDF_GetLastError());
    if (!(exception is NoLicenseException))
      return;
    Pdfium._noLicense = exception as NoLicenseException;
  }

  private static IntPtr PLE(IntPtr handle)
  {
    Pdfium.PLE();
    return handle;
  }

  private static bool PLE(bool val)
  {
    Pdfium.PLE();
    return val;
  }

  private static void PLE()
  {
    if (Pdfium._noLicense != null)
      throw Pdfium._noLicense;
  }

  internal static bool GetEnumDescription<T>(string attribute, out T result)
  {
    foreach (FieldInfo field in typeof (T).GetFields())
    {
      DescriptionAttribute[] customAttributes = (DescriptionAttribute[]) field.GetCustomAttributes(typeof (DescriptionAttribute), false);
      if (customAttributes != null && customAttributes.Length != 0 && customAttributes[0].Description.ToLower() == attribute.ToLower())
      {
        result = (T) Enum.Parse(typeof (T), field.Name);
        return true;
      }
    }
    result = default (T);
    return false;
  }

  internal static string GetEnumDescription(Enum value)
  {
    FieldInfo field = value.GetType().GetField(value.ToString());
    if (field == (FieldInfo) null)
      return (string) null;
    DescriptionAttribute[] customAttributes = (DescriptionAttribute[]) field.GetCustomAttributes(typeof (DescriptionAttribute), false);
    return customAttributes != null && customAttributes.Length != 0 ? customAttributes[0].Description : value.ToString();
  }

  /// <summary>Enable multithread lock.</summary>
  /// <param name="bEnable">true or false</param>
  public static void EnableLock(bool bEnable)
  {
    using (Lock syncMt = Lock.SyncMT)
      syncMt.IsEnabled = bEnable;
  }

  private static void CheckForInit()
  {
    if (Pdfium._isInitializes)
      return;
    lock (Pdfium._syncInit)
    {
      if (Pdfium._isInitializes)
        return;
      Pdfium.FPDF_InitICU((string) null);
      Pdfium.FPDF_InitLibrary((string) null, (string) null);
      if (!Pdfium._isInitializes)
        throw new Exception(Error.err0017);
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SetMgrCallback", SetLastError = true)]
  private static extern void FPDF_SetMgrCallback_native([MarshalAs(UnmanagedType.FunctionPtr)] Pdfium.ManagedCallbackDelegate callback);

  /// <summary>Reserved for internal usage.</summary>
  /// <param name="level">Must be zero.</param>
  /// <returns></returns>
  [DllImport("pdfium", SetLastError = true)]
  internal static extern bool FPDF_TestCompare(int level);

  /// <summary>Reserved for internal usage.</summary>
  /// <param name="name">Resource name.</param>
  /// <returns>Assembly where the resource is located.</returns>
  public static Assembly FindResource(ref string name) => SearchResource.FindResource(ref name);

  /// <summary>
  /// The SetWorldTransform function sets a two-dimensional linear transformation between world space and page space for the specified device context. This transformation can be used to scale, rotate, shear, or translate graphics output.
  /// </summary>
  /// <param name="hdc">A handle to the device context.</param>
  /// <param name="pMatrix">A pointer to an FS_MATRIX structure that contains the transformation data.</param>
  public static void SetWorldTransform(IntPtr hdc, [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX pMatrix)
  {
    Platform.SetWorldTransform(hdc, pMatrix);
  }

  /// <summary>
  /// The IntersectClipRect function creates a new clipping region from the intersection of the current clipping region and the specified rectangle.
  /// </summary>
  /// <param name="hdc">A handle to the device context.</param>
  /// <param name="left">The x-coordinate, in logical units, of the upper-left corner of the rectangle.</param>
  /// <param name="top">The y-coordinate, in logical units, of the upper-left corner of the rectangle.</param>
  /// <param name="right">The x-coordinate, in logical units, of the lower-right corner of the rectangle.</param>
  /// <param name="bottom">The y-coordinate, in logical units, of the lower-right corner of the rectangle.</param>
  /// <returns>The return value specifies the new clipping region's type and can be one of the following values.</returns>
  /// <remarks>The lower and right-most edges of the given rectangle are excluded from the clipping region.
  /// If a clipping region does not already exist then the system may apply a default clipping region to the specified HDC.A clipping region is then created from the intersection of that default clipping region and the rectangle specified in the function parameters.</remarks>
  public static int IntersectClipRect(IntPtr hdc, int left, int top, int right, int bottom)
  {
    return Platform.IntersectClipRect(hdc, left, top, right, bottom);
  }

  [DllImport("pdfium", SetLastError = true)]
  internal static extern void FPDF_GetDllDate(out int year, out int month, out int day);

  /// <summary>
  /// Check if compact version of pdfium dynamic library (.dll/.dylib) is used.
  /// </summary>
  /// <returns>true if compact version is used.</returns>
  [DllImport("pdfium", SetLastError = true)]
  public static extern bool FPDF_IsCompact();

  [DllImport("pdfium", SetLastError = true)]
  private static extern bool FPDF_IsXFA();

  /// <summary>
  /// A flag indicating whether the native module is built with XFA support.
  /// </summary>
  public static bool IsXfaNative => Pdfium.FPDF_IsXFA();

  /// <summary>
  /// A flag indicating whether the managed assembly is built with XFA support.
  /// </summary>
  public static bool IsXfaManaged => false;

  /// <summary>
  /// Gets or sets the platform in that current application is running.
  /// </summary>
  public static Platforms CurrentPlatform
  {
    get => Platform.CurrentPlatform;
    set => Platform.CurrentPlatform = value;
  }

  /// <summary>
  /// Gets or sets the encoding that is used to encode/decode ANSI strings.
  /// </summary>
  /// <remarks>By default used the system's current ANSI code page.</remarks>
  public static Encoding DefaultAnsiEncoding
  {
    get
    {
      lock (Pdfium._syncDefEnc)
        return Pdfium._defEnc;
    }
    set
    {
      lock (Pdfium._syncDefEnc)
        Pdfium._defEnc = value;
    }
  }

  /// <summary>Determines whether the engine is initialized</summary>
  public static bool IsInitialize
  {
    get
    {
      lock (Pdfium._syncInit)
        return Pdfium._isInitializes;
    }
  }

  /// <summary>
  /// Determines whether the engine is initialized in full API mode.
  /// </summary>
  /// <remarks>
  /// true if all features are available; false - if LITE features are available only.
  /// </remarks>
  public static bool IsFullAPI { get; private set; }

  /// <summary>
  /// Determines whether the engine is initialized in a trial mode.
  /// </summary>
  /// <remarks>true if a trial mode; false otherwise.</remarks>
  public static bool IsTrial { get; private set; }

  /// <summary>
  /// Gets or sets the assembly in which the license file is saved. Default is null
  /// </summary>
  /// <remarks>If this property is null, then the engine will search the license in the following order:
  ///  EntryAssembly, CallingAssembly, ExecutingAssembly
  /// </remarks>
  public static Assembly LicensedAssembly
  {
    get
    {
      lock (Pdfium._syncInit)
        return Pdfium._licensedAssembly;
    }
    set
    {
      lock (Pdfium._syncInit)
        Pdfium._licensedAssembly = value;
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_InitEx", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDF_InitLibraryEx_native([MarshalAs(UnmanagedType.LPStr)] string licenseKey, [MarshalAs(UnmanagedType.LPStr)] string version);

  /// <summary>Initialize the Pdfium SDK library</summary>
  /// <param name="licenseKey">Your license kuy oe null for trial</param>
  /// <param name="specificPath">Path to the pdfium dynamic library (.dll/.dylib). See remarks sections for detail.</param>
  /// <param name="syncMode">Reserved. Must be 0.</param>
  /// <remarks>
  /// <para>You have to call this function before you can call any PDF processing functions.</para>
  /// <para>In some cases, library initializer can not find pdfim.dll library to download.
  /// A typical example of this situation is a Web application.
  /// Web apps is running in a IIS working directory, unlike the classical apps. As a consequence, standard LoadLibrary function can not find the dll during loading process.
  /// </para>
  /// <para>In this case, you must explicitly specify the full path to the pdfium(.dll/.dylib) file through specificPath parameter in the initialization method.</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_InitLibrary(string licenseKey, string specificPath, int syncMode = 0)
  {
    if (Pdfium._isInitializes)
      return;
    lock (Pdfium._syncInit)
    {
      try
      {
        if (Pdfium._isInitializes)
          return;
        Log.Info("Initialize Patagames Pdf.Net SDK");
        IntPtr hModule = IntPtr.Zero;
        if (Pdfium.CurrentPlatform == Platforms.Windows)
        {
          hModule = Platform.GetModuleHandle(Platform.PdfiumDllName);
          if (hModule == IntPtr.Zero && specificPath != null)
            hModule = Platform.LoadLibrary(specificPath);
          if (hModule == IntPtr.Zero)
            Log.Info($"Try to load the {Platform.PdfiumDllName} according to standard dynamic library search order");
          if (hModule == IntPtr.Zero && Pdfium._isx64)
            hModule = Platform.LoadLibrary("x64\\" + Platform.PdfiumDllName);
          else if (hModule == IntPtr.Zero)
            hModule = Platform.LoadLibrary("x86\\" + Platform.PdfiumDllName);
          if (hModule == IntPtr.Zero)
            hModule = Platform.LoadLibrary(Platform.PdfiumDllName);
          string path1_1 = (string) null;
          if (hModule == IntPtr.Zero)
          {
            path1_1 = Patagames.Activation.Activation.GetCodeBasePath(3);
            Log.Info($"Try to load {Platform.PdfiumDllName} at {{0}}", (object) path1_1);
          }
          if (path1_1 != null && Pdfium._isx64)
            hModule = Platform.LoadLibrary(Path.Combine(path1_1, "x64\\" + Platform.PdfiumDllName));
          else if (path1_1 != null)
            hModule = Platform.LoadLibrary(Path.Combine(path1_1, "x86\\" + Platform.PdfiumDllName));
          if (hModule == IntPtr.Zero && path1_1 != null)
            hModule = Platform.LoadLibrary(Path.Combine(path1_1, Platform.PdfiumDllName));
          string path1_2 = (string) null;
          if (hModule == IntPtr.Zero)
          {
            path1_2 = Patagames.Activation.Activation.GetCodeBasePath(4);
            Log.Info($"Try to load {Platform.PdfiumDllName} at {{0}}", (object) path1_2);
          }
          if (path1_2 != null && Pdfium._isx64)
            hModule = Platform.LoadLibrary(Path.Combine(path1_2, "x64\\" + Platform.PdfiumDllName));
          else if (path1_2 != null)
            hModule = Platform.LoadLibrary(Path.Combine(path1_2, "x86\\" + Platform.PdfiumDllName));
          if (hModule == IntPtr.Zero && path1_2 != null)
            hModule = Platform.LoadLibrary(Path.Combine(path1_2, Platform.PdfiumDllName));
          string path1_3 = (string) null;
          if (hModule == IntPtr.Zero)
          {
            path1_3 = Patagames.Activation.Activation.GetCodeBasePath(1);
            Log.Info($"Try to load {Platform.PdfiumDllName} at {{0}}", (object) path1_3);
          }
          if (path1_3 != null && Pdfium._isx64)
            hModule = Platform.LoadLibrary(Path.Combine(path1_3, "x64\\" + Platform.PdfiumDllName));
          else if (path1_3 != null)
            hModule = Platform.LoadLibrary(Path.Combine(path1_3, "x86\\" + Platform.PdfiumDllName));
          if (hModule == IntPtr.Zero && path1_3 != null)
            hModule = Platform.LoadLibrary(Path.Combine(path1_3, Platform.PdfiumDllName));
          string str1 = (string) null;
          if (hModule == IntPtr.Zero)
          {
            str1 = Patagames.Activation.Activation.GetCodeBasePath(1);
            Log.Info($"Try to copy {Platform.PdfiumDllName} to {{0}}", (object) str1);
          }
          if (str1 != null)
            Patagames.Activation.Activation.CopyNative(str1);
          if (str1 != null && Pdfium._isx64)
            hModule = Platform.LoadLibrary(Path.Combine(str1, "x64\\" + Platform.PdfiumDllName));
          else if (str1 != null)
            hModule = Platform.LoadLibrary(Path.Combine(str1, "x86\\" + Platform.PdfiumDllName));
          string str2 = (string) null;
          if (hModule == IntPtr.Zero)
          {
            str2 = Patagames.Activation.Activation.GetCodeBasePath(3);
            Log.Info($"Try to copy {Platform.PdfiumDllName} to {{0}}", (object) str2);
          }
          if (str2 != null)
            Patagames.Activation.Activation.CopyNative(str2, true);
          if (str2 != null && Pdfium._isx64)
            hModule = Platform.LoadLibrary(Path.Combine(str2, "x64\\" + Platform.PdfiumDllName));
          else if (str2 != null)
            hModule = Platform.LoadLibrary(Path.Combine(str2, "x86\\" + Platform.PdfiumDllName));
          string str3 = (string) null;
          if (hModule == IntPtr.Zero)
          {
            str3 = Patagames.Activation.Activation.GetCodeBasePath(4);
            Log.Info($"Try to copy {Platform.PdfiumDllName} to {{0}}", (object) str3);
          }
          if (str3 != null)
            Patagames.Activation.Activation.CopyNative(str3, true);
          if (str3 != null && Pdfium._isx64)
            hModule = Platform.LoadLibrary(Path.Combine(str3, "x64\\" + Platform.PdfiumDllName));
          else if (str3 != null)
            hModule = Platform.LoadLibrary(Path.Combine(str3, "x86\\" + Platform.PdfiumDllName));
          string str4 = (string) null;
          if (hModule == IntPtr.Zero)
          {
            str4 = Patagames.Activation.Activation.GetCodeBasePath(2);
            Log.Info($"Try to copy {Platform.PdfiumDllName} to {{0}}", (object) str4);
          }
          if (str4 != null)
            Patagames.Activation.Activation.CopyNative(str4, true);
          if (str4 != null && Pdfium._isx64)
            hModule = Platform.LoadLibrary(Path.Combine(str4, "x64\\" + Platform.PdfiumDllName));
          else if (str4 != null)
            hModule = Platform.LoadLibrary(Path.Combine(str4, "x86\\" + Platform.PdfiumDllName));
          if (hModule == IntPtr.Zero)
            Log.Info($"Try to load {Platform.PdfiumDllName} from installation path");
          if (hModule == IntPtr.Zero && Pdfium._isx64)
            hModule = Platform.LoadLibrary(Patagames.Activation.Activation.x64Path);
          else if (hModule == IntPtr.Zero)
            hModule = Platform.LoadLibrary(Patagames.Activation.Activation.x86Path);
          if (hModule == IntPtr.Zero)
          {
            Log.Info(Platform.PdfiumDllName + " not found");
            throw new Exception(Error.err0012);
          }
        }
        string version = (string) null;
        try
        {
          version = Assembly.Load(new AssemblyName("Patagames.Pdf")).GetName().Version.ToString();
        }
        catch
        {
        }
        string savedKey = Patagames.Activation.Activation.GetSavedKey(Pdfium.LicensedAssembly);
        if ((savedKey ?? "").Trim() != "")
          licenseKey = savedKey;
        if ((licenseKey ?? "").ToUpper().Trim().Replace("-", "") == "EEF633080101E407081B0B50444649554D5F434F52501100656D61696C406D626F6C676F762E636F6D4000097DEEA6EC8BAC2D1408C5090DB1EB260E00345319A817F568EE14CFE986FD52A1CDED285A4D3D85C37786D6DEDC2E3AD76B20B852088EC45822631229FA6E93" && licenseKey != savedKey)
          throw new NoLicenseException("License key should be activated via Activation Tool.");
        if ((licenseKey ?? "").Trim() == "" && Patagames.Activation.Activation.GetTrialDate(true).AddDays(30.0) < DateTime.Now)
          throw new TrialExpiredException();
        uint code = 0;
        try
        {
          if (syncMode == 1)
          {
            using (Lock syncMt = Lock.SyncMT)
              syncMt.IsEnabled = false;
          }
          if (!Pdfium.FPDF_InitLibraryEx_native(licenseKey, version))
            throw Pdfium.ProcessLastError();
          code = Pdfium.FPDF_GetLastError();
        }
        catch (DllNotFoundException ex)
        {
          if (Pdfium.CurrentPlatform != Platforms.Windows)
            throw;
          Log.Info("FPDF_InitLibraryEx call failed with DllNotFoundException.");
          string moduleFileName = Platform.GetModuleFileName(hModule);
          Log.Info("Module file name is {0}", (object) moduleFileName);
          string directoryName = Path.GetDirectoryName(moduleFileName);
          Log.Info("Set DLL directory to {0}", (object) directoryName);
          if (!Platform.SetDllDirectory(directoryName))
            Log.Info("SetDllDirectory call failed.", (object) directoryName);
          Log.Info("Try to init again.", (object) directoryName);
          if (!Pdfium.FPDF_InitLibraryEx_native(licenseKey, version))
            throw Pdfium.ProcessLastError();
        }
        Pdfium._noLicense = (NoLicenseException) null;
        Pdfium.FPDF_SetMgrCallback_native(Pdfium.ManagedCallback);
        Pdfium._isInitializes = true;
        Pdfium.IsFullAPI = Pdfium.FPDF_TestCompare(3);
        Pdfium.IsTrial = (licenseKey ?? "").Trim() == "";
        if (code == 0U)
          return;
        Pdfium.FPDF_SetLastError(code);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Initialize the ICU data file. Should be called before <see cref="M:Patagames.Pdf.Pdfium.FPDF_InitLibrary(System.String,System.String,System.Int32)" />
  /// </summary>
  /// <param name="specificPath">Path to the icudt dynamic library (.dll/.dylib)</param>
  public static void FPDF_InitICU(string specificPath)
  {
    if (Pdfium._isInitializes)
      return;
    lock (Pdfium._syncInit)
    {
      if (Pdfium._isInitializes)
        return;
      Log.Info("Initialize ICU");
      if (Pdfium.CurrentPlatform != Platforms.Windows)
        return;
      IntPtr zero = IntPtr.Zero;
      IntPtr num = Platform.GetModuleHandle(Platform.IcuDllName);
      if (num == IntPtr.Zero && specificPath != null)
        num = Platform.LoadLibrary(specificPath);
      if (num == IntPtr.Zero)
      {
        Log.Info($"Try to load the {Platform.IcuDllName} according to standard dynamic library search order");
        num = Platform.LoadLibrary(Platform.IcuDllName);
      }
      if (num == IntPtr.Zero)
      {
        string codeBasePath = Patagames.Activation.Activation.GetCodeBasePath(3);
        Log.Info($"Try to load {Platform.IcuDllName} at {{0}}", (object) codeBasePath);
        if (codeBasePath != null)
          num = Platform.LoadLibrary(Path.Combine(codeBasePath, Platform.IcuDllName));
      }
      if (num == IntPtr.Zero)
      {
        string codeBasePath = Patagames.Activation.Activation.GetCodeBasePath(4);
        Log.Info($"Try to load {Platform.IcuDllName} at {{0}}", (object) codeBasePath);
        if (codeBasePath != null)
          num = Platform.LoadLibrary(Path.Combine(codeBasePath, Platform.IcuDllName));
      }
      if (num == IntPtr.Zero)
      {
        string codeBasePath = Patagames.Activation.Activation.GetCodeBasePath(1);
        Log.Info($"Try to load {Platform.IcuDllName} at {{0}}", (object) codeBasePath);
        if (codeBasePath != null)
          num = Platform.LoadLibrary(Path.Combine(codeBasePath, Platform.IcuDllName));
      }
      if (num == IntPtr.Zero)
      {
        string codeBasePath = Patagames.Activation.Activation.GetCodeBasePath(1);
        Log.Info($"Try to copy {Platform.IcuDllName} to {{0}}", (object) codeBasePath);
        if (codeBasePath != null)
        {
          Patagames.Activation.Activation.CopyNative(codeBasePath);
          num = Platform.LoadLibrary(Path.Combine(codeBasePath, Platform.IcuDllName));
        }
      }
      if (num == IntPtr.Zero)
      {
        string codeBasePath = Patagames.Activation.Activation.GetCodeBasePath(3);
        Log.Info($"Try to copy {Platform.IcuDllName} to {{0}}", (object) codeBasePath);
        if (codeBasePath != null)
        {
          Patagames.Activation.Activation.CopyNative(codeBasePath, true);
          num = Platform.LoadLibrary(Path.Combine(codeBasePath, Platform.IcuDllName));
        }
      }
      if (num == IntPtr.Zero)
      {
        string codeBasePath = Patagames.Activation.Activation.GetCodeBasePath(4);
        Log.Info($"Try to copy {Platform.IcuDllName} to {{0}}", (object) codeBasePath);
        if (codeBasePath != null)
        {
          Patagames.Activation.Activation.CopyNative(codeBasePath, true);
          num = Platform.LoadLibrary(Path.Combine(codeBasePath, Platform.IcuDllName));
        }
      }
      if (num == IntPtr.Zero)
      {
        string codeBasePath = Patagames.Activation.Activation.GetCodeBasePath(2);
        Log.Info($"Try to copy {Platform.IcuDllName} to {{0}}", (object) codeBasePath);
        if (codeBasePath != null)
        {
          Patagames.Activation.Activation.CopyNative(codeBasePath, true);
          num = Platform.LoadLibrary(Path.Combine(codeBasePath, Platform.IcuDllName));
        }
      }
      if (num == IntPtr.Zero)
      {
        Log.Info($"Try to load {Platform.IcuDllName} from installation path");
        num = Platform.LoadLibrary(Patagames.Activation.Activation.icuPath);
      }
      if (!(num == IntPtr.Zero))
        return;
      Log.Info(Platform.IcuDllName + " not found");
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_ReleaseEx", SetLastError = true)]
  private static extern void FPDF_DestroyLibraryEx_native();

  /// <summary>Release all resources allocated by the Pdfium library</summary>
  /// <remarks>You can call this function to release all memory blocks allocated by the library. After this function called, you should not call any PDF processing functions.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_DestroyLibrary()
  {
    if (!Pdfium._isInitializes)
      return;
    lock (Pdfium._syncInit)
    {
      try
      {
        if (!Pdfium._isInitializes)
          return;
        if (Pdfium._unsupportedHandler != null)
        {
          Pdfium._unsupportedHandler.Dispose();
          Pdfium._unsupportedHandler = (PointerManagerItem<UNSUPPORT_INFO>) null;
        }
        PointerManager.Clear();
        Pdfium.FPDF_DestroyLibraryEx_native();
        Pdfium._isInitializes = false;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Unload pdfium dynamic library (.dll/.dylib) from the process.
  /// </summary>
  [HandleProcessCorruptedStateExceptions]
  public static void UnloadDllFromProcess()
  {
    using (Lock.SyncMT)
    {
      try
      {
        for (int index1 = 0; index1 < 2; ++index1)
        {
          IntPtr moduleHandle = Platform.GetModuleHandle(index1 == 0 ? Platform.PdfiumDllName : Platform.IcuDllName);
          if (moduleHandle != IntPtr.Zero)
          {
            for (int index2 = 0; index2 < 100 && Platform.FreeLibrary(moduleHandle); ++index2)
              Thread.Sleep(100);
          }
        }
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetLastError")]
  [return: MarshalAs(UnmanagedType.U4)]
  private static extern uint FPDF_GetLastError_native();

  /// <summary>Get last error code when an SDK function failed.</summary>
  /// <returns>A 32-bit integer indicating error codes (defined below).
  /// 0 no error;
  /// 1 unknown error;
  /// 2 file not found or could not be opened;
  /// 3 file not in PDF format or corrupted;
  /// 4 password required or incorrect password;
  /// 5 unsupported security scheme;
  /// 6 page not found or content error;
  /// 1001 the requested operation cannot be completed due to a license restrictions;
  /// </returns>
  /// <remarks>If the previous SDK call succeeded, the return value of this function is not defined. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static uint FPDF_GetLastError()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetLastError_native();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SetLastError")]
  private static extern void FPDF_SetLastError_native(uint code);

  [HandleProcessCorruptedStateExceptions]
  internal static void FPDF_SetLastError(uint code)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_SetLastError_native(code);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAction_GetFilePath", SetLastError = true)]
  private static extern uint FPDFAction_GetFilePath_native(
    IntPtr action,
    [MarshalAs(UnmanagedType.LPArray)] byte[] file_path,
    int buflen);

  /// <summary>Get file path of an remote goto action</summary>
  /// <param name="action">Handle to the action. Must be a RMEOTEGOTO or LAUNCH action.
  /// Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFBookmark_GetAction(System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_GetAction(System.IntPtr)" /> function.</param>
  /// <returns>Return file path of an remote goto action </returns>
  /// <remarks>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK</remarks>
  [Obsolete("This method is obsolete", true)]
  public static string FPDFAction_GetFilePath(IntPtr action)
  {
    int num = 0;
    byte[] title = (byte[]) null;
    int titleNative = Pdfium.FPDFBookmark_GetTitle_native(action, title, 0);
    if (titleNative == 0)
      return "";
    byte[] numArray = new byte[titleNative];
    num = Pdfium.FPDFBookmark_GetTitle_native(action, numArray, titleNative);
    return Encoding.Unicode.GetString(numArray).Trim(new char[1]);
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetFont", SetLastError = true)]
  private static extern IntPtr FPDFText_GetFont_native(IntPtr text_page, int index);

  /// <summary>Get font of a particular character</summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function.</param>
  /// <param name="index">Zero-based index of the character</param>
  /// <returns>A handle to the font used by the particular character. This handle can be used in
  /// FPDFFont_xxx functions for more information about the font</returns>
  /// <remarks>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK</remarks>
  [Obsolete("This method is obsolete", true)]
  public static IntPtr FPDFText_GetFont(IntPtr text_page, int index)
  {
    return Pdfium.FPDFText_GetFont_native(text_page, index);
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_NewTextObj", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_NewTextObj_native();

  /// <summary>Create a new Text Object.</summary>
  /// <returns>Handle to text object.</returns>
  /// <remarks>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK</remarks>
  [Obsolete("This method is obsolete", true)]
  public static IntPtr FPDFPageObj_NewTextObj() => Pdfium.FPDFPageObj_NewTextObj_native();

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_NewTextObjEx", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_NewTextObjEx_native([MarshalAs(UnmanagedType.LPWStr)] string text, int size, IntPtr font);

  /// <summary>Create a new Text Object.</summary>
  /// <param name="text">Pointer to a string. The text you want to add in a text object.</param>
  /// <param name="size">The length of the string</param>
  /// <param name="font">Handle to the font. It could be FPDFTextObj_GetFont, FPDFFont_AddTrueType
  /// and FPDFFont_AddStandardFont".</param>
  /// <returns>Handle to text object.</returns>
  /// <remarks>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK</remarks>
  [Obsolete("This method is obsolete", true)]
  public static IntPtr FPDFPageObj_NewTextObjEx(string text, int size, IntPtr font)
  {
    return Pdfium.FPDFPageObj_NewTextObjEx_native(text, size, font);
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_NewPathObj", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_NewPathObj_native();

  /// <summary>Create a new path Object.</summary>
  /// <returns>Handle to path object.</returns>
  /// <remarks>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK</remarks>
  [Obsolete("This method is obsolete", true)]
  public static IntPtr FPDFPageObj_NewPathObj() => Pdfium.FPDFPageObj_NewPathObj_native();

  [DllImport("pdfium", EntryPoint = "FPDF_AllocMemory", SetLastError = true)]
  private static extern IntPtr FPDF_AllocMemory_native([MarshalAs(UnmanagedType.U4)] uint size);

  /// <summary>
  /// Allocated memory block in FPDFSDK. This memory can be freed by <see cref="M:Patagames.Pdf.Pdfium.FPDF_FreeMemory(System.IntPtr)" /> function.
  /// </summary>
  /// <param name="size">Byte size of requested memory block. Can not be zero.</param>
  /// <returns>The allocated pointer. IntPtr.Zero if memory not available.</returns>
  /// <remarks>
  /// <para>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK</para>
  /// Some FPDFSDK interface may require application to allocate memory for internal use of
  /// FPDFSDK. In this case application must call this function to allocate memory, don't use
  /// malloc() or other memory allocator. If an error handler installed and exception/long jump is
  /// used in the out of memory handling, this function might never return if no memory available.
  /// </remarks>
  [Obsolete("This method is obsolete", true)]
  public static IntPtr FPDF_AllocMemory(uint size) => Pdfium.FPDF_AllocMemory_native(size);

  [DllImport("pdfium", EntryPoint = "FPDF_FreeMemory", SetLastError = true)]
  private static extern void FPDF_FreeMemory_native(IntPtr handle);

  /// <summary>Free a memory area allocated by Pdfium SDK.</summary>
  /// <param name="handle">The pointer. Should not be IntPtr.Zero.</param>
  /// <returns>The allocated pointer. IntPtr.Zero if memory not available.</returns>
  /// <remarks>
  /// <para>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK</para>
  /// In case FPDFSDK allocated some memory for user application, the user application must free
  /// it to avoid memory leakage. And the application must call FPDF_FreeMemory function to do
  /// that. Do NOT use c/c++ memory free() function or other similar functions.
  /// </remarks>
  [Obsolete("This method is obsolete", true)]
  public static void FPDF_FreeMemory(IntPtr handle) => Pdfium.FPDF_FreeMemory_native(handle);

  /// <summary>
  /// This method is obsolete. Please use FPDF_GetStockFont instead
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="fontName">A string that specifies the typeface name of the font.</param>
  /// <returns>Handle to the new font object.</returns>
  [Obsolete("This method is obsolete. Please use FPDF_GetStockFont instead", true)]
  public static IntPtr FPDFFont_GetStockFont(IntPtr document, string fontName)
  {
    using (Lock.SyncMT)
      return Pdfium.FPDF_GetStockFont_native(document, fontName);
  }

  /// <summary>
  /// This method is obsolete. Please use FPDF_GetStockFont instead
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="fontName">A value that specifies the typeface name of the font.</param>
  /// <returns>Handle to the new font object.</returns>
  [Obsolete("This method is obsolete. Please use FPDF_GetStockFont instead", true)]
  public static IntPtr FPDFFont_GetStockFont(IntPtr document, FontStockNames fontName)
  {
    return Pdfium.FPDF_GetStockFont(document, fontName);
  }

  /// <summary>
  /// This method is obsolete. Please use <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Transform(System.IntPtr,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> instead
  /// </summary>
  /// <param name="formObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="pMatrix">The transform matrix</param>
  /// <remarks>This method is obsolete. Please use <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Transform(System.IntPtr,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> instead.</remarks>
  [Obsolete("This method is obsolete. Please use FPDFPageObj_Transform instead", true)]
  public static void FPDFFormObj_Transform(IntPtr formObject, FS_MATRIX pMatrix)
  {
  }

  /// <summary>
  /// This method is obsolete. Please use <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Transform(System.IntPtr,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> instead.
  /// </summary>
  /// <param name="image_obj">Handle to the image object</param>
  /// <param name="a">The coefficient "a" of the matrix.</param>
  /// <param name="b">The coefficient "b" of the matrix.</param>
  /// <param name="c">The coefficient "c" of the matrix.</param>
  /// <param name="d">The coefficient "d" of the matrix.</param>
  /// <param name="e">The coefficient "e" of the matrix. (x position)</param>
  /// <param name="f">The coefficient "f" of the matrix. (y position)</param>
  /// <remarks>This method is obsolete. Please use <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Transform(System.IntPtr,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> instead.</remarks>
  [Obsolete("This method is obsolete. Please use FPDFPageObj_Transform instead", true)]
  public static void FPDFImageObj_Transform(
    IntPtr image_obj,
    float a,
    float b,
    float c,
    float d,
    float e,
    float f)
  {
  }

  /// <summary>
  /// This method is obsolete. Please use <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Transform(System.IntPtr,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> instead.
  /// </summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="a">The coefficient "a" of the matrix</param>
  /// <param name="b">The coefficient "b" of the matrix</param>
  /// <param name="c">The coefficient "c" of the matrix</param>
  /// <param name="d">The coefficient "d" of the matrix</param>
  /// <param name="e">The coefficient "e" of the matrix</param>
  /// <param name="f">The coefficient "f" of the matrix</param>
  /// <remarks>This method is obsolete. Please use <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Transform(System.IntPtr,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> instead.</remarks>
  [Obsolete("This method is obsolete. Please use FPDFPageObj_Transform instead", true)]
  public static void FPDFTextObj_Transform(
    IntPtr textObject,
    float a,
    float b,
    float c,
    float d,
    float e,
    float f)
  {
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_Copy", SetLastError = true)]
  private static extern void FPDFPageObj_Copy_native(IntPtr dstPage_obj, IntPtr srcPage_obj);

  /// <summary>Copy page object information from one to another</summary>
  /// <param name="dstPage_obj">Handle to destination page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="srcPage_obj">Handle to source page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  [Obsolete("This method is obsolete", true)]
  public static void FPDFPageObj_Copy(IntPtr dstPage_obj, IntPtr srcPage_obj)
  {
    using (Lock.SyncMT)
      Pdfium.FPDFPageObj_Copy_native(dstPage_obj, srcPage_obj);
  }

  /// <summary>
  ///  Insert an object to the page. The page object is automatically freed.
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" />.</param>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObj" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObjEx(System.String,System.Int32,System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewPathObj" />.</param>
  [Obsolete("This method is obsolete. Please use FPDFPage_AddObject instead", false)]
  public static void FPDFPage_InsertObject(IntPtr page, IntPtr page_object)
  {
    Pdfium.FPDFPage_AddObject(page, page_object);
  }

  [DllImport("pdfium", EntryPoint = "FPDFDoc_GetPageMode", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  private static extern int FPDFDoc_GetPageMode_native(IntPtr document);

  /// <summary>
  ///  Get the document's PageMode(How the document should be displayed when opened)
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>The flags for page mode.</returns>
  /// <example><code>
  /// public void FPDFDoc_GetPageMode()
  /// {
  /// 	IntPtr doc = Pdfium.FPDF_LoadDocument(@"Files\test001.pdf");
  /// 	var mode = Pdfium.FPDFDoc_GetPageMode(doc);
  /// 	Pdfium.FPDF_CloseDocument(doc);
  /// }
  /// </code>
  /// </example>
  [HandleProcessCorruptedStateExceptions]
  public static PageModes FPDFDoc_GetPageMode(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (PageModes) Pdfium.FPDFDoc_GetPageMode_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FSDK_SetUnSpObjProcessHandler", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FSDK_SetUnSpObjProcessHandler_native(IntPtr unsp_info);

  /// <summary>
  /// Setup A UnSupport Object process handler for Pdfium sdk.
  /// </summary>
  /// <param name="unsp_info">Pointer to a UNSUPPORT_INFO structure.</param>
  /// <returns>True for success or False if any error occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FSDK_SetUnSpObjProcessHandler(UNSUPPORT_INFO unsp_info)
  {
    using (Lock.SyncMT)
    {
      try
      {
        if (Pdfium._unsupportedHandler != null)
        {
          Pdfium._unsupportedHandler.Dispose();
          Pdfium._unsupportedHandler = (PointerManagerItem<UNSUPPORT_INFO>) null;
        }
        Pdfium._unsupportedHandler = new PointerManagerItem<UNSUPPORT_INFO>(unsp_info);
        if (Pdfium.FSDK_SetUnSpObjProcessHandler_native(Pdfium._unsupportedHandler[0]))
          return true;
        Pdfium._unsupportedHandler.Dispose();
        Pdfium._unsupportedHandler = (PointerManagerItem<UNSUPPORT_INFO>) null;
        return false;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_Flatten", SetLastError = true)]
  private static extern int FPDFPage_Flatten_native(IntPtr page, int flag);

  /// <summary>
  /// Flat a pdf page, annotations or form fields will become part of the page contents.
  /// </summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" />function.</param>
  /// <param name="flag">the flag for the use of flatten result. Zero for normal display, 1 for print.</param>
  /// <returns>The result flag of the function, See flags above ( FLATTEN_FAIL, FLATTEN_SUCCESS, FLATTEN_NOTHINGTODO ).</returns>
  /// <remarks>Current Version on all fails return zero.</remarks>
  /// <example><code>
  /// public void FPDFPage_Flatten()
  /// {
  /// 	IntPtr doc = Pdfium.FPDF_LoadDocument(@"Files\test001.pdf");
  /// 	IntPtr page = Pdfium.FPDF_LoadPage(doc, 0);
  /// 
  /// 	var ret = Pdfium.FPDFPage_Flatten(page, FlattenFlags.FlatPrint);
  /// 	if (ret != FlattenResults.Success)
  /// 		throw new Exception();
  /// 
  /// 	ret = Pdfium.FPDFPage_Flatten(page, FlattenFlags.NormalDisplay);
  /// 	if (ret != FlattenResults.NothingTodo)
  /// 		throw new Exception();
  /// 
  /// 	Pdfium.FPDF_ClosePage(page);
  /// 	Pdfium.FPDF_CloseDocument(doc);
  /// }
  /// </code></example>
  [HandleProcessCorruptedStateExceptions]
  public static FlattenResults FPDFPage_Flatten(IntPtr page, FlattenFlags flag)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (FlattenResults) Pdfium.FPDFPage_Flatten_native(page, (int) flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_RenderPageBitmap_Start", SetLastError = true)]
  private static extern int FPDF_RenderPageBitmap_Start_native(
    IntPtr bitmap,
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flag,
    [MarshalAs(UnmanagedType.LPStruct)] IFSDK_PAUSE pause);

  /// <summary>
  /// Start to render page contents to a device independent bitmap progressively.
  /// </summary>
  /// <param name="bitmap">Handle to the device independent bitmap (as the output buffer). Bitmap handle can be created by <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Create(System.Int32,System.Int32,System.Boolean)" /> function.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="start_x">Left pixel position of the display area in the bitmap coordinate.</param>
  /// <param name="start_y">Top pixel position of the display area in the bitmap coordinate.</param>
  /// <param name="size_x">Horizontal size (in pixels) for displaying the page.</param>
  /// <param name="size_y">Vertical size (in pixels) for displaying the page.</param>
  /// <param name="rotate">Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</param>
  /// <param name="flag">0 for normal display, or combination of flags defined above.</param>
  /// <param name="pause">The <see cref="T:Patagames.Pdf.IFSDK_PAUSE" /> interface.A callback mechanism allowing the page rendering process</param>
  /// <returns>Rendering Status. See flags for progressive process status for the details.</returns>
  /// <example><code>
  /// public void ProgressiveRenderPage()
  /// {
  /// 	IntPtr doc = Pdfium.FPDF_LoadDocument(@"Files\test001.pdf");
  /// 	IntPtr page = Pdfium.FPDF_LoadPage(doc, 0);
  /// 
  /// 	double width, height;
  /// 	Pdfium.FPDF_GetPageSizeByIndex(doc, 0, out width, out height);
  /// 	IntPtr bitmap = Pdfium.FPDFBitmap_Create((int)width, (int)height, true);
  /// 
  /// 	bool needPause = true;
  /// 
  /// 	IFSDK_PAUSE pause = new IFSDK_PAUSE();
  /// 	pause.needToPauseNowCallback = (pthis) =&gt;
  /// 	{
  /// 		return needPause;
  /// 	};
  /// 
  /// 	var ret = Pdfium.FPDF_RenderPageBitmap_Start(bitmap, page, 0, 0, (int)width, (int)height, PageRotate.Normal, RenderFlags.None, pause);
  /// 	if (ret == ProgressiveRenderingStatuses.RenderFailed)
  /// 		throw new Exception();
  /// 	else if (ret == ProgressiveRenderingStatuses.RenderTobeContinued)
  /// 	{
  /// 		needPause = false;
  /// 		ret = Pdfium.FPDF_RenderPage_Continue(page, pause);
  /// 	}
  /// 
  /// 	if (ret == ProgressiveRenderingStatuses.RenderDone)
  /// 		Pdfium.FPDF_RenderPage_Close(page);
  /// 	else
  /// 		throw new Exception();
  /// 
  /// 	IntPtr buffer = Pdfium.FPDFBitmap_GetBuffer(bitmap);
  /// 	int stride = Pdfium.FPDFBitmap_GetStride(bitmap);
  /// 	using (System.Drawing.Bitmap bmp = new System.Drawing.Bitmap((int)width, (int)height, stride, System.Drawing.Imaging.PixelFormat.Format32bppArgb, buffer))
  /// 	{
  /// 		bmp.Save("FPDF_RenderPage_Continue.png", System.Drawing.Imaging.ImageFormat.Png);
  /// 	}
  /// 
  /// 	Pdfium.FPDFBitmap_Destroy(bitmap);
  /// 	Pdfium.FPDF_ClosePage(page);
  /// 	Pdfium.FPDF_CloseDocument(doc);
  /// }
  /// </code></example>
  [HandleProcessCorruptedStateExceptions]
  public static ProgressiveStatus FPDF_RenderPageBitmap_Start(
    IntPtr bitmap,
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    PageRotate rotate,
    RenderFlags flag,
    IFSDK_PAUSE pause)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (ProgressiveStatus) Pdfium.FPDF_RenderPageBitmap_Start_native(bitmap, page, start_x, start_y, size_x, size_y, (int) rotate, (int) flag, pause);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_RenderPage_Continue", SetLastError = true)]
  private static extern int FPDF_RenderPage_Continue_native(IntPtr page, [MarshalAs(UnmanagedType.LPStruct)] IFSDK_PAUSE pause);

  /// <summary>Continue rendering a PDF page.</summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="pause">The <see cref="T:Patagames.Pdf.IFSDK_PAUSE" /> interface.A callback mechanism allowing the page rendering
  /// process to be paused before it's finished. This can be NULL if you don't want to pause.</param>
  /// <returns>The rendering status. See flags for progressive process status for the details.</returns>
  /// <remarks>
  /// In Version 2236 of Pdfium this method is always returns RenderFailed if pause is NULL
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static ProgressiveStatus FPDF_RenderPage_Continue(IntPtr page, IFSDK_PAUSE pause)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (ProgressiveStatus) Pdfium.FPDF_RenderPage_Continue_native(page, pause);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_RenderPage_Close", SetLastError = true)]
  private static extern void FPDF_RenderPage_Close_native(IntPtr page);

  /// <summary>
  /// Release the resource allocate during page rendering. Need to be called after finishing rendering or cancel the rendering.
  /// </summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_RenderPage_Close(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_RenderPage_Close_native(page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetCharIndexFromTextIndex", SetLastError = true)]
  private static extern int FPDFText_GetCharIndexFromTextIndex_native(IntPtr text_page, int index);

  /// <summary>
  /// Get the actually char index in text_page's internal char list.
  /// </summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function.</param>
  /// <param name="index">The index of the text in the string get from <see cref="M:Patagames.Pdf.Pdfium.FPDFText_GetText(System.IntPtr,System.Int32,System.Int32)" /></param>
  /// <returns>The index of the character in internal charlist. -1 for error</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFText_GetCharIndexFromTextIndex(IntPtr text_page, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_GetCharIndexFromTextIndex_native(text_page, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_SetMediaBox", SetLastError = true)]
  private static extern void FPDFPage_SetMediaBox_native(
    IntPtr page,
    [MarshalAs(UnmanagedType.R4)] float left,
    [MarshalAs(UnmanagedType.R4)] float bottom,
    [MarshalAs(UnmanagedType.R4)] float right,
    [MarshalAs(UnmanagedType.R4)] float top);

  /// <summary>Set "MediaBox" entry to the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="left">The left of the rectangle.</param>
  /// <param name="bottom">The bottom of the rectangle.</param>
  /// <param name="right">The right of the rectangle.</param>
  /// <param name="top">The top of the rectangle.</param>
  /// <remarks>The media box defines the boundaries of the physical medium on which the
  /// page is to be printed. It may include any extended area surrounding the
  /// finished page for bleed, printing marks, or other such purposes. It may also
  /// <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF reference 1.7.pdf</a> SECTION 10.10 Prepress Support 963
  /// include areas close to the edges of the medium that cannot be marked because
  /// of physical limitations of the output device. Content falling outside this boundary
  /// can safely be discarded without affecting the meaning of the PDF file.</remarks>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7</seealso>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_SetMediaBox(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_SetMediaBox_native(page, left, bottom, right, top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_SetCropBox", SetLastError = true)]
  private static extern void FPDFPage_SetCropBox_native(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top);

  /// <summary>Set "CropBox" entry to the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">The left of the rectangle.</param>
  /// <param name="bottom">The bottom of the rectangle.</param>
  /// <param name="right">The right of the rectangle.</param>
  /// <param name="top">The top of the rectangle.</param>
  /// <remarks>The crop box defines the region to which the contents of the page are to be
  /// clipped (cropped) when displayed or printed. Unlike the other boxes, the crop
  /// box has no defined meaning in terms of physical page geometry or intended
  /// use; it merely imposes clipping on the page contents. However, in the absence
  /// of additional information (such as imposition instructions specified in a JDF or
  /// PJTF job ticket), the crop box determines how the page’s contents are to be positioned
  /// on the output medium. The default value is the page’s media box.
  /// See <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF reference 1.7.pdf</a> for more details
  /// </remarks>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7</seealso>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_SetCropBox(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_SetCropBox_native(page, left, bottom, right, top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_SetBleedBox", SetLastError = true)]
  private static extern void FPDFPage_SetBleedBox_native(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top);

  /// <summary>Set "BleedBox" entry to the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">The left of the rectangle.</param>
  /// <param name="bottom">The bottom of the rectangle.</param>
  /// <param name="right">The right of the rectangle.</param>
  /// <param name="top">The top of the rectangle.</param>
  /// <remarks>A rectangle, expressed in default user space units, defining the region to which the contents of the page should be clipped
  /// when output in a production environment. Default value: the value of CropBox.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_SetBleedBox(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_SetBleedBox_native(page, left, bottom, right, top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_SetTrimBox", SetLastError = true)]
  private static extern void FPDFPage_SetTrimBox_native(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top);

  /// <summary>Set "TrimBox" entry to the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">The left of the rectangle.</param>
  /// <param name="bottom">The bottom of the rectangle.</param>
  /// <param name="right">The right of the rectangle.</param>
  /// <param name="top">The top of the rectangle.</param>
  /// <remarks> A rectangle, expressed in default user space units, defining the intended dimensions of the finished page after trimming. Default value: the value of CropBox.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_SetTrimBox(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_SetTrimBox_native(page, left, bottom, right, top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_SetArtBox", SetLastError = true)]
  private static extern void FPDFPage_SetArtBox_native(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top);

  /// <summary>Set "ArtBox" entry to the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">The left of the rectangle.</param>
  /// <param name="bottom">The bottom of the rectangle.</param>
  /// <param name="right">The right of the rectangle.</param>
  /// <param name="top">The top of the rectangle.</param>
  /// <remarks>A rectangle, expressed in default user space units, defining the extent of the page’s meaningful content(including potential
  /// white space) as intended by the page’s creator. Default value: the value of CropBox.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_SetArtBox(
    IntPtr page,
    float left,
    float bottom,
    float right,
    float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_SetArtBox_native(page, left, bottom, right, top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GetMediaBox", SetLastError = true)]
  private static extern int FPDFPage_GetMediaBox_native(
    IntPtr page,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float bottom,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float top);

  /// <summary>Get "MediaBox" entry from the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">Pointer to a double value receiving the left of the rectangle.</param>
  /// <param name="bottom">Pointer to a double value receiving the bottom of the rectangle.</param>
  /// <param name="right">Pointer to a double value receiving the right of the rectangle.</param>
  /// <param name="top">Pointer to a double value receiving the top of the rectangle.</param>
  /// <returns>True if success, else False</returns>
  /// <remarks>The media box defines the boundaries of the physical medium on which the
  /// page is to be printed. It may include any extended area surrounding the
  /// finished page for bleed, printing marks, or other such purposes. It may also
  /// include areas close to the edges of the medium that cannot be marked because
  /// of physical limitations of the output device. Content falling outside this boundary
  /// can safely be discarded without affecting the meaning of the PDF file.</remarks>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7 SECTION 10.10 Prepress Support 963</seealso>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_GetMediaBox(
    IntPtr page,
    out float left,
    out float bottom,
    out float right,
    out float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_GetMediaBox_native(page, out left, out bottom, out right, out top) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GetCropBox", SetLastError = true)]
  private static extern int FPDFPage_GetCropBox_native(
    IntPtr page,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float bottom,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float top);

  /// <summary>Get "CropBox" entry from the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">Pointer to a double value receiving the left of the rectangle.</param>
  /// <param name="bottom">Pointer to a double value receiving the bottom of the rectangle.</param>
  /// <param name="right">Pointer to a double value receiving the right of the rectangle.</param>
  /// <param name="top">Pointer to a double value receiving the top of the rectangle.</param>
  /// <returns>True if success,else False</returns>
  /// <remarks>The crop box defines the region to which the contents of the page are to be
  /// clipped (cropped) when displayed or printed. Unlike the other boxes, the crop
  /// box has no defined meaning in terms of physical page geometry or intended
  /// use; it merely imposes clipping on the page contents. However, in the absence
  /// of additional information (such as imposition instructions specified in a JDF or
  /// PJTF job ticket), the crop box determines how the page’s contents are to be positioned
  /// on the output medium. The default value is the page’s media box.
  /// See <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF reference 1.7.pdf</a> for more details
  /// </remarks>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7</seealso>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_GetCropBox(
    IntPtr page,
    out float left,
    out float bottom,
    out float right,
    out float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_GetCropBox_native(page, out left, out bottom, out right, out top) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GetBleedBox", SetLastError = true)]
  private static extern int FPDFPage_GetBleedBox_native(
    IntPtr page,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float bottom,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float top);

  /// <summary>Get "BleedBox" entry from the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">Pointer to a double value receiving the left of the rectangle.</param>
  /// <param name="bottom">Pointer to a double value receiving the bottom of the rectangle.</param>
  /// <param name="right">Pointer to a double value receiving the right of the rectangle.</param>
  /// <param name="top">Pointer to a double value receiving the top of the rectangle.</param>
  /// <returns>True if success, else False</returns>
  /// <remarks>A rectangle, expressed in default user space units, defining the region to which the contents of the page should be clipped
  /// when output in a production environment. Default value: the value of CropBox.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_GetBleedBox(
    IntPtr page,
    out float left,
    out float bottom,
    out float right,
    out float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_GetBleedBox_native(page, out left, out bottom, out right, out top) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GetTrimBox", SetLastError = true)]
  private static extern int FPDFPage_GetTrimBox_native(
    IntPtr page,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float bottom,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float top);

  /// <summary>Get "TrimBox" entry from the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">Pointer to a double value receiving the left of the rectangle.</param>
  /// <param name="bottom">Pointer to a double value receiving the bottom of the rectangle.</param>
  /// <param name="right">Pointer to a double value receiving the right of the rectangle.</param>
  /// <param name="top">Pointer to a double value receiving the top of the rectangle.</param>
  /// <returns>True if success, else False</returns>
  /// <remarks> A rectangle, expressed in default user space units, defining the intended dimensions of the finished page after trimming. Default value: the value of CropBox.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_GetTrimBox(
    IntPtr page,
    out float left,
    out float bottom,
    out float right,
    out float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_GetTrimBox_native(page, out left, out bottom, out right, out top) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GetArtBox", SetLastError = true)]
  private static extern int FPDFPage_GetArtBox_native(
    IntPtr page,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float bottom,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float top);

  /// <summary>Get "ArtBox" entry from the page dictionary.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="left">Pointer to a double value receiving the left of the rectangle.</param>
  /// <param name="bottom">Pointer to a double value receiving the bottom of the rectangle.</param>
  /// <param name="right">Pointer to a double value receiving the right of the rectangle.</param>
  /// <param name="top">Pointer to a double value receiving the top of the rectangle.</param>
  /// <returns>True if success, else False</returns>
  /// <remarks>A rectangle, expressed in default user space units, defining the extent of the page’s meaningful content(including potential
  /// white space) as intended by the page’s creator. Default value: the value of CropBox.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_GetArtBox(
    IntPtr page,
    out float left,
    out float bottom,
    out float right,
    out float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_GetArtBox_native(page, out left, out bottom, out right, out top) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_TransFormWithClip", SetLastError = true)]
  private static extern int FPDFPage_TransFormWithClip_native(
    IntPtr page,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix,
    ref FS_RECTF clip_rect);

  /// <summary>
  /// Transform the whole page with a specified matrix, then clip the page content region.
  /// </summary>
  /// <param name="page">A page handle. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="matrix">The transform matrix</param>
  /// <param name="clip_rect">A rectangle page area to be clipped</param>
  /// <returns>True if success,else false</returns>
  /// <remarks>This function will transform the whole page, and would take effect to all the objects in the page.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_TransFormWithClip(IntPtr page, FS_MATRIX matrix, FS_RECTF clip_rect)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_TransFormWithClip_native(page, matrix, ref clip_rect) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_TransformClipPath", SetLastError = true)]
  private static extern void FPDFPageObj_TransformClipPath_native(
    IntPtr page_object,
    [MarshalAs(UnmanagedType.R8)] double a,
    [MarshalAs(UnmanagedType.R8)] double b,
    [MarshalAs(UnmanagedType.R8)] double c,
    [MarshalAs(UnmanagedType.R8)] double d,
    [MarshalAs(UnmanagedType.R8)] double e,
    [MarshalAs(UnmanagedType.R8)] double f);

  /// <summary>
  /// Transform (scale, rotate, shear, move) the clip path of page object.
  /// </summary>
  /// <param name="page_object">page_object - Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" /> function.</param>
  /// <param name="a">The coefficient "a" of the matrix</param>
  /// <param name="b">The coefficient "b" of the matrix</param>
  /// <param name="c">The coefficient "c" of the matrix</param>
  /// <param name="d">The coefficient "d" of the matrix</param>
  /// <param name="e">The coefficient "e" of the matrix</param>
  /// <param name="f">The coefficient "f" of the matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_TransformClipPath(
    IntPtr page_object,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_TransformClipPath_native(page_object, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CreateClipPath", SetLastError = true)]
  private static extern IntPtr FPDF_CreateClipPath_native(
    float left,
    float bottom,
    float right,
    float top);

  /// <summary>Create a new clip path, with a rectangle inserted.</summary>
  /// <param name="left">The left of the clip box.</param>
  /// <param name="bottom">The bottom of the clip box.</param>
  /// <param name="right">The right of the clip box.</param>
  /// <param name="top">The top of the clip box.</param>
  /// <returns>a handle to the clip path.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_CreateClipPath(float left, float bottom, float right, float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_CreateClipPath_native(left, bottom, right, top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_DestroyClipPath", SetLastError = true)]
  private static extern void FPDF_DestroyClipPath_native(IntPtr clip_path);

  /// <summary>Destroy the clip path.</summary>
  /// <param name="clip_path">A handle to the clip path. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateClipPath(System.Single,System.Single,System.Single,System.Single)" /> function.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_DestroyClipPath(IntPtr clip_path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_DestroyClipPath_native(clip_path);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_InsertClipPath", SetLastError = true)]
  private static extern void FPDFPage_InsertClipPath_native(IntPtr page, IntPtr clip_path);

  /// <summary>
  /// Clip the page content, the page content that outside the clipping region become invisible.
  /// </summary>
  /// <param name="page">A page handle. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="clip_path">A handle to the clip path.  Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateClipPath(System.Single,System.Single,System.Single,System.Single)" /> function.</param>
  /// <remarks>A clip path will be inserted before the page content stream or content array.
  /// In this way, the page content will be clipped by this clip path.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_InsertClipPath(IntPtr page, IntPtr clip_path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_InsertClipPath_native(page, clip_path);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBookmark_GetFirstChild", SetLastError = true)]
  private static extern IntPtr FPDFBookmark_GetFirstChild_native(IntPtr document, IntPtr bookmark);

  /// <summary>
  /// Get first child of a bookmark item, or first top level bookmark item.
  /// </summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="bookmark">Handle to the current bookmark. Can be IntPtr.Zero if you want to get the first top level item.</param>
  /// <returns>Handle to the first child or top level bookmark item. IntPtr.Zero if no child or top level bookmark found</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBookmark_GetFirstChild(IntPtr document, IntPtr bookmark)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBookmark_GetFirstChild_native(document, bookmark);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBookmark_GetNextSibling", SetLastError = true)]
  private static extern IntPtr FPDFBookmark_GetNextSibling_native(IntPtr document, IntPtr bookmark);

  /// <summary>Get next bookmark item on the same level.</summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="bookmark">Handle to the current bookmark. Cannot be IntPtr.Zero</param>
  /// <returns>Handle to the next bookmark item on the same level. IntPtr.Zero if this is the last bookmark on this level.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBookmark_GetNextSibling(IntPtr document, IntPtr bookmark)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBookmark_GetNextSibling_native(document, bookmark);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBookmark_Find", SetLastError = true)]
  private static extern IntPtr FPDFBookmark_Find_native(IntPtr document, [MarshalAs(UnmanagedType.LPWStr)] string title);

  /// <summary>
  /// Find a bookmark in the document, using the bookmark title
  /// </summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions</param>
  /// <param name="title">The string for the bookmark title to be searched. Can't be NULL.</param>
  /// <returns>Handle to the found bookmark item. IntPtr.Zero if the title can't be found.</returns>
  /// <remarks>It always returns the first found bookmark if more than one bookmarks have the same title. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBookmark_Find(IntPtr document, string title)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBookmark_Find_native(document, title);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBookmark_GetTitle", CharSet = CharSet.Unicode, SetLastError = true)]
  private static extern int FPDFBookmark_GetTitle_native(IntPtr bookmark, [MarshalAs(UnmanagedType.LPArray)] byte[] title, int buflen);

  /// <summary>Get title of a bookmark</summary>
  /// <param name="bookmark">Handle to the bookmark.</param>
  /// <returns> return title of a bookmark</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFBookmark_GetTitle(IntPtr bookmark)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int num = 0;
        byte[] title = (byte[]) null;
        int titleNative = Pdfium.FPDFBookmark_GetTitle_native(bookmark, title, 0);
        byte[] numArray = new byte[titleNative];
        num = Pdfium.FPDFBookmark_GetTitle_native(bookmark, numArray, titleNative);
        return Encoding.Unicode.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBookmark_GetAction", SetLastError = true)]
  private static extern IntPtr FPDFBookmark_GetAction_native(IntPtr bookmark);

  /// <summary>Get the action associated with a bookmark item</summary>
  /// <param name="bookmark">Handle to the bookmark</param>
  /// <returns>Handle to the action data. IntPtr.Zero if no action is associated with this bookmark.
  /// In this case, the application should try <see cref="M:Patagames.Pdf.Pdfium.FPDFBookmark_GetDest(System.IntPtr,System.IntPtr)" /></returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBookmark_GetAction(IntPtr bookmark)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBookmark_GetAction_native(bookmark);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBookmark_GetDest", SetLastError = true)]
  private static extern IntPtr FPDFBookmark_GetDest_native(IntPtr document, IntPtr bookmark);

  /// <summary>Get the destination associated with a bookmark item</summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /></param>
  /// <param name="bookmark">Handle to the bookmark</param>
  /// <returns>Handle to the destination data. IntPtr.Zero if no destination is associated with this bookmark</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBookmark_GetDest(IntPtr document, IntPtr bookmark)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBookmark_GetDest_native(document, bookmark);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAction_GetType", SetLastError = true)]
  private static extern uint FPDFAction_GetType_native(IntPtr action);

  /// <summary>Get type of an action</summary>
  /// <param name="action">Handle to the action </param>
  /// <returns>
  /// A type number as defined below
  /// 0 - Unsupported action type.
  /// 1 - Go to a destination within current document.
  /// 2 - Go to a destination within another document.
  /// 3 - Universal Resource Identifier, including web pages and other Internet based resources.
  /// 4 - Launch an application or open a file.
  /// </returns>
  [HandleProcessCorruptedStateExceptions]
  public static ActionTypes FPDFAction_GetType(IntPtr action)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (ActionTypes) Pdfium.FPDFAction_GetType_native(action);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAction_GetDest", SetLastError = true)]
  private static extern IntPtr FPDFAction_GetDest_native(IntPtr document, IntPtr action);

  /// <summary>Get destination of an action</summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="action">Handle to the action. It must be a GOTO or REMOTEGOTO action</param>
  /// <returns>Handle to the destination data</returns>
  /// <remarks>In case of remote goto action, the application should first use <see cref="M:Patagames.Pdf.Pdfium.FPDFAction_GetFilePath(System.IntPtr)" />
  /// to get file path, then load that particular document, and use its document handle to call this function</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFAction_GetDest(IntPtr document, IntPtr action)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFAction_GetDest_native(document, action);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAction_GetURIPath", SetLastError = true)]
  private static extern int FPDFAction_GetURIPath_native(
    IntPtr document,
    IntPtr action,
    [MarshalAs(UnmanagedType.LPArray)] byte[] uri,
    int buflen);

  /// <summary>Get URI path of a URI action</summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="action">Handle to the action. Must be a URI action </param>
  /// <returns>URI path of a URI action</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFAction_GetURIPath(IntPtr document, IntPtr action)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int num = 0;
        byte[] uri = (byte[]) null;
        int uriPathNative = Pdfium.FPDFAction_GetURIPath_native(document, action, uri, 0);
        if (uriPathNative == 0)
          return "";
        byte[] numArray = new byte[uriPathNative];
        num = Pdfium.FPDFAction_GetURIPath_native(document, action, numArray, uriPathNative);
        return Encoding.ASCII.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDest_GetPageIndex", SetLastError = true)]
  private static extern uint FPDFDest_GetPageIndex_native(IntPtr document, IntPtr destination);

  /// <summary>Get page index of a destination</summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="destination">Handle to the destination. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFAction_GetDest(System.IntPtr,System.IntPtr)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFBookmark_GetDest(System.IntPtr,System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_GetDest(System.IntPtr,System.IntPtr)" /> functions.</param>
  /// <returns>The page index. Starting from 0 for the first page</returns>
  [HandleProcessCorruptedStateExceptions]
  public static uint FPDFDest_GetPageIndex(IntPtr document, IntPtr destination)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDest_GetPageIndex_native(document, destination);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAction_GetRemoteDest", SetLastError = true)]
  private static extern int FPDFAction_GetRemoteDest_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>
  /// Get th e name of named destination in a remote document for GoToR and GoToE action.
  /// </summary>
  /// <param name="handle">A handle to the action. May be <see cref="F:Patagames.Pdf.Enums.ActionTypes.ExternalDoc" /> or <see cref="F:Patagames.Pdf.Enums.ActionTypes.EmbeddedDoc" /> only.</param>
  /// <returns>A string value representing the destination in the remote document.</returns>
  /// <remarks>The string is decoding using the <see cref="P:Patagames.Pdf.Pdfium.DefaultAnsiEncoding" /> property.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFAction_GetRemoteDest(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] buffer = (byte[]) null;
        int remoteDestNative = Pdfium.FPDFAction_GetRemoteDest_native(handle, buffer, 0);
        if (remoteDestNative <= 0)
          return (string) null;
        byte[] numArray = new byte[remoteDestNative];
        return Pdfium.FPDFAction_GetRemoteDest_native(handle, numArray, remoteDestNative) <= 0 ? (string) null : Pdfium.DefaultAnsiEncoding.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_GetLinkAtPoint", SetLastError = true)]
  private static extern IntPtr FPDFLink_GetLinkAtPoint_native(IntPtr page, double x, double y);

  /// <summary>Find a link at specified point on a document page</summary>
  /// <param name="page">Handle to the document page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="x">The x coordinate of the point, specified in page coordinate system</param>
  /// <param name="y">The y coordinate of the point, specified in page coordinate system</param>
  /// <returns>Handle to the link. IntPtr.Zero if there’s no link at that point.</returns>
  /// <remarks>The point coordinate are specified in page coordinate system.
  /// You can convert coordinate from screen system to page system using <see cref="M:Patagames.Pdf.Pdfium.FPDF_DeviceToPage(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Patagames.Pdf.Enums.PageRotate,System.Int32,System.Int32,System.Double@,System.Double@)" /> function</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFLink_GetLinkAtPoint(IntPtr page, double x, double y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_GetLinkAtPoint_native(page, x, y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_GetDest", SetLastError = true)]
  private static extern IntPtr FPDFLink_GetDest_native(IntPtr document, IntPtr link);

  /// <summary>Get destination info of a link.</summary>
  /// <param name="document">Handle to the document.</param>
  /// <param name="link">Handle to the link. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_GetLinkAtPoint(System.IntPtr,System.Double,System.Double)" /> function</param>
  /// <returns>Handle to the destination. IntPtr.Zero if there is no destination associated with the link,
  /// in this case the application should try <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_GetAction(System.IntPtr)" /> </returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFLink_GetDest(IntPtr document, IntPtr link)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_GetDest_native(document, link);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_GetAction", SetLastError = true)]
  private static extern IntPtr FPDFLink_GetAction_native(IntPtr link);

  /// <summary>Get action info of a link</summary>
  /// <param name="link">Handle to the link. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_GetLinkAtPoint(System.IntPtr,System.Double,System.Double)" /></param>
  /// <returns>Handle to the action. IntPtr.Zero if there is no action associated with the link.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFLink_GetAction(IntPtr link)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_GetAction_native(link);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_Enumerate", SetLastError = true)]
  private static extern int FPDFLink_Enumerate_native(
    IntPtr page,
    [MarshalAs(UnmanagedType.I4)] ref int start_pos,
    out IntPtr link_anno);

  /// <summary>
  /// This function would enumerate all the link annotations in a single PDF page.
  /// </summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="start_pos">The start position to enumerate the link annotations, which should be specified to start
  /// from -	0 for the first call, and would receive the next position for enumerating to start from.</param>
  /// <param name="link_annot">Receive the link handle</param>
  /// <returns>TRUE if succceed, else False;</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFLink_Enumerate(IntPtr page, ref int start_pos, out IntPtr link_annot)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_Enumerate_native(page, ref start_pos, out link_annot) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_GetAnnotRect", SetLastError = true)]
  private static extern int FPDFLink_GetAnnotRect_native(IntPtr link_annot, [MarshalAs(UnmanagedType.Struct)] out FS_RECTF rect);

  /// <summary>
  /// Get the annotation rectangle. (Specified by the Ў°RectЎ± entry of annotation dictionary).
  /// </summary>
  /// <param name="link_annot">Handle to the link annotation.</param>
  /// <param name="rect">The annotation rect.</param>
  /// <returns>TRUE if succceed, else False;</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFLink_GetAnnotRect(IntPtr link_annot, out FS_RECTF rect)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_GetAnnotRect_native(link_annot, out rect) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_CountQuadPoints", SetLastError = true)]
  private static extern int FPDFLink_CountQuadPoints_native(IntPtr link_annot);

  /// <summary>
  /// Get the count of quadrilaterals fo the link annotation
  /// </summary>
  /// <param name="link_annot">Handle to the link annotation received by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_Enumerate(System.IntPtr,System.Int32@,System.IntPtr@)" /> function.</param>
  /// <returns>The count of quadrilaterals.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFLink_CountQuadPoints(IntPtr link_annot)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_CountQuadPoints_native(link_annot);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_GetQuadPoints", SetLastError = true)]
  private static extern int FPDFLink_GetQuadPoints_native(
    IntPtr link_annot,
    int quadIndex,
    [MarshalAs(UnmanagedType.Struct)] out FS_QUADPOINTSF quadPoints);

  /// <summary>
  /// Get the quadrilateral from link annotation  at the specified index.
  /// </summary>
  /// <param name="link_annot">Handle to the link annotation received by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_Enumerate(System.IntPtr,System.Int32@,System.IntPtr@)" /> function.</param>
  /// <param name="quadIndex">The index of the quadrilateral.</param>
  /// <param name="quadPoints">Receive the quadrilateral.</param>
  /// <returns>True if succeed, else False</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFLink_GetQuadPoints(
    IntPtr link_annot,
    int quadIndex,
    out FS_QUADPOINTSF quadPoints)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_GetQuadPoints_native(link_annot, quadIndex, out quadPoints) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetMetaText", CharSet = CharSet.Unicode, SetLastError = true)]
  private static extern int FPDF_GetMetaText_native(
    IntPtr document,
    [MarshalAs(UnmanagedType.LPStr)] string tag,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>Get meta-data tag content from document.</summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="tag">The tag to retrieve.</param>
  /// <returns>The meta-data tag content.</returns>
  /// <overloads>Get meta-data tag content from document.</overloads>
  /// <remarks>
  ///  Currently, The tag can be one of "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "CreationDate", or "ModDate". For detailed explanation of these tags and their respective values, please refer to <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.6</a>, section 10.2.1, "Document Information Dictionary".
  /// </remarks>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7</seealso>
  public static string FPDF_GetMetaText(IntPtr document, DocumentTags tag)
  {
    string enumDescription = Pdfium.GetEnumDescription((Enum) tag);
    return Pdfium.FPDF_GetMetaText(document, enumDescription);
  }

  /// <summary>Get meta-data tag content from document.</summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="tag">The tag to retrieve.</param>
  /// <returns>The meta-data tag content.</returns>
  /// <overloads>Get meta-data tag content from document.</overloads>
  /// <remarks>
  ///  Currently, The tag can be one of "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "CreationDate", or "ModDate". For detailed explanation of these tags and their respective values, please refer to <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.6</a>, section 10.2.1, "Document Information Dictionary".
  /// </remarks>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7</seealso>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDF_GetMetaText(IntPtr document, string tag)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int num = 0;
        byte[] buffer = (byte[]) null;
        int metaTextNative = Pdfium.FPDF_GetMetaText_native(document, tag, buffer, 0);
        if (metaTextNative == 0)
          return "";
        byte[] numArray = new byte[metaTextNative];
        num = Pdfium.FPDF_GetMetaText_native(document, tag, numArray, metaTextNative);
        return Encoding.Unicode.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SetMetaText", SetLastError = true)]
  private static extern bool FPDF_SetMetaText_native(IntPtr document, [MarshalAs(UnmanagedType.LPStr)] string tag, [MarshalAs(UnmanagedType.LPWStr)] string text);

  /// <summary>
  /// Set the specified text to document meta-data under the specified tag.
  /// </summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="tag">The tag to which text should be set.</param>
  /// <param name="text">The text to be set.</param>
  /// <returns>
  /// Returns TRUE if successful, FALSE otherwise. Returns FALSE if Info dictionary does not exists.
  /// </returns>
  /// <overloads>Set the specified text to document meta-data under the specified tag.</overloads>
  /// <remarks>
  ///  Currently, The tag can be one of "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "CreationDate", or "ModDate". For detailed explanation of these tags and their respective values, please refer to <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.6</a>, section 10.2.1, "Document Information Dictionary".
  /// </remarks>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7</seealso>
  public static bool FPDF_SetMetaText(IntPtr document, DocumentTags tag, string text)
  {
    string enumDescription = Pdfium.GetEnumDescription((Enum) tag);
    return Pdfium.FPDF_SetMetaText(document, enumDescription, text);
  }

  /// <summary>
  /// Set specidied text to document meta-data under specified tag.
  /// </summary>
  /// <param name="document">Handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="tag">The tag to be set.</param>
  /// <param name="text">The text to be set</param>
  /// <returns>
  /// Returns TRUE if successful, FALSE otherwise. Returns FALSE if Info dictionary does not exists.
  /// </returns>
  /// <remarks>
  ///  Currently, The tag can be one of "Title", "Author", "Subject", "Keywords", "Creator", "Producer", "CreationDate", or "ModDate". For detailed explanation of these tags and their respective values, please refer to <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.6</a>, section 10.2.1, "Document Information Dictionary".
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_SetMetaText(IntPtr document, string tag, string text)
  {
    if (tag == "Trapped")
      throw new NotSupportedException(Error.err0055);
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDF_SetMetaText_native(document, tag, text));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CreateNewDocument", SetLastError = true)]
  private static extern IntPtr FPDF_CreateNewDocument_native();

  /// <summary>Create a new PDF document.</summary>
  /// <returns>A handle to a document. If failed, IntPtr.Zero is returned</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_CreateNewDocument()
  {
    Pdfium.CheckForInit();
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_CreateNewDocument_native();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_New", SetLastError = true)]
  private static extern IntPtr FPDFPage_New_native(
    IntPtr document,
    int page_index,
    double width,
    double height);

  /// <summary>Construct an empty page</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="page_index">The index of a page</param>
  /// <param name="width">The page width</param>
  /// <param name="height">The page height.</param>
  /// <returns>The handle to a page. IntPtr.Zero if any error occurs.</returns>
  /// <remarks>Loaded page can be deleted by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_Delete(System.IntPtr,System.Int32)" /> functions</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPage_New(IntPtr document, int page_index, double width, double height)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_New_native(document, page_index, width, height);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_Delete", SetLastError = true)]
  private static extern void FPDFPage_Delete_native(IntPtr document, int page_index);

  /// <summary>Delete a PDF page.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" />.</param>
  /// <param name="page_index">The index of a page.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_Delete(IntPtr document, int page_index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_Delete_native(document, page_index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GetRotation", SetLastError = true)]
  private static extern int FPDFPage_GetRotation_native(IntPtr page);

  /// <summary>
  /// Get the page rotation. One of following values will be returned：0(0), 1(90), 2(180), 3(270).
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" />.</param>
  /// <returns>The PDF page rotation</returns>
  /// <remarks>The PDF page rotates clockwise.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static PageRotate FPDFPage_GetRotation(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int rotation = Pdfium.FPDFPage_GetRotation_native(page) % 4;
        if (rotation < 0)
          rotation = 4 + rotation;
        return (PageRotate) rotation;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_SetRotation", SetLastError = true)]
  private static extern void FPDFPage_SetRotation_native(IntPtr page, int rotate);

  /// <summary>
  /// Set page rotation. One of following values will be set: 0(0), 1(90), 2(180), 3(270).
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" />.</param>
  /// <param name="rotate">The value of the PDF page rotation</param>
  /// <remarks>The PDF page rotates clockwise. When it’s done, the content in this pagewill be changed.
  /// You must call the <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> to reload the page</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_SetRotation(IntPtr page, PageRotate rotate)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_SetRotation_native(page, (int) rotate);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_AddObject", SetLastError = true)]
  private static extern void FPDFPage_AddObject_native(IntPtr page, IntPtr page_object);

  /// <summary>
  /// Add an object to the page. The page object is automatically freed.
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" />.</param>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObj" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObjEx(System.String,System.Int32,System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewPathObj" />.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_AddObject(IntPtr page, IntPtr page_object)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_AddObject_native(page, page_object);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_InsertObjectEx", SetLastError = true)]
  private static extern void FPDFPage_InsertObject_native(
    IntPtr page,
    IntPtr page_object,
    int index);

  /// <summary>
  /// Add an object to the objects coolection after specified index. The page object is automatically freed.
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" />.</param>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObj" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObjEx(System.String,System.Int32,System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewPathObj" />.</param>
  /// <param name="index">&gt;The zero-based index at which object should be inserted.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_InsertObject(IntPtr page, IntPtr page_object, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_InsertObject_native(page, page_object, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_RemoveObject", SetLastError = true)]
  private static extern void FPDFPage_RemoveObject_native(IntPtr page, int index);

  /// <summary>Remove object from the collection at specified index.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" />.</param>
  /// <param name="index">The zero-based index of the item to remove.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_RemoveObject(IntPtr page, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_RemoveObject_native(page, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_CountObject", SetLastError = true)]
  private static extern int FPDFPage_CountObject_native(IntPtr page);

  /// <summary>Get number of page objects inside the page</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" />.</param>
  /// <returns>The number of the page object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFPage_CountObject(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_CountObject_native(page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GetObject", SetLastError = true)]
  private static extern IntPtr FPDFPage_GetObject_native(IntPtr page, int index);

  /// <summary>Get page object by index</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" />.</param>
  /// <param name="index">The index of a page object.</param>
  /// <returns>The Handle to the page object. IntPtr.Zero for failed</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPage_GetObject(IntPtr page, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_GetObject_native(page, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_HasTransparency", SetLastError = true)]
  private static extern int FPDFPage_HasTransparency_native(IntPtr page);

  /// <summary>
  /// Check whether the content of specified PDF page contains transparency or not.
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" />.</param>
  /// <returns>TRUE means that the PDF page does contains transparency. Otherwise, returns FALSE</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_HasTransparency(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_HasTransparency_native(page) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GenerateContent", SetLastError = true)]
  private static extern int FPDFPage_GenerateContent_native(IntPtr page);

  /// <summary>Generate PDF Page content.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" /></param>
  /// <returns>True if successful, false otherwise.</returns>
  /// <remarks>Before you save the page to a file, or reload the page, you must call the <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GenerateContent(System.IntPtr)" /> function  or any changes to <paramref name="page" /> will be lost.
  /// <note type="note">Only images may be generated by this method.</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_GenerateContent(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_GenerateContent_native(page) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_GenerateContentEx", SetLastError = true)]
  private static extern bool FPDFPage_GenerateContentEx_native(
    IntPtr page,
    IntPtr objLisе,
    [MarshalAs(UnmanagedType.FunctionPtr)] Pdfium.GenerateContentCallback callback,
    IntPtr userData);

  /// <summary>
  /// Generate PDF Page content from the specified list of page objects.
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" /></param>
  /// <param name="objList">Handle to a list of objects, returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetListFromPage(System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetListFromForm(System.IntPtr)" />. Can be IntPtr.Zero</param>
  /// <param name="callback">A delegate that represents an application-defined callback function. For more information, see <see cref="T:Patagames.Pdf.Pdfium.GenerateContentCallback" /></param>
  /// <param name="userData">An application-defined data to be passed to the callback function.</param>
  /// <returns>True if successful, false otherwise. If user cancel generation, return value is TRUE.</returns>
  /// <remarks>
  /// If handle to the list object is IntPtr.Zero then the page content will be generated, otherwise the content of the specified list.
  /// You should generate page content before you save or reload it or any changes to <paramref name="page" /> will be lost.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPage_GenerateContentEx(
    IntPtr page,
    IntPtr objList,
    Pdfium.GenerateContentCallback callback,
    IntPtr userData)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPage_GenerateContentEx_native(page, objList, callback, userData);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Generate PDF Page content from the specified list of page objects.
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" /></param>
  /// <param name="objList">Handle to a list of objects, returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetListFromPage(System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetListFromForm(System.IntPtr)" />. Can be IntPtr.Zero</param>
  /// <returns>True if successful, false otherwise.</returns>
  /// <remarks>
  /// If handle to the list object is IntPtr.Zero then the page content will be generated, otherwise the content of the specified list.
  /// You should generate page content before you save or reload it or any changes to <paramref name="page" /> will be lost.
  /// </remarks>
  public static bool FPDFPage_GenerateContentEx(IntPtr page, IntPtr objList)
  {
    return Pdfium.FPDFPage_GenerateContentEx(page, objList, (Pdfium.GenerateContentCallback) null, IntPtr.Zero);
  }

  /// <summary>Generate PDF Page content.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" /></param>
  /// <returns>True if successful, false otherwise.</returns>
  /// <remarks>
  /// Before you save the page to a file, or reload the page, you must call the <see cref="O:Patagames.Pdf.Pdfium.FPDFPage_GenerateContentEx" /> function  or any changes to <paramref name="page" /> will be lost.
  /// </remarks>
  public static bool FPDFPage_GenerateContentEx(IntPtr page)
  {
    return Pdfium.PLE(Pdfium.FPDFPage_GenerateContentEx(page, IntPtr.Zero, (Pdfium.GenerateContentCallback) null, IntPtr.Zero));
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GenerateContentToStream", SetLastError = true)]
  private static extern bool FPDF_GenerateContentToStream_native(
    IntPtr doc,
    IntPtr objList,
    IntPtr stream,
    IntPtr resDict,
    [MarshalAs(UnmanagedType.FunctionPtr)] Pdfium.GenerateContentCallback callback,
    IntPtr userData);

  /// <summary>
  /// Generate stream content from the specified  list of object and write it to the stream.
  /// </summary>
  /// <param name="doc">Handle to a document.</param>
  /// <param name="objList">Handle to a list of objects, returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetListFromPage(System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetListFromForm(System.IntPtr)" /></param>
  /// <param name="stream">Handle to the Stream object.</param>
  /// <param name="resDict">Handle to dictionary, where the rosurces will be generated. If IntPtr.Zero, then resources will be generated to the stream dictionary.</param>
  /// <param name="callback">A delegate that represents an application-defined callback function. For more information, see <see cref="T:Patagames.Pdf.Pdfium.GenerateContentCallback" /></param>
  /// <param name="userData">An application-defined data to be passed to the callback function.</param>
  /// <returns>True if successful, false otherwise. If user cancel generation, return value is TRUE.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_GenerateContentToStream(
    IntPtr doc,
    IntPtr objList,
    IntPtr stream,
    IntPtr resDict,
    Pdfium.GenerateContentCallback callback,
    IntPtr userData)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GenerateContentToStream_native(doc, objList, stream, resDict, callback, userData);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Generate stream content from the specified  list of object and write it to the stream.
  /// </summary>
  /// <param name="doc">Handle to a document.</param>
  /// <param name="objList">Handle to a list of objects, returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetListFromPage(System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetListFromForm(System.IntPtr)" /></param>
  /// <param name="stream">Handle to the Stream object.</param>
  /// <param name="resDict">Handle to dictionary, where the rosurces will be generated. If IntPtr.Zero, then resources will be generated to the stream dictionary.</param>
  /// <returns>False if any error is occured, otherwise true.</returns>
  public static bool FPDF_GenerateContentToStream(
    IntPtr doc,
    IntPtr objList,
    IntPtr stream,
    IntPtr resDict)
  {
    return Pdfium.PLE(Pdfium.FPDF_GenerateContentToStream(doc, objList, stream, resDict, (Pdfium.GenerateContentCallback) null, IntPtr.Zero));
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetListFromPage", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_GetListFromPage_native(IntPtr page);

  /// <summary>Get handle to the page objects list from page.</summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" /></param>
  /// <returns>Handle to the list.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPageObj_GetListFromPage(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_GetListFromPage_native(page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetListFromForm", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_GetListFromForm_native(IntPtr formContent);

  /// <summary>
  /// Get handle to the page objects list from form object.
  /// </summary>
  /// <param name="formContent">Handle to content of form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <returns>Handle to the list.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPageObj_GetListFromForm(IntPtr formContent)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_GetListFromForm_native(formContent);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_HasTransparency", SetLastError = true)]
  private static extern int FPDFPageObj_HasTransparency_native(IntPtr page_object);

  /// <summary>
  /// Check whether the specified PDF page object contains transparency or not.
  /// </summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObj" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObjEx(System.String,System.Int32,System.IntPtr)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewPathObj" /> and etc.</param>
  /// <returns>TRUE means that the PDF page object does contains transparency. Otherwise, returns FALSE.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPageObj_HasTransparency(IntPtr page_object)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_HasTransparency_native(page_object) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_Transform", SetLastError = true)]
  private static extern void FPDFPageObj_Transform_native(
    IntPtr page_object,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f);

  /// <summary>Transform (scale, rotate, shear, move) page object.</summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObj" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObjEx(System.String,System.Int32,System.IntPtr)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewPathObj" /> and etc.</param>
  /// <param name="a">The coefficient "a" of the matrix</param>
  /// <param name="b">The coefficient "b" of the matrix</param>
  /// <param name="c">The coefficient "c" of the matrix</param>
  /// <param name="d">The coefficient "d" of the matrix</param>
  /// <param name="e">The coefficient "e" of the matrix</param>
  /// <param name="f">The coefficient "f" of the matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_Transform(
    IntPtr page_object,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_Transform_native(page_object, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPage_TransformAnnots", SetLastError = true)]
  private static extern void FPDFPage_TransformAnnots_native(
    IntPtr page,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f);

  /// <summary>
  /// Transform (scale, rotate, shear, move) all annots in a page.
  /// </summary>
  /// <param name="page">Handle to a page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_New(System.IntPtr,System.Int32,System.Double,System.Double)" /> and others</param>
  /// <param name="a">The coefficient "a" of the matrix</param>
  /// <param name="b">The coefficient "b" of the matrix</param>
  /// <param name="c">The coefficient "c" of the matrix</param>
  /// <param name="d">The coefficient "d" of the matrix</param>
  /// <param name="e">The coefficient "e" of the matrix</param>
  /// <param name="f">The coefficient "f" of the matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPage_TransformAnnots(
    IntPtr page,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPage_TransformAnnots_native(page, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_ImportPages", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDF_ImportPages_native(
    IntPtr dest_doc,
    IntPtr src_doc,
    [MarshalAs(UnmanagedType.LPStr)] string pagerange,
    int index);

  /// <summary>Import some pages to a PDF document.</summary>
  /// <param name="dest_doc">The destination document which add the pages.</param>
  /// <param name="src_doc">A document to be imported.</param>
  /// <param name="pagerange">A page range string, Such as "1,3,5-7". If this parameter is NULL, it would import all pages in src_doc.</param>
  /// <param name="index">The page index wanted to insert from.</param>
  /// <returns>TRUE for succeed, FALSE for Failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_ImportPages(
    IntPtr dest_doc,
    IntPtr src_doc,
    string pagerange,
    int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_ImportPages_native(dest_doc, src_doc, pagerange, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CopyViewerPreferences", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDF_CopyViewerPreferences_native(IntPtr dest_doc, IntPtr src_doc);

  /// <summary>
  /// Copy the viewer preferences from one PDF document to another
  /// </summary>
  /// <param name="dest_doc">Handle to document to write the viewer preferences to.</param>
  /// <param name="src_doc">Handle to document with the viewer preferences.</param>
  /// <returns>TRUE for success, FALSE for failure.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_CopyViewerPreferences(IntPtr dest_doc, IntPtr src_doc)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_CopyViewerPreferences_native(dest_doc, src_doc);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SaveAsCopy", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDF_SaveAsCopy_native(
    IntPtr document,
    [MarshalAs(UnmanagedType.LPStruct)] FPDF_FILEWRITE saveData,
    int flag);

  /// <summary>Saves the copy of specified document in custom way.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="saveData">A pointer to a custom file write structure</param>
  /// <param name="flag">The creating flags.</param>
  /// <returns>TRUE for succeed, FALSE for failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_SaveAsCopy(IntPtr document, FPDF_FILEWRITE saveData, SaveFlags flag)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_SaveAsCopy_native(document, saveData, (int) flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
      finally
      {
        GC.KeepAlive((object) saveData);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SaveWithVersion", SetLastError = true)]
  private static extern int FPDF_SaveWithVersion_native(
    IntPtr document,
    [MarshalAs(UnmanagedType.LPStruct)] FPDF_FILEWRITE saveData,
    int flag,
    int fileVersion);

  /// <summary>
  /// Same as function <see cref="M:Patagames.Pdf.Pdfium.FPDF_SaveAsCopy(System.IntPtr,Patagames.Pdf.FPDF_FILEWRITE,Patagames.Pdf.Enums.SaveFlags)" />, except the file Version of the saved document could be specified by user.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="saveData">A pointer to a custom file write structure</param>
  /// <param name="flag">The creating flags.</param>
  /// <param name="fileVersion">The PDF file Version. File Version: 14 for 1.4, 15 for 1.5, ...</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_SaveWithVersion(
    IntPtr document,
    FPDF_FILEWRITE saveData,
    SaveFlags flag,
    int fileVersion)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_SaveWithVersion_native(document, saveData, (int) flag, fileVersion) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
      finally
      {
        GC.KeepAlive((object) saveData);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_LoadPage", SetLastError = true)]
  private static extern IntPtr FPDFText_LoadPage_native(IntPtr page);

  /// <summary>Prepare information about all characters in a page.</summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <returns>A handle to the text page information structure. IntPtr.Zero if something goes wrong.</returns>
  /// <remarks>Application must call <see cref="M:Patagames.Pdf.Pdfium.FPDFText_ClosePage(System.IntPtr)" /> to release the text page information.
  /// If you didn’t purchase Text Module , this function will return IntPtr.Zero.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFText_LoadPage(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_LoadPage_native(page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_ClosePage", SetLastError = true)]
  private static extern void FPDFText_ClosePage_native(IntPtr text_page);

  /// <summary>
  /// Release all resources allocated for a text page information structure
  /// </summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFText_ClosePage(IntPtr text_page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFText_ClosePage_native(text_page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_CountChars", SetLastError = true)]
  private static extern int FPDFText_CountChars_native(IntPtr text_page);

  /// <summary>Get number of characters in a page</summary>
  /// <param name="text_page">Handle to a text page information structure returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function</param>
  /// <returns>Number of characters in the page. Return -1 for error.
  /// Generated characters, like additional space characters, new line characters, are also
  /// counted.</returns>
  /// <remarks>Characters in a page form a "stream", inside the stream, each character has an index.
  /// We will use the index parameters in many of FPDFTEXT functions. The first character in the
  /// page has an index value of zero.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFText_CountChars(IntPtr text_page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_CountChars_native(text_page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetUnicode", SetLastError = true)]
  private static extern uint FPDFText_GetUnicode_native(IntPtr text_page, int index);

  /// <summary>Get Unicode of a character in a page</summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function.</param>
  /// <param name="index">Zero-based index of the character</param>
  /// <returns>The Unicode of the particular character.
  /// If a character is not encoded in Unicode and Pdfium engine can't convert to Unicode,
  /// the return value will be zero.</returns>
  /// <overloads>Get Unicode of a character in a page</overloads>
  [HandleProcessCorruptedStateExceptions]
  public static uint FPDFText_GetUnicode(IntPtr text_page, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_GetUnicode_native(text_page, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Get Unicode of a character in a page</summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function.</param>
  /// <param name="index">Zero-based index of the character</param>
  /// <returns>The Unicode of the particular character.
  /// If a character is not encoded in Unicode and Pdfium engine can't convert to Unicode,
  /// the return value will be zero character (\0).</returns>
  public static char FPDFText_GetUnicodeEx(IntPtr text_page, int index)
  {
    uint unicode = Pdfium.FPDFText_GetUnicode(text_page, index);
    if (unicode == 0U)
      return char.MinValue;
    string str = Encoding.Unicode.GetString(BitConverter.GetBytes(unicode));
    return str.Length == 0 ? char.MinValue : str.ToCharArray()[0];
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetFontSizeEx", SetLastError = true)]
  private static extern void FPDFText_GetFontSize_native(
    IntPtr text_page,
    int index,
    out double size);

  /// <summary>Get the font size of a particular character</summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function</param>
  /// <param name="index">Zero-based index of the character.</param>
  /// <returns>The font size of the particular character, measured in points (about 1/72 inch). This is the typographic size of the font (so called "em size").</returns>
  [HandleProcessCorruptedStateExceptions]
  public static double FPDFText_GetFontSize(IntPtr text_page, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        double size = 0.0;
        Pdfium.FPDFText_GetFontSize_native(text_page, index, out size);
        return size;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetCharBox", SetLastError = true)]
  private static extern void FPDFText_GetCharBox_native(
    IntPtr text_page,
    int index,
    [MarshalAs(UnmanagedType.R8)] out double left,
    [MarshalAs(UnmanagedType.R8)] out double right,
    [MarshalAs(UnmanagedType.R8)] out double bottom,
    [MarshalAs(UnmanagedType.R8)] out double top);

  /// <summary>Get bounding box of a particular character</summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function</param>
  /// <param name="index">Zero-based index of the character.</param>
  /// <param name="left">Pointer to a double number receiving left position of the character box</param>
  /// <param name="right">Pointer to a double number receiving right position of the character box.</param>
  /// <param name="bottom">Pointer to a double number receiving bottom position of the character box</param>
  /// <param name="top">Pointer to a double number receiving top position of the character box.</param>
  /// <remarks>All positions are measured in PDF "user space"</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFText_GetCharBox(
    IntPtr text_page,
    int index,
    out double left,
    out double right,
    out double bottom,
    out double top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFText_GetCharBox_native(text_page, index, out left, out right, out bottom, out top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetCharIndexAtPos", SetLastError = true)]
  private static extern int FPDFText_GetCharIndexAtPos_native(
    IntPtr text_page,
    double x,
    double y,
    double xTolerance,
    double yTolerance);

  /// <summary>
  /// Get the index of a character at or nearby a certain position on the page
  /// </summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function</param>
  /// <param name="x">X position in PDF "user space"</param>
  /// <param name="y">Y position in PDF "user space"</param>
  /// <param name="xTolerance">An x-axis tolerance value for character hit detection, in point unit.</param>
  /// <param name="yTolerance">A y-axis tolerance value for character hit detection, in point unit</param>
  /// <returns>The zero-based index of the character at, or nearby the point (x,y).
  /// If there is no character at or nearby the point, return value will be -1.
  /// If an error occurs, -3 will be returned.
  /// </returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFText_GetCharIndexAtPos(
    IntPtr text_page,
    double x,
    double y,
    double xTolerance,
    double yTolerance)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_GetCharIndexAtPos_native(text_page, x, y, xTolerance, yTolerance);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetText", SetLastError = true)]
  private static extern int FPDFText_GetText_native(
    IntPtr text_page,
    int start_index,
    int count,
    [MarshalAs(UnmanagedType.LPArray)] byte[] result);

  /// <summary>Extract unicode text string from the page</summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function.</param>
  /// <param name="start_index">Index for the start characters</param>
  /// <param name="count">Number of characters to be extracted</param>
  /// <returns>Unicode text string from the page</returns>
  /// <remarks>This function ignores characters without unicode information</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFText_GetText(IntPtr text_page, int start_index, int count)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] numArray = new byte[count * 2 + 2];
        Pdfium.FPDFText_GetText_native(text_page, start_index, count, numArray);
        return Encoding.Unicode.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_CountRects", SetLastError = true)]
  private static extern int FPDFText_CountRects_native(
    IntPtr text_page,
    int start_index,
    int count);

  /// <summary>
  /// Count number of rectangular areas occupied by a segment of texts.
  /// </summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function</param>
  /// <param name="start_index">Index for the start characters</param>
  /// <param name="count">Number of characters</param>
  /// <returns>Number of rectangles. Zero for error</returns>
  /// <remarks>This function, along with <see cref="M:Patagames.Pdf.Pdfium.FPDFText_GetRect(System.IntPtr,System.Int32,System.Double@,System.Double@,System.Double@,System.Double@)" /> can be used by applications to detect the position
  /// on the page for a text segment, so proper areas can be highlighted or something. FPDFTEXT
  /// will automatically merge small character boxes into bigger one if those characters are on the
  /// same line and use same font settings.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFText_CountRects(IntPtr text_page, int start_index, int count)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_CountRects_native(text_page, start_index, count);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetRect", SetLastError = true)]
  private static extern void FPDFText_GetRect_native(
    IntPtr text_page,
    int index,
    [MarshalAs(UnmanagedType.R8)] out double left,
    [MarshalAs(UnmanagedType.R8)] out double top,
    [MarshalAs(UnmanagedType.R8)] out double right,
    [MarshalAs(UnmanagedType.R8)] out double bottom);

  /// <summary>
  /// Get a rectangular area from the result generated by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_CountRects(System.IntPtr,System.Int32,System.Int32)" />.
  /// </summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function</param>
  /// <param name="rect_index">Zero-based index for the rectangle</param>
  /// <param name="left">Pointer to a double value receiving the rectangle left boundary.</param>
  /// <param name="top">Pointer to a double value receiving the rectangle top boundary</param>
  /// <param name="right">Pointer to a double value receiving the rectangle right boundary.</param>
  /// <param name="bottom">Pointer to a double value receiving the rectangle bottom boundary</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFText_GetRect(
    IntPtr text_page,
    int rect_index,
    out double left,
    out double top,
    out double right,
    out double bottom)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFText_GetRect_native(text_page, rect_index, out left, out top, out right, out bottom);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetBoundedText", SetLastError = true)]
  private static extern int FPDFText_GetBoundedText_native(
    IntPtr text_page,
    double left,
    double top,
    double right,
    double bottom,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>
  /// Extract unicode text within a rectangular boundary on the page
  /// </summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function.</param>
  /// <param name="left">Left boundary</param>
  /// <param name="top">Top boundary</param>
  /// <param name="right">Right boundary</param>
  /// <param name="bottom">Bottom boundary.</param>
  /// <returns>Unicode text within a rectangular boundary on the page</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFText_GetBoundedText(
    IntPtr text_page,
    double left,
    double top,
    double right,
    double bottom)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int num = 0;
        byte[] buffer = (byte[]) null;
        int boundedTextNative = Pdfium.FPDFText_GetBoundedText_native(text_page, left, top, right, bottom, buffer, 0);
        if (boundedTextNative == 0)
          return "";
        byte[] numArray = new byte[boundedTextNative * 2 + 2];
        num = Pdfium.FPDFText_GetBoundedText_native(text_page, left, top, right, bottom, numArray, boundedTextNative);
        return Encoding.Unicode.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_FindStart", SetLastError = true)]
  private static extern IntPtr FPDFText_FindStart_native(
    IntPtr text_page,
    [MarshalAs(UnmanagedType.LPWStr)] string findwhat,
    FindFlags flags,
    int start_index);

  /// <summary>Start a search.</summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function.</param>
  /// <param name="findwhat">A unicode match pattern</param>
  /// <param name="flags">Option flags. See <see cref="T:Patagames.Pdf.Enums.FindFlags" /> for details </param>
  /// <param name="start_index">Start from this character. -1 for end of the page</param>
  /// <returns>A handle for the search context. <see cref="M:Patagames.Pdf.Pdfium.FPDFText_FindClose(System.IntPtr)" /> must be called to release this handle</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFText_FindStart(
    IntPtr text_page,
    string findwhat,
    FindFlags flags,
    int start_index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_FindStart_native(text_page, findwhat, flags, start_index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_FindNext", SetLastError = true)]
  private static extern int FPDFText_FindNext_native(IntPtr search_handle);

  /// <summary>Search in the direction from page start to end.</summary>
  /// <param name="search_handle">A search context handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_FindStart(System.IntPtr,System.String,Patagames.Pdf.Enums.FindFlags,System.Int32)" /></param>
  /// <returns>Whether a match is found</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFText_FindNext(IntPtr search_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_FindNext_native(search_handle) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_FindPrev", SetLastError = true)]
  private static extern int FPDFText_FindPrev_native(IntPtr search_handle);

  /// <summary>Search in the direction from page end to start.</summary>
  /// <param name="search_handle">A search context handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_FindStart(System.IntPtr,System.String,Patagames.Pdf.Enums.FindFlags,System.Int32)" /></param>
  /// <returns>Whether a match is found.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFText_FindPrev(IntPtr search_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_FindPrev_native(search_handle) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetSchResultIndex", SetLastError = true)]
  private static extern int FPDFText_GetSchResultIndex_native(IntPtr search_handle);

  /// <summary>
  /// Get the starting character index of the search result.
  /// </summary>
  /// <param name="search_handle">A search context handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_FindStart(System.IntPtr,System.String,Patagames.Pdf.Enums.FindFlags,System.Int32)" />.</param>
  /// <returns>Index for the starting character</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFText_GetSchResultIndex(IntPtr search_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_GetSchResultIndex_native(search_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_GetSchCount", SetLastError = true)]
  private static extern int FPDFText_GetSchCount_native(IntPtr search_handle);

  /// <summary>
  /// Get the number of matched characters in the search result
  /// </summary>
  /// <param name="search_handle">A search context handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_FindStart(System.IntPtr,System.String,Patagames.Pdf.Enums.FindFlags,System.Int32)" />.</param>
  /// <returns>Number of matched characters</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFText_GetSchCount(IntPtr search_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFText_GetSchCount_native(search_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFText_FindClose", SetLastError = true)]
  private static extern void FPDFText_FindClose_native(IntPtr search_handle);

  /// <summary>Release a search context</summary>
  /// <param name="search_handle">A search context handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_FindStart(System.IntPtr,System.String,Patagames.Pdf.Enums.FindFlags,System.Int32)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFText_FindClose(IntPtr search_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFText_FindClose_native(search_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_LoadWebLinks", SetLastError = true)]
  private static extern IntPtr FPDFLink_LoadWebLinks_native(IntPtr text_page);

  /// <summary>Prepare information about weblinks in a page</summary>
  /// <param name="text_page">Handle to a text page information structure. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFText_LoadPage(System.IntPtr)" /> function</param>
  /// <returns>A handle to the page's links information structure. IntPtr.Zero if something goes wrong</returns>
  /// <remarks>
  /// Weblinks are those links implicitly embedded in PDF pages. PDF also has a type of annotation
  /// called "link", FPDFTEXT doesn't deal with that kind of link. FPDFTEXT weblink feature is
  /// useful for automatically detecting links in the page contents. For example, things like
  /// "http://www.patagames.com" will be detected, so applications can allow user to click on those
  /// characters to activate the link, even the PDF doesn't come with link annotations.
  /// <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_CloseWebLinks(System.IntPtr)" /> must be called to release resources.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFLink_LoadWebLinks(IntPtr text_page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_LoadWebLinks_native(text_page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_CountWebLinks", SetLastError = true)]
  private static extern int FPDFLink_CountWebLinks_native(IntPtr link_page);

  /// <summary>Count number of detected web links.</summary>
  /// <param name="link_page">Handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_LoadWebLinks(System.IntPtr)" />.</param>
  /// <returns>Number of detected web links.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFLink_CountWebLinks(IntPtr link_page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_CountWebLinks_native(link_page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_GetURL", SetLastError = true)]
  private static extern int FPDFLink_GetURL_native(
    IntPtr link_page,
    int link_index,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>Fetch the URL information for a detected web link.</summary>
  /// <param name="link_page">Handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_LoadWebLinks(System.IntPtr)" />.</param>
  /// <param name="link_index">Zero-based index for the link</param>
  /// <returns>URL information for a detected web link</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFLink_GetURL(IntPtr link_page, int link_index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] buffer = (byte[]) null;
        int num = 0;
        int urlNative = Pdfium.FPDFLink_GetURL_native(link_page, link_index, buffer, 0);
        if (urlNative <= 0)
          return "";
        byte[] numArray = new byte[urlNative * 2 + 2];
        num = Pdfium.FPDFLink_GetURL_native(link_page, link_index, numArray, urlNative);
        return Encoding.Unicode.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_CountRects", SetLastError = true)]
  private static extern int FPDFLink_CountRects_native(IntPtr link_page, int link_index);

  /// <summary>Count number of rectangular areas for the link.</summary>
  /// <param name="link_page">Handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_LoadWebLinks(System.IntPtr)" />.</param>
  /// <param name="link_index">Zero-based index for the link.</param>
  /// <returns>Number of rectangular areas for the link.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFLink_CountRects(IntPtr link_page, int link_index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFLink_CountRects_native(link_page, link_index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_GetRect", SetLastError = true)]
  private static extern void FPDFLink_GetRect_native(
    IntPtr link_page,
    int link_index,
    int rect_index,
    [MarshalAs(UnmanagedType.R8)] out double left,
    [MarshalAs(UnmanagedType.R8)] out double top,
    [MarshalAs(UnmanagedType.R8)] out double right,
    [MarshalAs(UnmanagedType.R8)] out double bottom);

  /// <summary>Fetch the boundaries of a rectangle for a link</summary>
  /// <param name="link_page">Handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_LoadWebLinks(System.IntPtr)" />.</param>
  /// <param name="link_index">Zero-based index for the link</param>
  /// <param name="rect_index">Zero-based index for a rectangle</param>
  /// <param name="left">Pointer to a double value receiving the rectangle left boundary</param>
  /// <param name="top">Pointer to a double value receiving the rectangle top boundar</param>
  /// <param name="right">Pointer to a double value receiving the rectangle right boundary</param>
  /// <param name="bottom">Pointer to a double value receiving the rectangle bottom boundary</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFLink_GetRect(
    IntPtr link_page,
    int link_index,
    int rect_index,
    out double left,
    out double top,
    out double right,
    out double bottom)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFLink_GetRect_native(link_page, link_index, rect_index, out left, out top, out right, out bottom);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFLink_CloseWebLinks", SetLastError = true)]
  private static extern void FPDFLink_CloseWebLinks_native(IntPtr link_page);

  /// <summary>Release resources used by weblink feature.</summary>
  /// <param name="link_page">Handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFLink_LoadWebLinks(System.IntPtr)" />.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFLink_CloseWebLinks(IntPtr link_page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFLink_CloseWebLinks_native(link_page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_LoadDocument", SetLastError = true)]
  private static extern IntPtr FPDF_LoadDocument_native([MarshalAs(UnmanagedType.LPStr)] string file_path, [MarshalAs(UnmanagedType.LPStr)] string password);

  /// <summary>Open and load a PDF document.</summary>
  /// <param name="file_path">Path to the PDF file (including extension)</param>
  /// <param name="password">A string used as the password for PDF file. If no password needed, empty or NULL can be used</param>
  /// <returns>A handle to the loaded document. If failed, IntPtr.Zero is returned</returns>
  /// <remarks>Loaded document can be closed by <see cref="M:Patagames.Pdf.Pdfium.FPDF_CloseDocument(System.IntPtr)" />.
  /// If this function fails, you can use <see cref="M:Patagames.Pdf.Pdfium.FPDF_GetLastError" /> to retrieve the reason why it fails.
  /// <note type="note">
  /// With the trial version the documents which size is smaller than 1024 Kb, or greater than 10 Mb can be loaded without any restrictions. For other documents the allowed ranges is 1.5 - 2 Mb; 2.5 - 3 Mb; 3.5 - 4 Mb; 4.5 - 5 Mb and so on.
  /// </note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_LoadDocument(string file_path, string password = "")
  {
    Pdfium.CheckForInit();
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_LoadDocument_native(file_path, password);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_LoadMemDocument", SetLastError = true)]
  private static extern IntPtr FPDF_LoadMemDocument_native(
    [MarshalAs(UnmanagedType.LPArray)] byte[] file_content,
    [MarshalAs(UnmanagedType.I4)] int content_size,
    [MarshalAs(UnmanagedType.LPStr)] string password);

  /// <summary>Open and load a PDF document from memory.</summary>
  /// <param name="file_content">Pointer to a buffer containing the PDF document.</param>
  /// <param name="content_size">Number of bytes in the PDF document.</param>
  /// <param name="password">A string used as the password for PDF file. If no password needed, empty or NULL can be used</param>
  /// <returns>A handle to the loaded document. If failed, IntPtr.Zero is returned.</returns>
  /// <remarks>
  /// The memory buffer must remain valid when the document is open. Loaded document can be
  /// closed by <see cref="M:Patagames.Pdf.Pdfium.FPDF_CloseDocument(System.IntPtr)" />.
  /// If this function fails, you can use <see cref="M:Patagames.Pdf.Pdfium.FPDF_GetLastError" /> to retrieve the reason why it fails.
  /// <note type="note">
  /// With the trial version the documents which size is smaller than 1024 Kb, or greater than 10 Mb can be loaded without any restrictions. For other documents the allowed ranges is 1.5 - 2 Mb; 2.5 - 3 Mb; 3.5 - 4 Mb; 4.5 - 5 Mb and so on.
  /// </note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_LoadMemDocument(byte[] file_content, int content_size, string password)
  {
    Pdfium.CheckForInit();
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_LoadMemDocument_native(file_content, content_size, password);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_LoadCustomDocument", SetLastError = true)]
  private static extern IntPtr FPDF_LoadCustomDocument_native(
    [MarshalAs(UnmanagedType.LPStruct)] FPDF_FILEACCESS pFileAccess,
    [MarshalAs(UnmanagedType.LPStr)] string password);

  /// <summary>Load PDF document from a custom access descriptor.</summary>
  /// <param name="pFileAccess">A structure for access the file.</param>
  /// <param name="password">Optional password for decrypting the PDF file.</param>
  /// <returns>A handle to the loaded document. If failed, IntPtr.Zero is returned.</returns>
  /// <remarks>The application should maintain the file resources being valid until the PDF document close.
  /// Loaded document can be closed by <see cref="M:Patagames.Pdf.Pdfium.FPDF_CloseDocument(System.IntPtr)" />.
  /// If this function fails, you can use <see cref="M:Patagames.Pdf.Pdfium.FPDF_GetLastError" /> to retrieve the reason why it fails.
  /// <note type="note">
  /// With the trial version the documents which size is smaller than 1024 Kb, or greater than 10 Mb can be loaded without any restrictions. For other documents the allowed ranges is 1.5 - 2 Mb; 2.5 - 3 Mb; 3.5 - 4 Mb; 4.5 - 5 Mb and so on.
  /// </note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_LoadCustomDocument(FPDF_FILEACCESS pFileAccess, string password)
  {
    Pdfium.CheckForInit();
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_LoadCustomDocument_native(pFileAccess, password);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetFileVersion", SetLastError = true)]
  private static extern int FPDF_GetFileVersion_native(IntPtr doc, [MarshalAs(UnmanagedType.I4)] out int fileVersion);

  /// <summary>Get the file Version of the specific PDF document.</summary>
  /// <param name="doc">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /></param>
  /// <param name="fileVersion">The PDF file Version. File Version: 14 for 1.4, 15 for 1.5, ...</param>
  /// <returns>TRUE if this call succeed, If failed, FALSE is returned.</returns>
  /// <remarks>If the document is created by function <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />, then this function would always fail.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_GetFileVersion(IntPtr doc, out int fileVersion)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetFileVersion_native(doc, out fileVersion) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetDocPermissions", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.U4)]
  private static extern uint FPDF_GetDocPermissions_native(IntPtr document);

  /// <summary>Get file permission flags of the document.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>A 32-bit integer indicating permission flags. Please refer to <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference</a> for detailed description. If the document is not protected, 0xffffffff will be returned.</returns>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7</seealso>
  [HandleProcessCorruptedStateExceptions]
  public static uint FPDF_GetDocPermissions(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetDocPermissions_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetSecurityHandlerRevision", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.U4)]
  private static extern int FPDF_GetSecurityHandlerRevision_native(IntPtr document);

  /// <summary>Get the revision for security handler.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>The security handler revision number. Please refer to <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference</a> for detailed description. If the document is not protected, -1 will be returned.</returns>
  /// <seealso href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF Reference 1.7</seealso>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDF_GetSecurityHandlerRevision(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetSecurityHandlerRevision_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CloseDocument", SetLastError = true)]
  private static extern void FPDF_CloseDocument_native(IntPtr document);

  /// <summary>Close a loaded PDF document.</summary>
  /// <param name="document">Handle to the loaded document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_CloseDocument(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_CloseDocument_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetPageCount", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.I4)]
  private static extern int FPDF_GetPageCount_native(IntPtr document);

  /// <summary>Get total number of pages in a document</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>Total number of pages in the document.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDF_GetPageCount(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetPageCount_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_LoadPage", SetLastError = true)]
  private static extern IntPtr FPDF_LoadPage_native(IntPtr document, int page_index);

  /// <summary>Load a page inside a document.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="page_index">Index number of the page. 0 for the first page.</param>
  /// <returns>A handle to the loaded page. If failed, IntPtr.Zero is returned.</returns>
  /// <remarks>Loaded page can be rendered to devices using <see cref="M:Patagames.Pdf.Pdfium.FPDF_RenderPage(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Patagames.Pdf.Enums.PageRotate,Patagames.Pdf.Enums.RenderFlags)" /> function.
  /// Loaded page can be closed by <see cref="M:Patagames.Pdf.Pdfium.FPDF_ClosePage(System.IntPtr)" />.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_LoadPage(IntPtr document, int page_index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_LoadPage_native(document, page_index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetPageWidthEx")]
  private static extern void FPDF_GetPageWidth_native(IntPtr page, out double width);

  /// <summary>Get page width</summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <returns>Page width (excluding non-displayable area) measured in points. One point is 1/72 inch (around 0.3528 mm)</returns>
  [HandleProcessCorruptedStateExceptions]
  public static double FPDF_GetPageWidth(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        double width = 0.0;
        Pdfium.FPDF_GetPageWidth_native(page, out width);
        return width;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetPageHeightEx", SetLastError = true)]
  private static extern void FPDF_GetPageHeight_native(IntPtr page, out double height);

  /// <summary>Get page height</summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <returns>Page height (excluding non-displayable area) measured in points. One point is 1/72 inch (around 0.3528 mm)</returns>
  [HandleProcessCorruptedStateExceptions]
  public static double FPDF_GetPageHeight(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        double height = 0.0;
        Pdfium.FPDF_GetPageHeight_native(page, out height);
        return height;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetPageSizeByIndex", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDF_GetPageSizeByIndex_native(
    IntPtr document,
    int page_index,
    [MarshalAs(UnmanagedType.R8)] out double width,
    [MarshalAs(UnmanagedType.R8)] out double height);

  /// <summary>Get the size of a page by index.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="page_index">Page index, zero for the first page.</param>
  /// <param name="width">Pointer to a double value receiving the page width (in points).</param>
  /// <param name="height">Pointer to a double value receiving the page height (in points).</param>
  /// <returns>True for success. False for error (document or page not found)</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_GetPageSizeByIndex(
    IntPtr document,
    int page_index,
    out double width,
    out double height)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetPageSizeByIndex_native(document, page_index, out width, out height);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetPageIndexByDict", SetLastError = true)]
  private static extern int FPDF_GetPageIndexByDict_native(
    IntPtr document,
    IntPtr dict,
    int objNumber);

  /// <summary>
  /// Get the page index by its dictionary or by the object number of the dictionary.
  /// </summary>
  /// <param name="document">A handle to the document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="dict">A handle to the page dictionary. Can be IntPtr.Zero</param>
  /// <param name="objNumber">The object number of page's dictionary. Cannot be omited if <paramref name="dict" /> is not <see cref="F:System.IntPtr.Zero" /> specified.</param>
  /// <returns>Zero-based page index or -1 if nothing found.</returns>
  /// <remarks>With the simultaneous passing of <paramref name="dict" /> and <paramref name="objNumber" />, the <paramref name="dict" /> parameter has a precedence over <paramref name="objNumber" />.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDF_GetPageIndexByDict(IntPtr document, IntPtr dict, int objNumber = 0)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetPageIndexByDict_native(document, dict, objNumber);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetPageSizes", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDF_GetPageSizes_native(IntPtr document, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2, ArraySubType = UnmanagedType.R4)] float[] buffer, int szBuf);

  /// <summary>Get the sizes of all pages in document</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="buffer">Pointer to a buffer of pairs of float values receiving the pages size.</param>
  /// <returns>True for success. False for error (document or page not found)</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_GetPageSizes(IntPtr document, float[] buffer)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetPageSizes_native(document, buffer, buffer.Length);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetPageRotationByIndex", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDF_GetPageRotationByIndex_native(
    IntPtr document,
    int page_index,
    out int rotation);

  /// <summary>Get the page rotation.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="page_index">Page index, zero for the first page.</param>
  /// <param name="rotation">Pointer to an integer value receiving the page rotation. One of following values will be returned：0(0), 1(90), 2(180), 3(270).</param>
  /// <returns>True for success. False for error (document or page not found)</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_GetPageRotationByIndex(
    IntPtr document,
    int page_index,
    out PageRotate rotation)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int rotation1 = 0;
        rotation = PageRotate.Normal;
        int num = Pdfium.FPDF_GetPageRotationByIndex_native(document, page_index, out rotation1) ? 1 : 0;
        if (num != 0)
        {
          rotation1 %= 4;
          if (rotation1 < 0)
            rotation1 = 4 + rotation1;
          rotation = (PageRotate) rotation1;
        }
        return num != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_RenderPage", SetLastError = true)]
  private static extern void FPDF_RenderPage_native(
    IntPtr hdc,
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags);

  /// <summary>
  /// Render contents in a page to a device (screen, bitmap, or printer). This function is only supported on Windows system.
  /// </summary>
  /// <param name="hdc">Handle to device context</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="start_x">Left pixel position of the display area in the device coordinate</param>
  /// <param name="start_y">Top pixel position of the display area in the device coordinate</param>
  /// <param name="size_x">Horizontal size (in pixels) for displaying the page.</param>
  /// <param name="size_y">Vertical size (in pixels) for displaying the page</param>
  /// <param name="rotate">Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise)</param>
  /// <param name="flags">0 for normal display, or combination of flags defined below
  /// 0x01 Set if annotations are to be rendered
  /// 0x02 Set if using text rendering optimized for LCD display
  /// 0x04 Set if you don't want to use GDI+
  /// Applicable to desktop Windows systems only.
  /// 0x08 Grayscale output
  /// 0x80 Set if you want to get some debug info.
  /// 0x100 Set if you don't want to catch exception
  /// </param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_RenderPage(
    IntPtr hdc,
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    PageRotate rotate,
    RenderFlags flags)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_RenderPage_native(hdc, page, start_x, start_y, size_x, size_y, (int) rotate, (int) flags);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_RenderPageBitmap", SetLastError = true)]
  private static extern void FPDF_RenderPageBitmap_native(
    IntPtr bitmap,
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags);

  /// <summary>
  /// Render contents in a page to a device-independent bitmap
  /// </summary>
  /// <param name="bitmap">Handle to the device independent bitmap (as the output buffer). Bitmap handle can be created by <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Create(System.Int32,System.Int32,System.Boolean)" /> function.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="start_x">Left pixel position of the display area in the device coordinate</param>
  /// <param name="start_y">Top pixel position of the display area in the device coordinate</param>
  /// <param name="size_x">Horizontal size (in pixels) for displaying the page.</param>
  /// <param name="size_y">Vertical size (in pixels) for displaying the page</param>
  /// <param name="rotate">Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise)</param>
  /// <param name="flags">0 for normal display, or combination of flags defined below
  /// 0x01 Set if annotations are to be rendered
  /// 0x02 Set if using text rendering optimized for LCD display
  /// 0x04 Set if you don't want to use GDI+
  /// Applicable to desktop Windows systems only.
  /// 0x08 Grayscale output
  /// 0x80 Set if you want to get some debug info.
  /// 0x100 Set if you don't want to catch exception
  /// </param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_RenderPageBitmap(
    IntPtr bitmap,
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    PageRotate rotate,
    RenderFlags flags)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_RenderPageBitmap_native(bitmap, page, start_x, start_y, size_x, size_y, (int) rotate, (int) flags);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_ClosePage", SetLastError = true)]
  private static extern void FPDF_ClosePage_native(IntPtr page);

  /// <summary>Close a loaded PDF page.</summary>
  /// <param name="page">Handle to the loaded page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_ClosePage(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_ClosePage_native(page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_DeviceToPage", SetLastError = true)]
  private static extern void FPDF_DeviceToPage_native(
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int device_x,
    int device_y,
    [MarshalAs(UnmanagedType.R8)] out double page_x,
    [MarshalAs(UnmanagedType.R8)] out double page_y);

  /// <summary>
  /// Convert the screen coordinate of a point to page coordinate.
  /// </summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="start_x">Left pixel position of the display area in the device coordinate</param>
  /// <param name="start_y">Top pixel position of the display area in the device coordinate</param>
  /// <param name="size_x">Horizontal size (in pixels) for displaying the page</param>
  /// <param name="size_y">Vertical size (in pixels) for displaying the page</param>
  /// <param name="rotate">Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise),2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</param>
  /// <param name="device_x">X value in device coordinate, for the point to be converted</param>
  /// <param name="device_y">Y value in device coordinate, for the point to be converted</param>
  /// <param name="page_x">A pointer to a double value receiving the converted X value in page coordinate</param>
  /// <param name="page_y">A pointer to a double value receiving the converted Y value in page coordinate</param>
  /// <remarks>The page coordinate system has its origin at left-bottom corner of the page, with X axis goes
  /// along the bottom side to the right, and Y axis goes along the left side upward. NOTE: this
  /// coordinate system can be altered when you zoom, scroll, or rotate a page, however, a point on
  /// the page should always have the same coordinate values in the page coordinate system.
  /// The device coordinate system is device dependant. For screen device, its origin is at left-top
  /// corner of the window. However this origin can be altered by Windows coordinate
  /// transformation utilities. You must make sure the start_x, start_y, size_x, size_y and rotate
  /// parameters have exactlysame values as you used in <see cref="M:Patagames.Pdf.Pdfium.FPDF_RenderPage(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Patagames.Pdf.Enums.PageRotate,Patagames.Pdf.Enums.RenderFlags)" /> function call.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_DeviceToPage(
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    PageRotate rotate,
    int device_x,
    int device_y,
    out double page_x,
    out double page_y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_DeviceToPage_native(page, start_x, start_y, size_x, size_y, (int) rotate, device_x, device_y, out page_x, out page_y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_PageToDevice", SetLastError = true)]
  private static extern void FPDF_PageToDevice_native(
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    [MarshalAs(UnmanagedType.R8)] double page_x,
    [MarshalAs(UnmanagedType.R8)] double page_y,
    [MarshalAs(UnmanagedType.I4)] out int device_x,
    [MarshalAs(UnmanagedType.I4)] out int device_y);

  /// <summary>
  /// Convert the page coordinate of a point to screen coordinate
  /// </summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="start_x">Left pixel position of the display area in the device coordinate</param>
  /// <param name="start_y">Top pixel position of the display area in the device coordinate</param>
  /// <param name="size_x">Horizontal size (in pixels) for displaying the page</param>
  /// <param name="size_y">Vertical size (in pixels) for displaying the page</param>
  /// <param name="rotate">Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise),2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</param>
  /// <param name="page_x">X value in page coordinate, for the point to be converted</param>
  /// <param name="page_y">Y value in page coordinate, for the point to be converted</param>
  /// <param name="device_x">A pointer to an integer value receiving the result X value in device coordinate</param>
  /// <param name="device_y">A pointer to an integer value receiving the result Y value in device coordinate</param>
  /// <remarks>See remarks of <see cref="M:Patagames.Pdf.Pdfium.FPDF_DeviceToPage(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Patagames.Pdf.Enums.PageRotate,System.Int32,System.Int32,System.Double@,System.Double@)" /> function</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_PageToDevice(
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    PageRotate rotate,
    double page_x,
    double page_y,
    out int device_x,
    out int device_y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_PageToDevice_native(page, start_x, start_y, size_x, size_y, (int) rotate, page_x, page_y, out device_x, out device_y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_Create", SetLastError = true)]
  private static extern IntPtr FPDFBitmap_Create_native(int width, int height, int alpha);

  /// <summary>
  /// Create a device independent bitmap with the specified <paramref name="width" />, <paramref name="height" /> and <paramref name="isUseAlpha" /> flag.
  /// </summary>
  /// <param name="width">Number of pixels in a horizontal line of the bitmap. Must be greater than 0.</param>
  /// <param name="height">Number of pixels in a vertical line of the bitmap. Must be greater than 0.</param>
  /// <param name="isUseAlpha">A flag indicating whether alpha channel is used. True for using alpha, false for not using.</param>
  /// <returns>The created bitmap handle, or IntPtr.Zero if a parameter error or out of memory.</returns>
  /// <remarks><para>A bitmap created by this function, always use 4 byte per pixel. The first byte of a pixel is always double word aligned.
  /// Each pixel contains red (R), green (G), blue (B) and optionally alpha (A) values. The byte order
  /// is BGRx (the last byte unused if no alpha channel) or ARGB.</para>
  /// <para>The pixels in a horizontal line (also called scan line) are stored side by side, with left most pixel stored first (with lower
  /// memory address). Each scan line uses <paramref name="width" />*4 bytes. Scan lines are stored one after another,
  /// with top most scan line stored first. There is no gap between adjacent scan lines.</para>
  /// <para>This function allocates enough memory for holding all pixels in the bitmap, but it doesn't
  /// initialize the buffer. Applications can use <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_FillRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Clear(System.IntPtr,System.UInt32)" /> to fill the bitmap using any
  /// color.</para>
  /// <para>When an application is finished using the bitmap handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Create(System.Int32,System.Int32,System.Boolean)" />, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBitmap_Create(int width, int height, bool isUseAlpha)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_Create_native(width, height, isUseAlpha ? 1 : 0);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_CreateEx", SetLastError = true)]
  private static extern IntPtr FPDFBitmap_CreateEx_native(
    int width,
    int height,
    int format,
    IntPtr first_scan,
    int stride);

  /// <summary>
  /// Create a device independent bitmap with the specified <paramref name="width" />, <paramref name="height" />, pixel <paramref name="format" /> and external buffer.
  /// </summary>
  /// <param name="width">Number of pixels in a horizontal line of the bitmap. Must be greater than 0.</param>
  /// <param name="height">Number of pixels in a vertical line of the bitmap. Must be greater than 0.</param>
  /// <param name="format">A number indicating for bitmap format, as defined in <see cref="T:Patagames.Pdf.Enums.FXDIBFormats" /> enumeration.</param>
  /// <param name="first_scan">A pointer to the first byte of first scan line, for external buffer only. If this parameter is IntPtr.Zero, then the SDK will create its own buffer.</param>
  /// <param name="stride">Number of bytes for each scan line, for external buffer only.</param>
  /// <returns>The created bitmap handle, or IntPtr.Zero if a parameter error or out of memory.</returns>
  /// <remarks><para>Similar to <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Create(System.Int32,System.Int32,System.Boolean)" /> function, with support for more formats and an external buffer.</para>
  /// <para>Bitmap created by this function can be used in any place that a device independent bitmap handle is required. </para>
  /// <para>If external scanline buffer is used, then the application should destroy the buffer by itself.
  /// The <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function will not destroy the buffer.</para>
  /// <para>When an application is finished using the bitmap handle returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFBitmap_CreateEx" />, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBitmap_CreateEx(
    int width,
    int height,
    FXDIBFormats format,
    IntPtr first_scan,
    int stride)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_CreateEx_native(width, height, (int) format, first_scan, stride);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_CreateEx2", SetLastError = true)]
  private static extern IntPtr FPDFBitmap_CreateEx2_native(
    int width,
    int height,
    BitmapFormats format,
    IntPtr first_scan,
    int stride);

  /// <summary>
  /// Create a device independent bitmap with the specified <paramref name="width" />, <paramref name="height" />, pixel <paramref name="format" /> and external buffer.
  /// </summary>
  /// <param name="width">Number of pixels in a horizontal line of the bitmap. Must be greater than 0.</param>
  /// <param name="height">Number of pixels in a vertical line of the bitmap. Must be greater than 0</param>
  /// <param name="format">A number indicating for bitmap format, as defined in <see cref="T:Patagames.Pdf.Enums.BitmapFormats" /> enumeration</param>
  /// <param name="first_scan">A pointer to the first byte of first scan line, for external buffer only. If this parameter is IntPtr.Zero, then the SDK will create its own buffer.</param>
  /// <param name="stride">Number of bytes for each scan line, for external buffer only</param>
  /// <returns>The created bitmap handle, or IntPtr.Zero if a parameter error or out of memory.</returns>
  /// <remarks><para>Similar to <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Create(System.Int32,System.Int32,System.Boolean)" /> function, with support for more formats and an external buffer.</para>
  /// <para>Bitmap created by this function can be used in any place that a device independent bitmap handle is
  /// required.</para>
  /// <para>If external scanline buffer is used, then the application should destroy the buffer by
  /// itself. <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function will not destroy the buffer.</para>
  /// <para>When an application is finished using the bitmap handle returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFBitmap_CreateEx" />, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBitmap_CreateEx(
    int width,
    int height,
    BitmapFormats format,
    IntPtr first_scan,
    int stride)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_CreateEx2_native(width, height, format, first_scan, stride);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_FillRect", SetLastError = true)]
  private static extern void FPDFBitmap_FillRect_native(
    IntPtr bitmap,
    int left,
    int top,
    int width,
    int height,
    int color);

  /// <summary>
  /// Fills the rectangular area in the <paramref name="bitmap" /> specified by a pair of coordinates, width and height.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="left">The left side position. Starting from 0 at the left-most pixel.</param>
  /// <param name="top">The top side position. Starting from 0 at the top-most scan line.</param>
  /// <param name="width">Number of pixels to be filled in each scan line</param>
  /// <param name="height">Number of scan lines to be filled.</param>
  /// <param name="color">A 32-bit value specifing the color, in 8888 ARGB format.</param>
  /// <remarks>
  /// <para>This function set the color and (optionally) alpha value in specified region of the bitmap.</para>
  /// <note type="note">If alpha channel is used, this function does NOT composite the background with the source
  /// color, instead the background will be replaced by the source color and alpha. </note>
  /// <para>If alpha channel is not used, the "alpha" parameter is ignored.</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFBitmap_FillRect(
    IntPtr bitmap,
    int left,
    int top,
    int width,
    int height,
    int color)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFBitmap_FillRect_native(bitmap, left, top, width, height, color);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_GetBuffer", SetLastError = true)]
  private static extern IntPtr FPDFBitmap_GetBuffer_native(IntPtr bitmap);

  /// <summary>
  /// Returns pointer to an array of bytes that contains the pixel data of the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>The pointer to the first byte of the bitmap buffer.</returns>
  /// <remarks>Applications can use this function to get the bitmap buffer pointer, then manipulate any color and/or alpha values for any pixels in the bitmap.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBitmap_GetBuffer(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_GetBuffer_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_GetWidth", SetLastError = true)]
  private static extern int FPDFBitmap_GetWidth_native(IntPtr bitmap);

  /// <summary>
  /// Returns the width, in pixels, of the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>The number of pixels in a horizontal line of the <paramref name="bitmap" />.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFBitmap_GetWidth(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_GetWidth_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_GetHeight", SetLastError = true)]
  private static extern int FPDFBitmap_GetHeight_native(IntPtr bitmap);

  /// <summary>
  /// Returns the height, in pixels, of the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>The number of pixels in a vertical line of the <paramref name="bitmap" />.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFBitmap_GetHeight(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_GetHeight_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_GetStride", SetLastError = true)]
  private static extern int FPDFBitmap_GetStride_native(IntPtr bitmap);

  /// <summary>
  /// Returns number of bytes for each scan line in the <paramref name="bitmap" /> buffer.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>An integer that specifies the byte offset between the beginning of one scan line and the next. This is usually (but not necessarily) the number of bytes in the pixel format (for example, 2 for 16 bits per pixel) multiplied by the width of the bitmap. The value passed to this parameter must be a multiple of four.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFBitmap_GetStride(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_GetStride_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_Destroy", SetLastError = true)]
  private static extern void FPDFBitmap_Destroy_native(IntPtr bitmap);

  /// <summary>
  /// Destroy a device independent bitmap and release all related buffers.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Create(System.Int32,System.Int32,System.Boolean)" />, <see cref="O:Patagames.Pdf.Pdfium.FPDFBitmap_CreateEx" /> function.</param>
  /// <remarks>This function will not destroy any external buffer.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFBitmap_Destroy(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFBitmap_Destroy_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintScaling", SetLastError = true)]
  private static extern int FPDF_VIEWERREF_GetPrintScaling_native(IntPtr document);

  /// <summary>Whether the PDF document prefers to be scaled or not.</summary>
  /// <param name="document">Handle to the loaded document.</param>
  /// <returns>True if PDF document prefers to be scaled</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_VIEWERREF_GetPrintScaling(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_VIEWERREF_GetPrintScaling_native(document) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetNumCopies", SetLastError = true)]
  private static extern int FPDF_VIEWERREF_GetNumCopies_native(IntPtr document);

  /// <summary>Returns the number of copies to be printed.</summary>
  /// <param name="document">Handle to the loaded document.</param>
  /// <returns>The number of copies to be printed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDF_VIEWERREF_GetNumCopies(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_VIEWERREF_GetNumCopies_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetPrintPageRange", SetLastError = true)]
  private static extern IntPtr FPDF_VIEWERREF_GetPrintPageRange_native(IntPtr document);

  /// <summary>
  /// Page numbers to initialize print dialog box when file is printed.
  /// </summary>
  /// <param name="document">Handle to the loaded document.</param>
  /// <returns>The print page range to be used for printing.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_VIEWERREF_GetPrintPageRange(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_VIEWERREF_GetPrintPageRange_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_VIEWERREF_GetDuplex", SetLastError = true)]
  private static extern int FPDF_VIEWERREF_GetDuplex_native(IntPtr document);

  /// <summary>
  /// Returns the paper handling option to be used when printing from print dialog.
  /// </summary>
  /// <param name="document">Handle to the loaded document.</param>
  /// <returns>The paper handling option to be used when printing.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static DuplexTypes FPDF_VIEWERREF_GetDuplex(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (DuplexTypes) Pdfium.FPDF_VIEWERREF_GetDuplex_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CountNamedDests", SetLastError = true)]
  private static extern int FPDF_CountNamedDests_native(IntPtr document);

  /// <summary>
  /// Get the count of named destinations in the PDF document.
  /// </summary>
  /// <param name="document">Handle to a document</param>
  /// <returns>The count of named destinations.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDF_CountNamedDests(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_CountNamedDests_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetNamedDestByName", SetLastError = true)]
  private static extern IntPtr FPDF_GetNamedDestByName_native(IntPtr document, [MarshalAs(UnmanagedType.LPStr)] string name);

  /// <summary>Get a special dest handle by the name.</summary>
  /// <param name="document">Handle to the loaded document.</param>
  /// <param name="name">The name of a special named dest.</param>
  /// <returns>The Handle to the dest.</returns>
  /// <remarks>This method have problem with non english national character encoding</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_GetNamedDestByName(IntPtr document, string name)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetNamedDestByName_native(document, name);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetNamedDest", SetLastError = true)]
  private static extern IntPtr FPDF_GetNamedDest_native(
    IntPtr document,
    int index,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    [MarshalAs(UnmanagedType.I4)] ref int buflen);

  /// <summary>
  /// Get the specified named destinations of the PDF document by index.
  /// </summary>
  /// <param name="document">Handle to a document</param>
  /// <param name="index">The index of named destination.</param>
  /// <param name="name">Retrieve the name of named destinations</param>
  /// <returns>The destination Handle to a named destination, or IntPtr.Zero if no named destination corresponding to |index|.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_GetNamedDest(IntPtr document, int index, out string name)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int buflen = 0;
        name = "";
        Pdfium.FPDF_GetNamedDest_native(document, index, (byte[]) null, ref buflen);
        if (buflen <= 0)
          return IntPtr.Zero;
        byte[] numArray = new byte[buflen];
        IntPtr zero = IntPtr.Zero;
        IntPtr namedDestNative = Pdfium.FPDF_GetNamedDest_native(document, index, numArray, ref buflen);
        name = Encoding.Unicode.GetString(numArray);
        name = name.Trim(new char[1]);
        return namedDestNative;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SetSandBoxPolicy", SetLastError = true)]
  private static extern void FPDF_SetSandBoxPolicy_native([MarshalAs(UnmanagedType.I4)] int policy, [MarshalAs(UnmanagedType.Bool)] bool enable);

  /// <summary>Set the policy for the sandbox environment.</summary>
  /// <param name="policy">The specified policy for setting, for example:FPDF_POLICY_MACHINETIME_ACCESS.</param>
  /// <param name="enable">True for enable, False for disable the policy.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_SetSandBoxPolicy(SandboxPolicies policy, bool enable)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_SetSandBoxPolicy_native((int) policy, enable);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAvail_Create", SetLastError = true)]
  private static extern IntPtr FPDFAvail_Create_native(IntPtr file_avail, IntPtr file);

  /// <summary>Create a document availability provider.</summary>
  /// <param name="file_avail">Pointer to file availability interface to check availability of file data.</param>
  /// <param name="file">Pointer to a file access interface for reading data from file.</param>
  /// <returns>A handle to the document availability provider. IntPtr.Zero for error.</returns>
  /// <remarks>Application must call <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_Destroy(System.IntPtr)" /> when done with the availability provider.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFAvail_Create(FX_FILEAVAIL file_avail, FPDF_FILEACCESS file)
  {
    using (Lock.SyncMT)
    {
      try
      {
        PointerManagerItem<FX_FILEAVAIL, FPDF_FILEACCESS> pointerManagerItem = new PointerManagerItem<FX_FILEAVAIL, FPDF_FILEACCESS>(file_avail, file);
        IntPtr zero = IntPtr.Zero;
        pointerManagerItem.Key = Pdfium.FPDFAvail_Create_native(pointerManagerItem[0], pointerManagerItem[1]);
        if (pointerManagerItem.Key == IntPtr.Zero)
          pointerManagerItem.Dispose();
        else
          PointerManager.Add((IPointerManagerItem) pointerManagerItem);
        return pointerManagerItem.Key;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAvail_Destroy", SetLastError = true)]
  private static extern void FPDFAvail_Destroy_native(IntPtr avail);

  /// <summary>Destroy a document availibity provider.</summary>
  /// <param name="avail">Handle to document availability provider returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_Create(Patagames.Pdf.FX_FILEAVAIL,Patagames.Pdf.FPDF_FILEACCESS)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFAvail_Destroy(IntPtr avail)
  {
    using (Lock.SyncMT)
    {
      try
      {
        PointerManager.Remove(avail);
        Pdfium.FPDFAvail_Destroy_native(avail);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAvail_IsDocAvail", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFAvail_IsDocAvail_native(IntPtr avail, [MarshalAs(UnmanagedType.LPStruct)] FX_DOWNLOADHINTS hints);

  /// <summary>
  /// Check whether the document is ready for loading, if not, get download hints.
  /// </summary>
  /// <param name="avail">Handle to document availability provider returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_Create(Patagames.Pdf.FX_FILEAVAIL,Patagames.Pdf.FPDF_FILEACCESS)" /></param>
  /// <param name="hints">Pointer to a download hints interface, receiving generated hints</param>
  /// <returns>True for page is fully available, False for page not yet available.</returns>
  /// <remarks>
  /// The application should call this function whenever new data arrived, and process all the
  /// generated download hints if any, until the function returns non-zero value. Then the application can call <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_GetDocument(System.IntPtr,System.String)" /> to get a document handle.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFAvail_IsDocAvail(IntPtr avail, FX_DOWNLOADHINTS hints)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFAvail_IsDocAvail_native(avail, hints);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAvail_GetDocument", SetLastError = true)]
  private static extern IntPtr FPDFAvail_GetDocument_native(IntPtr avail, [MarshalAs(UnmanagedType.LPStr)] string password);

  /// <summary>Get document from the availability provider.</summary>
  /// <param name="avail">Handle to document availability provider returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_Create(Patagames.Pdf.FX_FILEAVAIL,Patagames.Pdf.FPDF_FILEACCESS)" /></param>
  /// <param name="password">Optional password for decrypting the PDF file.</param>
  /// <returns>Handle to the document.</returns>
  /// <remarks>
  /// After <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_IsDocAvail(System.IntPtr,Patagames.Pdf.FX_DOWNLOADHINTS)" /> returns TRUE, the application should call this function to
  /// get the document handle. To close the document, use <see cref="M:Patagames.Pdf.Pdfium.FPDF_CloseDocument(System.IntPtr)" /> function.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFAvail_GetDocument(IntPtr avail, string password)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFAvail_GetDocument_native(avail, password);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAvail_GetFirstPageNum", SetLastError = true)]
  private static extern int FPDFAvail_GetFirstPageNum_native(IntPtr document);

  /// <summary>
  /// Get page number for the first available page in a linearized PDF
  /// </summary>
  /// <param name="document">A document handle returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_GetDocument(System.IntPtr,System.String)" /></param>
  /// <returns>Zero-based index for the first available page.</returns>
  /// <remarks>For most linearized PDFs, the first available page would be just the first page, however,
  /// some PDFs might make other page to be the first available page.
  /// For non-linearized PDF, this function will always return zero.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFAvail_GetFirstPageNum(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFAvail_GetFirstPageNum_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAvail_IsPageAvail", SetLastError = true)]
  private static extern int FPDFAvail_IsPageAvail_native(
    IntPtr avail,
    int page_index,
    [MarshalAs(UnmanagedType.LPStruct)] FX_DOWNLOADHINTS hints);

  /// <summary>
  /// Check whether a page is ready for loading, if not, get download hints.
  /// </summary>
  /// <param name="avail">Handle to document availability provider returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_Create(Patagames.Pdf.FX_FILEAVAIL,Patagames.Pdf.FPDF_FILEACCESS)" /></param>
  /// <param name="page_index">Index number of the page. 0 for the first page.</param>
  /// <param name="hints">Pointer to a download hints interface, receiving generated hints</param>
  /// <returns>True for page is fully available, False for page not yet available.</returns>
  /// <remarks>
  /// This function call be called only after <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_GetDocument(System.IntPtr,System.String)" /> if called.
  /// The application should call this function whenever new data arrived, and process all the
  /// generated download hints if any, until the function returns non-zero value. Then the
  /// application can perform page loading.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFAvail_IsPageAvail(IntPtr avail, int page_index, FX_DOWNLOADHINTS hints)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFAvail_IsPageAvail_native(avail, page_index, hints) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAvail_IsFormAvail", SetLastError = true)]
  private static extern int FPDFAvail_IsFormAvail_native(IntPtr avail, [MarshalAs(UnmanagedType.LPStruct)] FX_DOWNLOADHINTS hints);

  /// <summary>
  /// Check whether Form data is ready for init, if not, get download hints.
  /// </summary>
  /// <param name="avail">Handle to document availability provider returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_Create(Patagames.Pdf.FX_FILEAVAIL,Patagames.Pdf.FPDF_FILEACCESS)" /></param>
  /// <param name="hints">Pointer to a download hints interface, receiving generated hints</param>
  /// <returns>
  /// Non-zero for Form data is fully available, 0 for Form data not yet available.
  /// Details: -1 - error, the input parameter not correct, such as hints is null.
  /// 0 - data not available
  /// 1 - data available
  /// 2 - no form data.
  /// </returns>
  /// <remarks>
  /// This function call be called only after <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_GetDocument(System.IntPtr,System.String)" /> is called.
  /// The application should call this function whenever new data arrived, and process all the
  /// generated download hints if any, until the function returns non-zero value. Then the
  /// application can perform page loading. It is recommend to call <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />
  /// after the function returns non-zero value.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IsFormAvailableResults FPDFAvail_IsFormAvail(IntPtr avail, FX_DOWNLOADHINTS hints)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (IsFormAvailableResults) Pdfium.FPDFAvail_IsFormAvail_native(avail, hints);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFAvail_IsLinearized", SetLastError = true)]
  private static extern int FPDFAvail_IsLinearized_native(IntPtr avail);

  /// <summary>To check whether a document is Linearized PDF file.</summary>
  /// <param name="avail">Handle to document availability provider returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFAvail_Create(Patagames.Pdf.FX_FILEAVAIL,Patagames.Pdf.FPDF_FILEACCESS)" /></param>
  /// <returns>
  /// IsLinearized is a linearize file.
  /// NotLinearized is not a linearize file.
  /// UnknownLinearized don't know whether the file is a linearize file.
  /// </returns>
  /// <remarks>
  /// return IsLinearized means the document is linearized PDF else not.
  /// It return IsLinearized/NotLinearized state as soon as we have first 1K data. If the file's size less than
  /// 1K,we don't known whether the PDF is a linearized file.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IsLinearizedResults FPDFAvail_IsLinearized(IntPtr avail)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (IsLinearizedResults) Pdfium.FPDFAvail_IsLinearized_native(avail);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDOC_InitFormFillEnvironmentEx", SetLastError = true)]
  private static extern IntPtr FPDFDOC_InitFormFillEnvironment_native(
    IntPtr document,
    IntPtr formInfo,
    IntPtr jsPlatform);

  /// <summary>Init form fill environment.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="formInfo">Pointer to a <see cref="T:Patagames.Pdf.FPDF_FORMFILLINFO" /> structure.</param>
  /// <param name="jsPlatform">Pointer to a <see cref="T:Patagames.Pdf.IPDF_JSPLATFORM" /> structure.</param>
  /// <returns>Return handle to the form fill module. IntPtr.Zero means fails. </returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDOC_InitFormFillEnvironment(
    IntPtr document,
    FPDF_FORMFILLINFO formInfo,
    IPDF_JSPLATFORM jsPlatform)
  {
    PointerManagerItem<FPDF_FORMFILLINFO, IPDF_JSPLATFORM> pointerManagerItem = new PointerManagerItem<FPDF_FORMFILLINFO, IPDF_JSPLATFORM>(formInfo, jsPlatform);
    pointerManagerItem.Key = Pdfium.FPDFDOC_InitFormFillEnvironment(document, pointerManagerItem[0], pointerManagerItem[1]);
    if (pointerManagerItem.Key == IntPtr.Zero)
      pointerManagerItem.Dispose();
    else
      PointerManager.Add((IPointerManagerItem) pointerManagerItem);
    return pointerManagerItem.Key;
  }

  /// <summary>Init form fill environment.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="formInfo">Pointer to a <see cref="T:Patagames.Pdf.FPDF_FORMFILLINFO" /> structure located in the unmanaged memory.</param>
  /// <param name="jsPlatform">Pointer to a <see cref="T:Patagames.Pdf.IPDF_JSPLATFORM" /> structure located in the unmanaged memory.</param>
  /// <returns>Return handle to the form fill module. IntPtr.Zero means fails. </returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDOC_InitFormFillEnvironment(
    IntPtr document,
    IntPtr formInfo,
    IntPtr jsPlatform)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDOC_InitFormFillEnvironment_native(document, formInfo, jsPlatform);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDOC_ExitFormFillEnvironment", SetLastError = true)]
  private static extern void FPDFDOC_ExitFormFillEnvironment_native(IntPtr form_handle);

  /// <summary>Exit form fill environment.</summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <returns></returns>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDOC_ExitFormFillEnvironment(IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        if (Pdfium._interforms.ContainsKey(form_handle) && Pdfium._interforms[form_handle] != IntPtr.Zero)
          Pdfium.FPDFInterForm_SetFormNotify(Pdfium._interforms[form_handle], (FPDF_FORMFILLNOTIFY) null);
        Pdfium.FPDFDOC_ExitFormFillEnvironment_native(form_handle);
        PointerManager.Remove(form_handle);
        if (!Pdfium._interforms.ContainsKey(form_handle))
          return;
        Pdfium._interforms.Remove(form_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_OnAfterLoadPage", SetLastError = true)]
  private static extern void FORM_OnAfterLoadPage_native(IntPtr page, IntPtr form_handle);

  /// <summary>
  /// This method is required for implementing all the form related functions. Should be invoked after user
  /// successfully loaded a PDF page, and method <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" /> had been invoked.
  /// </summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FORM_OnAfterLoadPage(IntPtr page, IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FORM_OnAfterLoadPage_native(page, form_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_OnBeforeClosePage", SetLastError = true)]
  private static extern void FORM_OnBeforeClosePage_native(IntPtr page, IntPtr form_handle);

  /// <summary>
  /// This method is required for implementing all the form related functions. Should be invoked before user close the PDF page.
  /// </summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FORM_OnBeforeClosePage(IntPtr page, IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FORM_OnBeforeClosePage_native(page, form_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_DoDocumentJSAction", SetLastError = true)]
  private static extern void FORM_DoDocumentJSAction_native(IntPtr form_handle);

  /// <summary>
  /// This method is required for performing Document-level JavaScript action. It should be invoked after the PDF document had been loaded.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <remarks>If there is Document-level JavaScript action embedded in the document, this method will execute the javascript action;
  /// otherwise, the method will do nothing.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FORM_DoDocumentJSAction(IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FORM_DoDocumentJSAction_native(form_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_DoDocumentOpenAction", SetLastError = true)]
  private static extern void FORM_DoDocumentOpenAction_native(IntPtr form_handle);

  /// <summary>
  /// This method is required for performing open-action when the document is opened.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <remarks>This method will do nothing if there is no open-actions embedded in the document. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FORM_DoDocumentOpenAction(IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FORM_DoDocumentOpenAction_native(form_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_DoDocumentAAction", SetLastError = true)]
  private static extern void FORM_DoDocumentAAction_native(IntPtr form_handle, int aaType);

  /// <summary>
  /// This method is required for performing the document's additional-action.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="aatype"> The type of the additional-actions. See <see cref="T:Patagames.Pdf.Enums.DocumentActionTypes" /> for detail</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FORM_DoDocumentAAction(IntPtr form_handle, DocumentActionTypes aatype)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FORM_DoDocumentAAction_native(form_handle, (int) aatype);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_DoPageAAction", SetLastError = true)]
  private static extern void FORM_DoPageAAction_native(IntPtr page, IntPtr form_handle, int aaType);

  /// <summary>
  /// This method is required for performing the page object's additional-action when opened or closed.
  /// </summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="aatype">The type of the page object's additional-actions. See <see cref="T:Patagames.Pdf.Enums.PageActionTypes" /> for details.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FORM_DoPageAAction(IntPtr page, IntPtr form_handle, PageActionTypes aatype)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FORM_DoPageAAction_native(page, form_handle, (int) aatype);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_OnMouseMove", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FORM_OnMouseMove_native(
    IntPtr form_handle,
    IntPtr page,
    int modifier,
    double page_x,
    double page_y);

  /// <summary>
  /// You can call this member function when the mouse cursor moves.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="modifier">Indicates whether various virtual keys are down. </param>
  /// <param name="page_x">Specifies the x-coordinate of the cursor in PDF user space.</param>
  /// <param name="page_y">Specifies the y-coordinate of the cursor in PDF user space.</param>
  /// <returns>TRUE indicates success; otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FORM_OnMouseMove(
    IntPtr form_handle,
    IntPtr page,
    int modifier,
    double page_x,
    double page_y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_OnMouseMove_native(form_handle, page, modifier, page_x, page_y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_OnLButtonDown", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FORM_OnLButtonDown_native(
    IntPtr form_handle,
    IntPtr page,
    int modifier,
    double page_x,
    double page_y);

  /// <summary>
  /// You can call this member function when the user presses the left mouse button.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="modifier">Indicates whether various virtual keys are down. </param>
  /// <param name="page_x">Specifies the x-coordinate of the cursor in PDF user space.</param>
  /// <param name="page_y">Specifies the y-coordinate of the cursor in PDF user space.</param>
  /// <returns>TRUE indicates success; otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FORM_OnLButtonDown(
    IntPtr form_handle,
    IntPtr page,
    int modifier,
    double page_x,
    double page_y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_OnLButtonDown_native(form_handle, page, modifier, page_x, page_y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_OnLButtonUp", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FORM_OnLButtonUp_native(
    IntPtr form_handle,
    IntPtr page,
    int modifier,
    double page_x,
    double page_y);

  /// <summary>
  /// You can call this member function when the user releases the left mouse button.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="modifier">Indicates whether various virtual keys are down. </param>
  /// <param name="page_x">Specifies the x-coordinate of the cursor in PDF user space.</param>
  /// <param name="page_y">Specifies the y-coordinate of the cursor in PDF user space.</param>
  /// <returns>TRUE indicates success; otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FORM_OnLButtonUp(
    IntPtr form_handle,
    IntPtr page,
    int modifier,
    double page_x,
    double page_y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_OnLButtonUp_native(form_handle, page, modifier, page_x, page_y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_OnKeyDown", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FORM_OnKeyDown_native(
    IntPtr form_handle,
    IntPtr page,
    int keyCode,
    int modifier);

  /// <summary>
  /// You can call this member function when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="keyCode">Indicates whether various virtual keys are down. </param>
  /// <param name="modifier">Contains the scan code, key-transition code, previous key state, and context code.</param>
  /// <returns>TRUE indicates success; otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FORM_OnKeyDown(
    IntPtr form_handle,
    IntPtr page,
    FWL_VKEYCODE keyCode,
    KeyboardModifiers modifier)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_OnKeyDown_native(form_handle, page, (int) keyCode, (int) modifier);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_OnKeyUp", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FORM_OnKeyUp_native(
    IntPtr form_handle,
    IntPtr page,
    int keyCode,
    int modifier);

  /// <summary>
  /// You can call this member function when a nonsystem key is released.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="keyCode">Indicates whether various virtual keys are released. </param>
  /// <param name="modifier">Contains the scan code, key-transition code, previous key state, and context code.</param>
  /// <returns>TRUE indicates success; otherwise false.</returns>
  /// <remarks>In Version 2236 of Pdfium this method is not implemented and always returns False</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FORM_OnKeyUp(
    IntPtr form_handle,
    IntPtr page,
    FWL_VKEYCODE keyCode,
    KeyboardModifiers modifier)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_OnKeyUp_native(form_handle, page, (int) keyCode, (int) modifier);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_OnChar", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FORM_OnChar_native(
    IntPtr form_handle,
    IntPtr page,
    int nChar,
    int modifier);

  /// <summary>
  /// You can call this member function when a keystroke translates to a nonsystem character.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="nChar">The character code value of the key.</param>
  /// <param name="modifier">Contains the scan code, key-transition code, previous key state, and context code.</param>
  /// <returns>TRUE indicates success; otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FORM_OnChar(
    IntPtr form_handle,
    IntPtr page,
    int nChar,
    KeyboardModifiers modifier)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_OnChar_native(form_handle, page, nChar, (int) modifier);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_ForceToKillFocus", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FORM_ForceToKillFocus_native(IntPtr form_handle);

  /// <summary>
  /// You can call this member function to force to kill the focus of the form field which got focus.
  /// It would kill the focus on the form field, save the value of form field if it's changed by user.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <returns>TRUE indicates success; otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FORM_ForceToKillFocus(IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_ForceToKillFocus_native(form_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDPage_HasFormFieldAtPoint", SetLastError = true)]
  private static extern int FPDPage_HasFormFieldAtPoint_native(
    IntPtr form_handle,
    IntPtr page,
    double page_x,
    double page_y);

  /// <summary>Check the form field position by point.</summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="page_x">X position in PDF "user space".</param>
  /// <param name="page_y">Y position in PDF "user space".</param>
  /// <returns>Return the type of the formfiled; -1 indicates no fields.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FormFieldTypes FPDPage_HasFormFieldAtPoint(
    IntPtr form_handle,
    IntPtr page,
    double page_x,
    double page_y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (FormFieldTypes) Pdfium.FPDPage_HasFormFieldAtPoint_native(form_handle, page, page_x, page_y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SetFormFieldHighlightColor", SetLastError = true)]
  private static extern void FPDF_SetFormFieldHighlightColor_native(
    IntPtr form_handle,
    int field_type,
    [MarshalAs(UnmanagedType.I4)] int color);

  /// <summary>
  /// Set the highlight color of specified or all the form fields in the document.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="field_type">A 32-bit integer indicating the type of a form field.</param>
  /// <param name="color">The highlight color of the form field.Constructed by 0xxxrrggbb.</param>
  /// <remarks>When the parameter fieldType is set to zero, the highlight color will be applied to all the form fields in the document.
  /// Please refresh the client window to show the highlight immediately if necessary.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_SetFormFieldHighlightColor(
    IntPtr form_handle,
    FormFieldTypes field_type,
    int color)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int num1 = (int) (byte) (color >> 24);
        byte num2 = (byte) (color >> 16 /*0x10*/);
        byte num3 = (byte) (color >> 8);
        byte num4 = (byte) color;
        int color1 = num1 << 24 | (int) num4 << 16 /*0x10*/ | (int) num3 << 8 | (int) num2;
        Pdfium.FPDF_SetFormFieldHighlightColor_native(form_handle, (int) field_type, color1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SetFormFieldHighlightAlpha", SetLastError = true)]
  private static extern void FPDF_SetFormFieldHighlightAlpha_native(IntPtr form_handle, [MarshalAs(UnmanagedType.U1)] byte alpha);

  /// <summary>
  /// Set the transparency of the form field highlight color in the document.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="alpha">The transparency of the form field highlight color. between 0-255.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_SetFormFieldHighlightAlpha(IntPtr form_handle, byte alpha)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_SetFormFieldHighlightAlpha_native(form_handle, alpha);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_RemoveFormFieldHighlight", SetLastError = true)]
  private static extern void FPDF_RemoveFormFieldHighlight_native(IntPtr form_handle);

  /// <summary>
  /// Remove the form field highlight color in the document.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <remarks>Please refresh the client window to remove the highlight immediately if necessary.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_RemoveFormFieldHighlight(IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_RemoveFormFieldHighlight_native(form_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_FFLDraw", SetLastError = true)]
  private static extern void FPDF_FFLDraw_native(
    IntPtr form_handle,
    IntPtr bitmap,
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    int rotate,
    int flags);

  /// <summary>
  /// Render FormFeilds on a page to a device independent bitmap.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="bitmap">Handle to the device independent bitmap (as the output buffer). Bitmap handle can be created by <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Create(System.Int32,System.Int32,System.Boolean)" /> function.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="start_x">Left pixel position of the display area in the device coordinate.</param>
  /// <param name="start_y">Top pixel position of the display area in the device coordinate.</param>
  /// <param name="size_x">Horizontal size (in pixels) for displaying the page.</param>
  /// <param name="size_y">Vertical size (in pixels) for displaying the page.</param>
  /// <param name="rotate">Page orientation: 0 (normal), 1 (rotated 90 degrees clockwise), 2 (rotated 180 degrees), 3 (rotated 90 degrees counter-clockwise).</param>
  /// <param name="flags">0 for normal display, or combination of flags defined above.</param>
  /// <remarks>
  /// This method is designed to only render annotations and FormFields on the page.
  /// Without FPDF_ANNOT specified for flags, Rendering functions such as <see cref="M:Patagames.Pdf.Pdfium.FPDF_RenderPageBitmap(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Patagames.Pdf.Enums.PageRotate,Patagames.Pdf.Enums.RenderFlags)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_RenderPageBitmap_Start(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Patagames.Pdf.Enums.PageRotate,Patagames.Pdf.Enums.RenderFlags,Patagames.Pdf.IFSDK_PAUSE)" /> will only render page contents(without annotations) to a bitmap.
  /// In order to implement the FormFill functions,Implementation should call this method after rendering functions finish rendering the page contents.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_FFLDraw(
    IntPtr form_handle,
    IntPtr bitmap,
    IntPtr page,
    int start_x,
    int start_y,
    int size_x,
    int size_y,
    PageRotate rotate,
    RenderFlags flags)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_FFLDraw_native(form_handle, bitmap, page, start_x, start_y, size_x, size_y, (int) rotate, (int) flags);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_AddInstalledFont")]
  private static extern void FPDF_AddInstalledFont_native(
    IntPtr mapper,
    [MarshalAs(UnmanagedType.LPStr)] string face,
    CharacterSetTypes charset);

  /// <summary>Add a system font to the list in Pdfium SDK.</summary>
  /// <param name="mapper">Opaque pointer to Pdfium font mapper</param>
  /// <param name="face">The font face name</param>
  /// <param name="charset">Font character set. See <see cref="T:Patagames.Pdf.Enums.CharacterSetTypes" />.</param>
  /// <remarks>This function is only called during the system font list building process.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_AddInstalledFont(IntPtr mapper, string face, CharacterSetTypes charset)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_AddInstalledFont_native(mapper, face, charset);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_SetSystemFontInfo", SetLastError = true)]
  private static extern void FPDF_SetSystemFontInfo_native(IntPtr pFontInfo);

  /// <summary>Set the system font info interface into Pdfium SDK</summary>
  /// <param name="pFontInfo">Pointer to a <see cref="T:Patagames.Pdf.FPDF_SYSFONTINFO" /> structure</param>
  /// <remarks>Platform support implementation should implement required methods of <see cref="T:Patagames.Pdf.FPDF_SYSFONTINFO" /> interface,
  /// then call this function during SDK initialization process.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_SetSystemFontInfo(FPDF_SYSFONTINFO pFontInfo)
  {
    using (Lock.SyncMT)
    {
      try
      {
        PointerManagerItem<FPDF_SYSFONTINFO> pointerManagerItem = new PointerManagerItem<FPDF_SYSFONTINFO>(pFontInfo);
        pointerManagerItem.IsNeedCheckForMemoryLeaks = false;
        Pdfium.FPDF_SetSystemFontInfo_native(pointerManagerItem[0]);
        if (Pdfium._setfontStructure != null)
          Pdfium._setfontStructure.Dispose();
        Pdfium._setfontStructure = pointerManagerItem;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetDefaultSystemFontInfo", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.LPStruct)]
  private static extern FPDF_SYSFONTINFO FPDF_GetDefaultSystemFontInfo_native();

  /// <summary>
  /// Get default system font info interface for current platform
  /// </summary>
  /// <returns>Pointer to a <see cref="T:Patagames.Pdf.FPDF_SYSFONTINFO" /> structure describing the default interface.
  /// Or NULL if the platform doesn't have a default interface.
  /// Application should call <see cref="M:Patagames.Pdf.Pdfium.FPDF_FreeMemory(System.IntPtr)" /> to free the returned pointer.</returns>
  /// <remarks>For some platforms Pdfium SDK implement a default Version of system font info interface.
  /// The default implementation can be used in <see cref="M:Patagames.Pdf.Pdfium.FPDF_SetSystemFontInfo(Patagames.Pdf.FPDF_SYSFONTINFO)" /> function.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static FPDF_SYSFONTINFO FPDF_GetDefaultSystemFontInfo()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetDefaultSystemFontInfo_native();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPRINT_Open", SetLastError = true)]
  private static extern IntPtr FPDFPRINT_Open_native(
    IntPtr doc,
    [MarshalAs(UnmanagedType.LPStr)] string pageRange,
    int paperWidth,
    int paperHeight,
    int printableAreaLeft,
    int printableAreaTop,
    int printableAreaRight,
    int printableAreaBottom,
    PrintScallingMode ScallingMode);

  /// <summary>Prepares given document for direct printing</summary>
  /// <param name="document">A document handle. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadMemDocument(System.Byte[],System.Int32,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadCustomDocument(Patagames.Pdf.FPDF_FILEACCESS,System.String)" /> functions.</param>
  /// <param name="pageRange">A page range string, Such as "1,3,5-7". If this parameter is NULL, it would import all pages in src_doc.</param>
  /// <param name="paperWidth">A paper width in points.</param>
  /// <param name="paperHeight">A paper height in points.</param>
  /// <param name="printableAreaLeft">A Page printable area values in points.</param>
  /// <param name="printableAreaTop">A Page printable area values in points.</param>
  /// <param name="printableAreaRight">A Page printable area values in points.</param>
  /// <param name="printableAreaBottom">A Page printable area values in points.</param>
  /// <param name="ScallingMode">The scalling mode.</param>
  /// <returns>
  /// If the function succeeds, the return value is an open handle to the direct print object.
  /// If the function fails, the return value is IntPtr.Zero.
  /// To get extended error information, call <see cref="M:Patagames.Pdf.Pdfium.FPDF_GetLastError" />.
  /// </returns>
  /// <remarks>
  /// When an application is finished using the object handle returned by FPDFPRINT_Open, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFPRINT_Close(System.IntPtr)" /> function to close the handle.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPRINT_Open(
    IntPtr document,
    string pageRange,
    int paperWidth,
    int paperHeight,
    int printableAreaLeft,
    int printableAreaTop,
    int printableAreaRight,
    int printableAreaBottom,
    PrintScallingMode ScallingMode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPRINT_Open_native(document, pageRange, paperWidth, paperHeight, printableAreaLeft, printableAreaTop, printableAreaRight, printableAreaBottom, ScallingMode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPRINT_GetData", SetLastError = true)]
  private static extern IntPtr FPDFPRINT_GetData_native(IntPtr printHandle, out int bufferLen);

  /// <summary>Gets the content of prepared document</summary>
  /// <param name="printHandle">A valid handle to an open direct printing object.</param>
  /// <returns>Content of prepared document or null if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static byte[] FPDFPRINT_GetData(IntPtr printHandle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int bufferLen;
        IntPtr dataNative = Pdfium.FPDFPRINT_GetData_native(printHandle, out bufferLen);
        if (dataNative == IntPtr.Zero || bufferLen <= 0)
          return (byte[]) null;
        byte[] destination = new byte[bufferLen];
        Marshal.Copy(dataNative, destination, 0, bufferLen);
        return destination;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPRINT_GetDocument", SetLastError = true)]
  private static extern IntPtr FPDFPRINT_GetDocument_native(IntPtr printHandle);

  /// <summary>Gets the handle to the prepared document</summary>
  /// <param name="printHandle">A valid handle to an open direct printing object.</param>
  /// <returns>Prepared document or IntPtr.Zero if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPRINT_GetDocument(IntPtr printHandle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPRINT_GetDocument_native(printHandle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPRINT_Close", SetLastError = true)]
  private static extern void FPDFPRINT_Close_native(IntPtr printHandle);

  /// <summary>Closes an open object handle.</summary>
  /// <param name="printHandle">A valid handle to an open direct printing object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPRINT_Close(IntPtr printHandle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPRINT_Close_native(printHandle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFDF_CreateNew", SetLastError = true)]
  private static extern IntPtr FFDF_CreateNew_native();

  /// <summary>Create new FDF document</summary>
  /// <returns>The return value is a handle to the FDF document.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFDF_CreateNew()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FFDF_CreateNew_native());
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFDF_LoadDocument", SetLastError = true)]
  private static extern IntPtr FFDF_LoadDocument_native([MarshalAs(UnmanagedType.LPStr)] string path);

  /// <summary>Load FDF document from file</summary>
  /// <param name="path">Path to FDF document</param>
  /// <returns>Handle to the loaded FDF document</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFDF_LoadDocument(string path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FFDF_LoadDocument_native(path));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFDF_LoadMemDocument", SetLastError = true)]
  private static extern IntPtr FFDF_LoadMemDocument_native([MarshalAs(UnmanagedType.LPArray)] byte[] buffer, int size);

  /// <summary>Load FDF document from file</summary>
  /// <param name="buffer">Byte array with FDF document</param>
  /// <returns>Handle to the loaded FDF document</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFDF_LoadMemDocument(byte[] buffer)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FFDF_LoadMemDocument_native(buffer, buffer.Length));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFDF_CloseDocument", SetLastError = true)]
  private static extern void FFDF_CloseDocument_native(IntPtr fdfDoc);

  /// <summary>Close a loaded FDF document.</summary>
  /// <param name="fdfDoc">Handle to the loaded document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadDocument(System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadMemDocument(System.Byte[])" /> function.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FFDF_CloseDocument(IntPtr fdfDoc)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FFDF_CloseDocument_native(fdfDoc);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFDF_GetDocumentContent", SetLastError = true)]
  private static extern int FFDF_GetDocumentContent_native(IntPtr fdfDoc, [MarshalAs(UnmanagedType.LPArray)] byte[] val, int len);

  /// <summary>
  /// Gets FDF content as an operating system's current ANSI encoded string
  /// </summary>
  /// <param name="fdfDoc">Handle to the loaded document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadDocument(System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadMemDocument(System.Byte[])" /> function.</param>
  /// <returns>Return document content or null if any errors occurs.</returns>
  public static string FFDF_GetDocumentContent(IntPtr fdfDoc)
  {
    byte[] documentContentEx = Pdfium.FFDF_GetDocumentContentEx(fdfDoc);
    return documentContentEx == null ? (string) null : Pdfium.DefaultAnsiEncoding.GetString(documentContentEx, 0, documentContentEx.Length);
  }

  /// <summary>Gets FDF content as a byte array</summary>
  /// <param name="fdfDoc">Handle to the loaded document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadDocument(System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadMemDocument(System.Byte[])" /> function.</param>
  /// <returns>Return document content or null if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static byte[] FFDF_GetDocumentContentEx(IntPtr fdfDoc)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int documentContentNative = Pdfium.FFDF_GetDocumentContent_native(fdfDoc, (byte[]) null, 0);
        if (documentContentNative <= 0)
          return (byte[]) null;
        byte[] val = new byte[documentContentNative - 1];
        Pdfium.FFDF_GetDocumentContent_native(fdfDoc, val, val.Length);
        return val;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFDF_GetRoot", SetLastError = true)]
  private static extern IntPtr FFDF_GetRoot_native(IntPtr fdfDoc);

  /// <summary>Gets dictionary from FDF document</summary>
  /// <param name="fdfDoc">Handle to the loaded document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadDocument(System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadMemDocument(System.Byte[])" /> function.</param>
  /// <returns>Handle to the FDF dictionary, IntPtr.Zero otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFDF_GetRoot(IntPtr fdfDoc)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FFDF_GetRoot_native(fdfDoc));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFDF_GetPath", SetLastError = true)]
  private static extern int FFDF_GetPath_native(IntPtr fdfDoc, [MarshalAs(UnmanagedType.LPArray)] byte[] val, int len);

  /// <summary>
  /// Gets a path to the PDF file from the spicified FDF document
  /// </summary>
  /// <param name="fdfDoc">Handle to the loaded document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadDocument(System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FFDF_LoadMemDocument(System.Byte[])" /> function.</param>
  /// <returns>The source file or target file: the PDF document file that this FDF file was exported from or is intended to be imported into.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FFDF_GetPath(IntPtr fdfDoc)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int pathNative = Pdfium.FFDF_GetPath_native(fdfDoc, (byte[]) null, 0);
        if (pathNative == 0)
          return "";
        byte[] numArray = new byte[pathNative];
        Pdfium.FFDF_GetPath_native(fdfDoc, numArray, pathNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_OpenFile", SetLastError = true)]
  private static extern IntPtr FPDF_OpenFile_native([MarshalAs(UnmanagedType.LPStr)] string path);

  /// <summary>Opens a file on the specified path.</summary>
  /// <param name="path">The file to open.</param>
  /// <returns>Handle to file opened in the specified path.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_OpenFile(string path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_OpenFile_native(path);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CloseFile", SetLastError = true)]
  private static extern void FPDF_CloseFile_native(IntPtr handle);

  /// <summary>
  /// Closes the file opened by <see cref="M:Patagames.Pdf.Pdfium.FPDF_OpenFile(System.String)" /> and releases all resources.
  /// </summary>
  /// <param name="handle">Handle to opened file.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_CloseFile(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_CloseFile_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_SetIdentity", SetLastError = true)]
  private static extern void FPDFMatrix_SetIdentity_native([MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst);

  /// <summary>Set the identity matrix to destination matrix</summary>
  /// <param name="dst">Destination matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_SetIdentity(FS_MATRIX dst)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_SetIdentity_native(dst);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_SetReverse", SetLastError = true)]
  private static extern void FPDFMatrix_SetReverse_native([MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst, [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX src);

  /// <summary>
  /// Inverts the source matrix, if it is invertible and set it to destination matrix.
  /// </summary>
  /// <param name="dst">Destination matrix</param>
  /// <param name="src">Source matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_SetReverse(FS_MATRIX dst, FS_MATRIX src)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_SetReverse_native(dst, src);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_Concat", SetLastError = true)]
  private static extern void FPDFMatrix_Concat_native(
    [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX src,
    bool bPrepended);

  /// <summary>
  /// Multiplies the matrices in the order specified in the bPrepended parameter.
  /// </summary>
  /// <param name="dst">The destination matrix</param>
  /// <param name="src">The source matrix.</param>
  /// <param name="bPrepended">Represents the order of the multiplication.</param>
  /// <remarks>
  /// <para>
  /// if the specified order is Prepend (the prepend parameter is True),
  /// The Matrices are multiplied in a prepended order.
  /// Otherwise in an appended order.
  /// </para>
  /// <para>
  /// <list type="bullet">
  /// <item>Prepended order: [dst] = [src] x [dst]</item>
  /// <item>Appended  order: [dst] = [dst] x [src]</item>
  /// </list>
  /// </para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_Concat(FS_MATRIX dst, FS_MATRIX src, bool bPrepended = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_Concat_native(dst, src, bPrepended);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_ConcatInverse", SetLastError = true)]
  private static extern void FPDFMatrix_ConcatInverse_native(
    [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX src,
    bool bPrepended);

  /// <summary>
  /// Inverts the matrix specified in the src parameter and than multiplies the dst matrix by the inverted matrix, and in the order specified in the prepended parameter.
  /// </summary>
  /// <param name="dst">The destination matrix</param>
  /// <param name="src">The source matrix.</param>
  /// <param name="bPrepended">Represents the order of the multiplication.</param>
  /// <remarks>
  /// <para>
  /// if the specified order is Prepend (the prepend parameter is True),
  /// The Matrices are multiplied in a prepended order.
  /// Otherwise in an appended order.
  /// </para>
  /// <para>
  /// <list type="bullet">
  /// <item>Prepended order: [dst] = [src] x [dst]</item>
  /// <item>Appended  order: [dst] = [dst] x [src]</item>
  /// </list>
  /// </para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_ConcatInverse(FS_MATRIX dst, FS_MATRIX src, bool bPrepended = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_ConcatInverse_native(dst, src, bPrepended);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_Rotate", SetLastError = true)]
  private static extern void FPDFMatrix_Rotate_native(
    [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst,
    [MarshalAs(UnmanagedType.R4)] float fRadian,
    bool bPrepended);

  /// <summary>
  /// Applies a clockwise rotation of an amount specified in the angle parameter, around the origin (zero x and y coordinates) for the specified Matrix.
  /// </summary>
  /// <param name="dst">The matrix</param>
  /// <param name="angle">The angle of the rotation, in radians.</param>
  /// <param name="bPrepended">Specifies the order (append or prepend) in which the rotation is applied to the Matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_Rotate(FS_MATRIX dst, float angle, bool bPrepended = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_Rotate_native(dst, angle, bPrepended);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_RotateAt", SetLastError = true)]
  private static extern void FPDFMatrix_RotateAt_native(
    [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst,
    [MarshalAs(UnmanagedType.R4)] float fRadian,
    [MarshalAs(UnmanagedType.R4)] float x,
    [MarshalAs(UnmanagedType.R4)] float y,
    bool bPrepended);

  /// <summary>
  /// Applies a clockwise rotation about the specified point to the specified Matrix in the specified order.
  /// </summary>
  /// <param name="dst">The matrix</param>
  /// <param name="angle">The angle of the rotation, in radians.</param>
  /// <param name="x">The x-coordinate of the point that represents the center of the rotation.</param>
  /// <param name="y">The y-coordinate of the point that represents the center of the rotation.</param>
  /// <param name="bPrepended">Specifies the order (append or prepend) in which the rotation is applied to the Matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_RotateAt(
    FS_MATRIX dst,
    float angle,
    float x,
    float y,
    bool bPrepended = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_RotateAt_native(dst, angle, x, y, bPrepended);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_Scale", SetLastError = true)]
  private static extern void FPDFMatrix_Scale_native(
    [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst,
    [MarshalAs(UnmanagedType.R4)] float sx,
    [MarshalAs(UnmanagedType.R4)] float sy,
    bool bPrepended);

  /// <summary>
  /// Applies the specified scale vector (sx and sy) to the specified Matrix using the specified order.
  /// </summary>
  /// <param name="dst">The matrix</param>
  /// <param name="sx">The value by which to scale this Matrix in the x-axis direction.</param>
  /// <param name="sy">The value by which to scale this Matrix in the y-axis direction.</param>
  /// <param name="bPrepended">Specifies the order (append or prepend) in which the scale vector is applied to the Matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_Scale(FS_MATRIX dst, float sx, float sy, bool bPrepended = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_Scale_native(dst, sx, sy, bPrepended);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_Translate", SetLastError = true)]
  private static extern void FPDFMatrix_Translate_native(
    [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst,
    [MarshalAs(UnmanagedType.R4)] float x,
    [MarshalAs(UnmanagedType.R4)] float y,
    bool bPrepended);

  /// <summary>
  /// Applies the specified translation vector to the Matrix in the specified order.
  /// </summary>
  /// <param name="dst">The matrix</param>
  /// <param name="x">The x value by which to translate this Matrix.</param>
  /// <param name="y">The y value by which to translate this Matrix.</param>
  /// <param name="bPrepended">Specifies the order (append or prepend) in which the translation is applied to the Matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_Translate(FS_MATRIX dst, float x, float y, bool bPrepended = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_Translate_native(dst, x, y, bPrepended);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TranslateI", SetLastError = true)]
  private static extern void FPDFMatrix_Translate_native(
    [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst,
    int x,
    int y,
    bool bPrepended);

  /// <summary>
  /// Applies the specified translation vector to the Matrix in the specified order.
  /// </summary>
  /// <param name="dst">The matrix</param>
  /// <param name="x">The x value by which to translate this Matrix.</param>
  /// <param name="y">The y value by which to translate this Matrix.</param>
  /// <param name="bPrepended">Specifies the order (append or prepend) in which the translation is applied to the Matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_Translate(FS_MATRIX dst, int x, int y, bool bPrepended = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_Translate_native(dst, x, y, bPrepended);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_Shear", SetLastError = true)]
  private static extern void FPDFMatrix_Shear_native(
    [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX dst,
    [MarshalAs(UnmanagedType.R4)] float fAlphaRadian,
    [MarshalAs(UnmanagedType.R4)] float fBetaRadian,
    bool bPrepended);

  /// <summary>
  /// Applies the specified shear vector to the Matrix in the specified order.
  /// </summary>
  /// <param name="dst">The matrix</param>
  /// <param name="shearX">The horizontal shear factor.</param>
  /// <param name="shearY">The vertical shear factor.</param>
  /// <param name="bPrepended">Specifies the order (append or prepend) in which the shear is applied.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_Shear(FS_MATRIX dst, float shearX, float shearY, bool bPrepended = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_Shear_native(dst, shearX, shearY, bPrepended);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformPoint", SetLastError = true)]
  private static extern void FPDFMatrix_TransformPoint_native(
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix,
    [MarshalAs(UnmanagedType.R4)] ref float x,
    [MarshalAs(UnmanagedType.R4)] ref float y);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a specified point.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="x">The x-coordinate of the point</param>
  /// <param name="y">The y-coordinate of the point</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformPoint(FS_MATRIX matrix, ref float x, ref float y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformPoint_native(matrix, ref x, ref y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformPointI", SetLastError = true)]
  private static extern void FPDFMatrix_TransformPoint_native(
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix,
    ref int x,
    ref int y);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a specified point.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="x">The x-coordinate of the point</param>
  /// <param name="y">The y-coordinate of the point</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformPoint(FS_MATRIX matrix, ref int x, ref int y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformPoint_native(matrix, ref x, ref y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformDistance", SetLastError = true)]
  private static extern void FPDFMatrix_TransformDistance_native(
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix,
    [MarshalAs(UnmanagedType.R4)] out float pDistance,
    [MarshalAs(UnmanagedType.R4)] float dx,
    [MarshalAs(UnmanagedType.R4)] float dy);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a distance.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="dx">The x-coordinate of the distance vector</param>
  /// <param name="dy">The Y-coordinate of the distance vector</param>
  /// <returns>The length of hte distance vector</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFMatrix_TransformDistance(FS_MATRIX matrix, float dx, float dy)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float pDistance;
        Pdfium.FPDFMatrix_TransformDistance_native(matrix, out pDistance, dx, dy);
        return pDistance;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformDistanceI", SetLastError = true)]
  private static extern void FPDFMatrix_TransformDistance_native(
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix,
    out int pDistance,
    int dx,
    int dy);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a distance.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="dx">The x-coordinate of the distance vector</param>
  /// <param name="dy">The Y-coordinate of the distance vector</param>
  /// <returns>The length of hte distance vector</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFMatrix_TransformDistance(FS_MATRIX matrix, int dx, int dy)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int pDistance;
        Pdfium.FPDFMatrix_TransformDistance_native(matrix, out pDistance, dx, dy);
        return pDistance;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformDistanceV", SetLastError = true)]
  private static extern void FPDFMatrix_TransformDistance_native(
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix,
    [MarshalAs(UnmanagedType.R4)] ref float pDistance);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a distance.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="distance">The distance vector</param>
  /// <returns>The length of hte distance vector</returns>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformDistance(FS_MATRIX matrix, ref float distance)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformDistance_native(matrix, ref distance);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformRect", SetLastError = true)]
  private static extern void FPDFMatrix_TransformRect_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix, ref FS_RECTF rect);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a specified rectangle.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="rect">The rectangle to transform</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformRect(FS_MATRIX matrix, ref FS_RECTF rect)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformRect_native(matrix, ref rect);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformVector", SetLastError = true)]
  private static extern void FPDFMatrix_TransformVector_native(
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix,
    [MarshalAs(UnmanagedType.R4)] ref float vx,
    [MarshalAs(UnmanagedType.R4)] ref float vy);

  /// <summary>
  /// Applies only the scale and rotate components of the Matrix to the specified point.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="vx">The x-coordinate of the point</param>
  /// <param name="vy">The y-coordinate of the point</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformVector(FS_MATRIX matrix, ref float vx, ref float vy)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformVector_native(matrix, ref vx, ref vy);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformXDistance", SetLastError = true)]
  private static extern void FPDFMatrix_TransformXDistance_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix, [MarshalAs(UnmanagedType.R4)] ref float dx);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a x-coordinate of the distance vector.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="dx">The x-coordinate of the distance vector</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformXDistance(FS_MATRIX matrix, ref float dx)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformXDistance_native(matrix, ref dx);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformYDistance", SetLastError = true)]
  private static extern void FPDFMatrix_TransformYDistance_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix, [MarshalAs(UnmanagedType.R4)] ref float dy);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a y-coordinate of the distance vector.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="dy">The y-coordinate of the distance vector</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformYDistance(FS_MATRIX matrix, ref float dy)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformYDistance_native(matrix, ref dy);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformXDistanceI", SetLastError = true)]
  private static extern void FPDFMatrix_TransformXDistance_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix, ref int dx);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a x-coordinate of the distance vector.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="dx">The x-coordinate of the distance vector</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformXDistance(FS_MATRIX matrix, ref int dx)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformXDistance_native(matrix, ref dx);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_TransformYDistanceI", SetLastError = true)]
  private static extern void FPDFMatrix_TransformYDistance_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix, ref int dy);

  /// <summary>
  /// Applies the geometric transform represented by the Matrix to a y-coordinate of the distance vector.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <param name="dy">The y-coordinate of the distance vector</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFMatrix_TransformYDistance(FS_MATRIX matrix, ref int dy)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFMatrix_TransformYDistance_native(matrix, ref dy);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_GetUnitArea", SetLastError = true)]
  private static extern void FPDFMatrix_GetUnitArea_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix, [MarshalAs(UnmanagedType.R4)] out float unitArea);

  /// <summary>Get unit area</summary>
  /// <param name="matrix">The matrix</param>
  /// <returns>Unit area</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFMatrix_GetUnitArea(FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float unitArea;
        Pdfium.FPDFMatrix_GetUnitArea_native(matrix, out unitArea);
        return unitArea;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_GetXUnit", SetLastError = true)]
  private static extern void FPDFMatrix_GetXUnit_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix, [MarshalAs(UnmanagedType.R4)] out float xUnit);

  /// <summary>Get x unit</summary>
  /// <param name="matrix">The matrix</param>
  /// <returns>x unit</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFMatrix_GetXUnit(FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float xUnit;
        Pdfium.FPDFMatrix_GetXUnit_native(matrix, out xUnit);
        return xUnit;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_GetYUnit", SetLastError = true)]
  private static extern void FPDFMatrix_GetYUnit_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix, [MarshalAs(UnmanagedType.R4)] out float yUnit);

  /// <summary>Get y unit</summary>
  /// <param name="matrix">The matrix</param>
  /// <returns>y unit</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFMatrix_GetYUnit(FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float yUnit;
        Pdfium.FPDFMatrix_GetYUnit_native(matrix, out yUnit);
        return yUnit;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_Is90Rotated", SetLastError = true)]
  private static extern bool FPDFMatrix_Is90Rotated_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix);

  /// <summary>
  /// Gets a value indicating whether the Matrix is rotated.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <returns>true if the Matrix is rotated; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFMatrix_Is90Rotated(FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFMatrix_Is90Rotated_native(matrix);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_IsIdentity", SetLastError = true)]
  private static extern bool FPDFMatrix_IsIdentity_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix);

  /// <summary>
  /// Gets a value indicating whether the specified Matrix is the identity matrix.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <returns>true if the Matrix is identity; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFMatrix_IsIdentity(FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFMatrix_IsIdentity_native(matrix);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_IsInvertible", SetLastError = true)]
  private static extern bool FPDFMatrix_IsInvertible_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix);

  /// <summary>
  /// Gets a value indicating whether the specified Matrix is invertible.
  /// </summary>
  /// <param name="matrix">The matrix</param>
  /// <returns>true if the Matrix is invertible; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFMatrix_IsInvertible(FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFMatrix_IsInvertible_native(matrix);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFMatrix_IsScaled", SetLastError = true)]
  private static extern bool FPDFMatrix_IsScaled_native([MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix);

  /// <summary>Gets a value indicating whether the Matrix is scaled.</summary>
  /// <param name="matrix">Matrix to check.</param>
  /// <returns>true if the Matrix is scaled; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFMatrix_IsScaled(FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFMatrix_IsScaled_native(matrix);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_StartLoadPage", SetLastError = true)]
  private static extern IntPtr FPDF_StartLoadPage_native(IntPtr document, int page_index);

  /// <summary>Start to load a page inside a document.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="page_index">Index number of the page. 0 for the first page.</param>
  /// <returns>A handle to the loaded page. If failed, IntPtr.Zero is returned.</returns>
  /// <remarks>The page must be continue load using <see cref="M:Patagames.Pdf.Pdfium.FPDF_ContinueLoadPage(System.IntPtr,Patagames.Pdf.IFSDK_PAUSE)" /> function.
  /// Loaded page can be closed by <see cref="M:Patagames.Pdf.Pdfium.FPDF_ClosePage(System.IntPtr)" />.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_StartLoadPage(IntPtr document, int page_index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_StartLoadPage_native(document, page_index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_ContinueLoadPage", SetLastError = true)]
  private static extern int FPDF_ContinueLoadPage_native(IntPtr page, [MarshalAs(UnmanagedType.LPStruct)] IFSDK_PAUSE pause);

  /// <summary>Continue loading a PDF page.</summary>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_StartLoadPage(System.IntPtr,System.Int32)" /> function.</param>
  /// <param name="pause">The <see cref="T:Patagames.Pdf.IFSDK_PAUSE" /> interface. A callback mechanism allowing the page loading
  /// process to be paused before it's finished. This can be NULL if you don't want to pause.</param>
  /// <returns>The loading status.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static ProgressiveStatus FPDF_ContinueLoadPage(IntPtr page, IFSDK_PAUSE pause)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (ProgressiveStatus) Pdfium.FPDF_ContinueLoadPage_native(page, pause);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_IsOwnerPasswordIsUsed", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDF_IsOwnerPasswordIsUsed_native(IntPtr document);

  /// <summary>
  /// Gets a flag indicating whether the owner password was used when opening the document.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>True if owner passward was used.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDF_IsOwnerPasswordIsUsed(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_IsOwnerPasswordIsUsed_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_CreateSampled", SetLastError = true)]
  private static extern IntPtr FPDFFunction_CreateSampled_native(
    int numOfInputs,
    int numOfOutputs,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] domain,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] range,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.I4), In] int[] sampleSizes,
    int BitsPerSample,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] Encode,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] Decode,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.I1), In] byte[] Samples,
    int Order);

  /// <summary>Create sampled function.</summary>
  /// <param name="numOfInputs">The number of input values of a function.</param>
  /// <param name="numOfOutputs">The number of output values of a function.</param>
  /// <param name="domain">The domain of definition of a function.</param>
  /// <param name="range">The range of a function.</param>
  /// <param name="numOfSamples">The number of samples in each input dimension of the sample table.</param>
  /// <param name="bitsPerSample">The number of bits used to represent each sample.</param>
  /// <param name="sampleTable">A sequence of sample values which are organized as an <paramref name="numOfInputs" /> - dimensional table.</param>
  /// <param name="encode">The linear mapping of input values into the domain of the function’s sample table.</param>
  /// <param name="decode">The linear mapping of sample values into the range appropriate for the function’s output values.</param>
  /// <param name="order">The order of interpolation between samples.</param>
  /// <returns>The handle to the created function.</returns>
  /// <remarks>
  /// <list type="table">
  /// <item><term><paramref name="domain" /></term><term>Required</term><description>An array of <i>2 ×</i> <paramref name="numOfInputs" /> numbers. Input values outside the declared domain are clipped to the nearest boundary value.</description></item>
  /// <item><term><paramref name="range" /></term><term>Required</term><description>An array of <i>2 ×</i> <paramref name="numOfOutputs" /> numbers. Output values outside the declared range are clipped to the nearest boundary value.</description></item>
  /// <item><term><paramref name="numOfSamples" /></term><term>Required</term><description>An array of <paramref name="numOfInputs" /> positive integers specifying the number of samples in each input dimension of the sample table.</description></item>
  /// <item><term><paramref name="bitsPerSample" /></term><term>Required</term><description>A number of bits used to represent each sample. (If the function has multiple output values, each one occupies BitsPerSample bits.) Valid values are 1, 2, 4, 8, 12, 16, 24, and 32.</description></item>
  /// <item><term><paramref name="encode" /></term><term>Optional</term><description>An array of <i>2 ×</i> <paramref name="numOfInputs" /> numbers specifying the linear mapping of input values into the domain of the function’s sample table.</description></item>
  /// <item><term><paramref name="decode" /></term><term>Optional</term><description>An array of <i>2 ×</i> <paramref name="numOfOutputs" /> numbers specifying the linear mapping of sample values into the range appropriate for the function’s output values.</description></item>
  /// <item><term><paramref name="order" /></term><term>Optional</term><description>The order of interpolation between samples. Valid values are 1 and 3, specifying linear and cubic spline interpolation, respectively.</description></item>
  /// </list>
  /// <note type="note">When an application is finished using the function handle returned by method, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" /> function to close the handle.</note>
  /// </remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFunction_CreateSampled(
    int numOfInputs,
    int numOfOutputs,
    float[] domain,
    float[] range,
    int[] numOfSamples,
    int bitsPerSample,
    byte[] sampleTable,
    float[] encode = null,
    float[] decode = null,
    int order = 0)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFFunction_CreateSampled_native(numOfInputs, numOfOutputs, domain, range, numOfSamples, bitsPerSample, encode, decode, sampleTable, order));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_CreateExp", SetLastError = true)]
  private static extern IntPtr FPDFFunction_CreateExp_native(
    int numOfInputs,
    int numOfOutputs,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] domain,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] range,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] beginValues,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] endValues,
    float exponent);

  /// <summary>Create exponential interpolation function.</summary>
  /// <param name="numOfInputs">The number of input values of a function.</param>
  /// <param name="numOfOutputs">The number of output values of a function.</param>
  /// <param name="exponent">The interpolation exponent.</param>
  /// <param name="domain">The domain of definition of a function.</param>
  /// <param name="range">The range of a function.</param>
  /// <param name="valuesAt0">An array of numbers defining the function result when x = 0.0.</param>
  /// <param name="valuesAt1">An array of numbers defining the function result when x = 1.0.</param>
  /// <returns>The handle to the created function.</returns>
  /// <remarks>
  /// <list type="table">
  /// <item><term><paramref name="exponent" /></term><term>Required</term><description>An interpolation exponent. Each input value <i>x</i> will return <paramref name="numOfOutputs" /> values, given by <i>y<sub>j</sub> = <paramref name="valuesAt0" /><sub>j</sub> + x<sup><paramref name="exponent" /></sup> × (<paramref name="valuesAt1" /><sub>j</sub> - <paramref name="valuesAt0" /><sub>j</sub>)</i>, for <i>0 ≤ j<![CDATA[ < ]]><paramref name="numOfOutputs" /></i>.</description></item>
  /// <item><term><paramref name="domain" /></term><term>Required</term><description>An array of <i>2 × </i><paramref name="numOfInputs" /> numbers. Input values outside the declared domain are clipped to the nearest boundary value.</description></item>
  /// <item><term><paramref name="range" /></term><term>Optional</term><description>An array of <i>2 × </i><paramref name="numOfOutputs" /> numbers. Output values outside the declared range are clipped to the nearest boundary value. If absent, no clipping is done.</description></item>
  /// <item><term><paramref name="valuesAt0" /></term><term>Optional</term><description>An array of <paramref name="numOfOutputs" /> numbers defining the function result when <i>x = 0.0</i>. Default value: <i>[0.0]</i></description></item>
  /// <item><term><paramref name="valuesAt1" /></term><term>Optional</term><description>An array of <paramref name="numOfOutputs" /> numbers defining the function result when <i>x = 1.0</i>. Default value: <i>[1.0]</i></description></item>
  /// </list>
  /// <para>
  /// Values of <paramref name="domain" /> must constrain <i>x</i> in such a way that if <paramref name="exponent" /> is not an integer, all
  /// values of <i>x</i> must be non-negative, and if <paramref name="exponent" /> is negative, no value of <i>x</i> may be zero.
  /// Typically, <paramref name="domain" /> is declared as <i>[0.0 1.0]</i>, and <paramref name="exponent" /> is a positive number.
  /// The <paramref name="range" /> attribute is optional and can be used to clip the output to a specified range.
  /// </para>
  /// <para>
  /// Note that when <paramref name="exponent" /> is <i>1</i>, the function performs a linear interpolation between <paramref name="valuesAt0" /> and <paramref name="valuesAt1" />;
  /// therefore, the function can also be expressed as a sampled function.
  /// </para>
  /// <note type="note">When an application is finished using the function handle returned by method, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" /> function to close the handle.</note>
  /// </remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFunction_CreateExp(
    int numOfInputs,
    int numOfOutputs,
    float exponent,
    float[] domain,
    float[] range = null,
    float[] valuesAt0 = null,
    float[] valuesAt1 = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFFunction_CreateExp_native(numOfInputs, numOfOutputs, domain, range, valuesAt0, valuesAt1, exponent));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_CreateStitch", SetLastError = true)]
  private static extern IntPtr FPDFFunction_CreateStitch_native(
    IntPtr document,
    int numOfOutputs,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] domain,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] range,
    [MarshalAs(UnmanagedType.LPArray), In] IntPtr[] functions,
    byte numOfFunctions,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] encode,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] bounds);

  /// <summary>
  /// Create a stitching of the subdomains of several 1-input functions to produce a single new 1-input function.
  /// </summary>
  /// <param name="document">The handle to the PDF document.</param>
  /// <param name="numOfOutputs">The number of output values of a function.</param>
  /// <param name="functions">An array of k 1-input functions making up the stitching function.</param>
  /// <param name="encode">An array of 2 × k numbers that, taken in pairs, map each subset of the domain defined by Domain and the Bounds array to the domain of the corresponding function.</param>
  /// <param name="bounds">An array of k − 1 numbers that, in combination with Domain, define the intervals to which each function from the Functions array applies.</param>
  /// <param name="domain">The domain of definition of a function.</param>
  /// <param name="range">The range of a function.</param>
  /// <returns>The handle to the created function.</returns>
  /// <remarks>
  /// <list type="table">
  /// <item><term><strong>Domain</strong></term><term>Required</term><description>Since the resulting stitching function is a 1-input function, the domain is given by a two-element array.</description></item>
  /// <item><term><strong>Range</strong></term><term>Optional</term><description>An array of 2 × <italic>numOfOutputs</italic> numbers. Output values outside the declared range are clipped to the nearest boundary value. If absent, no clipping is done.</description></item>
  /// <item><term><strong>functions</strong></term><term>Required</term><description>An array of k-1 handles to functions. The output dimensionality of all functions must be the same, and compatible with the value of <strong>Range</strong> if <strong>Range</strong> is present.</description></item>
  /// <item><term><strong>bounds</strong></term><term>Required</term><description>An array of k − 1 numbers that, in combination with <strong>Domain</strong>, define the intervals to which each function from the <strong>Functions</strong> array applies. <strong>Bounds</strong> elements must be in order of increasing value, and each value must be within the domain defined by <strong>Domain</strong>.</description></item>
  /// <item><term><strong>encode</strong></term><term>Required</term><description>An array of 2 × k numbers that, taken in pairs, map each subset of the domain defined by <strong>Domain</strong> and the <strong>Bounds</strong> array to the domain of the corresponding function.</description></item>
  /// </list>
  /// <note type="note">When an application is finished using the function handle returned by method, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" /> function to close the handle.</note>
  /// </remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFunction_CreateStitch(
    IntPtr document,
    int numOfOutputs,
    IntPtr[] functions,
    float[] encode,
    float[] bounds,
    float[] domain,
    float[] range = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFFunction_CreateStitch_native(document, numOfOutputs, domain, range, functions, functions == null ? (byte) 0 : (byte) functions.Length, encode, bounds));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_CreatePS", SetLastError = true)]
  private static extern IntPtr FPDFFunction_CreatePS_native(
    int numOfInputs,
    int numOfOutputs,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] domain,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In] float[] range,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.I1), In] byte[] psProg,
    int psProgSize);

  /// <summary>Create a PostScript calculator function.</summary>
  /// <param name="numOfInputs">The number of input values of a function.</param>
  /// <param name="numOfOutputs">The number of output values of a function.</param>
  /// <param name="domain">The domain of definition of a function.</param>
  /// <param name="range">The range of a function.</param>
  /// <param name="psProg">A PostScript program represented by byte array.</param>
  /// <returns>The handle to the created function.</returns>
  /// <remarks>
  /// <list type="table">
  /// <item><term><strong>Domain</strong></term><term>Required</term><description>An array of 2 × <italic>numOfInputs</italic> numbers. Input values outside the declared domain are clipped to the nearest boundary value.</description></item>
  /// <item><term><strong>Range</strong></term><term>Required</term><description>An array of 2 × <italic>numOfOutputs</italic> numbers. Output values outside the declared range are clipped to the nearest boundary value.</description></item>
  /// <item><term><strong>psProg</strong></term><term>Required</term><description>A PostScript code written in a small subset of the PostScript language.</description></item>
  /// </list>
  /// <note type="note">When an application is finished using the function handle returned by method, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" /> function to close the handle.</note>
  /// </remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFunction_CreatePS(
    int numOfInputs,
    int numOfOutputs,
    float[] domain,
    float[] range,
    byte[] psProg)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFFunction_CreatePS_native(numOfInputs, numOfOutputs, domain, range, psProg, psProg == null ? 0 : psProg.Length));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_OpenHandle", SetLastError = true)]
  private static extern IntPtr FPDFFunction_OpenHandle_native(IntPtr obj);

  /// <summary>
  /// Create a function from the Dictionary or Stream object.
  /// </summary>
  /// <param name="obj">The handle to the Dictionary or Stream object that represents the function.</param>
  /// <returns>The handle to the created function.</returns>
  /// <remarks>
  /// <note type="note">When an application is finished using the function handle returned by method, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" /> function to close the handle.</note>
  /// </remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFunction_OpenHandle(IntPtr obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFunction_OpenHandle_native(obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_GetObject", SetLastError = true)]
  private static extern IntPtr FPDFFunction_GetObject_native(IntPtr function);

  /// <summary>Get an underlying Dictionary or Stream object.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>The handle to the underlying Dictionary or Stream object.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />  and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFunction_GetObject(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFFunction_GetObject_native(function));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_CloseHandle", SetLastError = true)]
  private static extern void FPDFFunction_CloseHandle_native(IntPtr function);

  /// <summary>Closes an open function handle.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />  and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFunction_CloseHandle(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFunction_CloseHandle_native(function);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_GetCountInput", SetLastError = true)]
  private static extern int FPDFFunction_GetCountInput_native(IntPtr function);

  /// <summary>Get the number of input values of a function.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>The number of input values or -1 if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFunction_GetCountInput(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFunction_GetCountInput_native(function);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_GetCountOutput", SetLastError = true)]
  private static extern int FPDFFunction_GetCountOutput_native(IntPtr function);

  /// <summary>Get the number of output values of a function.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>The number of output values or -1 if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFunction_GetCountOutput(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFunction_GetCountOutput_native(function);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_GetType", SetLastError = true)]
  private static extern int FPDFFunction_GetType_native(IntPtr function);

  /// <summary>The function type.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>The function type or <see cref="F:Patagames.Pdf.Enums.FunctionTypes.Unknown" /> if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static FunctionTypes FPDFFunction_GetType(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (FunctionTypes) Pdfium.FPDFFunction_GetType_native(function);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_GetDomainArray", SetLastError = true)]
  private static extern int FPDFFunction_GetDomainArray_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] domain);

  /// <summary>Get the domain of definition of a function.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of 2 × m numbers, where m is the number of input values; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFunction_GetDomainArray(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int domainArrayNative = Pdfium.FPDFFunction_GetDomainArray_native(function, 0, (float[]) null);
        if (domainArrayNative <= 0)
          return (float[]) null;
        float[] domain = new float[domainArrayNative];
        return Pdfium.FPDFFunction_GetDomainArray_native(function, domainArrayNative, domain) <= 0 ? (float[]) null : domain;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunction_GetRangeArray", SetLastError = true)]
  private static extern int FPDFFunction_GetRangeArray_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] range);

  /// <summary>Get the range of a function.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of 2 × n numbers, where n is the number of output values; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFunction_GetRangeArray(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int rangeArrayNative = Pdfium.FPDFFunction_GetRangeArray_native(function, 0, (float[]) null);
        if (rangeArrayNative <= 0)
          return (float[]) null;
        float[] range = new float[rangeArrayNative];
        return Pdfium.FPDFFunction_GetRangeArray_native(function, rangeArrayNative, range) <= 0 ? (float[]) null : range;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionExp_GetExponent", SetLastError = true)]
  private static extern bool FPDFFunctionExp_GetExponent_native(IntPtr function, [MarshalAs(UnmanagedType.R4)] out float exp);

  /// <summary>
  /// Get the interpolation exponent of an exponential function.
  /// </summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>The interpolation exponent.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <exception cref="T:Patagames.Pdf.Net.Exceptions.PdfiumException">code= ERROR_INVALID_PARAMETER(87): the input paramenter is wrong.</exception>
  /// <exception cref="T:Patagames.Pdf.Net.Exceptions.PdfiumException">code= INVALID_FUNCTION_TYPE(536871424): unsupported function type.</exception>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFFunctionExp_GetExponent(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float exp;
        if (!Pdfium.FPDFFunctionExp_GetExponent_native(function, out exp))
          throw Pdfium.ProcessLastError();
        return exp;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionExp_GetValuesArray0", SetLastError = true)]
  private static extern int FPDFFunctionExp_GetValuesArray0_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] vals);

  /// <summary>
  /// Get an array of numbers defining the function result when x = 0.0.
  /// </summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of n numbers, where n is the number of output values; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray1(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFunctionExp_GetValuesArray0(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int valuesArray0Native = Pdfium.FPDFFunctionExp_GetValuesArray0_native(function, 0, (float[]) null);
        if (valuesArray0Native <= 0)
          return (float[]) null;
        float[] vals = new float[valuesArray0Native];
        return Pdfium.FPDFFunctionExp_GetValuesArray0_native(function, valuesArray0Native, vals) <= 0 ? (float[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionExp_GetValuesArray1", SetLastError = true)]
  private static extern int FPDFFunctionExp_GetValuesArray1_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] vals);

  /// <summary>
  /// Get an array of numbers defining the function result when x = 1.0.
  /// </summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of n numbers, where n is the number of output values; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetExponent(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionExp_GetValuesArray0(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFunctionExp_GetValuesArray1(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int valuesArray1Native = Pdfium.FPDFFunctionExp_GetValuesArray1_native(function, 0, (float[]) null);
        if (valuesArray1Native <= 0)
          return (float[]) null;
        float[] vals = new float[valuesArray1Native];
        return Pdfium.FPDFFunctionExp_GetValuesArray1_native(function, valuesArray1Native, vals) <= 0 ? (float[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionSampled_GetNumOfSamlesArray", SetLastError = true)]
  private static extern int FPDFFunctionSampled_GetNumOfSamlesArray_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.I4), Out] int[] vals);

  /// <summary>
  /// Get an array of number of samples in the sample table.
  /// </summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of m numbers, where m is the number of input values; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static int[] FPDFFunctionSampled_GetNumOfSamlesArray(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int samlesArrayNative = Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray_native(function, 0, (int[]) null);
        if (samlesArrayNative <= 0)
          return (int[]) null;
        int[] vals = new int[samlesArrayNative];
        return Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray_native(function, samlesArrayNative, vals) <= 0 ? (int[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionSampled_GetEncodeArray", SetLastError = true)]
  private static extern int FPDFFunctionSampled_GetEncodeArray_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] vals);

  /// <summary>
  /// Get the linear mapping of input values into the domain of the function’s sample table.
  /// </summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of 2 × m numbers, where m is the number of input values; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />  and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFunctionSampled_GetEncodeArray(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int encodeArrayNative = Pdfium.FPDFFunctionSampled_GetEncodeArray_native(function, 0, (float[]) null);
        if (encodeArrayNative <= 0)
          return (float[]) null;
        float[] vals = new float[encodeArrayNative];
        return Pdfium.FPDFFunctionSampled_GetEncodeArray_native(function, encodeArrayNative, vals) <= 0 ? (float[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionSampled_GetDecodeArray", SetLastError = true)]
  private static extern int FPDFFunctionSampled_GetDecodeArray_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] vals);

  /// <summary>
  /// Get the linear mapping of sample values into the range appropriate for the function’s output values.
  /// </summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of 2 × n numbers, where n is the number of output values; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFunctionSampled_GetDecodeArray(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int decodeArrayNative = Pdfium.FPDFFunctionSampled_GetDecodeArray_native(function, 0, (float[]) null);
        if (decodeArrayNative <= 0)
          return (float[]) null;
        float[] vals = new float[decodeArrayNative];
        return Pdfium.FPDFFunctionSampled_GetDecodeArray_native(function, decodeArrayNative, vals) <= 0 ? (float[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionSampled_GetBitsPerSample", SetLastError = true)]
  private static extern int FPDFFunctionSampled_GetBitsPerSample_native(IntPtr function);

  /// <summary>Get the number of bits used to represent each sample.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>The number of bits per sample or -1 if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFunctionSampled_GetBitsPerSample(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFunctionSampled_GetBitsPerSample_native(function);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionSampled_GetOrder", SetLastError = true)]
  private static extern int FPDFFunctionSampled_GetOrder_native(IntPtr function);

  /// <summary>Get the order of interpolation between samples.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>1 - linear interpolation, 3 - cubic spline interpolation, -1 if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" /></remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetSamplesTable(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFunctionSampled_GetOrder(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFunctionSampled_GetOrder_native(function);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionSampled_GetSamplesTable", SetLastError = true)]
  private static extern int FPDFFunctionSampled_GetSamplesTable_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.I1), Out] byte[] vals);

  /// <summary>Get a sequence of sample values.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of sample values which are organized as an m-dimensional table, where m is the number of input values; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetNumOfSamlesArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetDecodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetBitsPerSample(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionSampled_GetOrder(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static byte[] FPDFFunctionSampled_GetSamplesTable(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int samplesTableNative = Pdfium.FPDFFunctionSampled_GetSamplesTable_native(function, 0, (byte[]) null);
        if (samplesTableNative <= 0)
          return (byte[]) null;
        byte[] vals = new byte[samplesTableNative];
        return Pdfium.FPDFFunctionSampled_GetSamplesTable_native(function, samplesTableNative, vals) <= 0 ? (byte[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionStitch_GetBoundsArray", SetLastError = true)]
  private static extern int FPDFFunctionStitch_GetBoundsArray_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] vals);

  /// <summary>Get the Bounds array.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of k − 1 numbers, where k is the number of functions; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFunctionStitch_GetBoundsArray(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int boundsArrayNative = Pdfium.FPDFFunctionStitch_GetBoundsArray_native(function, 0, (float[]) null);
        if (boundsArrayNative <= 0)
          return (float[]) null;
        float[] vals = new float[boundsArrayNative];
        return Pdfium.FPDFFunctionStitch_GetBoundsArray_native(function, boundsArrayNative, vals) <= 0 ? (float[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionStitch_GetEncodeArray", SetLastError = true)]
  private static extern int FPDFFunctionStitch_GetEncodeArray_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] vals);

  /// <summary>Get the Encode array.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array of 2 × k numbers, where k is the number of functions; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFunctionStitch_GetEncodeArray(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int encodeArrayNative = Pdfium.FPDFFunctionStitch_GetEncodeArray_native(function, 0, (float[]) null);
        if (encodeArrayNative <= 0)
          return (float[]) null;
        float[] vals = new float[encodeArrayNative];
        return Pdfium.FPDFFunctionStitch_GetEncodeArray_native(function, encodeArrayNative, vals) <= 0 ? (float[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionStitch_GetFunctionsCount", SetLastError = true)]
  private static extern int FPDFFunctionStitch_GetFunctionsCount_native(IntPtr function);

  /// <summary>Get the number of functions.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>Number of functionsl; or -1 if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />  and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFunctionStitch_GetFunctionsCount(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFunctionStitch_GetFunctionsCount_native(function);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionStitch_GetFunctionAt", SetLastError = true)]
  private static extern IntPtr FPDFFunctionStitch_GetFunctionAt_native(IntPtr function, int index);

  /// <summary>Get the function at a given position.</summary>
  /// <param name="function">The handle to the type 3 (Stitching) function.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than or equal to the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />.</param>
  /// <returns>The handle to the function at the specified index in the type 3 (Stitching) function.</returns>
  /// <remarks>
  /// The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />  and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.
  /// <note type="note">When an application is finished using the function handle returned by method, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" /> function to close the handle.</note>
  /// </remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetBoundsArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetEncodeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionsCount(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFunctionStitch_GetFunctionAt(IntPtr function, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFunctionStitch_GetFunctionAt_native(function, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFunctionPs_GetProg", SetLastError = true)]
  private static extern int FPDFFunctionPs_GetProg_native(
    IntPtr function,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.I1), Out] byte[] vals);

  /// <summary>Get a PostScript program represented by byte array.</summary>
  /// <param name="function">The handle to the function.</param>
  /// <returns>An array that contain PS program; or null if any error has occurred.</returns>
  /// <remarks>The <strong>function</strong> is a handle returned by these methods: <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDFFunctionStitch_GetFunctionAt(System.IntPtr,System.Int32)" />.</remarks>
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateSampled(System.Int32,System.Int32,System.Single[],System.Single[],System.Int32[],System.Int32,System.Byte[],System.Single[],System.Single[],System.Int32)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateExp(System.Int32,System.Int32,System.Single,System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreateStitch(System.IntPtr,System.Int32,System.IntPtr[],System.Single[],System.Single[],System.Single[],System.Single[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CreatePS(System.Int32,System.Int32,System.Single[],System.Single[],System.Byte[])" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_OpenHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetObject(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountInput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetCountOutput(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetType(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetDomainArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunction_GetRangeArray(System.IntPtr)" />
  /// <seealso cref="M:Patagames.Pdf.Pdfium.FPDFFunctionPs_GetProg(System.IntPtr)" />
  [HandleProcessCorruptedStateExceptions]
  public static byte[] FPDFFunctionPs_GetProg(IntPtr function)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int progNative = Pdfium.FPDFFunctionPs_GetProg_native(function, 0, (byte[]) null);
        if (progNative <= 0)
          return (byte[]) null;
        byte[] vals = new byte[progNative];
        return Pdfium.FPDFFunctionPs_GetProg_native(function, progNative, vals) <= 0 ? (byte[]) null : vals;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetType", SetLastError = true)]
  private static extern int FPDFPageObj_GetType_native(IntPtr page_object);

  /// <summary>Gets page object type.</summary>
  /// <param name="page_object">Handle to a page object.</param>
  /// <returns>Returns one of the FPDF_PAGEOBJ_xxxx constants defined following.
  /// <para>FPDF_PAGEOBJ_TEXT 1</para>
  /// <para>FPDF_PAGEOBJ_PATH 2</para>
  /// <para>FPDF_PAGEOBJ_IMAGE 3</para>
  /// <para>FPDF_PAGEOBJ_SHADING 4</para>
  /// <para>FPDF_PAGEOBJ_FORM 5</para>
  /// </returns>
  [HandleProcessCorruptedStateExceptions]
  public static PageObjectTypes FPDFPageObj_GetType(IntPtr page_object)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (PageObjectTypes) Pdfium.FPDFPageObj_GetType_native(page_object);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_Create", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_Create_native(PageObjectTypes type);

  /// <summary>Create new page object specified by type</summary>
  /// <param name="type">Types of page object</param>
  /// <returns>Handle to a page object</returns>
  /// <remarks>
  /// Currently, It can be "PDFPAGE_TEXT", "PDFPAGE_IMAGE", "PDFPAGE_PATH",
  /// "PDFPAGE_SHADING", "PDFPAGE_FORM"
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPageObj_Create(PageObjectTypes type)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_Create_native(type);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_Release", SetLastError = true)]
  private static extern void FPDFPageObj_Release_native(IntPtr handle);

  /// <summary>Release page object</summary>
  /// <param name="handle">Handle to page object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" />.</param>
  /// <remarks>
  /// The application should not call this method if object was inserted into page. In this case it would be called automatically.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_Release(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_Release_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_Clone", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_Clone_native(IntPtr srcPage_obj);

  /// <summary>Create a new page object based on this page object.</summary>
  /// <param name="srcPage_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>Handle to a page object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPageObj_Clone(IntPtr srcPage_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_Clone_native(srcPage_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_RemoveClipPath", SetLastError = true)]
  private static extern void FPDFPageObj_RemoveClipPath_native(IntPtr page_obj);

  /// <summary>Remove a clip from the page object.</summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_RemoveClipPath(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_RemoveClipPath_native(page_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_AppendClipPath", SetLastError = true)]
  private static extern void FPDFPageObj_AppendClipPath_native(
    IntPtr page_obj,
    IntPtr path,
    FillModes type,
    bool bAutoMerge);

  /// <summary>Append a path to the current clip</summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="path">Handle to a path.</param>
  /// <param name="type">The fill mode types defined following. FPDF_FILL_NULL= 0, FPDF_FILL_ALTERNATE = 1, FPDF_FILL_WINDING = 2</param>
  /// <param name="bAutoMerge">True for auto merge</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_AppendClipPath(
    IntPtr page_obj,
    IntPtr path,
    FillModes type,
    bool bAutoMerge)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_AppendClipPath_native(page_obj, path, type, bAutoMerge);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_CopyClipPath", SetLastError = true)]
  private static extern void FPDFPageObj_CopyClipPath_native(
    IntPtr dstPageObject,
    IntPtr srcPageObject);

  /// <summary>Copy clip path from one page object to another</summary>
  /// <param name="dstPageObject">Handle to a destination page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="srcPageObject">Handle to a source page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_CopyClipPath(IntPtr dstPageObject, IntPtr srcPageObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_CopyClipPath_native(dstPageObject, srcPageObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetBoundingBox", SetLastError = true)]
  private static extern void FPDFPageObj_GetBoundingBox_native(
    IntPtr page_obj,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX pMatrix,
    out int left,
    out int top,
    out int right,
    out int bottom);

  /// <summary>Get page object bounding box.</summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="pMatrix">Modify box before return. Can be null</param>
  /// <param name="left">Pointer to a value receiving the left of a rectangle (in points).</param>
  /// <param name="top">Pointer to a value receiving the bottom of a rectangle (in points).</param>
  /// <param name="right">Pointer to a value receiving the right of a rectangle (in points).</param>
  /// <param name="bottom">Pointer to a value receiving the top of a rectangle (in points).</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_GetBBox(
    IntPtr page_obj,
    FS_MATRIX pMatrix,
    out int left,
    out int top,
    out int right,
    out int bottom)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_GetBoundingBox_native(page_obj, pMatrix, out left, out top, out right, out bottom);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetBoundingBoxEx", SetLastError = true)]
  private static extern void FPDFPageObj_GetBoundingBox_native(
    IntPtr page_obj,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX pMatrix,
    out float left,
    out float top,
    out float right,
    out float bottom);

  /// <summary>Get page object bounding box.</summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="pMatrix">Modify box before return. Can be null</param>
  /// <param name="left">Pointer to a value receiving the left of a rectangle (in points).</param>
  /// <param name="top">Pointer to a value receiving the bottom of a rectangle (in points).</param>
  /// <param name="right">Pointer to a value receiving the right of a rectangle (in points).</param>
  /// <param name="bottom">Pointer to a value receiving the top of a rectangle (in points).</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_GetBBox(
    IntPtr page_obj,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX pMatrix,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float top,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float bottom)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_GetBoundingBox_native(page_obj, pMatrix, out left, out top, out right, out bottom);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetFillColor", SetLastError = true)]
  private static extern int FPDFPageObj_GetFillColor_native(IntPtr page_obj);

  /// <summary>Get the fill color of a page object.</summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>The fill color of a page object. Constructed by 0xaarrggbb.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFPageObj_GetFillColor(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_GetFillColor_native(page_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetStrokeColor", SetLastError = true)]
  private static extern int FPDFPageObj_GetStrokeColor_native(IntPtr page_obj);

  /// <summary>Get the stroke color of a page object.</summary>
  /// <param name="page_obj">Handle to page object, could be text_object, path_object and uncolored images.</param>
  /// <returns>The stroke color of a page object. Constructed by 0xaarrggbb</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFPageObj_GetStrokeColor(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_GetStrokeColor_native(page_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetFillColor", SetLastError = true)]
  private static extern void FPDFPageObj_SetFillColor_native(IntPtr page_obj, int argb);

  /// <summary>Set the fill color of a page object.</summary>
  /// <param name="page_obj">Handle to page object, could be text_object, path_object and uncolored images.</param>
  /// <param name="argb">The fill color of a page object. Constructed by 0xaarrggbb.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetFillColor(IntPtr page_obj, int argb)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetFillColor_native(page_obj, argb);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetStrokeColor", SetLastError = true)]
  private static extern void FPDFPageObj_SetStrokeColor_native(IntPtr page_obj, int argb);

  /// <summary>Set the stroke color of a page object.</summary>
  /// <param name="page_obj">Handle to page object, could be text_object, path_object and uncolored images.</param>
  /// <param name="argb">The stroke color of a page object. Constructed by 0xaarrggbb.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetStrokeColor(IntPtr page_obj, int argb)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetStrokeColor_native(page_obj, argb);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_CountMarks", SetLastError = true)]
  private static extern int FPDFPageObj_CountMarks_native(IntPtr page_object);

  /// <summary>
  /// Gets the number of elements in marked content of the object
  /// </summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>Number of elements in marked content.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFPageObj_CountMarks(IntPtr page_object)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_CountMarks_native(page_object);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_AddMark", SetLastError = true)]
  private static extern void FPDFPageObj_AddMark_native(
    IntPtr page_object,
    [MarshalAs(UnmanagedType.LPStr)] string tag,
    IntPtr dictionary,
    bool bDirect);

  /// <summary>Adds new element at the end of marked content</summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="tag">A tag operand of the marked content operator</param>
  /// <param name="dictionary">Handle to the dictionary</param>
  /// <param name="bDirect">The type of the dictionary</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_AddMark(
    IntPtr page_object,
    string tag,
    IntPtr dictionary,
    bool bDirect)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_AddMark_native(page_object, tag, dictionary, bDirect);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_DeleteLastMark", SetLastError = true)]
  private static extern void FPDFPageObj_DeleteLastMark_native(IntPtr page_object);

  /// <summary>Remove the last element of the marked content</summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_DeleteLastMark(IntPtr page_object)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_DeleteLastMark_native(page_object);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetMarkName", SetLastError = true)]
  private static extern int FPDFPageObj_GetMarkName_native(
    IntPtr page_object,
    int index,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>Get a tag operand of the marked content operator.</summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="index">Zero-based index of the element in the marked content</param>
  /// <returns>A tag operand of the marked content operator.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFPageObj_GetMarkName(IntPtr page_object, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int num = 0;
        byte[] buffer = (byte[]) null;
        int markNameNative = Pdfium.FPDFPageObj_GetMarkName_native(page_object, index, buffer, 0);
        byte[] numArray = new byte[markNameNative];
        num = Pdfium.FPDFPageObj_GetMarkName_native(page_object, index, numArray, markNameNative);
        return Pdfium.DefaultAnsiEncoding.GetString(numArray, 0, numArray.Length).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetMarkParamType", SetLastError = true)]
  private static extern int FPDFPageObj_GetMarkParamType_native(IntPtr page_object, int index);

  /// <summary>Get a type of the associated property list</summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="index">Zero-based index of the element in the marked content</param>
  /// <returns>Type of the associated property list.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static PropertyListTypes FPDFPageObj_GetMarkParamType(IntPtr page_object, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (PropertyListTypes) Pdfium.FPDFPageObj_GetMarkParamType_native(page_object, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetMarkParam", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_GetMarkParam_native(IntPtr page_object, int index);

  /// <summary>
  /// Get the property list associated with marked contetent.
  /// </summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="index">Zero-based index of the element in the marked content</param>
  /// <returns>The property list associated with marked contetent.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPageObj_GetMarkParam(IntPtr page_object, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_GetMarkParam_native(page_object, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_MarkHasMCID", SetLastError = true)]
  private static extern bool FPDFPageObj_MarkHasMCID_native(IntPtr page_object, int index);

  /// <summary>
  /// Gets a value indicating whether the parameters dictionary contains a marked-content
  /// identifier that uniquely identifies the marked-content sequence within its content stream.
  /// </summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="index">Zero-based index of the element in the marked content</param>
  /// <returns>True if the parameters dictionary contains MCID entry; false otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPageObj_MarkHasMCID(IntPtr page_object, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_MarkHasMCID_native(page_object, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetMarkName", SetLastError = true)]
  private static extern void FPDFPageObj_SetMarkName_native(
    IntPtr page_object,
    int index,
    [MarshalAs(UnmanagedType.LPStr)] string tag);

  /// <summary>Set tag operand of the marked content operator</summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="index">Zero-based index of the element in the marked content</param>
  /// <param name="tag">A tag operand of the marked content operator</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetMarkName(IntPtr page_object, int index, string tag)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetMarkName_native(page_object, index, tag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetMarkParam", SetLastError = true)]
  private static extern void FPDFPageObj_SetMarkParam_native(
    IntPtr page_object,
    int index,
    int paramType,
    IntPtr dictionary);

  /// <summary>Set property list at the specified index</summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="index">Zero-based index of the element in the marked content</param>
  /// <param name="paramType">A type of the associated property list</param>
  /// <param name="dictionary">Handle to the dictionary</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetMarkParam(
    IntPtr page_object,
    int index,
    PropertyListTypes paramType,
    IntPtr dictionary)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetMarkParam_native(page_object, index, (int) paramType, dictionary);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Set marked content at the specified index</summary>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="index">Zero-based index of the element in the marked content</param>
  /// <param name="tag">A tag operand of the marked content operator</param>
  /// <param name="paramType">A type of the associated property list</param>
  /// <param name="dictionary">Handle to the dictionary</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetMark(
    IntPtr page_object,
    int index,
    [MarshalAs(UnmanagedType.LPStr)] string tag,
    PropertyListTypes paramType,
    IntPtr dictionary)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetMarkName_native(page_object, index, tag);
        Pdfium.FPDFPageObj_SetMarkParam_native(page_object, index, (int) paramType, dictionary);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_NewImgeObj", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_NewImgeObj_native(IntPtr document);

  /// <summary>Create a new Image Object.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" /> function.</param>
  /// <returns>Handle to image object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPageObj_NewImgeObj(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_NewImgeObj_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_GetMatrix", SetLastError = true)]
  private static extern void FPDFImageObj_GetMatrix_native(
    IntPtr image_object,
    [MarshalAs(UnmanagedType.R8)] out double a,
    [MarshalAs(UnmanagedType.R8)] out double b,
    [MarshalAs(UnmanagedType.R8)] out double c,
    [MarshalAs(UnmanagedType.R8)] out double d,
    [MarshalAs(UnmanagedType.R8)] out double e,
    [MarshalAs(UnmanagedType.R8)] out double f);

  /// <summary>Get the matrix of an image object</summary>
  /// <param name="image_object">Handle to image object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" /></param>
  /// <param name="a">Pointer to a float value receiving the coefficient "a" of the matrix.</param>
  /// <param name="b">Pointer to a float value receiving the coefficient "b" of the matrix.</param>
  /// <param name="c">Pointer to a float value receiving the coefficient "c" of the matrix.</param>
  /// <param name="d">Pointer to a float value receiving the coefficient "d" of the matrix.</param>
  /// <param name="e">Pointer to a float value receiving the coefficient "e" of the matrix.</param>
  /// <param name="f">Pointer to a float value receiving the coefficient "f" of the matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFImageObj_GetMatrix(
    IntPtr image_object,
    out double a,
    out double b,
    out double c,
    out double d,
    out double e,
    out double f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFImageObj_GetMatrix_native(image_object, out a, out b, out c, out d, out e, out f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Get the matrix of an image object</summary>
  /// <param name="image_object">Handle to image object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" /></param>
  /// <returns>Transformation matrix.</returns>
  public static FS_MATRIX FPDFImageObj_GetMatrix(IntPtr image_object)
  {
    double a;
    double b;
    double c;
    double d;
    double e;
    double f;
    Pdfium.FPDFImageObj_GetMatrix(image_object, out a, out b, out c, out d, out e, out f);
    return new FS_MATRIX(a, b, c, d, e, f);
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_SetMatrix", SetLastError = true)]
  private static extern void FPDFImageObj_SetMatrix_native(
    IntPtr image_object,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f);

  /// <summary>Set the matrix of an image object</summary>
  /// <param name="image_object">Handle to image object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" />.</param>
  /// <param name="a">The coefficient "a" of the matrix</param>
  /// <param name="b">The coefficient "b" of the matrix</param>
  /// <param name="c">The coefficient "c" of the matrix</param>
  /// <param name="d">The coefficient "d" of the matrix</param>
  /// <param name="e">The coefficient "e" of the matrix</param>
  /// <param name="f">The coefficient "f" of the matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFImageObj_SetMatrix(
    IntPtr image_object,
    double a,
    double b,
    double c,
    double d,
    double e,
    double f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFImageObj_SetMatrix_native(image_object, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Set the matrix of an image object</summary>
  /// <param name="image_object">Handle to image object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" />.</param>
  /// <param name="matrix">The matrix to set.</param>
  public static void FPDFImageObj_SetMatrix(IntPtr image_object, FS_MATRIX matrix)
  {
    Pdfium.FPDFImageObj_SetMatrix(image_object, (double) matrix.a, (double) matrix.b, (double) matrix.c, (double) matrix.d, (double) matrix.e, (double) matrix.f);
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_LoadJpegFile", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFImageObj_LoadJpegFile_native(
    IntPtr pages,
    int nCount,
    IntPtr image_object,
    IntPtr fileAccess);

  /// <summary>
  /// Load Image from a JPEG image file and then set it to an image object.
  /// </summary>
  /// <param name="pages">Pointers to the start of all loaded pages, could be IntPtr.Zero.</param>
  /// <param name="nCount">Number of pages, could be 0.</param>
  /// <param name="image_object">Handle to image object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" />.</param>
  /// <param name="fileAccess">The custom file access handler, which specifies the JPEG image file.</param>
  /// <returns>Jpeg file handle if successful, IntPtr.Zero otherwise.</returns>
  /// <remarks>The image object might already has an associated image, which is shared and cached by the loaded pages, In this case, we need to clear the cache of image for all the loaded pages.
  /// Pass pages and count to this API to clear the image cache. The image must be destroyed by calling <see cref="M:Patagames.Pdf.Pdfium.FPDFImageObj_DestroyJpegFile(System.IntPtr)" /></remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFImageObj_LoadJpegFile(
    IntPtr pages,
    int nCount,
    IntPtr image_object,
    FPDF_FILEACCESS fileAccess)
  {
    using (Lock.SyncMT)
    {
      try
      {
        PointerManagerItem<FPDF_FILEACCESS> pointerManagerItem = new PointerManagerItem<FPDF_FILEACCESS>(fileAccess);
        if (!Pdfium.FPDFImageObj_LoadJpegFile_native(pages, nCount, image_object, pointerManagerItem[0]))
          return IntPtr.Zero;
        pointerManagerItem.Key = pointerManagerItem[0];
        PointerManager.Add((IPointerManagerItem) pointerManagerItem);
        return pointerManagerItem[0];
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Destroy an jpeg image object and release all related buffers
  /// </summary>
  /// <param name="jpegHandle">Handle to the jpeg. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFImageObj_LoadJpegFile(System.IntPtr,System.Int32,System.IntPtr,Patagames.Pdf.FPDF_FILEACCESS)" /> function.</param>
  public static void FPDFImageObj_DestroyJpegFile(IntPtr jpegHandle)
  {
    PointerManager.Remove(jpegHandle);
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_SetBitmap", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFImageObj_SetBitmap_native(
    IntPtr pages,
    int nCount,
    IntPtr image_object,
    IntPtr bitmap);

  /// <summary>Set the bitmap to an image object.</summary>
  /// <param name="pages">Pointer's to the start of all loaded pages.</param>
  /// <param name="nCount">Number of pages.</param>
  /// <param name="image_object">Handle to image object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" />.</param>
  /// <param name="bitmap">The Handle to the bitmap which you want to set it to the image object.</param>
  /// <returns>TRUE if successful, FALSE otherwise.</returns>
  /// <remarks>See remarks of <see cref="M:Patagames.Pdf.Pdfium.FPDFImageObj_LoadJpegFile(System.IntPtr,System.Int32,System.IntPtr,Patagames.Pdf.FPDF_FILEACCESS)" /> function for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFImageObj_SetBitmap(
    IntPtr pages,
    int nCount,
    IntPtr image_object,
    IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFImageObj_SetBitmap_native(pages, nCount, image_object, bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_GetCloneBitmap", SetLastError = true)]
  private static extern IntPtr FPDFImageObj_GetCloneBitmap_native(IntPtr image_object);

  /// <summary>Get the copy of bitmap from an image object.</summary>
  /// <param name="image_object">Handle to image object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" />.</param>
  /// <returns>The Handle to the bitmap.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFImageObj_GetCloneBitmap(IntPtr image_object)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFImageObj_GetCloneBitmap_native(image_object);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_CalcBoundingBox", SetLastError = true)]
  private static extern void FPDFImageObj_CalcBoundingBox_native(IntPtr image_obj);

  /// <summary>Calculate bounding box</summary>
  /// <param name="image_obj">Image object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFImageObj_CalcBoundingBox(IntPtr image_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFImageObj_CalcBoundingBox_native(image_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_GenerateStream", SetLastError = true)]
  private static extern IntPtr FPDFImageObj_GenerateStream_native(IntPtr image_obj, IntPtr page);

  /// <summary>Generate content stream of an image object</summary>
  /// <param name="image_obj">The handle to image object</param>
  /// <param name="page">The handle to page</param>
  /// <returns>The handle to the Stream in unmanaged memory</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFImageObj_GenerateStream(IntPtr image_obj, IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFImageObj_GenerateStream_native(image_obj, page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_GetStream", SetLastError = true)]
  private static extern IntPtr FPDFImageObj_GetStream_native(IntPtr image_obj);

  /// <summary>
  /// Get the stream contains image data from the specified image object.
  /// </summary>
  /// <param name="image_obj">The handle to an image object.</param>
  /// <returns>The handle to the Stream.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFImageObj_GetStream(IntPtr image_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFImageObj_GetStream_native(image_obj));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_GetOC", SetLastError = true)]
  private static extern IntPtr FPDFImageObj_GetOC_native(IntPtr image_obj);

  /// <summary>
  /// Get an optional content from the specified image object.
  /// </summary>
  /// <param name="image_obj">The handle to an image object.</param>
  /// <returns>The handle to the dictionary contains optional content.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFImageObj_GetOC(IntPtr image_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFImageObj_GetOC_native(image_obj));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_GetInlineDict", SetLastError = true)]
  private static extern IntPtr FPDFImageObj_GetInlineDict_native(IntPtr image_obj);

  /// <summary>Get the dictionary of the inline image object.</summary>
  /// <param name="image_obj">The handle to an image object.</param>
  /// <returns>The handle to the dictionary.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFImageObj_GetInlineDict(IntPtr image_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFImageObj_GetInlineDict_native(image_obj));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_IsInline", SetLastError = true)]
  private static extern bool FPDFImageObj_IsInline_native(IntPtr image_obj);

  /// <summary>
  /// Get a flag indicating whether the specified image object is inline image.
  /// </summary>
  /// <param name="image_obj">The handle to an image object.</param>
  /// <returns>TRUE if the specified image object is inline, otherwise FALSE.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFImageObj_IsInline(IntPtr image_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFImageObj_IsInline_native(image_obj));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_LoadFromStream", SetLastError = true)]
  private static extern bool FPDFImageObj_LoadFromStream_native(
    IntPtr image_obj,
    IntPtr stream,
    bool bInline);

  /// <summary>
  /// Load image from specified image stream to the specified image object
  /// </summary>
  /// <param name="image_obj">The handle to an image object.</param>
  /// <param name="stream">The handle to an image.</param>
  /// <param name="bInline">Flag indicating whether the image should be inline.</param>
  /// <returns>TRUE if successful; otherwise FALSE.</returns>
  [HandleProcessCorruptedStateExceptions]
  internal static bool FPDFImageObj_LoadFromStream(IntPtr image_obj, IntPtr stream, bool bInline)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFImageObj_LoadFromStream_native(image_obj, stream, bInline);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_SetJpegImage", SetLastError = true)]
  private static extern bool FPDFImageObj_SetJpegImage_native(
    IntPtr image_obj,
    byte[] imageData,
    int dataSize);

  /// <summary>
  /// Load Image from an array containing JPEG image and then set it to an image object.
  /// </summary>
  /// <param name="image_obj">The handle to an image object.</param>
  /// <param name="imageData">An array that contains jpeg encoded image</param>
  /// <returns>Returns TRUE on success; FALSE otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFImageObj_SetJpegImage(IntPtr image_obj, byte[] imageData)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFImageObj_SetJpegImage_native(image_obj, imageData, imageData == null ? 0 : imageData.Length));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_GetPixelSize", SetLastError = true)]
  private static extern bool FPDFImageObj_GetPixelSize_native(
    IntPtr image_obj,
    out int width,
    out int height);

  /// <summary>Get size of the image in pixels.</summary>
  /// <param name="image_obj">The handle to an image object.</param>
  /// <param name="width">The width in pixels of the specified image object.</param>
  /// <param name="height">The height in pixels of the specified image object.</param>
  /// <returns>Returns TRUE on success; FALSE otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFImageObj_GetPixelSize(IntPtr image_obj, out int width, out int height)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFImageObj_GetPixelSize_native(image_obj, out width, out height));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFImageObj_SetBitmapEx", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFImageObj_SetBitmap_native(
    IntPtr pages,
    int nCount,
    IntPtr image_object,
    IntPtr bitmap,
    [MarshalAs(UnmanagedType.U4)] ImageCompression iCompress);

  /// <summary>Set the bitmap to an image object.</summary>
  /// <param name="pages">Pointer's to the start of all loaded pages.</param>
  /// <param name="nCount">Number of pages.</param>
  /// <param name="image_object">Handle to image object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" />.</param>
  /// <param name="bitmap">The Handle to the bitmap which you want to set it to the image object.</param>
  /// <param name="compress">A flag indicating which compression to apply to the bitmap.</param>
  /// <returns>TRUE if successful, FALSE otherwise.</returns>
  /// <remarks>See remarks of <see cref="M:Patagames.Pdf.Pdfium.FPDFImageObj_LoadJpegFile(System.IntPtr,System.Int32,System.IntPtr,Patagames.Pdf.FPDF_FILEACCESS)" /> function for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFImageObj_SetBitmap(
    IntPtr pages,
    int nCount,
    IntPtr image_object,
    IntPtr bitmap,
    ImageCompression compress)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFImageObj_SetBitmap_native(pages, nCount, image_object, bitmap, compress));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_GetFormat", SetLastError = true)]
  private static extern BitmapFormats FPDFBitmap_GetFormat_native(IntPtr bitmap);

  /// <summary>
  /// Returns the pixel format for the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>A <see cref="T:Patagames.Pdf.Enums.BitmapFormats" /> that represents the pixel format for the <paramref name="bitmap" />.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static BitmapFormats FPDFBitmap_GetFormat(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_GetFormat_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_GetPitch", SetLastError = true)]
  private static extern int FPDFBitmap_GetPitch_native(IntPtr bitmap);

  /// <summary>
  /// Gets number of bytes for each scan line in the bitmap <see cref="T:System.Buffer" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>Integer that specifies the byte offset between the beginning of one scan line and the next. This is usually (but not necessarily) the number of bytes in the pixel format (for example, 2 for 16 bits per pixel) multiplied by the width of the bitmap. The value passed to this parameter must be a multiple of four.</returns>
  /// <remarks>This property is obsolete and will be removed in a future release of the Pdfium .Net SDK. Please use <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_GetStride(System.IntPtr)" /> instead.</remarks>
  [HandleProcessCorruptedStateExceptions]
  [Obsolete("This method is obsolete and will be removed in a future release of the Pdfium .Net SDK. Please use FPDFBitmap_GetStride instead.", false)]
  public static int FPDFBitmap_GetPitch(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_GetPitch_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_GetPaletteSize", SetLastError = true)]
  private static extern int FFPDFBitmap_GetPaletteSize_native(IntPtr bitmap);

  /// <summary>
  /// Returns the number of elements in color palette used for the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>The number of elements in color palette used for the <paramref name="bitmap" />.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FFPDFBitmap_GetPaletteSize(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_GetPaletteSize_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_GetPalette", SetLastError = true)]
  private static extern IntPtr FFPDFBitmap_GetPalette_native(IntPtr bitmap);

  /// <summary>
  /// Returns the color palette used for the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>A copy of an array of the palette used by the <paramref name="bitmap" />.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int[] FFPDFBitmap_GetPalette(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int paletteSize = Pdfium.FFPDFBitmap_GetPaletteSize(bitmap);
        if (paletteSize == 0)
          return (int[]) null;
        IntPtr paletteNative = Pdfium.FFPDFBitmap_GetPalette_native(bitmap);
        if (paletteNative == IntPtr.Zero)
          return (int[]) null;
        int[] destination = new int[paletteSize];
        Marshal.Copy(paletteNative, destination, 0, paletteSize);
        return destination;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_GetBPP", SetLastError = true)]
  private static extern int FFPDFBitmap_GetBPP_native(IntPtr bitmap);

  /// <summary>
  /// Returns the color depth, in number of bits per pixel, of the specified <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>The color depth of the specified <paramref name="bitmap" />.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FFPDFBitmap_GetBPP(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_GetBPP_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_IsAlphaMask", SetLastError = true)]
  private static extern bool FFPDFBitmap_IsAlphaMask_native(IntPtr bitmap);

  /// <summary>
  /// Returns a flag indicating whether the <paramref name="bitmap" /> is a transparency mask.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>A boolean value indicating whether this <paramref name="bitmap" /> is a transparency mask (true) or not (false).</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FFPDFBitmap_IsAlphaMask(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_IsAlphaMask_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_HasAlpha", SetLastError = true)]
  private static extern bool FFPDFBitmap_HasAlpha_native(IntPtr bitmap);

  /// <summary>
  /// Returns a flag indicating whether the <paramref name="bitmap" /> contains an alpha channel.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>A boolean value indicating whether the <paramref name="bitmap" /> contains an alpha channel (true) or not (false).</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FFPDFBitmap_HasAlpha(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_HasAlpha_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_IsOpaqueImage", SetLastError = true)]
  private static extern bool FFPDFBitmap_IsOpaqueImage_native(IntPtr bitmap);

  /// <summary>
  /// Returns a flag indicating whether the <paramref name="bitmap" /> is opaque or not.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>A boolean value indicating whether the <paramref name="bitmap" /> is opaque(true) or not(false).</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FFPDFBitmap_IsOpaqueImage(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_IsOpaqueImage_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_IsCmykImage", SetLastError = true)]
  private static extern bool FFPDFBitmap_IsCmykImage_native(IntPtr bitmap);

  /// <summary>
  /// Returns a flag indicating whether the <paramref name="bitmap" /> is a CMYK image or not.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <returns>A boolean value indicating whether the <paramref name="bitmap" /> is a CMYK image(true) or not(false).</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FFPDFBitmap_IsCmykImage(IntPtr bitmap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_IsCmykImage_native(bitmap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_GetPaletteEntry", SetLastError = true)]
  private static extern int FFPDFBitmap_GetPaletteEntry_native(IntPtr bitmap, int index);

  /// <summary>
  /// Returns the color in the color palette for a certain position.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="index">An index of the color in the color palette.</param>
  /// <returns>The color in 8888 ARGB format.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FFPDFBitmap_GetPaletteEntry(IntPtr bitmap, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_GetPaletteEntry_native(bitmap, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_SetPaletteEntry", SetLastError = true)]
  private static extern void FFPDFBitmap_SetPaletteEntry_native(
    IntPtr bitmap,
    int index,
    int entry);

  /// <summary>
  /// Set given <paramref name="color" /> to a certain position in the color palette of the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="index">An index of the <paramref name="color" /> in the color palette.</param>
  /// <param name="color">A color to be set in 8888 ARGB format.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FFPDFBitmap_SetPaletteEntry(IntPtr bitmap, int index, int color)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FFPDFBitmap_SetPaletteEntry_native(bitmap, index, color);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_GetPaletteArgb", SetLastError = true)]
  private static extern int FFPDFBitmap_GetPaletteArgb_native(IntPtr bitmap, int index);

  /// <summary>
  /// Returns the color in the color palette for a certain position.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="index">An index of the color in the color palette.</param>
  /// <returns>The color in 8888 ARGB format.</returns>
  /// <remarks>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK. Please use <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_GetPaletteEntry(System.IntPtr,System.Int32)" /> instead."</remarks>
  [HandleProcessCorruptedStateExceptions]
  [Obsolete("This method is obsolete and will be removed in a future release of the Pdfium .Net SDK. Please use FFPDFBitmap_GetPaletteEntry instead.", false)]
  public static int FFPDFBitmap_GetPaletteArgb(IntPtr bitmap, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_GetPaletteArgb_native(bitmap, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_SetPaletteArgb", SetLastError = true)]
  private static extern void FFPDFBitmap_SetPaletteArgb_native(IntPtr bitmap, int index, int argb);

  /// <summary>
  /// Set given <paramref name="color" /> to a certain position in the color palette of the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="index">An index of the <paramref name="color" /> in the color palette.</param>
  /// <param name="color">A color to be set in 8888 ARGB format.</param>
  /// <remarks>This method is obsolete and will be removed in a future release of the Pdfium .Net SDK. Please use <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_SetPaletteEntry(System.IntPtr,System.Int32,System.Int32)" /> instead."</remarks>
  [HandleProcessCorruptedStateExceptions]
  [Obsolete("This method is obsolete and will be removed in a future release of the Pdfium .Net SDK. Please use FFPDFBitmap_SetPaletteEntry instead.", false)]
  public static void FFPDFBitmap_SetPaletteArgb(IntPtr bitmap, int index, int color)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FFPDFBitmap_SetPaletteArgb_native(bitmap, index, color);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_CopyPalette", SetLastError = true)]
  private static extern void FFPDFBitmap_CopyPalette_native(IntPtr bitmap, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] int[] srcPal, int size);

  /// <summary>
  /// Copy the specified color <paramref name="palette" /> to the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="palette">An array representing the color palette to be set to the <paramref name="bitmap" />.</param>
  /// <remarks>
  /// <para>Applies only to bitmaps whose color depth is less than or equal to 8 bits per pixel.</para>
  /// <para>Parameter <paramref name="palette" /> can be null.</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FFPDFBitmap_CopyPalette(IntPtr bitmap, int[] palette)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FFPDFBitmap_CopyPalette_native(bitmap, palette, palette != null ? palette.Length : 0);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_Clone", SetLastError = true)]
  private static extern IntPtr FFPDFBitmap_Clone_native(IntPtr bitmap, [MarshalAs(UnmanagedType.LPStruct)] FX_RECT rect);

  /// <summary>
  /// Clone specified <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="clip">Clipping area.</param>
  /// <returns>A bitmap descriptor containing copied pixels.
  /// When an application is finished using the bitmap handle returned by <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_Clone(System.IntPtr,Patagames.Pdf.FX_RECT)" />,
  /// use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFPDFBitmap_Clone(IntPtr bitmap, FX_RECT clip = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_Clone_native(bitmap, clip);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_CloneConvert", SetLastError = true)]
  private static extern IntPtr FFPDFBitmap_CloneConvert_native(IntPtr bitmap, BitmapFormats format);

  /// <summary>
  /// Clone and convert the <paramref name="bitmap" /> to the specified <paramref name="format" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="format">The pixel format to convert <paramref name="bitmap" /> to.</param>
  /// <returns>A bitmap descriptor containing copied pixels.
  /// When an application is finished using the bitmap handle returned by <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_CloneConvert(System.IntPtr,Patagames.Pdf.Enums.BitmapFormats)" />,
  /// use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFPDFBitmap_CloneConvert(IntPtr bitmap, BitmapFormats format)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_CloneConvert_native(bitmap, format);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_StretchTo", SetLastError = true)]
  private static extern IntPtr FFPDFBitmap_StretchTo_native(
    IntPtr bitmap,
    int dest_width,
    int dest_height,
    ImageInterpolation flags,
    [MarshalAs(UnmanagedType.LPStruct)] FX_RECT pClip);

  /// <summary>
  /// Clone and stretch the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="width">The width, in pixels, of the resulting bitmap.</param>
  /// <param name="height">The height, in pixels, of the resulting bitmap.</param>
  /// <param name="flags">A flag indicating the interpolation mode.</param>
  /// <param name="clip">Clipping area.</param>
  /// <returns>A bitmap descriptor containing copied pixels.
  /// When an application is finished using the bitmap handle returned by <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_StretchTo(System.IntPtr,System.Int32,System.Int32,Patagames.Pdf.Enums.ImageInterpolation,Patagames.Pdf.FX_RECT)" />,
  /// use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFPDFBitmap_StretchTo(
    IntPtr bitmap,
    int width,
    int height,
    ImageInterpolation flags = ImageInterpolation.Default,
    FX_RECT clip = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_StretchTo_native(bitmap, width, height, flags, clip);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_TransformTo", SetLastError = true)]
  private static extern IntPtr FFPDFBitmap_TransformTo_native(
    IntPtr bitmap,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX pMatrix,
    ref int left,
    ref int top,
    ImageInterpolation flags,
    [MarshalAs(UnmanagedType.LPStruct)] FX_RECT pClip);

  /// <summary>
  /// Clone and transform the <paramref name="bitmap" /> with the specified transformation <paramref name="matrix" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="matrix">Transformation matrix.</param>
  /// <param name="left">A pointer to a integer value that receives the new X coordinate of the <paramref name="bitmap" />.</param>
  /// <param name="top">A pointer to a integer value that receives the new Y coordinate of the <paramref name="bitmap" />.</param>
  /// <param name="flags">A flag indicating the interpolation mode.</param>
  /// <param name="pClip">Clipping area.</param>
  /// <returns>A bitmap descriptor containing copied pixels.
  /// When an application is finished using the bitmap handle returned by <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_TransformTo(System.IntPtr,Patagames.Pdf.FS_MATRIX,System.Int32@,System.Int32@,Patagames.Pdf.Enums.ImageInterpolation,Patagames.Pdf.FX_RECT)" />,
  /// use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFPDFBitmap_TransformTo(
    IntPtr bitmap,
    FS_MATRIX matrix,
    ref int left,
    ref int top,
    ImageInterpolation flags = ImageInterpolation.Default,
    FX_RECT pClip = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_TransformTo_native(bitmap, matrix, ref left, ref top, flags, pClip);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_GetAlphaMask", SetLastError = true)]
  private static extern IntPtr FFPDFBitmap_GetAlphaMask_native(IntPtr bitmap, [MarshalAs(UnmanagedType.LPStruct)] FX_RECT pClip);

  /// <summary>
  /// Get the <paramref name="bitmap" />'s alpha channel as a <see cref="F:Patagames.Pdf.Enums.BitmapFormats.FXDIB_8bppMask" /> bitmap.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="pClip">Clipping area.</param>
  /// <returns>A bitmap descriptor containing copied pixels.
  /// When an application is finished using the bitmap handle returned by <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_GetAlphaMask(System.IntPtr,Patagames.Pdf.FX_RECT)" />,
  /// use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</returns>
  /// <remarks>
  /// <note type="warning"> The <paramref name="bitmap" /> can be <see cref="F:Patagames.Pdf.Enums.BitmapFormats.FXDIB_Argb" /> only.</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFPDFBitmap_GetAlphaMask(IntPtr bitmap, FX_RECT pClip = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_GetAlphaMask_native(bitmap, pClip);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_SwapXY", SetLastError = true)]
  private static extern IntPtr FFPDFBitmap_SwapXY_native(
    IntPtr bitmap,
    bool bXFlip,
    bool bYFlip,
    [MarshalAs(UnmanagedType.LPStruct)] FX_RECT pClip);

  /// <summary>
  /// Clone and swap the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="bXFlip">A flag indicating whether to swap an image in horizontal dimension.</param>
  /// <param name="bYFlip">A flag indicating whether to swap an image in vertical dimension.</param>
  /// <param name="pClip">Clipping area.</param>
  /// <returns>A bitmap descriptor containing copied pixels.
  /// When an application is finished using the bitmap handle returned by <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_SwapXY(System.IntPtr,System.Boolean,System.Boolean,Patagames.Pdf.FX_RECT)" />,
  /// use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFPDFBitmap_SwapXY(IntPtr bitmap, bool bXFlip, bool bYFlip, FX_RECT pClip = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_SwapXY_native(bitmap, bXFlip, bYFlip, pClip);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_FlipImage", SetLastError = true)]
  private static extern IntPtr FFPDFBitmap_FlipImage_native(
    IntPtr bitmap,
    bool bXFlip,
    bool bYFlip);

  /// <summary>
  /// Clone and flip the <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="bXFlip">A flag indicating whether to flip an image in horizontal dimension.</param>
  /// <param name="bYFlip">A flag indicating whether to flip an image in vertical dimension.</param>
  /// <returns>A bitmap descriptor containing copied pixels.
  /// When an application is finished using the bitmap handle returned by <see cref="M:Patagames.Pdf.Pdfium.FFPDFBitmap_FlipImage(System.IntPtr,System.Boolean,System.Boolean)" />,
  /// use the <see cref="M:Patagames.Pdf.Pdfium.FPDFBitmap_Destroy(System.IntPtr)" /> function to close the handle.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FFPDFBitmap_FlipImage(IntPtr bitmap, bool bXFlip, bool bYFlip)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_FlipImage_native(bitmap, bXFlip, bYFlip);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FFPDFBitmap_CopyAlphaMask", SetLastError = true)]
  private static extern bool FFPDFBitmap_CopyAlphaMask_native(
    IntPtr bitmap,
    IntPtr alphaMask,
    [MarshalAs(UnmanagedType.LPStruct)] FX_RECT pClip);

  /// <summary>
  /// Copy the specified <paramref name="mask" /> to the specified <paramref name="bitmap" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independed bitmap.</param>
  /// <param name="mask">A bitmap descriptor containing transparency mask.</param>
  /// <param name="pClip">Clippig area.</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FFPDFBitmap_CopyAlphaMask(IntPtr bitmap, IntPtr mask, FX_RECT pClip = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FFPDFBitmap_CopyAlphaMask_native(bitmap, mask, pClip);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_ConvertFormat", SetLastError = true)]
  private static extern bool FPDFBitmap_ConvertFormat_native(IntPtr bitmap, BitmapFormats format);

  /// <summary>
  /// Convert the <paramref name="bitmap" /> to the specified <paramref name="format" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="format">The pixel format to convert <paramref name="bitmap" /> to.</param>
  /// <returns>True if successful, false if conversion from the current format to the requested one is not supported.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_ConvertFormat(IntPtr bitmap, BitmapFormats format)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_ConvertFormat_native(bitmap, format);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_Clear", SetLastError = true)]
  private static extern void FPDFBitmap_Clear_native(IntPtr bitmap, uint color);

  /// <summary>
  /// Clears the entire <paramref name="bitmap" /> and fills it with the specified <paramref name="color" />.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="color">A 32-bit value specifing the color.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFBitmap_Clear(IntPtr bitmap, uint color)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFBitmap_Clear_native(bitmap, color);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_GetPixel", SetLastError = true)]
  private static extern uint FPDFBitmap_GetPixel_native(IntPtr bitmap, int x, int y);

  /// <summary>
  /// Gets the color value of the pixel at the specified coordinates.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="x">The x-coordinate of the pixel to retrieve.</param>
  /// <param name="y">The y-coordinate of the pixel to retrieve.</param>
  /// <returns>An uint value that represents the color of the specified pixel.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static uint FPDFBitmap_GetPixel(IntPtr bitmap, int x, int y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_GetPixel_native(bitmap, x, y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_SetPixel", SetLastError = true)]
  private static extern void FPDFBitmap_SetPixel_native(IntPtr bitmap, int x, int y, uint color);

  /// <summary>
  /// Sets the pixel at the specified coordinates to the specified color.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="x">The x-coordinate of the pixel to set.</param>
  /// <param name="y">The y-coordinate of the pixel to set.</param>
  /// <param name="color">An uint value that represents the color to assign to the specified pixel.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFBitmap_SetPixel(IntPtr bitmap, int x, int y, uint color)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFBitmap_SetPixel_native(bitmap, x, y, color);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_LoadChannel", SetLastError = true)]
  private static extern bool FPDFBitmap_LoadChannel_native(
    IntPtr bitmap,
    BitmapChannels dstChannel,
    IntPtr srcBitmap,
    BitmapChannels srcChannel);

  /// <summary>Copy the specified channel from one bitmap to another</summary>
  /// <param name="dstBitmap">A handle to the destination bitmap.</param>
  /// <param name="dstChannel">A color component channel in the destionation bitmap.</param>
  /// <param name="srcBitmap">A handle to the source bitmap.</param>
  /// <param name="srcChannel">A color component channel in the source bitmap.</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_LoadChannel(
    IntPtr dstBitmap,
    BitmapChannels dstChannel,
    IntPtr srcBitmap,
    BitmapChannels srcChannel)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_LoadChannel_native(dstBitmap, dstChannel, srcBitmap, srcChannel);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_LoadChannelEx", SetLastError = true)]
  private static extern bool FPDFBitmap_LoadChannel_native(
    IntPtr bitmap,
    BitmapChannels dstChannel,
    int value);

  /// <summary>
  /// Fills the specified channel of the bitmap by the value.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="channel">A color component channel in the <paramref name="bitmap" />.</param>
  /// <param name="value">The value by which the <paramref name="channel" /> should be filled.</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_LoadChannel(IntPtr bitmap, BitmapChannels channel, int value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_LoadChannel_native(bitmap, channel, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_MultiplyAlpha", SetLastError = true)]
  private static extern bool FPDFBitmap_MultiplyAlpha_native(IntPtr bitmap, int alpha);

  /// <summary>
  /// Multiply the alpha channel of the specified bitmap by the specified alpha value.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="multiplier">The value by which the value in the alpha channel is to be multiplied.</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_MultiplyAlpha(IntPtr bitmap, int multiplier)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_MultiplyAlpha_native(bitmap, multiplier);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_MultiplyAlphaEx", SetLastError = true)]
  private static extern bool FPDFBitmap_MultiplyAlpha_native(IntPtr bitmap, IntPtr alphaMask);

  /// <summary>
  /// Multiply alpha channel of the specified bitmap and specified alpha mask.
  /// </summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="alphaMask">Handle to the bitmapp with alpha mask</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_MultiplyAlpha(IntPtr bitmap, IntPtr alphaMask)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_MultiplyAlpha_native(bitmap, alphaMask);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_TransferBitmap", SetLastError = true)]
  private static extern bool FPDFBitmap_TransferBitmap_native(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    IntPtr pSrcBitmap,
    int src_left,
    int src_top);

  /// <summary>Transfer buffer from one Bitmap to another.</summary>
  /// <param name="bitmap">A handle to the destination device independent bitmap.</param>
  /// <param name="dest_left">The left point in the destination bitmap</param>
  /// <param name="dest_top">The top point in the destination bitmap</param>
  /// <param name="width">The width</param>
  /// <param name="height">The height</param>
  /// <param name="pSrcBitmap">A handle to the source device independent bitmap.</param>
  /// <param name="src_left">The left point in the source bitmap</param>
  /// <param name="src_top">The top point in the source bitmap</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_TransferBitmap(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    IntPtr pSrcBitmap,
    int src_left,
    int src_top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_TransferBitmap_native(bitmap, dest_left, dest_top, width, height, pSrcBitmap, src_left, src_top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_TransferMask", SetLastError = true)]
  private static extern bool FPDFBitmap_TransferMask_native(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    IntPtr pBitmapMask,
    uint color,
    int src_left,
    int src_top,
    int alpha_flag);

  /// <summary>Transfer mask from one Bitmap to another.</summary>
  /// <param name="bitmap">A handle to the destination device independent bitmap.</param>
  /// <param name="dest_left">The left point in the destination bitmap</param>
  /// <param name="dest_top">The top point in the destination bitmap</param>
  /// <param name="width">The width</param>
  /// <param name="height">The height</param>
  /// <param name="pBitmapMask">A handle to the source device independent bitmap.</param>
  /// <param name="color">The color</param>
  /// <param name="src_left">The left point in the source bitmap</param>
  /// <param name="src_top">The top point in the source bitmap</param>
  /// <param name="alpha_flag">alpha flag</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_TransferMask(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    IntPtr pBitmapMask,
    uint color,
    int src_left,
    int src_top,
    int alpha_flag = 0)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_TransferMask_native(bitmap, dest_left, dest_top, width, height, pBitmapMask, color, src_left, src_top, alpha_flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_CompositeBitmap", SetLastError = true)]
  private static extern bool FPDFBitmap_CompositeBitmap_native(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    IntPtr pSrcBitmap,
    int src_left,
    int src_top,
    BlendTypes blend_type,
    [MarshalAs(UnmanagedType.LPStruct)] FX_RECT pClipRgn,
    bool bRgbByteOrder);

  /// <summary>
  /// Composites bitmaps that have transparent or semitransparent pixels.
  /// </summary>
  /// <param name="bitmap">A handle to the destination device independent bitmap.</param>
  /// <param name="dest_left">The left point in the destination bitmap</param>
  /// <param name="dest_top">The top point in the destination bitmap</param>
  /// <param name="width">The width</param>
  /// <param name="height">The height</param>
  /// <param name="pSrcBitmap">A handle to the sourcde device independent bitmap.</param>
  /// <param name="src_left">The left point in the source bitmap</param>
  /// <param name="src_top">The top point in the source bitmap</param>
  /// <param name="blend_type">The <see cref="T:Patagames.Pdf.Enums.BlendTypes" /> controls blending by specifying the blending type for source and destination bitmaps.</param>
  /// <param name="pClipRgn">Clipping region</param>
  /// <param name="bRgbByteOrder">Byte order</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_CompositeBitmap(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    IntPtr pSrcBitmap,
    int src_left,
    int src_top,
    BlendTypes blend_type = BlendTypes.FXDIB_BLEND_NORMAL,
    FX_RECT pClipRgn = null,
    bool bRgbByteOrder = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_CompositeBitmap_native(bitmap, dest_left, dest_top, width, height, pSrcBitmap, src_left, src_top, blend_type, pClipRgn, bRgbByteOrder);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_CompositeMask", SetLastError = true)]
  private static extern bool FPDFBitmap_CompositeMask_native(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    IntPtr pMaskBitmap,
    uint color,
    int src_left,
    int src_top,
    BlendTypes blend_type,
    [MarshalAs(UnmanagedType.LPStruct)] FX_RECT pClipRgn,
    bool bRgbByteOrder,
    int alpha_flag);

  /// <summary>Composites specified bitmap and mask.</summary>
  /// <param name="bitmap">A handle to the destination device independent bitmap.</param>
  /// <param name="dest_left">The left point in the destination bitmap</param>
  /// <param name="dest_top">The top point in the destination bitmap</param>
  /// <param name="width">The width</param>
  /// <param name="height">The height</param>
  /// <param name="pMaskBitmap">A handle to the device independent bitmap, that represents transparency mask.</param>
  /// <param name="color">Mask color</param>
  /// <param name="src_left">The left point in the source bitmap</param>
  /// <param name="src_top">The top point in the source bitmap</param>
  /// <param name="blend_type">The <see cref="T:Patagames.Pdf.Enums.BlendTypes" /> controls blending by specifying the blending type for source and destination bitmaps.</param>
  /// <param name="pClipRgn">Clipping region</param>
  /// <param name="bRgbByteOrder">Byte order</param>
  /// <param name="alpha_flag">alpha flag</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_CompositeMask(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    IntPtr pMaskBitmap,
    uint color,
    int src_left,
    int src_top,
    BlendTypes blend_type = BlendTypes.FXDIB_BLEND_NORMAL,
    FX_RECT pClipRgn = null,
    bool bRgbByteOrder = false,
    int alpha_flag = 0)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_CompositeMask_native(bitmap, dest_left, dest_top, width, height, pMaskBitmap, color, src_left, src_top, blend_type, pClipRgn, bRgbByteOrder, alpha_flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_CompositeRect", SetLastError = true)]
  private static extern bool FPDFBitmap_CompositeRect_native(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    uint color,
    int alpha_flag);

  /// <summary>Composites specified bitmap and color.</summary>
  /// <param name="bitmap">A handle to the destination device independent bitmap.</param>
  /// <param name="dest_left">The left point in the destination bitmap</param>
  /// <param name="dest_top">The top point in the destination bitmap</param>
  /// <param name="width">The width</param>
  /// <param name="height">The height</param>
  /// <param name="color">The color</param>
  /// <param name="alpha_flag">alpha flag</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_CompositeRect(
    IntPtr bitmap,
    int dest_left,
    int dest_top,
    int width,
    int height,
    uint color,
    int alpha_flag = 0)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_CompositeRect_native(bitmap, dest_left, dest_top, width, height, color, alpha_flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_ConvertColorScale", SetLastError = true)]
  private static extern bool FPDFBitmap_ConvertColorScale_native(
    IntPtr bitmap,
    uint forecolor,
    uint backcolor);

  /// <summary>Convert color scale</summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="forecolor">Foreground color</param>
  /// <param name="backcolor">Background color</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_ConvertColorScale(IntPtr bitmap, uint forecolor, uint backcolor)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_ConvertColorScale_native(bitmap, forecolor, backcolor);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBitmap_DitherFS", SetLastError = true)]
  private static extern bool FPDFBitmap_DitherFS_native(
    IntPtr bitmap,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2, ArraySubType = UnmanagedType.I4)] uint[] pPalette,
    int pal_size,
    [MarshalAs(UnmanagedType.LPStruct)] FX_RECT pRect);

  /// <summary>DitherFS</summary>
  /// <param name="bitmap">A handle to the device independent bitmap.</param>
  /// <param name="pPalette">Palette</param>
  /// <param name="pRect">Rectangle</param>
  /// <returns>TRUE if succeed, FALSE if failed.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFBitmap_DitherFS(IntPtr bitmap, uint[] pPalette, FX_RECT pRect = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFBitmap_DitherFS_native(bitmap, pPalette, pPalette.Length, pRect);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetText", SetLastError = true)]
  private static extern void FPDFTextObj_SetText_native(IntPtr textObject, [MarshalAs(UnmanagedType.LPArray)] byte[] buffer);

  /// <summary>Stores a string on the text object.</summary>
  /// <param name="textObject">A handle to the text object.</param>
  /// <param name="text">The string to be set in the text object.</param>
  /// <param name="enc">The encoding applied to the text to be set in the text object.</param>
  /// <remarks>If no encoding is specified, the <see cref="P:Patagames.Pdf.Pdfium.DefaultAnsiEncoding" /> is used.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetText(IntPtr textObject, string text, Encoding enc = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        if (text == null)
          return;
        if (enc == null)
          enc = Pdfium.DefaultAnsiEncoding;
        byte[] bytes = enc.GetBytes(text);
        byte[] buffer = new byte[bytes.Length + 1];
        bytes.CopyTo((Array) buffer, 0);
        Pdfium.FPDFTextObj_SetText_native(textObject, buffer);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetText", SetLastError = true)]
  private static extern int FPDFTextObj_GetText_native(
    IntPtr textObject,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>Retrieves non-unicode text from the text object.</summary>
  /// <param name="textObject">A handle to the text object.</param>
  /// <param name="enc">The encoding applied to the contents of the text object.</param>
  /// <returns>The text that corresponds to a text object.</returns>
  /// <remarks>If no encoding is specified, the <see cref="P:Patagames.Pdf.Pdfium.DefaultAnsiEncoding" /> is used.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFTextObj_GetText(IntPtr textObject, Encoding enc = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int textNative = Pdfium.FPDFTextObj_GetText_native(textObject, (byte[]) null, 0);
        if (textNative <= 0)
          return "";
        byte[] numArray = new byte[textNative];
        Pdfium.FPDFTextObj_GetText_native(textObject, numArray, textNative);
        if (enc == null)
          enc = Pdfium.DefaultAnsiEncoding;
        return enc.GetString(numArray, 0, numArray.Length - 1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetTextUnicode", SetLastError = true)]
  private static extern void FPDFTextObj_SetTextUnicode_native(IntPtr textObject, [MarshalAs(UnmanagedType.LPWStr)] string buffer);

  /// <summary>Stores a string on the text object.</summary>
  /// <param name="textObject">A handle to the text object.</param>
  /// <param name="text">The string to be set in the text object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetTextUnicode(IntPtr textObject, string text)
  {
    using (Lock.SyncMT)
    {
      try
      {
        if (text == null)
          return;
        Pdfium.FPDFTextObj_SetTextUnicode_native(textObject, text);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetTextUnicode", SetLastError = true)]
  private static extern int FPDFTextObj_GetTextUnicode_native(
    IntPtr textObject,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>Retrieves unicode text from the text object.</summary>
  /// <param name="textObject">A handle to the text object.</param>
  /// <returns>The text that corresponds to a text object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFTextObj_GetTextUnicode(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int textUnicodeNative = Pdfium.FPDFTextObj_GetTextUnicode_native(textObject, (byte[]) null, 0);
        if (textUnicodeNative <= 0)
          return "";
        byte[] numArray = new byte[textUnicodeNative];
        Pdfium.FPDFTextObj_GetTextUnicode_native(textObject, numArray, textUnicodeNative);
        return Encoding.Unicode.GetString(numArray, 0, numArray.Length - 2);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_CountItems", SetLastError = true)]
  private static extern int FPDFTextObj_CountItems_native(IntPtr textObject);

  /// <summary>Get the number of items from a text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>A number of items in the text object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFTextObj_CountItems(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFTextObj_CountItems_native(textObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_CountChars", SetLastError = true)]
  private static extern int FPDFTextObj_CountChars_native(IntPtr textObject);

  /// <summary>Get the number of characters from a text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>A number of characters in the text object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFTextObj_CountChars(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFTextObj_CountChars_native(textObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetItemInfo", SetLastError = true)]
  private static extern void FPDFTextObj_GetItemInfo_native(
    IntPtr textObject,
    int index,
    out int charCode,
    [MarshalAs(UnmanagedType.R4)] out float originX,
    [MarshalAs(UnmanagedType.R4)] out float originY);

  /// <summary>Get item information</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="index">The index of the item to get the information.</param>
  /// <param name="charCode">Pointer to a int value receiving the item information.</param>
  /// <param name="originX">Pointer to a float value receiving the physical offset from the start to the specified item by horizontal</param>
  /// <param name="originY">Pointer to a float value receiving the physical offset from the start to the specified item by vertical</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetItemInfo(
    IntPtr textObject,
    int index,
    out int charCode,
    out float originX,
    out float originY)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetItemInfo_native(textObject, index, out charCode, out originX, out originY);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetCharInfo", SetLastError = true)]
  private static extern void FPDFTextObj_GetCharInfo_native(
    IntPtr textObject,
    int index,
    out int charCode,
    [MarshalAs(UnmanagedType.R4)] out float kerning);

  /// <summary>
  /// Get the unicode of a special character in a text object and kerning.
  /// </summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="index">The index of the character to get the unicode.</param>
  /// <param name="charCode">Pointer to a int value receiving the unicode value.</param>
  /// <param name="kerning">Pointer to a float value receiving the kerning</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetCharInfo(
    IntPtr textObject,
    int index,
    out int charCode,
    out float kerning)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetCharInfo_native(textObject, index, out charCode, out kerning);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetCharInfoEx", SetLastError = true)]
  private static extern void FPDFTextObj_GetCharInfo_native(
    IntPtr textObject,
    int index,
    out int charCode,
    [MarshalAs(UnmanagedType.R4)] out float originX,
    [MarshalAs(UnmanagedType.R4)] out float originY);

  /// <summary>
  /// Get the unicode of a special character in a text object and its placement.
  /// </summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="index">The index of the character to get.</param>
  /// <param name="charCode">Pointer to a int value receiving the unicode value.</param>
  /// <param name="originX">Pointer to a float value receiving the physical offset from the start to the specified character by horizontal</param>
  /// <param name="originY">Pointer to a float value receiving the physical offset from the start to the specified character by vertical</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetCharInfo(
    IntPtr textObject,
    int index,
    out int charCode,
    out float originX,
    out float originY)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetCharInfo_native(textObject, index, out charCode, out originX, out originY);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetTextMatrix", SetLastError = true)]
  private static extern void FPDFTextObj_GetTextMatrix_native(
    IntPtr textObject,
    [MarshalAs(UnmanagedType.R4)] out float a,
    [MarshalAs(UnmanagedType.R4)] out float b,
    [MarshalAs(UnmanagedType.R4)] out float c,
    [MarshalAs(UnmanagedType.R4)] out float d,
    [MarshalAs(UnmanagedType.R4)] out float e,
    [MarshalAs(UnmanagedType.R4)] out float f);

  /// <summary>Get the text object matrix.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="a">Pointer to a float value receiving the coefficient "a" of the matrix.</param>
  /// <param name="b">Pointer to a float value receiving the coefficient "b" of the matrix.</param>
  /// <param name="c">Pointer to a float value receiving the coefficient "c" of the matrix.</param>
  /// <param name="d">Pointer to a float value receiving the coefficient "d" of the matrix.</param>
  /// <param name="e">Pointer to a float value receiving the coefficient "e" of the matrix.</param>
  /// <param name="f">Pointer to a float value receiving the coefficient "f" of the matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetTextMatrix(
    IntPtr textObject,
    out float a,
    out float b,
    out float c,
    out float d,
    out float e,
    out float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetTextMatrix_native(textObject, out a, out b, out c, out d, out e, out f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Get the text object matrix.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="matrix">Transformation matrix.</param>
  public static void FPDFTextObj_GetTextMatrix(IntPtr textObject, out FS_MATRIX matrix)
  {
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    Pdfium.FPDFTextObj_GetTextMatrix(textObject, out a, out b, out c, out d, out e, out f);
    matrix = new FS_MATRIX()
    {
      a = a,
      b = b,
      c = c,
      d = d,
      e = e,
      f = f
    };
  }

  /// <summary>Get the text object matrix.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>The transformation matrix.</returns>
  public static FS_MATRIX FPDFTextObj_GetTextMatrix(IntPtr textObject)
  {
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    Pdfium.FPDFTextObj_GetTextMatrix(textObject, out a, out b, out c, out d, out e, out f);
    return new FS_MATRIX()
    {
      a = a,
      b = b,
      c = c,
      d = d,
      e = e,
      f = f
    };
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetTextMatrix", SetLastError = true)]
  private static extern void FPDFTextObj_SetTextMatrix_native(
    IntPtr textObject,
    [MarshalAs(UnmanagedType.R4)] float a,
    [MarshalAs(UnmanagedType.R4)] float b,
    [MarshalAs(UnmanagedType.R4)] float c,
    [MarshalAs(UnmanagedType.R4)] float d,
    [MarshalAs(UnmanagedType.R4)] float e,
    [MarshalAs(UnmanagedType.R4)] float f);

  /// <summary>Set the text object matrix.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="a">The coefficient "a" of the matrix.</param>
  /// <param name="b">The coefficient "b" of the matrix.</param>
  /// <param name="c">The coefficient "c" of the matrix.</param>
  /// <param name="d">The coefficient "d" of the matrix.</param>
  /// <param name="e">The coefficient "e" of the matrix.</param>
  /// <param name="f">The coefficient "f" of the matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetTextMatrix(
    IntPtr textObject,
    float a,
    float b,
    float c,
    float d,
    float e,
    float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetTextMatrix_native(textObject, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Set the text object matrix.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="matrix">The matrix to set</param>
  public static void FPDFTextObj_SetTextMatrix(IntPtr textObject, FS_MATRIX matrix)
  {
    Pdfium.FPDFTextObj_SetTextMatrix(textObject, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetText", SetLastError = true)]
  private static extern void FPDFTextObj_SetText_native(IntPtr textObject, [MarshalAs(UnmanagedType.LPStr)] string text);

  /// <summary>Insert non-unicode string into text object</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="text">The text to be inserted into an text object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetText(IntPtr textObject, string text)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetText_native(textObject, text);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetTextEx", SetLastError = true)]
  private static extern void FPDFTextObj_SetText_native(
    IntPtr textObject,
    int countChars,
    [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.I4)] int[] chars,
    [MarshalAs(UnmanagedType.LPArray)] float[] kernings);

  /// <summary>Insert unicode string into text object</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="countChars">The number of characters in the text to insert.</param>
  /// <param name="chars">A four-byte array containing the unicode characters to insert into text object.</param>
  /// <param name="kernings">Array containing the kernings</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetText(
    IntPtr textObject,
    int countChars,
    int[] chars,
    float[] kernings)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetText_native(textObject, countChars, chars, kernings);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Insert unicode string into text object</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="text">String to insert.</param>
  /// <param name="kernings">Array containing the kernings</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetText(IntPtr textObject, string text, float[] kernings)
  {
    if (text == null)
      return;
    IntPtr font = Pdfium.FPDFTextObj_GetFont(textObject);
    if (font == IntPtr.Zero)
      return;
    int length = text.Length;
    int[] chars = new int[length];
    kernings = new float[length];
    for (int index = 0; index < length; ++index)
      chars[index] = Pdfium.FPDFFont_CharCodeFromUnicode(font, text[index]);
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetText_native(textObject, length, chars, kernings);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetEmpty", SetLastError = true)]
  private static extern void FPDFTextObj_SetEmpty_native(IntPtr textObject);

  /// <summary>Set empty string in a text object</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetEmpty(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetEmpty_native(textObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  private static bool GetTextsFromItems(IntPtr textObject, out byte[] ascii, out char[] unicode)
  {
    ascii = (byte[]) null;
    unicode = (char[]) null;
    IntPtr font = Pdfium.FPDFTextObj_GetFont(textObject);
    if (font == IntPtr.Zero)
      return false;
    int num1 = Pdfium.FPDFTextObj_CountChars(textObject);
    if (num1 == 0)
      return false;
    float width = 0.0f;
    Pdfium.FPDFTextObj_GetSpaceCharWidth(textObject, out width);
    float[] pPosArray = new float[num1 * 2];
    Pdfium.FPDFTextObj_CalcCharPos(textObject, pPosArray);
    int index1 = 0;
    int index2 = 0;
    List<char> charList = new List<char>();
    Pdfium.FPDFTextObj_GetSpaceCharWidth(textObject, out width);
    int num2 = 0;
    for (; index1 < num1; ++index1)
    {
      int charCode;
      Pdfium.FPDFTextObj_GetItemInfo(textObject, index1, out charCode, out float _, out float _);
      if (charCode == -1 && index2 > 0)
      {
        ++num1;
        float num3 = pPosArray[index2] - pPosArray[index2 - 1];
        int count = (int) ((double) num3 / (double) width) - num2;
        if (count > 0)
          charList.AddRange((IEnumerable<char>) new string(' ', count));
        else if ((double) num3 > 1.0 && num2 == 0)
          charList.Add(' ');
      }
      else
      {
        char ch1 = Pdfium.FPDFFont_UnicodeFromCharCode(font, charCode);
        char ch2 = ch1 == char.MinValue ? (char) charCode : ch1;
        charList.Add(ch2);
        num2 = ch2 == ' ' ? num2 + 1 : 0;
        index2 += 2;
      }
    }
    unicode = new char[charList.Count];
    ascii = new byte[charList.Count];
    for (int index3 = 0; index3 < charList.Count; ++index3)
    {
      unicode[index3] = charList[index3];
      ascii[index3] = (byte) charList[index3];
    }
    return true;
  }

  /// <summary>Get non-unicode text containing in text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="codePage">The code page identifier of the preferred encoding. If 0 then <see cref="P:Patagames.Pdf.Pdfium.DefaultAnsiEncoding" /> is used.</param>
  /// <returns>Text from text object.</returns>
  public static string FPDFTextObj_GetTextFromItems(IntPtr textObject, int codePage)
  {
    byte[] ascii;
    return Pdfium.GetTextsFromItems(textObject, out ascii, out char[] _) ? (codePage != 0 ? Encoding.GetEncoding(codePage) : Pdfium.DefaultAnsiEncoding).GetString(ascii) : "";
  }

  /// <summary>Get unicod text containing in text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>Text from text object.</returns>
  public static string FPDFTextObj_GetTextFromItems(IntPtr textObject)
  {
    char[] unicode;
    return Pdfium.GetTextsFromItems(textObject, out byte[] _, out unicode) ? new string(unicode) : "";
  }

  private static bool GetTexts(
    IntPtr textObject,
    out byte[] ascii,
    out char[] unicode,
    out float[] kernings)
  {
    ascii = (byte[]) null;
    unicode = (char[]) null;
    kernings = (float[]) null;
    int length = Pdfium.FPDFTextObj_CountChars(textObject);
    if (length == 0)
      return false;
    IntPtr font = Pdfium.FPDFTextObj_GetFont(textObject);
    if (font == IntPtr.Zero)
      return false;
    ascii = new byte[length];
    unicode = new char[length];
    kernings = new float[length];
    for (int index = 0; index < length; ++index)
    {
      int charCode;
      float kerning;
      Pdfium.FPDFTextObj_GetCharInfo(textObject, index, out charCode, out kerning);
      unicode[index] = Pdfium.FPDFFont_UnicodeFromCharCode(font, charCode);
      if (unicode[index] == char.MinValue)
        unicode[index] = (char) charCode;
      ascii[index] = (byte) charCode;
      kernings[index] = kerning;
    }
    return true;
  }

  /// <summary>Get non-unicode text containing in text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="codePage">The code page identifier of the preferred encoding. If 0 then <see cref="P:Patagames.Pdf.Pdfium.DefaultAnsiEncoding" /> is used.</param>
  /// <param name="kernings">Pointer to a float values receiving the kernings.</param>
  /// <returns>Text from text object.</returns>
  public static string FPDFTextObj_GetText(IntPtr textObject, int codePage, out float[] kernings)
  {
    kernings = (float[]) null;
    byte[] ascii;
    return Pdfium.GetTexts(textObject, out ascii, out char[] _, out kernings) ? (codePage != 0 ? Encoding.GetEncoding(codePage) : Pdfium.DefaultAnsiEncoding).GetString(ascii) : "";
  }

  /// <summary>Get unicod text containing in text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="kernings">Pointer to a float values receiving the kernings.</param>
  /// <returns>Text from text object.</returns>
  public static string FPDFTextObj_GetText(IntPtr textObject, out float[] kernings)
  {
    kernings = (float[]) null;
    char[] unicode;
    return Pdfium.GetTexts(textObject, out byte[] _, out unicode, out kernings) ? new string(unicode) : "";
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetCharWidth", SetLastError = true)]
  private static extern void FPDFTextObj_GetCharWidth_native(
    IntPtr textObject,
    int charcode,
    [MarshalAs(UnmanagedType.R4)] out float width);

  /// <summary>Get the width of specified character</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="charcode">Character code the width of which is necessary to obtain.</param>
  /// <param name="width">Pointer to a float value receiving the width.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetCharWidth(IntPtr textObject, int charcode, out float width)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetCharWidth_native(textObject, charcode, out width);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetSpaceCharWidth", SetLastError = true)]
  private static extern void FPDFTextObj_GetSpaceCharWidth_native(
    IntPtr textObject,
    [MarshalAs(UnmanagedType.R4)] out float width);

  /// <summary>Get the width of space character</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="width">Pointer to a float value receiving the width.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetSpaceCharWidth(IntPtr textObject, out float width)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetSpaceCharWidth_native(textObject, out width);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetCharRect", SetLastError = true)]
  private static extern void FPDFTextObj_GetCharRect_native(
    IntPtr textObject,
    int index,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float bottom,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float top,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX matrix);

  /// <summary>Get character bounding box</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="index">The index of the character to get the bbox.</param>
  /// <param name="left">Pointer to a float value receiving the left of a rectangle.</param>
  /// <param name="bottom">Pointer to a float value receiving the bottom of a rectangle.</param>
  /// <param name="right">Pointer to a float value receiving the right of a rectangle.</param>
  /// <param name="top">Pointer to a float value receiving the top of a rectangle.</param>
  /// <param name="matrix">The matrix that shoud be appliend to the outpet rectangle. Typically it's the textObject's matrix </param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetCharRect(
    IntPtr textObject,
    int index,
    out float left,
    out float bottom,
    out float right,
    out float top,
    FS_MATRIX matrix = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetCharRect_native(textObject, index, out left, out bottom, out right, out top, matrix);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_RecalcPositionData", SetLastError = true)]
  private static extern void FPDFTextObj_RecalcPositionData_native(IntPtr textObject);

  /// <summary>Recalculate charactes positions</summary>
  /// Pointer to a float values receiving the offsets to start and end of each character in text object
  ///             <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_RecalcPositionData(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_RecalcPositionData_native(textObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_CalcCharPos", SetLastError = true)]
  private static extern void FPDFTextObj_CalcCharPos_native(IntPtr textObject, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.R4), In, Out] float[] pPosArray);

  /// <summary>
  /// Calculate the offsets to start and end of each character in text object
  /// </summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="pPosArray">Pointer to a float values receiving the offsets to start and end of each character in text object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_CalcCharPos(IntPtr textObject, float[] pPosArray)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_CalcCharPos_native(textObject, pPosArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetPosX", SetLastError = true)]
  private static extern void FPDFTextObj_GetPosX_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] out float x);

  /// <summary>Get X position of the specified text object</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="x">Pointer to a float value receiving the X coordinate of the text object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetPosX(IntPtr textObject, out float x)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetPosX_native(textObject, out x);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetPosY", SetLastError = true)]
  private static extern void FPDFTextObj_GetPosY_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] out float y);

  /// <summary>Get Y position of the specified text object</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="y">Pointer to a float value receiving the Y coordinate of the text object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetPosY(IntPtr textObject, out float y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetPosY_native(textObject, out y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetPos", SetLastError = true)]
  private static extern void FPDFTextObj_GetPos_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] out float x, [MarshalAs(UnmanagedType.R4)] out float y);

  /// <summary>Get location of the specified text object</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="x">Pointer to a float value receiving the X coordinate of the text object.</param>
  /// <param name="y">Pointer to a float value receiving the Y coordinate of the text object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetPos(IntPtr textObject, out float x, out float y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetPos_native(textObject, out x, out y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetPosition", SetLastError = true)]
  private static extern void FPDFTextObj_SetPosition_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] float x, [MarshalAs(UnmanagedType.R4)] float y);

  /// <summary>Move text object into specified location</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="x">The X coordinate of the text object.</param>
  /// <param name="y">The Y coordinate of the text object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetPosition(IntPtr textObject, float x, float y)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetPosition_native(textObject, x, y);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetFont", SetLastError = true)]
  private static extern IntPtr FPDFTextObj_GetFont_native(IntPtr textObject);

  /// <summary>Get the font Handle to a text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>Handle to the font.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFTextObj_GetFont(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFTextObj_GetFont_native(textObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetFont", SetLastError = true)]
  private static extern void FPDFTextObj_SetFont_native(IntPtr textObject, IntPtr font);

  /// <summary>Set the font into a text object</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="font">Handle to FPDF_FONT. It could be returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /> or <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetFont(IntPtr textObject, IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetFont_native(textObject, font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetFontSize", SetLastError = true)]
  private static extern void FPDFTextObj_GetFontSize_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] out float size);

  /// <summary>Get the font size of a text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="size">Pointer to a float value receiving the size of the font.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_GetFontSize(IntPtr textObject, out float size)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_GetFontSize_native(textObject, out size);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetFontSize", SetLastError = true)]
  private static extern void FPDFTextObj_SetFontSize_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] float size);

  /// <summary>Set the font size of a text object.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="size">The font size</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetFontSize(IntPtr textObject, float size)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetFontSize_native(textObject, size);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetRenderMode", SetLastError = true)]
  private static extern TextRenderingModes FPDFTextObj_GetRenderMode_native(IntPtr textObject);

  /// <summary>Get text rendering mode.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" />.</param>
  /// <returns>The text rendering mode.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static TextRenderingModes FPDFTextObj_GetRenderMode(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFTextObj_GetRenderMode_native(textObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetRenderMode", SetLastError = true)]
  private static extern void FPDFTextObj_SetRenderMode_native(
    IntPtr textObject,
    TextRenderingModes mode);

  /// <summary>Set text rendering mode.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" />.</param>
  /// <param name="mode">Text rendering mode</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetRenderMode(IntPtr textObject, TextRenderingModes mode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetRenderMode_native(textObject, mode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetCharSpacing", SetLastError = true)]
  private static extern void FPDFTextObj_GetCharSpacing_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] out float spacing);

  /// <summary>Get character spacing.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>The character spacing.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFTextObj_GetCharSpacing(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float spacing;
        Pdfium.FPDFTextObj_GetCharSpacing_native(textObject, out spacing);
        return spacing;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetCharSpacing", SetLastError = true)]
  private static extern void FPDFTextObj_SetCharSpacing_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] float spacing);

  /// <summary>Get character spacing.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="spacing">The character spacing.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetCharSpacing(IntPtr textObject, float spacing)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetCharSpacing_native(textObject, spacing);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_GetWordSpacing", SetLastError = true)]
  private static extern void FPDFTextObj_GetWordSpacing_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] out float spacing);

  /// <summary>Get word spacing.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>The word spacing.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFTextObj_GetWordSpacing(IntPtr textObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float spacing;
        Pdfium.FPDFTextObj_GetWordSpacing_native(textObject, out spacing);
        return spacing;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTextObj_SetWordSpacing", SetLastError = true)]
  private static extern void FPDFTextObj_SetWordSpacing_native(IntPtr textObject, [MarshalAs(UnmanagedType.R4)] float spacing);

  /// <summary>Get word spacing.</summary>
  /// <param name="textObject">Handle to text object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="spacing">The word spacing.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFTextObj_SetWordSpacing(IntPtr textObject, float spacing)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFTextObj_SetWordSpacing_native(textObject, spacing);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetStockFont", SetLastError = true)]
  private static extern IntPtr FPDF_GetStockFont_native(IntPtr document, [MarshalAs(UnmanagedType.LPStr)] string fontName);

  /// <summary>
  /// Creates a standard type font with the specified typeface name and the predefined WinAnsiEncoding encoding.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="fontName">A string that specifies the typeface name of the font.</param>
  /// <returns>Handle to newly created font or IntPtr.Zero if any error occurs.</returns>
  /// <remarks>See detailed information about standard fonts in <see cref="T:Patagames.Pdf.Enums.FontStockNames" />.
  /// <para>Possible values of <paramref name="fontName" /> are: "Arial", "Arial,Bold", "Arial,BoldItalic", "Arial,Italic", "Arial-Bold", "Arial-BoldItalic", "Arial-BoldItalicMT", "Arial-BoldMT", "Arial-Italic", "Arial-ItalicMT", "ArialBold", "ArialBoldItalic", "ArialItalic", "ArialMT", "ArialMT,Bold", "ArialMT,BoldItalic", "ArialMT,Italic", "ArialRoundedMTBold", "Courier", "Courier,Bold", "Courier,BoldItalic", "Courier,Italic", "Courier-Bold", "Courier-BoldOblique", "Courier-Oblique", "CourierBold", "CourierBoldItalic", "CourierItalic", "CourierNew", "CourierNew,Bold", "CourierNew,BoldItalic", "CourierNew,Italic", "CourierNew-Bold", "CourierNew-BoldItalic", "CourierNew-Italic", "CourierNewBold", "CourierNewBoldItalic", "CourierNewItalic", "CourierNewPS-BoldItalicMT", "CourierNewPS-BoldMT", "CourierNewPS-ItalicMT", "CourierNewPSMT", "CourierStd", "CourierStd-Bold", "CourierStd-BoldOblique", "CourierStd-Oblique", "Helvetica", "Helvetica,Bold", "Helvetica,BoldItalic", "Helvetica,Italic", "Helvetica-Bold", "Helvetica-BoldItalic", "Helvetica-BoldOblique", "Helvetica-Italic", "Helvetica-Oblique", "HelveticaBold", "HelveticaBoldItalic", "HelveticaItalic", "Symbol", "SymbolMT", "Times-Bold", "Times-BoldItalic", "Times-Italic", "Times-Roman", "TimesBold", "TimesBoldItalic", "TimesItalic", "TimesNewRoman", "TimesNewRoman,Bold", "TimesNewRoman,BoldItalic", "TimesNewRoman,Italic", "TimesNewRoman-Bold", "TimesNewRoman-BoldItalic", "TimesNewRoman-Italic", "TimesNewRomanBold", "TimesNewRomanBoldItalic", "TimesNewRomanItalic", "TimesNewRomanPS", "TimesNewRomanPS-Bold", "TimesNewRomanPS-BoldItalic", "TimesNewRomanPS-BoldItalicMT", "TimesNewRomanPS-BoldMT", "TimesNewRomanPS-Italic", "TimesNewRomanPS-ItalicMT", "TimesNewRomanPSMT", "TimesNewRomanPSMT,Bold", "TimesNewRomanPSMT,BoldItalic", "TimesNewRomanPSMT,Italic", "ZapfDingbats".</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_GetStockFont(IntPtr document, string fontName)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_GetStockFont_native(document, fontName);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Creates a standard type font with the specified typeface name and the predefined WinAnsiEncoding encoding.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="fontName">A value that specifies the typeface name of the font.</param>
  /// <returns>Handle to newly created font or IntPtr.Zero if any error occurs.</returns>
  /// <remarks>See detailed information about standard fonts in <see cref="T:Patagames.Pdf.Enums.FontStockNames" /></remarks>
  public static IntPtr FPDF_GetStockFont(IntPtr document, FontStockNames fontName)
  {
    return Pdfium.FPDF_GetStockFont(document, Pdfium.GetEnumDescription((Enum) fontName));
  }

  [DllImport("pdfium", EntryPoint = "FPDF_AddStandardFont", SetLastError = true)]
  private static extern IntPtr FPDF_AddStandardFont_native(
    IntPtr document,
    [MarshalAs(UnmanagedType.LPStr)] string fontName,
    int encoding);

  /// <summary>
  /// Creates a standard type font with the specified typeface name and encoding.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="fontName">A value that specifies the typeface name of the font.</param>
  /// <param name="encoding">A value that specifies an encoding.</param>
  /// <returns>Handle to newly created font or IntPtr.Zero if any error occurs.</returns>
  /// <remarks>See detailed information about standard fonts in <see cref="T:Patagames.Pdf.Enums.FontStockNames" />.
  /// <para>Possible values of <paramref name="encoding" /> are:</para>
  /// <list type="table">
  /// <listheader>
  /// <term>Name</term><term>Value</term><description>Description</description>
  /// </listheader>
  /// <item><term>WinAnsiEncoding</term><term>1</term><description>Windows Code Page 1252, often called the “Windows ANSI” encoding.This is the standard Windows encoding for Latin text in Western writing systems.PDF has a predefined encoding named WinAnsiEncoding that can be used with both Type 1 and TrueType fonts.</description></item>
  /// <item><term>MacRomanEncoding</term><term>2</term><description>Mac OS standard encoding for Latin text in Western writing systems. PDF has a predefined encoding named MacRomanEncoding that can be used with both Type 1 and TrueType fonts.</description></item>
  /// <item><term>MacExpertEncoding</term><term>3</term><description>An encoding for use with expert fonts—ones containing the expert character set.PDF has a predefined encoding named MacExpertEncoding.Despite its name, it is not a platform-specific encoding; however, only certain fonts have the appropriate character set for use with this encoding.No such fonts are among the standard 14 predefined fonts.</description></item>
  /// <item><term>StandardEncoding</term><term>4</term><description>Adobe standard Latin-text encoding. This is the built-in encoding defined in Type 1 Latin-text font programs(but generally not in TrueType font programs). PDF does not have a predefined encoding named StandardEncoding.However, it is useful to describe this encoding, since a font’s built-in encoding can be used as the base encoding from which differences are specified in an encoding dictionary.</description></item>
  /// <item><term>AdobeSymbolEncoding</term><term>5</term><description></description></item>
  /// <item><term>ZapDingBatsEncoding</term><term>6</term><description></description></item>
  /// <item><term>PDFDocEncoding</term><term>7</term><description>Encoding for text strings in a PDF document outside the document’s content streams. This is one of two encodings (the other being Unicode) that can be used to represent text strings; see Section, “Text String Type.” PDF does not have a predefined encoding named PDFDocEncoding; it is not customary to use this encoding to show text from fonts.</description></item>
  /// <item><term>MSSymbolEncoding</term><term>8</term><description></description></item>
  /// </list>
  /// <para>Possible values of <paramref name="fontName" /> are: "Arial", "Arial,Bold", "Arial,BoldItalic", "Arial,Italic", "Arial-Bold", "Arial-BoldItalic", "Arial-BoldItalicMT", "Arial-BoldMT", "Arial-Italic", "Arial-ItalicMT", "ArialBold", "ArialBoldItalic", "ArialItalic", "ArialMT", "ArialMT,Bold", "ArialMT,BoldItalic", "ArialMT,Italic", "ArialRoundedMTBold", "Courier", "Courier,Bold", "Courier,BoldItalic", "Courier,Italic", "Courier-Bold", "Courier-BoldOblique", "Courier-Oblique", "CourierBold", "CourierBoldItalic", "CourierItalic", "CourierNew", "CourierNew,Bold", "CourierNew,BoldItalic", "CourierNew,Italic", "CourierNew-Bold", "CourierNew-BoldItalic", "CourierNew-Italic", "CourierNewBold", "CourierNewBoldItalic", "CourierNewItalic", "CourierNewPS-BoldItalicMT", "CourierNewPS-BoldMT", "CourierNewPS-ItalicMT", "CourierNewPSMT", "CourierStd", "CourierStd-Bold", "CourierStd-BoldOblique", "CourierStd-Oblique", "Helvetica", "Helvetica,Bold", "Helvetica,BoldItalic", "Helvetica,Italic", "Helvetica-Bold", "Helvetica-BoldItalic", "Helvetica-BoldOblique", "Helvetica-Italic", "Helvetica-Oblique", "HelveticaBold", "HelveticaBoldItalic", "HelveticaItalic", "Symbol", "SymbolMT", "Times-Bold", "Times-BoldItalic", "Times-Italic", "Times-Roman", "TimesBold", "TimesBoldItalic", "TimesItalic", "TimesNewRoman", "TimesNewRoman,Bold", "TimesNewRoman,BoldItalic", "TimesNewRoman,Italic", "TimesNewRoman-Bold", "TimesNewRoman-BoldItalic", "TimesNewRoman-Italic", "TimesNewRomanBold", "TimesNewRomanBoldItalic", "TimesNewRomanItalic", "TimesNewRomanPS", "TimesNewRomanPS-Bold", "TimesNewRomanPS-BoldItalic", "TimesNewRomanPS-BoldItalicMT", "TimesNewRomanPS-BoldMT", "TimesNewRomanPS-Italic", "TimesNewRomanPS-ItalicMT", "TimesNewRomanPSMT", "TimesNewRomanPSMT,Bold", "TimesNewRomanPSMT,BoldItalic", "TimesNewRomanPSMT,Italic", "ZapfDingbats".</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_AddStandardFont(IntPtr document, string fontName, int encoding)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_AddStandardFont_native(document, fontName, encoding);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Creates a standard type font with the specified typeface name and the predefined WinAnsiEncoding encoding.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="fontName">A value that specifies the typeface name of the font.</param>
  /// <param name="encoding">A value that specifies an encoding.</param>
  /// <returns>Handle to newly created font or IntPtr.Zero if any error occurs.</returns>
  /// <remarks>See detailed information about standard fonts in <see cref="T:Patagames.Pdf.Enums.FontStockNames" />.
  /// <para>Possible values of <paramref name="encoding" /> are:</para>
  /// <list type="table">
  /// <listheader>
  /// <term>Name</term><term>Value</term><description>Description</description>
  /// </listheader>
  /// <item><term>WinAnsiEncoding</term><term>1</term><description>Windows Code Page 1252, often called the “Windows ANSI” encoding.This is the standard Windows encoding for Latin text in Western writing systems.PDF has a predefined encoding named WinAnsiEncoding that can be used with both Type 1 and TrueType fonts.</description></item>
  /// <item><term>MacRomanEncoding</term><term>2</term><description>Mac OS standard encoding for Latin text in Western writing systems. PDF has a predefined encoding named MacRomanEncoding that can be used with both Type 1 and TrueType fonts.</description></item>
  /// <item><term>MacExpertEncoding</term><term>3</term><description>An encoding for use with expert fonts—ones containing the expert character set.PDF has a predefined encoding named MacExpertEncoding.Despite its name, it is not a platform-specific encoding; however, only certain fonts have the appropriate character set for use with this encoding.No such fonts are among the standard 14 predefined fonts.</description></item>
  /// <item><term>StandardEncoding</term><term>4</term><description>Adobe standard Latin-text encoding. This is the built-in encoding defined in Type 1 Latin-text font programs(but generally not in TrueType font programs). PDF does not have a predefined encoding named StandardEncoding.However, it is useful to describe this encoding, since a font’s built-in encoding can be used as the base encoding from which differences are specified in an encoding dictionary.</description></item>
  /// <item><term>AdobeSymbolEncoding</term><term>5</term><description></description></item>
  /// <item><term>ZapDingBatsEncoding</term><term>6</term><description></description></item>
  /// <item><term>PDFDocEncoding</term><term>7</term><description>Encoding for text strings in a PDF document outside the document’s content streams. This is one of two encodings (the other being Unicode) that can be used to represent text strings; see Section, “Text String Type.” PDF does not have a predefined encoding named PDFDocEncoding; it is not customary to use this encoding to show text from fonts.</description></item>
  /// <item><term>MSSymbolEncoding</term><term>8</term><description></description></item>
  /// </list>
  /// </remarks>
  public static IntPtr FPDF_AddStandardFont(IntPtr document, FontStockNames fontName, int encoding)
  {
    return Pdfium.FPDF_AddStandardFont(document, Pdfium.GetEnumDescription((Enum) fontName), encoding);
  }

  [DllImport("pdfium", EntryPoint = "FPDF_AddWindowsFontW", SetLastError = true)]
  private static extern IntPtr FPDF_AddWindowsFontW_native(
    IntPtr document,
    [MarshalAs(UnmanagedType.LPStruct)] LOGFONTINT logfont,
    bool bVert,
    bool bTranslateName);

  /// <summary>
  /// Creates a font that has the specified characteristics.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="logfont">The LOGFONT structure that defines the characteristics of the font.</param>
  /// <param name="bVert">The font is vertical</param>
  /// <param name="bTranslateName">Translate names for CJK fonts</param>
  /// <returns>Handle to newly created font or IntPtr.Zero if any error occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_AddWindowsFont(
    IntPtr document,
    LOGFONT logfont,
    bool bVert,
    bool bTranslateName)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_AddWindowsFontW_native(document, new LOGFONTINT(logfont), bVert, bTranslateName);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CreateEmbeddedFont", SetLastError = true)]
  private static extern IntPtr FPDF_CreateEmbeddedFont_native(
    IntPtr document,
    [MarshalAs(UnmanagedType.LPArray)] byte[] data,
    int size,
    int charSet,
    bool bVert);

  /// <summary>
  /// Creates a built in font that has the specified characteristics.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="data">A byte array containing the font program that should be embedded.</param>
  /// <param name="charSet">The character set.</param>
  /// <param name="bVert">The font is vertical.</param>
  /// <returns>Handle to newly created font or IntPtr.Zero if any error occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_CreateEmbeddedFont(
    IntPtr document,
    byte[] data,
    FontCharSet charSet,
    bool bVert)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_CreateEmbeddedFont_native(document, data, data.Length, (int) charSet, bVert);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CreateFont", SetLastError = true)]
  private static extern IntPtr FPDF_CreateFont_native(
    IntPtr document,
    [MarshalAs(UnmanagedType.LPStr)] string faceName,
    bool bTrueType,
    FontFlags flags,
    FontWeight weight,
    int italicAngel,
    FontCharSet charSet,
    bool bVert);

  /// <summary>Creates a font with the specified characteristics.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="faceName">A string that specifies the typeface name of the font. The length of this string must not exceed 32 TCHAR values, including the terminating NULL.  If lfFaceName is an empty string, GDI uses the first font that matches the other specified attributes.</param>
  /// <param name="bTrueType">The true type font.</param>
  /// <param name="flags">The value of the <see cref="T:Patagames.Pdf.Enums.FontFlags" /> entry.</param>
  /// <param name="weight">The weight of the font.</param>
  /// <param name="italicAngel">The angle, expressed in degrees counterclockwise from the vertical, of the dominant vertical strokes of the font. (For example, the 9-o’clock position is 90 degrees, and the 3-o’clock position is –90 degrees.) The value is negative for fonts that slope to the right, as almost all italic fonts do.</param>
  /// <param name="charSet">The character set.</param>
  /// <param name="bVert">The font is vertical.</param>
  /// <returns>Handle to newly created font or IntPtr.Zero if any error occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_CreateFont(
    IntPtr document,
    string faceName,
    bool bTrueType,
    FontFlags flags,
    FontWeight weight,
    int italicAngel,
    FontCharSet charSet,
    bool bVert)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_CreateFont_native(document, faceName, bTrueType, flags, weight, italicAngel, charSet, bVert);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_CreateFontFromDict", SetLastError = true)]
  private static extern IntPtr FPDF_CreateFontFromDict_native(
    IntPtr document,
    IntPtr fontDict,
    bool bFindOnly);

  /// <summary>Creates a font with the specified characteristics.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> and <see cref="M:Patagames.Pdf.Pdfium.FPDF_CreateNewDocument" />.</param>
  /// <param name="fontDict">Handle to the font dictionary.</param>
  /// <param name="bFindOnly">Find only.</param>
  /// <returns>Handle to newly created font or IntPtr.Zero if any error occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_CreateFontFromDict(IntPtr document, IntPtr fontDict, bool bFindOnly = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDF_CreateFontFromDict_native(document, fontDict, bFindOnly);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetFontDict", SetLastError = true)]
  private static extern IntPtr FPDFFont_GetFontDict_native(IntPtr font);

  /// <summary>Gets dictionary from font object</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>Handle to the font dictionary; IntPtr.Zero if any error occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFont_GetFontDict(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFFont_GetFontDict_native(font));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetFontType", SetLastError = true)]
  private static extern FontTypes FPDFFont_GetFontType_native(IntPtr font);

  /// <summary>Get font type</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>Font type</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FontTypes FPDFFont_GetFontType(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetFontType_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetFontTypeName", SetLastError = true)]
  private static extern int FPDFFont_GetFontTypeName_native(IntPtr font, [MarshalAs(UnmanagedType.LPArray)] byte[] buffer, int len);

  /// <summary>
  /// Retrieve the font type name of the font and return the name in a string
  /// </summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>The string what represents the font type name</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFont_GetFontTypeName(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int fontTypeNameNative = Pdfium.FPDFFont_GetFontTypeName_native(font, (byte[]) null, 0);
        if (fontTypeNameNative == 0)
          return "";
        byte[] numArray = new byte[fontTypeNameNative];
        Pdfium.FPDFFont_GetFontTypeName_native(font, numArray, fontTypeNameNative);
        return Pdfium.DefaultAnsiEncoding.GetString(numArray, 0, numArray.Length - 1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetBaseFont", SetLastError = true)]
  private static extern int FPDFFont_GetBaseFont_native(IntPtr font, [MarshalAs(UnmanagedType.LPArray)] byte[] buffer, int len);

  /// <summary>
  /// Retrieve the base font name of the font and return the name in a string
  ///  </summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>The string what represents the base font name</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFont_GetBaseFont(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int baseFontNative = Pdfium.FPDFFont_GetBaseFont_native(font, (byte[]) null, 0);
        if (baseFontNative == 0)
          return "";
        byte[] numArray = new byte[baseFontNative];
        Pdfium.FPDFFont_GetBaseFont_native(font, numArray, baseFontNative);
        return Pdfium.DefaultAnsiEncoding.GetString(numArray, 0, numArray.Length - 1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetSubstFont", SetLastError = true)]
  private static extern void FPDFFont_GetSubstFont_native(
    IntPtr font,
    out IntPtr ExtHandle,
    out IntPtr Family,
    out int Charset,
    out FontSubstFlags SubstFlags,
    out int Weight,
    out int ItalicAngle,
    out bool SubstOfCJK,
    out int WeightCJK,
    out bool ItlicCJK);

  /// <summary>Get SubstFont</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <param name="ExtHandle">Handle</param>
  /// <param name="Family">Font family</param>
  /// <param name="Charset">Charset</param>
  /// <param name="SubstFlags">Flags</param>
  /// <param name="Weight">Wight</param>
  /// <param name="ItalicAngle">Italic angel</param>
  /// <param name="SubstOfCJK">Is Chines Japan Korean</param>
  /// <param name="WeightCJK">Weight of CJK</param>
  /// <param name="ItlicCJK">Is italick CJK</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFont_GetSubstFont(
    IntPtr font,
    out IntPtr ExtHandle,
    out string Family,
    out int Charset,
    out FontSubstFlags SubstFlags,
    out int Weight,
    out int ItalicAngle,
    out bool SubstOfCJK,
    out int WeightCJK,
    out bool ItlicCJK)
  {
    using (Lock.SyncMT)
    {
      try
      {
        IntPtr Family1 = IntPtr.Zero;
        Pdfium.FPDFFont_GetSubstFont_native(font, out ExtHandle, out Family1, out Charset, out SubstFlags, out Weight, out ItalicAngle, out SubstOfCJK, out WeightCJK, out ItlicCJK);
        Family = Marshal.PtrToStringAnsi(Family1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetFlags", SetLastError = true)]
  private static extern FontFlags FPDFFont_GetFlags_native(IntPtr font);

  /// <summary>
  /// Get the value of the flags entry in a font descriptor.
  /// </summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>Value of the flags entry in a font descriptor.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FontFlags FPDFFont_GetFlags(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetFlags_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_IsVertWriting", SetLastError = true)]
  private static extern bool FPDFFont_IsVertWriting_native(IntPtr font);

  /// <summary>Specifies whether the font is VertWriting</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>True if the font is VertWriting, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFont_IsVertWriting(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_IsVertWriting_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_IsEmbedded", SetLastError = true)]
  private static extern bool FPDFFont_IsEmbedded_native(IntPtr font);

  /// <summary>
  /// Specifies whether the font is embedded into PDF document
  /// </summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>True if the font is embedded, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFont_IsEmbedded(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_IsEmbedded_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_IsUnicodeCompatible", SetLastError = true)]
  private static extern bool FPDFFont_IsUnicodeCompatible_native(IntPtr font);

  /// <summary>Specifies whether the font is unicode compatible</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>True if the font is unicode compatible, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFont_IsUnicodeCompatible(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_IsUnicodeCompatible_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_IsStandardFont", SetLastError = true)]
  private static extern bool FPDFFont_IsStandardFont_native(IntPtr font);

  /// <summary>Specifies whether the font is a standard font</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>True if the font is a standard font, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFont_IsStandardFont(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_IsStandardFont_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetTypeAscent", SetLastError = true)]
  private static extern int FPDFFont_GetTypeAscent_native(IntPtr font);

  /// <summary>Get the ascent value in the font</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>Ascent value in the font</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFont_GetTypeAscent(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetTypeAscent_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetTypeDescent", SetLastError = true)]
  private static extern int FPDFFont_GetTypeDescent_native(IntPtr font);

  /// <summary>Get the descent value in the font</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>Descent value in the font</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFont_GetTypeDescent(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetTypeDescent_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetItalicAngle", SetLastError = true)]
  private static extern int FPDFFont_GetItalicAngle_native(IntPtr font);

  /// <summary>Get the italic angle value in the font</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>Italic angle value in the font</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFont_GetItalicAngle(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetItalicAngle_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetStemV", SetLastError = true)]
  private static extern int FPDFFont_GetStemV_native(IntPtr font);

  /// <summary>Get the StemV value in the font</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <returns>StemV value in the font</returns>
  /// <remarks>
  /// StemV value can be used to calculate the Weight of the font: Weight = StemV #x3C 140 ? StemV * 5 : (StemV * 4 + 140);
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFont_GetStemV(IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetStemV_native(font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetStringWidth", SetLastError = true)]
  private static extern int FPDFFont_GetStringWidth_native(IntPtr font, [MarshalAs(UnmanagedType.LPStr)] string text, int size);

  /// <summary>Get a special string width of a font object.</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <param name="text">Text the width of which is should be obtained.</param>
  /// <returns>String width of a font object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFont_GetStringWidth(IntPtr font, string text)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetStringWidth_native(font, text, text.Length);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetCharWidthF", SetLastError = true)]
  private static extern int FPDFFont_GetCharWidthF_native(IntPtr font, int charcode, int level = 0);

  /// <summary>Get a special character width of a font object.</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <param name="charcode">The character code.</param>
  /// <param name="level">Reserved. Mast be 0.</param>
  /// <returns>Character width of a font object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFont_GetCharWidthF(IntPtr font, int charcode, int level = 0)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetCharWidthF_native(font, charcode, level);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetCharTypeWidth", SetLastError = true)]
  private static extern int FPDFFont_GetCharTypeWidth_native(
    IntPtr font,
    int charcode,
    out bool IsVert);

  /// <summary>Get a special character width of a font object.</summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <param name="charcode">The character code.</param>
  /// <param name="isVert">Gets the flag indicating whether a given symbol is vertically inscribed.</param>
  /// <returns>Character width of a font object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFont_GetCharTypeWidth(IntPtr font, int charcode, out bool isVert)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_GetCharTypeWidth_native(font, charcode, out isVert);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_GetCharBBox", SetLastError = true)]
  private static extern void FPDFFont_GetCharBBox_native(
    IntPtr font,
    int charcode,
    out int left,
    out int top,
    out int right,
    out int bottom,
    int level = 0);

  /// <summary>
  /// Get the special character bounding box of a font object.
  /// </summary>
  /// <param name="font">Handle to the font obtained by <see cref="O:Patagames.Pdf.Pdfium.FPDF_GetStockFont" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFTextObj_GetFont(System.IntPtr)" /></param>
  /// <param name="charcode">The character code.</param>
  /// <param name="left">Pointer to a float value receiving the left of a rectangle (in points).</param>
  /// <param name="top">Pointer to a float value receiving the top of a rectangle (in points).</param>
  /// <param name="right">Pointer to a float value receiving the right of a rectangle (in points).</param>
  /// <param name="bottom">Pointer to a float value receiving the bottom of a rectangle (in points).</param>
  /// <param name="level">Reserved. Mast be 0</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFont_GetCharBBox(
    IntPtr font,
    int charcode,
    out int left,
    out int top,
    out int right,
    out int bottom,
    int level = 0)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFont_GetCharBBox_native(font, charcode, out left, out top, out right, out bottom, level);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_UnicodeFromCharCode", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.I2)]
  private static extern char FPDFFont_UnicodeFromCharCode_native(IntPtr font, [MarshalAs(UnmanagedType.I4)] int charcode);

  /// <summary>Convert char code to unicode</summary>
  /// <param name="font">Handle to the font object</param>
  /// <param name="charcode">Char code</param>
  /// <returns>A unicode character</returns>
  [HandleProcessCorruptedStateExceptions]
  public static char FPDFFont_UnicodeFromCharCode(IntPtr font, int charcode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_UnicodeFromCharCode_native(font, charcode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_CharCodeFromUnicode", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.I4)]
  private static extern int FPDFFont_CharCodeFromUnicode_native(IntPtr font, [MarshalAs(UnmanagedType.I2)] char unicode);

  /// <summary>Convert unicode to char code</summary>
  /// <param name="font">Handle to the font object</param>
  /// <param name="unicode">Unicode</param>
  /// <returns>A char code</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFont_CharCodeFromUnicode(IntPtr font, char unicode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_CharCodeFromUnicode_native(font, unicode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_AddToCMap", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.I4)]
  private static extern uint FPDFFont_AddToCMap_native(IntPtr font, [MarshalAs(UnmanagedType.I4)] uint unicode);

  /// <summary>
  /// Add an unicode character to the CMap table of the specified font.
  /// </summary>
  /// <param name="font">Handle to the font object.</param>
  /// <param name="unicode">Unicode character</param>
  /// <returns>A char code that was added. Zero if unicode already present in the CMap.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static uint FPDFFont_AddToCMap(IntPtr font, uint unicode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFont_AddToCMap_native(font, unicode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFont_AddToWidths", SetLastError = true)]
  private static extern void FPDFFont_AddToWidths_native(IntPtr font, [MarshalAs(UnmanagedType.I4)] uint charcode);

  /// <summary>
  /// Add thw character width to the Width array of the specified font.
  /// </summary>
  /// <param name="font">Handle to the font object.</param>
  /// <param name="charcode">A char code.</param>
  /// <remarks><note type="warning">Currently, only CID fonts are supported.</note></remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFont_AddToWidths(IntPtr font, uint charcode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFont_AddToWidths_native(font, charcode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDOC_SetSubstitutionFont", SetLastError = true)]
  private static extern void FPDFDOC_SetSubstitutionFont_native(IntPtr doc, IntPtr font);

  /// <summary>
  /// Set a substitution font that is used to display user input in acro forms.
  /// </summary>
  /// <param name="doc">Handle to the document.</param>
  /// <param name="font">Handle to the font.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDOC_SetSubstitutionFont(IntPtr doc, IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDOC_SetSubstitutionFont_native(doc, font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDOC_GetSubstitutionFont", SetLastError = true)]
  private static extern IntPtr FPDFDOC_GetSubstitutionFont_native(IntPtr doc);

  /// <summary>
  /// get a substitution font that is used to display user input in acro forms.
  /// </summary>
  /// <param name="doc">Handle to the document.</param>
  /// <returns>The handle to font.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDOC_GetSubstitutionFont(IntPtr doc)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDOC_GetSubstitutionFont_native(doc);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormObj_CalcBoundingBox", SetLastError = true)]
  private static extern void FPDFFormObj_CalcBoundingBox_native(IntPtr formObject);

  /// <summary>Calculate bounding box</summary>
  /// <param name="formObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormObj_CalcBoundingBox(IntPtr formObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormObj_CalcBoundingBox_native(formObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormObj_SetFormMatrix", SetLastError = true)]
  private static extern void FPDFFormObj_SetFormMatrix_native(IntPtr formObject, [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX pMatrix);

  /// <summary>Sets transform matrix for form object.</summary>
  /// <param name="formObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="pMatrix">The transform matrix</param>
  /// <remarks>Application should call <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_CalcBoundingBox(System.IntPtr)" /> method to take transformation effect.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormObj_SetFormMatrix(IntPtr formObject, FS_MATRIX pMatrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormObj_SetFormMatrix_native(formObject, pMatrix);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormObj_GetFormMatrix", SetLastError = true)]
  private static extern void FPDFFormObj_GetFormMatrix_native(IntPtr formObject, [MarshalAs(UnmanagedType.LPStruct), In, Out] FS_MATRIX pMatrix);

  /// <summary>Gets transform matrix for form object.</summary>
  /// <param name="formObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="pMatrix">The transform matrix</param>
  [Obsolete("This method is obsolete. Please use FPDFFormObj_GetFormMatrix(IntPtr formObject) instead.", false)]
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormObj_GetFormMatrix(IntPtr formObject, FS_MATRIX pMatrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormObj_GetFormMatrix_native(formObject, pMatrix);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Gets transform matrix for form object.</summary>
  /// <param name="formObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>The transformation matrix.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FS_MATRIX FPDFFormObj_GetFormMatrix(IntPtr formObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        FS_MATRIX pMatrix = new FS_MATRIX();
        Pdfium.FPDFFormObj_GetFormMatrix_native(formObject, pMatrix);
        return pMatrix;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormObj_GetFormContent", SetLastError = true)]
  private static extern IntPtr FPDFFormObj_GetFormContent_native(IntPtr formObject);

  /// <summary>Gets content for specified form object</summary>
  /// <param name="formObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>Handle to form content object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormObj_GetFormContent(IntPtr formObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormObj_GetFormContent_native(formObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormObj_SetFormContent", SetLastError = true)]
  private static extern void FPDFFormObj_SetFormContent_native(
    IntPtr formObject,
    IntPtr formContent);

  /// <summary>Sets content for specified form object</summary>
  /// <param name="formObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="formContent">Form content what should be set</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormObj_SetFormContent(IntPtr formObject, IntPtr formContent)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormObj_SetFormContent_native(formObject, formContent);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFANNOT_GetApperanceStream", SetLastError = true)]
  private static extern IntPtr FPDFAnnot_GetAppearanceStream_native(
    IntPtr annotDict,
    AppearanceStreamModes mode);

  /// <summary>
  /// Gets appearance stream for the specified annotation and mode
  /// </summary>
  /// <param name="annotDict">Handle to the PDF document.</param>
  /// <param name="mode">An annotation appearance mode.</param>
  /// <returns>Handle to the appearance stream.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFAnnot_GetAppearanceStream(IntPtr annotDict, AppearanceStreamModes mode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFAnnot_GetAppearanceStream_native(annotDict, mode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_BackgroundAlphaNeeded", SetLastError = true)]
  private static extern int FPDFFormContent_BackgroundAlphaNeeded_native(IntPtr contentObject);

  /// <summary>Check something.</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <returns>True or False</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormContent_BackgroundAlphaNeeded(IntPtr contentObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_BackgroundAlphaNeeded_native(contentObject) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_CountObjects", SetLastError = true)]
  private static extern int FPDFFormContent_CountObjects_native(IntPtr contentObject);

  /// <summary>Get number of page objects in this content object</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <returns>number of page objects or -1 if any error occurs</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormContent_CountObjects(IntPtr contentObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_CountObjects_native(contentObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_GetObjectByIndex", SetLastError = true)]
  private static extern IntPtr FPDFFormContent_GetObjectByIndex_native(
    IntPtr contentObject,
    int index);

  /// <summary>Gets the page objects from content object by index</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <param name="index">Index of page object in content object</param>
  /// <returns>Handle to the page object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormContent_GetObjectByIndex(IntPtr contentObject, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_GetObjectByIndex_native(contentObject, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_GetObjectIndex", SetLastError = true)]
  private static extern int FPDFFormContent_GetObjectIndex_native(
    IntPtr contentObject,
    IntPtr pageObjet);

  /// <summary>Gets the index of specified page objects</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <param name="pageObjet">Handle to the page object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormContent_GetObjectByIndex(System.IntPtr,System.Int32)" /></param>
  /// <returns>Index of page object or -1 if any error occurs</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormContent_GetObjectIndex(IntPtr contentObject, IntPtr pageObjet)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_GetObjectIndex_native(contentObject, pageObjet);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_IsParsed", SetLastError = true)]
  private static extern int FPDFFormContent_IsParsed_native(IntPtr contentObject);

  /// <summary>Check whether the content object is parsed or not.</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <returns>True if content parsed, false otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormContent_IsParsed(IntPtr contentObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_IsParsed_native(contentObject) != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_GetTransparency", SetLastError = true)]
  private static extern int FPDFFormContent_GetTransparency_native(IntPtr contentObject);

  /// <summary>Gets transparency type for specified content object</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <returns><see cref="T:Patagames.Pdf.Enums.FormObjectTransparency" /> enumeration</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FormObjectTransparency FPDFFormContent_GetTransparency(IntPtr contentObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return (FormObjectTransparency) Pdfium.FPDFFormContent_GetTransparency_native(contentObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_SetTransparency", SetLastError = true)]
  private static extern void FPDFFormContent_SetTransparency_native(
    IntPtr contentObject,
    int transparency);

  /// <summary>Sets transparency type for specified content object</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <param name="transparency">Transparency type</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormContent_SetTransparency(
    IntPtr contentObject,
    FormObjectTransparency transparency)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormContent_SetTransparency_native(contentObject, (int) transparency);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_TransformObjects", SetLastError = true)]
  private static extern void FPDFFormContent_TransformObjects_native(
    IntPtr contentObject,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX pMatrix);

  /// <summary>
  /// Transform all objects in content object with a specified matrix.
  /// </summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <param name="pMatrix">The transform matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormContent_TransformObjects(IntPtr contentObject, FS_MATRIX pMatrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormContent_TransformObjects_native(contentObject, pMatrix);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_InsertObject", SetLastError = true)]
  private static extern void FPDFFormContent_InsertObject_native(
    IntPtr contentObject,
    IntPtr newObject,
    int index);

  /// <summary>Insert specified page object into content object</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <param name="newObject">Handle to page object which will be inserted</param>
  /// <param name="index">The zero-based index at which the object should be inserted.</param>
  /// <remarks><note type="warning">If you insert the same objects multiple times, then an error will occur during disposing those objects.</note></remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormContent_InsertObject(
    IntPtr contentObject,
    IntPtr newObject,
    int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormContent_InsertObject_native(contentObject, newObject, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_RemoveObject", SetLastError = true)]
  private static extern void FPDFFormContent_RemoveObject_native(IntPtr contentObject, int index);

  /// <summary>
  /// Removes object from content object at the specified index.
  /// </summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <param name="index">The zero-based index of the item to remove.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormContent_RemoveObject(IntPtr contentObject, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormContent_RemoveObject_native(contentObject, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_GetDocument", SetLastError = true)]
  private static extern IntPtr FPDFFormContent_GetDocument_native(IntPtr contentObject);

  /// <summary>Get underlying document from content object</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFFormObj_GetFormContent(System.IntPtr)" /></param>
  /// <returns>Handle to PDF Document</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormContent_GetDocument(IntPtr contentObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_GetDocument_native(contentObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_Parse", SetLastError = true)]
  private static extern bool FPDFFormContent_Parse_native(IntPtr contentObject);

  /// <summary>Parse given content object.</summary>
  /// <param name="contentObject">Handle to form object returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFFormContent_Create" /></param>
  /// <returns>False if contentObject is IntPtr.Zero; true otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormContent_Parse(IntPtr contentObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_Parse_native(contentObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_Create", SetLastError = true)]
  private static extern IntPtr FPDFFormContent_Create_native(
    IntPtr doc,
    IntPtr stream,
    IntPtr pageRes,
    IntPtr parentRes);

  /// <summary>Creates content object from given stream.</summary>
  /// <param name="doc">Handle to the PDF document.</param>
  /// <param name="stream">The input stream to parse.</param>
  /// <param name="pageRes">Handle to the page's resource dictionary</param>
  /// <param name="parentRes">Handle to the parent's resource dictionary</param>
  /// <returns>Handle to form content object</returns>
  /// <remarks>The order of searching resourses is stream dictionary, pageRes, parentRes </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormContent_Create(
    IntPtr doc,
    IntPtr stream,
    IntPtr pageRes,
    IntPtr parentRes)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_Create_native(doc, stream, pageRes, parentRes);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Creates content object from given stream.</summary>
  /// <param name="doc">Handle to the PDF document.</param>
  /// <param name="stream">The input stream to parse.</param>
  /// <param name="pageRes">Handle to the page's resource dictionary</param>
  /// <returns>Handle to form content object</returns>
  public static IntPtr FPDFFormContent_Create(IntPtr doc, IntPtr stream, IntPtr pageRes)
  {
    return Pdfium.FPDFFormContent_Create(doc, stream, pageRes, IntPtr.Zero);
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_Delete", SetLastError = true)]
  private static extern void FPDFFormContent_Delete_native(IntPtr contentObject);

  /// <summary>Destroy content.</summary>
  /// <param name="contentObject">Handle to the content object returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFFormContent_Create" />.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormContent_Delete(IntPtr contentObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormContent_Delete_native(contentObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormContent_GetStream", SetLastError = true)]
  private static extern IntPtr FPDFFormContent_GetStream_native(IntPtr contentObject);

  /// <summary>Get the underlying stream object.</summary>
  /// <param name="contentObject">Handle to the content object returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFFormContent_Create" />.</param>
  /// <returns>The handle of stream object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormContent_GetStream(IntPtr contentObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormContent_GetStream_native(contentObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObjectList_GetObject", SetLastError = true)]
  private static extern IntPtr FPDFPageObjectList_GetObject_native(IntPtr list, int index);

  /// <summary>Get page object by index</summary>
  /// <param name="list">Handle to a list of page objects.</param>
  /// <param name="index">The index of a page object.</param>
  /// <returns>The Handle to the page object. IntPtr.Zero if any error has occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPageObjectList_GetObject(IntPtr list, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObjectList_GetObject_native(list, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObjectList_CountObject", SetLastError = true)]
  private static extern int FPDFPageObjectList_CountObject_native(IntPtr list);

  /// <summary>Get number of page objects.</summary>
  /// <param name="list">Handle to a list of page objects.</param>
  /// <returns>The number of the page object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFPageObjectList_CountObject(IntPtr list)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObjectList_CountObject_native(list);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObjectList_RemoveObject", SetLastError = true)]
  private static extern void FPDFPageObjectList_RemoveObject_native(IntPtr list, int index);

  /// <summary>Remove object from the collection at specified index.</summary>
  /// <param name="list">Handle to a list of page objects.</param>
  /// <param name="index">The zero-based index of the item to remove.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObjectList_RemoveObject(IntPtr list, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObjectList_RemoveObject_native(list, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObjectList_InsertObject", SetLastError = true)]
  private static extern void FPDFPageObjectList_InsertObject_native(
    IntPtr list,
    IntPtr page_object,
    int index);

  /// <summary>
  /// Add an object to the objects coolection after specified index. The page object is automatically freed.
  /// </summary>
  /// <param name="list">Handle to a list of page objects.</param>
  /// <param name="page_object">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObj" />, <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewTextObjEx(System.String,System.Int32,System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewPathObj" />.</param>
  /// <param name="index">&gt;The zero-based index at which object should be inserted.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObjectList_InsertObject(IntPtr list, IntPtr page_object, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObjectList_InsertObject_native(list, page_object, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPathObj_CalcBoundingBox", SetLastError = true)]
  private static extern void FPDFPathObj_CalcBoundingBox_native(IntPtr path_obj);

  /// <summary>Calculate bounding box</summary>
  /// <param name="path_obj">Handle to a path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPathObj_CalcBoundingBox(IntPtr path_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPathObj_CalcBoundingBox_native(path_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPathObj_GetPath", SetLastError = true)]
  private static extern IntPtr FPDFPathObj_GetPath_native(IntPtr path_obj);

  /// <summary>Get the path associated with this PathObject.</summary>
  /// <param name="path_obj">Handle to a path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>Handle to a path associated with this path object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPathObj_GetPath(IntPtr path_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPathObj_GetPath_native(path_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPathObj_GetFillType", SetLastError = true)]
  private static extern FillModes FPDFPathObj_GetFillType_native(IntPtr path_obj);

  /// <summary>Get the fill type of the specified path object.</summary>
  /// <param name="path_obj">Handle to a path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>The fill type of the specified path object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FillModes FPDFPathObj_GetFillType(IntPtr path_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPathObj_GetFillType_native(path_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPathObj_SetFillType", SetLastError = true)]
  private static extern void FPDFPathObj_SetFillType_native(IntPtr path_obj, FillModes fillMode);

  /// <summary>Set the fill type to the specified PathObject.</summary>
  /// <param name="path_obj">Handle to a path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="fillMode">The fill type of the specified path object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPathObj_SetFillType(IntPtr path_obj, FillModes fillMode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPathObj_SetFillType_native(path_obj, fillMode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPathObj_GetIsStroke", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFPathObj_GetIsStroke_native(IntPtr path_obj);

  /// <summary>Check whether the stroke flag is true or not.</summary>
  /// <param name="path_obj">Handle to a path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>The true mean to paint a line along the path; false otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPathObj_GetIsStroke(IntPtr path_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPathObj_GetIsStroke_native(path_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPathObj_SetIsStroke", SetLastError = true)]
  private static extern void FPDFPathObj_SetIsStroke_native(IntPtr path_obj, bool isStroke);

  /// <summary>Set the stroke flag.</summary>
  /// <param name="path_obj">Handle to a path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="isStroke">True mean to paint a line along the path.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPathObj_SetIsStroke(IntPtr path_obj, bool isStroke)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPathObj_SetIsStroke_native(path_obj, isStroke);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPathObj_GetMatrix", SetLastError = true)]
  private static extern void FPDFPathObj_GetMatrix_native(
    IntPtr path_obj,
    [MarshalAs(UnmanagedType.R4)] out float a,
    [MarshalAs(UnmanagedType.R4)] out float b,
    [MarshalAs(UnmanagedType.R4)] out float c,
    [MarshalAs(UnmanagedType.R4)] out float d,
    [MarshalAs(UnmanagedType.R4)] out float e,
    [MarshalAs(UnmanagedType.R4)] out float f);

  /// <summary>Get the transformation matrix of the path object.</summary>
  /// <param name="path_obj">Handle to path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <param name="a">Pointer to a float value receiving the coefficient "a" of the matrix.</param>
  /// <param name="b">Pointer to a float value receiving the coefficient "b" of the matrix.</param>
  /// <param name="c">Pointer to a float value receiving the coefficient "c" of the matrix.</param>
  /// <param name="d">Pointer to a float value receiving the coefficient "d" of the matrix.</param>
  /// <param name="e">Pointer to a float value receiving the coefficient "e" of the matrix.</param>
  /// <param name="f">Pointer to a float value receiving the coefficient "f" of the matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPathObj_GetMatrix(
    IntPtr path_obj,
    out float a,
    out float b,
    out float c,
    out float d,
    out float e,
    out float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPathObj_GetMatrix_native(path_obj, out a, out b, out c, out d, out e, out f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Get the transformation matrix of the path object.</summary>
  /// <param name="path_obj">Handle to the path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /></param>
  /// <returns>An instance of <see cref="T:Patagames.Pdf.FS_MATRIX" />. Never returns NULL.</returns>
  public static FS_MATRIX FPDFPathObj_GetMatrix(IntPtr path_obj)
  {
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    Pdfium.FPDFPathObj_GetMatrix(path_obj, out a, out b, out c, out d, out e, out f);
    return new FS_MATRIX()
    {
      a = a,
      b = b,
      c = c,
      d = d,
      e = e,
      f = f
    };
  }

  [DllImport("pdfium", EntryPoint = "FPDFPathObj_SetMatrix", SetLastError = true)]
  private static extern void FPDFPathObj_SetMatrix_native(
    IntPtr path_obj,
    [MarshalAs(UnmanagedType.R4)] float a,
    [MarshalAs(UnmanagedType.R4)] float b,
    [MarshalAs(UnmanagedType.R4)] float c,
    [MarshalAs(UnmanagedType.R4)] float d,
    [MarshalAs(UnmanagedType.R4)] float e,
    [MarshalAs(UnmanagedType.R4)] float f);

  /// <summary>Set the matrix of a path object</summary>
  /// <param name="path_obj">Handle to the path object returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_NewImgeObj(System.IntPtr)" />.</param>
  /// <param name="a">The coefficient "a" of the matrix</param>
  /// <param name="b">The coefficient "b" of the matrix</param>
  /// <param name="c">The coefficient "c" of the matrix</param>
  /// <param name="d">The coefficient "d" of the matrix</param>
  /// <param name="e">The coefficient "e" of the matrix</param>
  /// <param name="f">The coefficient "f" of the matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPathObj_SetMatrix(
    IntPtr path_obj,
    float a,
    float b,
    float c,
    float d,
    float e,
    float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPathObj_SetMatrix_native(path_obj, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Set the matrix of a path object</summary>
  /// <param name="path_obj">Handle to the path object.</param>
  /// <param name="matrix">The matrix of path object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPathObj_SetMatrix(IntPtr path_obj, FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPathObj_SetMatrix_native(path_obj, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_Create", SetLastError = true)]
  private static extern IntPtr FPDFPath_Create_native();

  /// <summary>Create a path object</summary>
  /// <returns>The Handle to the created path, or IntPtr.Zero if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPath_Create()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPath_Create_native();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_Delete", SetLastError = true)]
  private static extern void FPDFPath_Delete_native(IntPtr path);

  /// <summary>Destroy a path and release all related buffers</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> function.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_Delete(IntPtr path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_Delete_native(path);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_GetPointCount", SetLastError = true)]
  private static extern int FPDFPath_GetPointCount_native(IntPtr path);

  /// <summary>Gets the number of points in the current path</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <returns>The number of points in the current path.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFPath_GetPointCount(IntPtr path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPath_GetPointCount_native(path);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_GetFlag", SetLastError = true)]
  private static extern PathPointFlags FPDFPath_GetFlag_native(IntPtr path, int index);

  /// <summary>
  /// Gets the type of the path point at the specified index.
  /// </summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="index">The zero-based index of the point</param>
  /// <returns>The type of the path point.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static PathPointFlags FPDFPath_GetFlag(IntPtr path, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPath_GetFlag_native(path, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_GetPointX", SetLastError = true)]
  private static extern void FPDFPath_GetPointX_native(IntPtr path, int index, [MarshalAs(UnmanagedType.R4)] out float x);

  /// <summary>Get x-coordinate of the path point /&gt;.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="index">The zero-based index of the point</param>
  /// <returns>The x-coordinate of the path point</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFPath_GetPointX(IntPtr path, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float x;
        Pdfium.FPDFPath_GetPointX_native(path, index, out x);
        return x;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_GetPointY", SetLastError = true)]
  private static extern void FPDFPath_GetPointY_native(IntPtr path, int index, [MarshalAs(UnmanagedType.R4)] out float y);

  /// <summary>Get y-coordinate of the path point /&gt;.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="index">The zero-based index of the point</param>
  /// <returns>The y-coordinate of the path point</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFPath_GetPointY(IntPtr path, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float y;
        Pdfium.FPDFPath_GetPointY_native(path, index, out y);
        return y;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_GetPoints", SetLastError = true)]
  private static extern IntPtr FPDFPath_GetPoints_native(IntPtr path);

  /// <summary>Gets the points in the path.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <returns>An array of <see cref="T:Patagames.Pdf.FS_PATHPOINTF" />structures that represent the path; or null if any errors occurs</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FS_PATHPOINTF[] FPDFPath_GetPoints(IntPtr path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        IntPtr pointsNative = Pdfium.FPDFPath_GetPoints_native(path);
        if (pointsNative == IntPtr.Zero)
          return (FS_PATHPOINTF[]) null;
        int pointCountNative = Pdfium.FPDFPath_GetPointCount_native(path);
        if (pointCountNative <= 0)
          return new FS_PATHPOINTF[0];
        FS_PATHPOINTF[] points = new FS_PATHPOINTF[pointCountNative];
        int num = Marshal.SizeOf<FS_PATHPOINTF>(points[0]);
        for (int index = 0; index < pointCountNative; ++index)
        {
          IntPtr ptr = new IntPtr(pointsNative.ToInt64() + (long) (num * index));
          points[index] = Marshal.PtrToStructure<FS_PATHPOINTF>(ptr);
        }
        return points;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_GetBoundingBox", SetLastError = true)]
  private static extern void FPDFPath_GetBoundingBox_native(
    IntPtr path,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float top,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float bottom);

  /// <summary>Get a rectangle that bounds this Path.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <returns>A rectangle that bounds this Path.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FS_RECTF FPDFPath_GetBoundingBox(IntPtr path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float left;
        float top;
        float right;
        float bottom;
        Pdfium.FPDFPath_GetBoundingBox_native(path, out left, out top, out right, out bottom);
        return new FS_RECTF()
        {
          left = left,
          right = right,
          top = top,
          bottom = bottom
        };
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_GetBoundingBoxEx", SetLastError = true)]
  private static extern void FPDFPath_GetBoundingBoxEx_native(
    IntPtr path,
    [MarshalAs(UnmanagedType.R4)] float line_width,
    [MarshalAs(UnmanagedType.R4)] float miter_limit,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float top,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float bottom);

  /// <summary>Get a rectangle that bounds this Path.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="line_width">Line width.</param>
  /// <param name="miter_limit"></param>
  /// <returns>A rectangle that bounds this Path.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FS_RECTF FPDFPath_GetBoundingBoxEx(
    IntPtr path,
    float line_width,
    float miter_limit)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float left;
        float top;
        float right;
        float bottom;
        Pdfium.FPDFPath_GetBoundingBoxEx_native(path, line_width, miter_limit, out left, out top, out right, out bottom);
        return new FS_RECTF()
        {
          left = left,
          right = right,
          top = top,
          bottom = bottom
        };
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_IsRect", SetLastError = true)]
  private static extern bool FPDFPath_IsRect_native(IntPtr path);

  /// <summary>Determines whether this path is a rectangle.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <returns>true if this path is rectangle, false otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPath_IsRect(IntPtr path)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPath_IsRect_native(path);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_AppendEx", SetLastError = true)]
  private static extern void FPDFPath_AppendEx_native(
    IntPtr path,
    IntPtr src,
    [MarshalAs(UnmanagedType.R4)] float a,
    [MarshalAs(UnmanagedType.R4)] float b,
    [MarshalAs(UnmanagedType.R4)] float c,
    [MarshalAs(UnmanagedType.R4)] float d,
    [MarshalAs(UnmanagedType.R4)] float e,
    [MarshalAs(UnmanagedType.R4)] float f);

  /// <summary>Appends the specified Path to another path.</summary>
  /// <param name="path">Handle to the destination path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="src">Handle to the source path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="matrix">Transformation matrix.</param>
  /// <remarks>This method internally calls the <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_AddPointCount(System.IntPtr,System.Int32)" /> method.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_AppendEx(IntPtr path, IntPtr src, FS_MATRIX matrix)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_AppendEx_native(path, src, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_Append", SetLastError = true)]
  private static extern void FPDFPath_Append_native(IntPtr path, IntPtr src);

  /// <summary>Appends the specified Path to another path.</summary>
  /// <param name="path">Handle to the destination path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="src">Handle to the source path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <remarks>This method internally calls the <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_AddPointCount(System.IntPtr,System.Int32)" /> method.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_Append(IntPtr path, IntPtr src)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_Append_native(path, src);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_AppendRect", SetLastError = true)]
  private static extern void FPDFPath_AppendRect_native(
    IntPtr path,
    [MarshalAs(UnmanagedType.R4)] float left,
    [MarshalAs(UnmanagedType.R4)] float bottom,
    [MarshalAs(UnmanagedType.R4)] float right,
    [MarshalAs(UnmanagedType.R4)] float top);

  /// <summary>Adds a rectangle to the path.</summary>
  /// <param name="path">Handle to the destination path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="rect">A <see cref="T:Patagames.Pdf.FS_RECTF" /> that represents the rectangle to add.</param>
  /// <remarks>This method internally calls the <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_AddPointCount(System.IntPtr,System.Int32)" /> method.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_AppendRect(IntPtr path, FS_RECTF rect)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_AppendRect_native(path, rect.left, rect.bottom, rect.right, rect.top);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_Copy", SetLastError = true)]
  private static extern void FPDFPath_Copy_native(IntPtr path, IntPtr src);

  /// <summary>Copy points from one Path to another.</summary>
  /// <param name="path">Handle to the destination path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="src">Handle to the source path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <remarks>This method internally calls the <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_SetPointCount(System.IntPtr,System.Int32)" /> method.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_Copy(IntPtr path, IntPtr src)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_Copy_native(path, src);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_SetPoint", SetLastError = true)]
  private static extern void FPDFPath_SetPoint_native(
    IntPtr path,
    int index,
    [MarshalAs(UnmanagedType.R4)] float x,
    [MarshalAs(UnmanagedType.R4)] float y,
    PathPointFlags flags);

  /// <summary>Set specified point at specified index.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="index">The zero-based index of the point</param>
  /// <param name="point">The <see cref="T:Patagames.Pdf.FS_PATHPOINTF" /> that represents the point to add.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_SetPoint(IntPtr path, int index, FS_PATHPOINTF point)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_SetPoint_native(path, index, point.X, point.Y, point.Flags);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_SetPointCount", SetLastError = true)]
  private static extern void FPDFPath_SetPointCount_native(IntPtr path, int count);

  /// <summary>Sets the number of points in the specified path.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="count">Number of points</param>
  /// <remarks>If the existing buffer is smaller than necessary, then a new one is allocated, and the existing one is destroyed.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_SetPointCount(IntPtr path, int count)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_SetPointCount_native(path, count);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_AllocPointCount", SetLastError = true)]
  private static extern void FPDFPath_AllocPointCount_native(IntPtr path, int count);

  /// <summary>Allocates the buffer for a given number of points.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="count">Number of points</param>
  /// <remarks>If the existing buffer is smaller than necessary, a new one is created, and all existing points are copied to it. Otherwise do nothing.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_AllocPointCount(IntPtr path, int count)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_AllocPointCount_native(path, count);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_AddPointCount", SetLastError = true)]
  private static extern void FPDFPath_AddPointCount_native(IntPtr path, int count);

  /// <summary>
  /// Adds the specified number of points to the specified path.
  /// </summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="count">The number of points</param>
  /// <remarks>A new buffer is created, and all existing points are copied to it.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_AddPointCount(IntPtr path, int count)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_AddPointCount_native(path, count);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_TrimPoints", SetLastError = true)]
  private static extern void FPDFPath_TrimPoints_native(IntPtr path, int count);

  /// <summary>
  /// Decreases the number of points in the specified path to the specified count.
  /// </summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="count">The number of points</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_TrimPoints(IntPtr path, int count)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_TrimPoints_native(path, count);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPath_Transform", SetLastError = true)]
  private static extern void FPDFPath_Transform_native(
    IntPtr path,
    [MarshalAs(UnmanagedType.R4)] float a,
    [MarshalAs(UnmanagedType.R4)] float b,
    [MarshalAs(UnmanagedType.R4)] float c,
    [MarshalAs(UnmanagedType.R4)] float d,
    [MarshalAs(UnmanagedType.R4)] float e,
    [MarshalAs(UnmanagedType.R4)] float f);

  /// <summary>Transform (scale, rotate, shear, move) path.</summary>
  /// <param name="path">Handle to the path returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPath_Create" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPathObj_GetPath(System.IntPtr)" />.</param>
  /// <param name="a">The coefficient "a" of the matrix</param>
  /// <param name="b">The coefficient "b" of the matrix</param>
  /// <param name="c">The coefficient "c" of the matrix</param>
  /// <param name="d">The coefficient "d" of the matrix</param>
  /// <param name="e">The coefficient "e" of the matrix</param>
  /// <param name="f">The coefficient "f" of the matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPath_Transform(
    IntPtr path,
    float a,
    float b,
    float c,
    float d,
    float e,
    float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPath_Transform_native(path, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetLineWidth", SetLastError = true)]
  private static extern bool FPDFPageObj_GetLineWidth_native(IntPtr page_obj, out float width);

  /// <summary>
  /// Get the thickness, in user space units, of paths to be stroked.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>A non-negative number expressed in user space units, specifying the thickness of the line used to stroke a path.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFPageObj_GetLineWidth(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float width = 0.0f;
        Pdfium.FPDFPageObj_GetLineWidth_native(page_obj, out width);
        return width;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetLineWidth", SetLastError = true)]
  private static extern bool FPDFPageObj_SetLineWidth_native(IntPtr page_obj, float width);

  /// <summary>
  /// Set the thickness, in user space units, of paths to be stroked.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="width">A non-negative number expressed in user space units, specifying the thickness of the line used to stroke a path.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetLineWidth(IntPtr page_obj, float width)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetLineWidth_native(page_obj, width);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetMiterLimit", SetLastError = true)]
  private static extern bool FPDFPageObj_GetMiterLimit_native(IntPtr page_obj, out float miterLimit);

  /// <summary>
  /// Get the maximum length of mitered line joins for stroked paths.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>A non-negative number expressed in user space units, specifies the limitation of the length of “spikes” produced when line segments join at sharp angles.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFPageObj_GetMiterLimit(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float miterLimit = 0.0f;
        Pdfium.FPDFPageObj_GetMiterLimit_native(page_obj, out miterLimit);
        return miterLimit;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetMiterLimit", SetLastError = true)]
  private static extern bool FPDFPageObj_SetMiterLimit_native(IntPtr page_obj, float miterLimit);

  /// <summary>
  /// Set the maximum length of mitered line joins for stroked paths.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="miterLimit">This parameter limits the length of “spikes” produced when line segments join at sharp angles.</param>
  /// <remarks>
  /// When two line segments meet at a sharp angle and <see cref="F:Patagames.Pdf.Enums.LineJoin.Miter" /> have been specified as the line join style, it is possible for the miter to extend far beyond the
  /// thickness of the line stroking the path. The miter limit imposes a maximum on the ratio of the miter length to the line width.
  /// When the limit is exceeded, the join is converted from a <see cref="F:Patagames.Pdf.Enums.LineJoin.Miter" /> to a <see cref="F:Patagames.Pdf.Enums.LineJoin.Bevel" />.
  /// <list type="table">
  /// <item><term><img src="../Media/MiterLimit.png" /></term></item>
  /// <listheader>
  /// <term>FIGURE 4.7 Miter length</term>
  /// </listheader>
  /// </list>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetMiterLimit(IntPtr page_obj, float miterLimit)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetMiterLimit_native(page_obj, miterLimit);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetDashPhase", SetLastError = true)]
  private static extern bool FPDFPageObj_GetDashPhase_native(IntPtr page_obj, out float dashPhase);

  /// <summary>
  /// Get the dash phase. The dash phase specifies the distance into the dash pattern at which to start the dash.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>A non-negative number expressed in user space units.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFPageObj_GetDashPhase(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float dashPhase = 0.0f;
        Pdfium.FPDFPageObj_GetDashPhase_native(page_obj, out dashPhase);
        return dashPhase;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetDashPhase", SetLastError = true)]
  private static extern bool FPDFPageObj_SetDashPhase_native(IntPtr page_obj, float dashPhase);

  /// <summary>
  /// Set the dash phase. The dash phase specifies the distance into the dash pattern at which to start the dash.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="dashPhase">The dash phase - a non-negative number expressed in user space units.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetDashPhase(IntPtr page_obj, float dashPhase)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetDashPhase_native(page_obj, dashPhase);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetLineJoin", SetLastError = true)]
  private static extern bool FPDFPageObj_GetLineJoin_native(IntPtr page_obj, out LineJoin lineJoin);

  /// <summary>
  /// Get the shape of joints between connected segments of a stroked path.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>One of the values of the <see cref="T:Patagames.Pdf.Enums.LineJoin" /> enumeration.</returns>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.LineJoin" /> enumeration for details. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static LineJoin FPDFPageObj_GetLineJoin(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        LineJoin lineJoin;
        Pdfium.FPDFPageObj_GetLineJoin_native(page_obj, out lineJoin);
        return lineJoin;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetLineJoin", SetLastError = true)]
  private static extern bool FPDFPageObj_SetLineJoin_native(IntPtr page_obj, LineJoin lineJoin);

  /// <summary>
  /// Set the shape of joints between connected segments of a stroked path.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="lineJoin">One of the values of the <see cref="T:Patagames.Pdf.Enums.LineJoin" /> enumeration.</param>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.LineJoin" /> enumeration for details. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetLineJoin(IntPtr page_obj, LineJoin lineJoin)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetLineJoin_native(page_obj, lineJoin);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetLineCap", SetLastError = true)]
  private static extern bool FPDFPageObj_GetLineCap_native(IntPtr page_obj, out LineCap lineCap);

  /// <summary>
  /// Get the shape of the endpoints for any open path that is stroked.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>One of the values of the <see cref="T:Patagames.Pdf.Enums.LineCap" /> enumeration.</returns>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.LineCap" /> enumeration for details. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static LineCap FPDFPageObj_GetLineCap(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        LineCap lineCap;
        Pdfium.FPDFPageObj_GetLineCap_native(page_obj, out lineCap);
        return lineCap;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetLineCap", SetLastError = true)]
  private static extern bool FPDFPageObj_SetLineCap_native(IntPtr page_obj, LineCap lineCap);

  /// <summary>
  /// Set the shape of the endpoints for any open path that is stroked.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="lineCap">One of the values of the <see cref="T:Patagames.Pdf.Enums.LineCap" /> enumeration.</param>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.LineCap" /> enumeration for details. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetLineCap(IntPtr page_obj, LineCap lineCap)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetLineCap_native(page_obj, lineCap);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetDashArray", SetLastError = true)]
  private static extern bool FPDFPageObj_GetDashArray_native(
    IntPtr page_obj,
    out int cnt,
    out IntPtr dash);

  /// <summary>Get the line dash array.</summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>An array of  numbers that specify the lengths of alternating dashes and gaps; the numbers must be nonnegative and not all zero.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFPageObj_GetDashArray(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int cnt = 0;
        IntPtr dash;
        if (!Pdfium.FPDFPageObj_GetDashArray_native(page_obj, out cnt, out dash) || cnt <= 0)
          return (float[]) null;
        float[] destination = new float[cnt];
        Marshal.Copy(dash, destination, 0, cnt);
        return destination;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetDashArray", SetLastError = true)]
  private static extern bool FPDFPageObj_SetDashArray_native(
    IntPtr page_obj,
    int cnt,
    float[] dash);

  /// <summary>Set the line dash array.</summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="dash">An array of  numbers that specify the lengths of alternating dashes and gaps; the numbers must be nonnegative and not all zero.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetDashArray(IntPtr page_obj, float[] dash)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetDashArray_native(page_obj, dash == null ? 0 : dash.Length, dash);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetFlatness", SetLastError = true)]
  private static extern bool FPDFPageObj_GetFlatness_native(IntPtr page_obj, out float flatness);

  /// <summary>
  /// Get the precision with which curves are to be rendered on the output device.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>A number in the range 0 to 100; a value of 0 specifies the output device’s default flatness tolerance.</returns>
  /// <remarks>See details in the <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_SetFlatness(System.IntPtr,System.Single)" /> topic.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFPageObj_GetFlatness(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float flatness = 0.0f;
        Pdfium.FPDFPageObj_GetFlatness_native(page_obj, out flatness);
        return flatness;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetFlatness", SetLastError = true)]
  private static extern bool FPDFPageObj_SetFlatness_native(IntPtr page_obj, float flatness);

  /// <summary>
  /// Set the precision with which curves are to be rendered on the output device.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="flatness">A number in the range 0 to 100; a value of 0 specifies the output device’s default flatness tolerance.</param>
  /// <remarks>
  /// <para>The value of this parameter gives the maximum error tolerance, measured in output device pixels; smaller numbers give smoother curves at the expense of more computation and memory use.</para>
  /// <para>The flatness tolerance controls the maximum permitted distance in device pixels between the mathematically correct path and an approximation constructed from straight line segments, as shown in Figure 6.6 </para>
  /// <list type="table">
  /// <item><term><img src="../Media/Figure6.6FlatnessTolerance.png" /></term></item>
  /// <listheader>
  /// <term>FIGURE 6.6 Flatness tolerance</term>
  /// </listheader>
  /// </list>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetFlatness(IntPtr page_obj, float flatness)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetFlatness_native(page_obj, flatness);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetSmoothness", SetLastError = true)]
  private static extern bool FPDFPageObj_GetSmoothness_native(IntPtr page_obj, out float smoothness);

  /// <summary>
  /// Get the precision with which color gradients are to be rendered on the output device.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>A number in the range 0.0 to 1.0;</returns>
  /// <remarks>See details in the <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_SetSmoothness(System.IntPtr,System.Single)" /> topic.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFPageObj_GetSmoothness(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float smoothness = 0.0f;
        Pdfium.FPDFPageObj_GetSmoothness_native(page_obj, out smoothness);
        return smoothness;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetSmoothness", SetLastError = true)]
  private static extern bool FPDFPageObj_SetSmoothness_native(IntPtr page_obj, float smoothness);

  /// <summary>
  /// Set the precision with which color gradients are to be rendered on the output device.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="smoothness">A number in the range 0.0 to 1.0;</param>
  /// <remarks>
  /// <para>
  /// The value of this parameter gives the maximum error tolerance, expressed as a fraction of the range of each color component; smaller numbers give smoother color transitions at the expense of more computation and memory use.
  /// </para>
  /// <para>
  ///  The smoothness tolerance controls the quality of smooth shading (type 2 patterns and the sh operator) and thus indirectly controls the rendering performance.
  ///  Smoothness is the allowable color error between a shading approximated by piecewise linear interpolation and the true value of a (possibly nonlinear) shading function. The error is measured for each color component, and
  ///  the maximum error is used.The allowable error(or tolerance) is expressed as a
  ///  fraction of the range of the color component, from 0.0 to 1.0. Thus, a smoothness
  ///  tolerance of 0.1 represents a tolerance of 10 percent in each color component.
  ///  </para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetSmoothness(IntPtr page_obj, float smoothness)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetSmoothness_native(page_obj, smoothness);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetBlendMode", SetLastError = true)]
  private static extern bool FPDFPageObj_GetBlendMode_native(IntPtr page_obj, out int blendMode);

  /// <summary>
  /// Get the blend mode to be used in the transparent imaging model.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>One of the values of the <see cref="T:Patagames.Pdf.Enums.BlendTypes" /> enumeration.</returns>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.BlendTypes" /> enumeration for details. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static BlendTypes FPDFPageObj_GetBlendMode(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int blendMode;
        Pdfium.FPDFPageObj_GetBlendMode_native(page_obj, out blendMode);
        return (BlendTypes) blendMode;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetBlendMode", SetLastError = true)]
  private static extern bool FPDFPageObj_SetBlendMode_native(IntPtr page_obj, int blendMode);

  /// <summary>
  /// Set the blend mode to be used in the transparent imaging model.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="blendMode">The blend mode to be set.</param>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.BlendTypes" /> enumeration for details. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetBlendMode(IntPtr page_obj, BlendTypes blendMode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetBlendMode_native(page_obj, (int) blendMode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetRenderIntent", SetLastError = true)]
  private static extern bool FPDFPageObj_GetRenderIntent_native(
    IntPtr page_obj,
    out int renderIntent);

  /// <summary>
  /// Get the rendering intent to be used when converting CIE-based colors to device colors.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>One of the values of the <see cref="T:Patagames.Pdf.Enums.RenderIntent" /> enumeration.</returns>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.RenderIntent" /> enumeration for details. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static RenderIntent FPDFPageObj_GetRenderIntent(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int renderIntent;
        Pdfium.FPDFPageObj_GetRenderIntent_native(page_obj, out renderIntent);
        return (RenderIntent) renderIntent;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetRenderIntent", SetLastError = true)]
  private static extern bool FPDFPageObj_SetRenderIntent_native(IntPtr page_obj, int renderIntent);

  /// <summary>
  /// Set the rendering intent to be used when converting CIE-based colors to device colors.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="renderIntent">The rendering intent to be set.</param>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.RenderIntent" /> enumeration for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetRenderIntent(IntPtr page_obj, RenderIntent renderIntent)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetRenderIntent_native(page_obj, (int) renderIntent);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetOverprintMode", SetLastError = true)]
  private static extern bool FPDFPageObj_GetOverprintMode_native(
    IntPtr page_obj,
    out OverprintModes mode);

  /// <summary>Get an overprint mode.</summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>A code specifying whether a color component value of 0 in a DeviceCMYK color space should erase that component(<see cref="F:Patagames.Pdf.Enums.OverprintModes.Zero" />) or leave it unchanged(<see cref="F:Patagames.Pdf.Enums.OverprintModes.NonZero" />) when overprinting.</returns>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.OverprintModes" /> enumeration for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static OverprintModes FPDFPageObj_GetOverprintMode(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        OverprintModes mode;
        Pdfium.FPDFPageObj_GetOverprintMode_native(page_obj, out mode);
        return mode;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetOverprintMode", SetLastError = true)]
  private static extern bool FPDFPageObj_SetOverprintMode_native(
    IntPtr page_obj,
    OverprintModes mode);

  /// <summary>
  /// Set a code specifying whether a color component value of 0 in a DeviceCMYK color space should erase that component(<see cref="F:Patagames.Pdf.Enums.OverprintModes.Zero" />) or leave it unchanged(<see cref="F:Patagames.Pdf.Enums.OverprintModes.NonZero" />) when overprinting
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="mode">The overprint mode to be set.</param>
  /// <remarks>See <see cref="T:Patagames.Pdf.Enums.OverprintModes" /> enumeration for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetOverprintMode(IntPtr page_obj, OverprintModes mode)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetOverprintMode_native(page_obj, mode);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetAlphaIsShapeFlag", SetLastError = true)]
  private static extern bool FPDFPageObj_GetAlphaIsShapeFlag_native(IntPtr page_obj, out bool flag);

  /// <summary>
  /// Get a flag specifying whether the current soft mask and alpha constant parameters are to be interpreted as shape values (true) or opacity values(false).
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>true for shape values, false for opacity values.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPageObj_GetAlphaIsShapeFlag(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        bool flag;
        Pdfium.FPDFPageObj_GetAlphaIsShapeFlag_native(page_obj, out flag);
        return flag;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetAlphaIsShapeFlag", SetLastError = true)]
  private static extern bool FPDFPageObj_SetAlphaIsShapeFlag_native(IntPtr page_obj, bool flag);

  /// <summary>
  /// Set a flag specifying whether the current soft mask and alpha constant parameters are to be interpreted as shape values (true) or opacity values(false).
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="flag">The alpha source flag to be set. Set true for shape values, false - opacity values.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetAlphaIsShapeFlag(IntPtr page_obj, bool flag)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetAlphaIsShapeFlag_native(page_obj, flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetTextKnockoutFlag", SetLastError = true)]
  private static extern bool FPDFPageObj_GetTextKnockoutFlag_native(IntPtr page_obj, out bool flag);

  /// <summary>
  /// Get the text knockout flag, which determines the behavior of overlapping glyphs within a text object in the transparent imaging model.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>The current text knockout flag.</returns>
  /// <remarks>See remarks section of <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_SetTextKnockoutFlag(System.IntPtr,System.Boolean)" /> for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPageObj_GetTextKnockoutFlag(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        bool flag;
        Pdfium.FPDFPageObj_GetTextKnockoutFlag_native(page_obj, out flag);
        return flag;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetTextKnockoutFlag", SetLastError = true)]
  private static extern bool FPDFPageObj_SetTextKnockoutFlag_native(IntPtr page_obj, bool flag);

  /// <summary>
  /// Set the text knockout flag, which determines the behavior of overlapping glyphs within a text object in the transparent imaging model.
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="flag">The text knockout flag to be set.</param>
  /// <remarks>
  /// If its value is false, each glyph in a text object is treated as a separate elementary object; when glyphs overlap, they composite with one another.
  /// If the parameter is true, all glyphs in the text object are treated together as a single elementary object; when glyphs overlap, later glyphs overwrite(“knock out”) earlier ones in the area of overlap.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetTextKnockoutFlag(IntPtr page_obj, bool flag)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetTextKnockoutFlag_native(page_obj, flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetStrokeOverprintFlag", SetLastError = true)]
  private static extern bool FPDFPageObj_GetStrokeOverprintFlag_native(
    IntPtr page_obj,
    out bool flag);

  /// <summary>Get an overprint flag for stroking operations.</summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>A flag for stroking operations, specifying whether painting in one set of colorants should cause the corresponding areas of other colorants to be erased(false) or left unchanged(true). Please see remarks section for details.</returns>
  /// <remarks>
  /// <para>
  /// If the overprint mode is set to<see cref="F:Patagames.Pdf.Enums.OverprintModes.Zero" /> (the default value; see <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_SetOverprintMode(System.IntPtr,Patagames.Pdf.Enums.OverprintModes)" />), painting a color in any color space causes the corresponding areas of unspecified colorants to be erased(painted with a tint value of 0.0). The effect is that the color at any position on the page is whatever was painted there last, which is consistent with the normal painting behavior of the opaque imaging model.
  /// </para>
  /// <para>
  /// If the overprint is set to<see cref="F:Patagames.Pdf.Enums.OverprintModes.NonZero" /> and the output device supports overprinting, no such erasing actions are performed; anything previously painted in other colorants is left undisturbed. Consequently, the color at a given position on the page may be a combined result of several painting operations in different colorants. The effect produced by such overprinting is device-dependent and is not defined by the PDF language.
  /// </para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPageObj_GetStrokeOverprintFlag(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        bool flag;
        Pdfium.FPDFPageObj_GetStrokeOverprintFlag_native(page_obj, out flag);
        return flag;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetStrokeOverprintFlag", SetLastError = true)]
  private static extern bool FPDFPageObj_SetStrokeOverprintFlag_native(IntPtr page_obj, bool flag);

  /// <summary>
  /// Set a flag for stroking operations, specifying whether painting in one set of colorants should cause the corresponding areas of other colorants to be erased(false) or left unchanged(true).
  /// </summary>
  /// <param name="page_obj">A handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="flag">The overprint flag to be set.</param>
  /// <remarks>See remarks section of the <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetStrokeOverprintFlag(System.IntPtr)" /> for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetStrokeOverprintFlag(IntPtr page_obj, bool flag)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetStrokeOverprintFlag_native(page_obj, flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetFillOverprintFlag", SetLastError = true)]
  private static extern bool FPDFPageObj_GetFillOverprintFlag_native(IntPtr page_obj, out bool flag);

  /// <summary>Get an overprint flag for non-stroking operations.</summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>A flag for non-stroking operations, specifying whether painting in one set of colorants should cause the corresponding areas of other colorants to be erased(false) or left unchanged(true). Please see remarks section for details.</returns>
  /// <remarks>See remarks section of the <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetStrokeOverprintFlag(System.IntPtr)" /> for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFPageObj_GetFillOverprintFlag(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        bool flag;
        Pdfium.FPDFPageObj_GetFillOverprintFlag_native(page_obj, out flag);
        return flag;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetFillOverprintFlag", SetLastError = true)]
  private static extern bool FPDFPageObj_SetFillOverprintFlag_native(IntPtr page_obj, bool flag);

  /// <summary>
  /// Set a flag for non-stroking operations, specifying whether painting in one set of colorants should cause the corresponding areas of other colorants to be erased(false) or left unchanged(true).
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="flag">The overprint flag to be set.</param>
  /// <remarks>See remarks section of the <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_GetStrokeOverprintFlag(System.IntPtr)" /> for details.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetFillOverprintFlag(IntPtr page_obj, bool flag)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetFillOverprintFlag_native(page_obj, flag);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_GetSoftMask", SetLastError = true)]
  private static extern IntPtr FPDFPageObj_GetSoftMask_native(IntPtr page_obj);

  /// <summary>
  /// Get the current soft mask, specifying the mask shape or mask opacity values to be used in the transparent imaging model.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <returns>
  /// A soft-mask dictionary specifying the mask shape or mask opacity values to be used in the transparent imaging model, or the name None if no such mask is specified.
  /// </returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPageObj_GetSoftMask(IntPtr page_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPageObj_GetSoftMask_native(page_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPageObj_SetSoftMask", SetLastError = true)]
  private static extern void FPDFPageObj_SetSoftMask_native(IntPtr page_obj, IntPtr softMask);

  /// <summary>
  /// Set soft mask, specifying the mask shape or mask opacity values to be used in the transparent imaging model.
  /// </summary>
  /// <param name="page_obj">Handle to a page object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFPageObj_Create(Patagames.Pdf.Enums.PageObjectTypes)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GetObject(System.IntPtr,System.Int32)" /></param>
  /// <param name="softMask">A soft-mask dictionary specifying the mask shape or mask opacity values to be used in the transparent imaging model, or the name None if no such mask is specified.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPageObj_SetSoftMask(IntPtr page_obj, IntPtr softMask)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPageObj_SetSoftMask_native(page_obj, softMask);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPattern_SetForceClear", SetLastError = true)]
  private static extern void FPDFPattern_SetForceClear_native(IntPtr pattern, [MarshalAs(UnmanagedType.Bool)] bool bForceClear);

  /// <summary>Set ForceClear flag for the specified pattern.</summary>
  /// <param name="pattern">The handle to the pattern.</param>
  /// <param name="bForceClear">The Boolean value.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPattern_SetForceClear(IntPtr pattern, bool bForceClear)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPattern_SetForceClear_native(pattern, bForceClear);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPattern_GetPatternType", SetLastError = true)]
  private static extern PatternTypes FPDFPattern_GetPatternType_native(IntPtr pattern);

  /// <summary>Get the type of the specified pattern.</summary>
  /// <param name="pattern">The handle to the pattern.</param>
  /// <returns>An enumerated constant that indicates the type of pattern.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static PatternTypes FPDFPattern_GetPatternType(IntPtr pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPattern_GetPatternType_native(pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPattern_GetPatternObj", SetLastError = true)]
  private static extern IntPtr FPDFPattern_GetPatternObj_native(IntPtr pattern);

  /// <summary>Get Dictionary or Stream that describes the pattern.</summary>
  /// <param name="pattern">The handle to the pattern.</param>
  /// <returns>The handle to the Dictionary or Stream object that describes the pattern.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPattern_GetPatternObj(IntPtr pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPattern_GetPatternObj_native(pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPattern_GetDocument", SetLastError = true)]
  private static extern IntPtr FPDFPattern_GetDocument_native(IntPtr pattern);

  /// <summary>Get PDF Document assigned with the pattern.</summary>
  /// <param name="pattern">The handle to the pattern.</param>
  /// <returns>The handle to the PDF document.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFPattern_GetDocument(IntPtr pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFPattern_GetDocument_native(pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPattern_GetParentMatrix", SetLastError = true)]
  private static extern void FPDFPattern_GetParentMatrix_native(
    IntPtr pattern,
    [MarshalAs(UnmanagedType.R4)] out float a,
    [MarshalAs(UnmanagedType.R4)] out float b,
    [MarshalAs(UnmanagedType.R4)] out float c,
    [MarshalAs(UnmanagedType.R4)] out float d,
    [MarshalAs(UnmanagedType.R4)] out float e,
    [MarshalAs(UnmanagedType.R4)] out float f);

  /// <summary>Get a transformation matrix.</summary>
  /// <param name="pattern">The handle to the pattern.</param>
  /// <param name="a">The coefficient "a" of the matrix.</param>
  /// <param name="b">The coefficient "b" of the matrix.</param>
  /// <param name="c">The coefficient "c" of the matrix.</param>
  /// <param name="d">The coefficient "d" of the matrix.</param>
  /// <param name="e">The coefficient "e" of the matrix.</param>
  /// <param name="f">The coefficient "f" of the matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPattern_GetParentMatrix(
    IntPtr pattern,
    out float a,
    out float b,
    out float c,
    out float d,
    out float e,
    out float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPattern_GetParentMatrix_native(pattern, out a, out b, out c, out d, out e, out f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFPattern_GetPattern2FormMatrix", SetLastError = true)]
  private static extern void FPDFPattern_GetPattern2FormMatrix_native(
    IntPtr pattern,
    [MarshalAs(UnmanagedType.R4)] out float a,
    [MarshalAs(UnmanagedType.R4)] out float b,
    [MarshalAs(UnmanagedType.R4)] out float c,
    [MarshalAs(UnmanagedType.R4)] out float d,
    [MarshalAs(UnmanagedType.R4)] out float e,
    [MarshalAs(UnmanagedType.R4)] out float f);

  /// <summary>Get a transformation matrix.</summary>
  /// <param name="pattern">The handle to the pattern.</param>
  /// <param name="a">The coefficient "a" of the matrix.</param>
  /// <param name="b">The coefficient "b" of the matrix.</param>
  /// <param name="c">The coefficient "c" of the matrix.</param>
  /// <param name="d">The coefficient "d" of the matrix.</param>
  /// <param name="e">The coefficient "e" of the matrix.</param>
  /// <param name="f">The coefficient "f" of the matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFPattern_GetPattern2FormMatrix(
    IntPtr pattern,
    out float a,
    out float b,
    out float c,
    out float d,
    out float e,
    out float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFPattern_GetPattern2FormMatrix_native(pattern, out a, out b, out c, out d, out e, out f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingObj_CalcBoundingBox", SetLastError = true)]
  private static extern void FPDFShadingObj_CalcBoundingBox_native(IntPtr shadingObject);

  /// <summary>Calculate bounding box</summary>
  /// <param name="shadingObject">The handle to shading object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingObj_CalcBoundingBox(IntPtr shadingObject)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingObj_CalcBoundingBox_native(shadingObject);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingObj_GetMatrix", SetLastError = true)]
  private static extern void FPDFShadingObj_GetMatrix_native(
    IntPtr shading_obj,
    [MarshalAs(UnmanagedType.R4)] out float a,
    [MarshalAs(UnmanagedType.R4)] out float b,
    [MarshalAs(UnmanagedType.R4)] out float c,
    [MarshalAs(UnmanagedType.R4)] out float d,
    [MarshalAs(UnmanagedType.R4)] out float e,
    [MarshalAs(UnmanagedType.R4)] out float f);

  /// <summary>Get the transformation matrix of the shading object.</summary>
  /// <param name="shading_obj">The handle to shading object.</param>
  /// <param name="a">Pointer to a float value receiving the coefficient "a" of the matrix.</param>
  /// <param name="b">Pointer to a float value receiving the coefficient "b" of the matrix.</param>
  /// <param name="c">Pointer to a float value receiving the coefficient "c" of the matrix.</param>
  /// <param name="d">Pointer to a float value receiving the coefficient "d" of the matrix.</param>
  /// <param name="e">Pointer to a float value receiving the coefficient "e" of the matrix.</param>
  /// <param name="f">Pointer to a float value receiving the coefficient "f" of the matrix.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingObj_GetMatrix(
    IntPtr shading_obj,
    out float a,
    out float b,
    out float c,
    out float d,
    out float e,
    out float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingObj_GetMatrix_native(shading_obj, out a, out b, out c, out d, out e, out f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Get the transformation matrix of the shading object.</summary>
  /// <param name="shading_obj">The handle to the shading object.</param>
  /// <returns>An instance of <see cref="T:Patagames.Pdf.FS_MATRIX" />. Never returns NULL.</returns>
  public static FS_MATRIX FPDFShadingObj_GetMatrix(IntPtr shading_obj)
  {
    float a;
    float b;
    float c;
    float d;
    float e;
    float f;
    Pdfium.FPDFShadingObj_GetMatrix(shading_obj, out a, out b, out c, out d, out e, out f);
    return new FS_MATRIX()
    {
      a = a,
      b = b,
      c = c,
      d = d,
      e = e,
      f = f
    };
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingObj_SetMatrix", SetLastError = true)]
  private static extern void FPDFShadingObj_SetMatrix_native(
    IntPtr shading_obj,
    [MarshalAs(UnmanagedType.R4)] float a,
    [MarshalAs(UnmanagedType.R4)] float b,
    [MarshalAs(UnmanagedType.R4)] float c,
    [MarshalAs(UnmanagedType.R4)] float d,
    [MarshalAs(UnmanagedType.R4)] float e,
    [MarshalAs(UnmanagedType.R4)] float f);

  /// <summary>Set the transformation matrix into shading object</summary>
  /// <param name="shading_obj">The handle to shading object.</param>
  /// <param name="a">The coefficient "a" of the matrix</param>
  /// <param name="b">The coefficient "b" of the matrix</param>
  /// <param name="c">The coefficient "c" of the matrix</param>
  /// <param name="d">The coefficient "d" of the matrix</param>
  /// <param name="e">The coefficient "e" of the matrix</param>
  /// <param name="f">The coefficient "f" of the matrix</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingObj_SetMatrix(
    IntPtr shading_obj,
    float a,
    float b,
    float c,
    float d,
    float e,
    float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingObj_SetMatrix_native(shading_obj, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>Set the transformation matrix into shading object</summary>
  /// <param name="path_obj">The handle to the shading object.</param>
  /// <param name="matrix">The matrix of path object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingObj_SetMatrix(IntPtr path_obj, FS_MATRIX matrix)
  {
    if (matrix == null)
      throw new ArgumentNullException(nameof (matrix));
    Pdfium.FPDFShadingObj_SetMatrix(path_obj, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingObj_GetShaddingPattern", SetLastError = true)]
  private static extern IntPtr FPDFShadingObj_GetShaddingPattern_native(IntPtr shading_obj);

  /// <summary>Get shading pattern.</summary>
  /// <param name="shading_obj">The handle to shading object.</param>
  /// <returns>A handle to shading pattern; IntPtr.Zero if any error has occurred.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFShadingObj_GetShaddingPattern(IntPtr shading_obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingObj_GetShaddingPattern_native(shading_obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingObj_SetShaddingPattern", SetLastError = true)]
  private static extern void FPDFShadingObj_SetShaddingPattern_native(
    IntPtr shading_obj,
    IntPtr shading_pattern);

  /// <summary>
  /// Set shading pattern into the specified shading object.
  /// </summary>
  /// <param name="shading_obj">The handle to shading object.</param>
  /// <param name="shading_pattern">The handle to shading pattern.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingObj_SetShaddingPattern(IntPtr shading_obj, IntPtr shading_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingObj_SetShaddingPattern_native(shading_obj, shading_pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_Create", SetLastError = true)]
  private static extern IntPtr FPDFShadingPattern_Create_native(
    IntPtr document,
    ShadingTypes shadingType,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX pMatrix);

  /// <summary>Create a shading pattern.</summary>
  /// <param name="document">The handle to the PDF document.</param>
  /// <param name="shadingType">The type of shading pattern.</param>
  /// <param name="pMatrix">The transformation matrix.</param>
  /// <returns>Handle to the created shading pattern; IntPtr.Zero if any error has occurred.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFShadingPattern_Create(
    IntPtr document,
    ShadingTypes shadingType,
    FS_MATRIX pMatrix = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFShadingPattern_Create_native(document, shadingType, pMatrix));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_Delete", SetLastError = true)]
  private static extern void FPDFShadingPattern_Delete_native(IntPtr shadding_pattern);

  /// <summary>Delete shading pattern.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingPattern_Delete(IntPtr shadding_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingPattern_Delete_native(shadding_pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetShadingType", SetLastError = true)]
  private static extern ShadingTypes FPDFShadingPattern_GetShadingType_native(
    IntPtr shadding_pattern);

  /// <summary>Get type of shading</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <returns>Type of shadding; <see cref="F:Patagames.Pdf.Enums.ShadingTypes.Invalid" /> if any error has occured</returns>
  [HandleProcessCorruptedStateExceptions]
  public static ShadingTypes FPDFShadingPattern_GetShadingType(IntPtr shadding_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_GetShadingType_native(shadding_pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetShadingObj", SetLastError = true)]
  private static extern IntPtr FPDFShadingPattern_GetShadingObj_native(IntPtr function);

  /// <summary>Get shading.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <returns>The handle to the Dictionary or Stream object that describes the shading.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFShadingPattern_GetShadingObj(IntPtr shadding_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_GetShadingObj_native(shadding_pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetColorSpace", SetLastError = true)]
  private static extern ColorTypes FPDFShadingPattern_GetColorSpace_native(IntPtr shadding_pattern);

  /// <summary>
  /// Get the color space in which color values are expressed.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <returns>An enumerated constant that indicates the color space.</returns>
  /// <exception cref="T:Patagames.Pdf.Net.Exceptions.PdfiumException">code= ERROR_INVALID_PARAMETER(87);</exception>
  /// <remarks>
  /// This may be any device, CIE-based, or special color space except a <see cref="F:Patagames.Pdf.Enums.ColorTypes.Pattern" /> space.
  /// The <see cref="F:Patagames.Pdf.Enums.ColorTypes.Unsupported" /> does mean that this method can not be used to retrieve color space. In this case use shading's dictionary to get information about color space.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static ColorTypes FPDFShadingPattern_GetColorSpace(IntPtr shadding_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int colorSpaceNative = (int) Pdfium.FPDFShadingPattern_GetColorSpace_native(shadding_pattern);
        return colorSpaceNative >= 0 ? (ColorTypes) colorSpaceNative : throw Pdfium.ProcessLastError();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetColorSpace", SetLastError = true)]
  private static extern int FPDFShadingPattern_SetColorSpace_native(
    IntPtr shadding_pattern,
    ColorTypes colorSpace);

  /// <summary>
  /// Set the color space in which color values are expressed.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="colorSpace">An enumerated constant that indicates the color space.</param>
  /// <returns>
  /// <list type="table">
  /// <item><term>&lt;0</term><description>An error has been occurred.</description></item>
  /// <item><term>0</term><description>An unsupported color space was specified.</description></item>
  /// <item><term>&gt;0</term><description>If the function succeeds.</description></item>
  /// </list>
  /// </returns>
  /// <remarks>
  /// The following color spaces may be specified only: <see cref="F:Patagames.Pdf.Enums.ColorTypes.DeviceGray" />, <see cref="F:Patagames.Pdf.Enums.ColorTypes.DeviceGray" /> and <see cref="F:Patagames.Pdf.Enums.ColorTypes.DeviceRGB" />
  /// If you try to set other type of color space except listed above, the function fails  with 0. In this case use shading's dictionary to set such color space.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFShadingPattern_SetColorSpace(IntPtr shadding_pattern, ColorTypes colorSpace)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetColorSpace_native(shadding_pattern, colorSpace);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetBackground", SetLastError = true)]
  private static extern int FPDFShadingPattern_GetBackground_native(IntPtr shadding_pattern);

  /// <summary>Get the background color of a shading.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <returns>Background color of a shading in argb format (0xffrrggbb)</returns>
  /// <remarks>Alpha channel is ignored.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFShadingPattern_GetBackground(IntPtr shadding_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_GetBackground_native(shadding_pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetBackground", SetLastError = true)]
  private static extern void FPDFShadingPattern_SetBackground_native(
    IntPtr shadding_pattern,
    int argb);

  /// <summary>Set the fill color of a page object.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="argb">Background color of a shading in argb format (0xffrrggbb)</param>
  /// <remarks>Alpha channel is ignored.
  /// <note type="note">This function set background color in <see cref="F:Patagames.Pdf.Enums.ColorTypes.DeviceRGB" /> format only.</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingPattern_SetBackground(IntPtr shadding_pattern, int argb)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingPattern_SetBackground_native(shadding_pattern, argb);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetBoundingBox", SetLastError = true)]
  private static extern void FPDFShadingPattern_GetBoundingBox_native(
    IntPtr shadding_pattern,
    out float left,
    out float top,
    out float right,
    out float bottom);

  /// <summary>Get bounding box of the shading.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="left">X coordinate of the shading's left edge.</param>
  /// <param name="top">Y coordinate of the shading's top edge.</param>
  /// <param name="right">X coordinate of the shading's right edge.</param>
  /// <param name="bottom">Y coordinate of the shading's bottom edge.</param>
  /// <remarks>
  /// The coordinates are interpreted in the shading’s target coordinate space.
  /// If present, this bounding box is applied as a temporary clipping boundary when the shading is painted,
  /// in addition to the current clipping path and any other clipping boundaries in effect at that time.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingPattern_GetBoundingBox(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.R4)] out float left,
    [MarshalAs(UnmanagedType.R4)] out float top,
    [MarshalAs(UnmanagedType.R4)] out float right,
    [MarshalAs(UnmanagedType.R4)] out float bottom)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingPattern_GetBoundingBox_native(shadding_pattern, out left, out top, out right, out bottom);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetBoundingBox", SetLastError = true)]
  private static extern bool FPDFShadingPattern_SetBoundingBox_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.R4)] float left,
    [MarshalAs(UnmanagedType.R4)] float top,
    [MarshalAs(UnmanagedType.R4)] float right,
    [MarshalAs(UnmanagedType.R4)] float bottom);

  /// <summary>Set bounding box of the shading.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="left">X coordinate of the shading's left edge.</param>
  /// <param name="top">Y coordinate of the shading's top edge.</param>
  /// <param name="right">X coordinate of the shading's right edge.</param>
  /// <param name="bottom">Y coordinate of the shading's bottom edge.</param>
  /// <returns>True for successfull; false if any error has occurred.</returns>
  /// <remarks>
  /// The coordinates are interpreted in the shading’s target coordinate space.
  /// If present, this bounding box is applied as a temporary clipping boundary when the shading is painted,
  /// in addition to the current clipping path and any other clipping boundaries in effect at that time.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingPattern_SetBoundingBox(
    IntPtr shadding_pattern,
    float left,
    float top,
    float right,
    float bottom)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetBoundingBox_native(shadding_pattern, left, top, right, bottom);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetAntiAlias", SetLastError = true)]
  private static extern bool FPDFShadingPattern_GetAntiAlias_native(IntPtr shadding_pattern);

  /// <summary>
  /// Get a flag indicating whether to filter the shading function to prevent aliasing artifacts.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <returns>true if antialiasing is applied.</returns>
  /// <remarks>
  /// The shading operators sample shading functions at a rate determined by the resolution of the output device.
  /// Aliasing can occur if the function is not smooth—that is, if it has a high spatial frequency relative to
  /// the sampling rate.Anti-aliasing can be computationally expensive and is usually unnecessary, since most shading functions are smooth enough or are
  /// sampled at a high enough frequency to avoid aliasing effects. Anti-aliasing may not be implemented on some output devices, in which case this flag is ignored.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingPattern_GetAntiAlias(IntPtr shadding_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_GetAntiAlias_native(shadding_pattern);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetAntiAlias", SetLastError = true)]
  private static extern bool FPDFShadingPattern_SetAntiAlias_native(
    IntPtr shadding_pattern,
    bool flag);

  /// <summary>
  /// Set a flag indicating whether to filter the shading function to prevent aliasing artifacts.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="bAntiAlias">A flag</param>
  /// <returns>true if antialiasing is applied.</returns>
  /// <remarks>
  /// The shading operators sample shading functions at a rate determined by the resolution of the output device.
  /// Aliasing can occur if the function is not smooth—that is, if it has a high spatial frequency relative to
  /// the sampling rate.Anti-aliasing can be computationally expensive and is usually unnecessary, since most shading functions are smooth enough or are
  /// sampled at a high enough frequency to avoid aliasing effects. Anti-aliasing may not be implemented on some output devices, in which case this flag is ignored.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingPattern_SetAntiAlias(IntPtr shadding_pattern, bool bAntiAlias)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetAntiAlias_native(shadding_pattern, bAntiAlias);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetDomain", SetLastError = true)]
  private static extern int FPDFShadingPattern_GetDomain_native(
    IntPtr shadding_pattern,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), Out] float[] domain);

  /// <summary>Get the shading's domain.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <returns>An array of numbers depending on the specific type of shading; null if any error has occurred.</returns>
  /// <remarks>
  /// <list type="table">
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.FunctionBasedShading" /></term><description>An array of four numbers [Xmin Xmax Ymin Ymax] specifying the rectangular domain of coordinates over which the color function(s) are defined; null if any error has occurred. Default value: [0.0 1.0 0.0 1.0].</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" /></term><description>An array of two numbers [t0 t1] specifying the limiting values of a parametric variable t. The variable is considered to vary linearly between these two values as the color gradient varies between the starting and ending points of the axis. The variable t becomes the input argument to the color function(s). Default value: [0.0 1.0].</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" /></term><description>An array of two numbers [t0 t1] specifying the limiting values of a parametric variable t. The variable is considered to vary linearly between these two values as the color gradient varies between the starting and ending circles. The variable t becomes the input argument to the color function(s). Default value: [0.0 1.0]</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.FreeFormGouraudTriangleMeshShading" /></term><description>Unsupported.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.LatticeFormGouraudTriangleMeshShading" /></term><description>Unsupported.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.CoonsPatchMeshShading" /></term><description>Unsupported.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.TensorProductPatchMeshShading" /></term><description>Unsupported.</description></item>
  /// </list>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFShadingPattern_GetDomain(IntPtr shadding_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int domainNative = Pdfium.FPDFShadingPattern_GetDomain_native(shadding_pattern, 0, (float[]) null);
        if (domainNative <= 0)
          return (float[]) null;
        float[] domain = new float[domainNative];
        return Pdfium.FPDFShadingPattern_GetDomain_native(shadding_pattern, domainNative, domain) <= 0 ? (float[]) null : domain;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Get the rectangular domain of coordinates over which the color function(s) are defined.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="xMin">The minimum value of the rectangular domain of coordinates in horizontal dimension.</param>
  /// <param name="yMin">The minimum value of the rectangular domain of coordinates in vertical dimension.</param>
  /// <param name="xMax">The maximum value of the rectangular domain of coordinates in horizontal dimension.</param>
  /// <param name="yMax">The maximum value of the rectangular domain of coordinates in vertical dimension.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// The domain rectangle establishes an internal coordinate space for the shading that is independent of the target coordinate space in which it is to be painted.
  /// <note type="note">Only applicable to Type 1 (Function-Based) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.FunctionBasedShading" />).</note>
  /// </remarks>
  public static bool FPDFShadingType1_GetDomain(
    IntPtr shadding_pattern,
    out float xMin,
    out float yMin,
    out float xMax,
    out float yMax)
  {
    xMin = yMin = xMax = yMax = 0.0f;
    float[] domain = Pdfium.FPDFShadingPattern_GetDomain(shadding_pattern);
    if (domain == null || domain.Length != 4)
      return false;
    xMin = domain[0];
    xMax = domain[1];
    yMin = domain[2];
    yMax = domain[3];
    return true;
  }

  /// <summary>Get the limiting values of a parametric variable t.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="t0">The minimum value of a parametric variable t.</param>
  /// <param name="t1">The minimum value of a parametric variable t.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// The variable is considered to vary linearly between these two values as the color gradient varies between the starting and ending points of the axis.
  /// The variable t becomes the input argument to the color function(s).
  /// <note type="note">Only applicable to Type 2 (Axial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" />).</note>
  /// </remarks>
  public static bool FPDFShadingType2_GetDomain(
    IntPtr shadding_pattern,
    out float t0,
    out float t1)
  {
    t0 = t1 = 0.0f;
    float[] domain = Pdfium.FPDFShadingPattern_GetDomain(shadding_pattern);
    if (domain == null || domain.Length != 2)
      return false;
    t0 = domain[0];
    t1 = domain[1];
    return true;
  }

  /// <summary>Get the limiting values of a parametric variable t.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="t0">The minimum value of a parametric variable t.</param>
  /// <param name="t1">The minimum value of a parametric variable t.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// The variable is considered to vary linearly between these two values as the color gradient varies between the starting and ending circles.
  /// The variable t becomes the input argument to the color function(s).
  /// <note type="note">Only applicable to Type 3 (Radial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" />).</note>
  /// </remarks>
  public static bool FPDFShadingType3_GetDomain(
    IntPtr shadding_pattern,
    out float t0,
    out float t1)
  {
    t0 = t1 = 0.0f;
    float[] domain = Pdfium.FPDFShadingPattern_GetDomain(shadding_pattern);
    if (domain == null || domain.Length != 2)
      return false;
    t0 = domain[0];
    t1 = domain[1];
    return true;
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetDomain", SetLastError = true)]
  private static extern bool FPDFShadingPattern_SetDomain_native(
    IntPtr shadding_pattern,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.R4), In] float[] domain);

  /// <summary>Set the shading's domain.</summary>
  /// <param name="shadding_pattern">The handle to the shading.</param>
  /// <param name="domain">An array of numbers depending on the specific type of shading.</param>
  /// <returns>true for successful; false if any errors has occurred.</returns>
  /// <remarks>Please see remarks of <see cref="M:Patagames.Pdf.Pdfium.FPDFShadingPattern_GetDomain(System.IntPtr)" /></remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingPattern_SetDomain(IntPtr shadding_pattern, float[] domain)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetDomain_native(shadding_pattern, domain == null ? 0 : domain.Length, domain);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Set the rectangular domain of coordinates over which the color function(s) are defined.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="xMin">The minimum value of the rectangular domain of coordinates in horizontal dimension.</param>
  /// <param name="yMin">The minimum value of the rectangular domain of coordinates in vertical dimension.</param>
  /// <param name="xMax">The maximum value of the rectangular domain of coordinates in horizontal dimension.</param>
  /// <param name="yMax">The maximum value of the rectangular domain of coordinates in vertical dimension.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// The domain rectangle establishes an internal coordinate space for the shading that is independent of the target coordinate space in which it is to be painted.
  /// <note type="note">Only applicable to Type 1 (Function-Based) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.FunctionBasedShading" />).</note>
  /// </remarks>
  public static bool FPDFShadingType1_SetDomain(
    IntPtr shadding_pattern,
    float xMin,
    float yMin,
    float xMax,
    float yMax)
  {
    float[] domain = new float[4]{ xMin, xMax, yMin, yMax };
    return Pdfium.FPDFShadingPattern_SetDomain(shadding_pattern, domain);
  }

  /// <summary>Set the limiting values of a parametric variable t.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="t0">The minimum value of a parametric variable t.</param>
  /// <param name="t1">The minimum value of a parametric variable t.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// The variable is considered to vary linearly between these two values as the color gradient varies between the starting and ending points of the axis.
  /// The variable t becomes the input argument to the color function(s).
  /// <note type="note">Only applicable to Type 2 (Axial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" />).</note>
  /// </remarks>
  public static bool FPDFShadingType2_SetDomain(IntPtr shadding_pattern, float t0, float t1)
  {
    float[] domain = new float[2]{ t0, t1 };
    return Pdfium.FPDFShadingPattern_SetDomain(shadding_pattern, domain);
  }

  /// <summary>Set the limiting values of a parametric variable t.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="t0">The minimum value of a parametric variable t.</param>
  /// <param name="t1">The minimum value of a parametric variable t.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// The variable is considered to vary linearly between these two values as the color gradient varies between the starting and ending circles.
  /// The variable t becomes the input argument to the color function(s).
  /// <note type="note">Only applicable to Type 3 (Radial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" />).</note>
  /// </remarks>
  public static bool FPDFShadingType3_SetDomain(IntPtr shadding_pattern, float t0, float t1)
  {
    float[] domain = new float[2]{ t0, t1 };
    return Pdfium.FPDFShadingPattern_SetDomain(shadding_pattern, domain);
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetMatrix", SetLastError = true)]
  private static extern void FPDFShadingPattern_GetMatrix_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.R4)] out float a,
    [MarshalAs(UnmanagedType.R4)] out float b,
    [MarshalAs(UnmanagedType.R4)] out float c,
    [MarshalAs(UnmanagedType.R4)] out float d,
    [MarshalAs(UnmanagedType.R4)] out float e,
    [MarshalAs(UnmanagedType.R4)] out float f);

  /// <summary>
  /// Get a transformation matrix mapping the coordinate space specified by the shading's domain into the shading’s target coordinate space.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="a">The coefficient "a" of the matrix.</param>
  /// <param name="b">The coefficient "b" of the matrix.</param>
  /// <param name="c">The coefficient "c" of the matrix.</param>
  /// <param name="d">The coefficient "d" of the matrix.</param>
  /// <param name="e">The coefficient "e" of the matrix.</param>
  /// <param name="f">The coefficient "f" of the matrix.</param>
  /// <remarks>
  /// <note type="note">Only applicable to Type 1 (Function-Based) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.FunctionBasedShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingType1_GetMatrix(
    IntPtr shadding_pattern,
    out float a,
    out float b,
    out float c,
    out float d,
    out float e,
    out float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingPattern_GetMatrix_native(shadding_pattern, out a, out b, out c, out d, out e, out f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetMatrix", SetLastError = true)]
  private static extern bool FPDFShadingPattern_SetMatrix_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.R4)] float a,
    [MarshalAs(UnmanagedType.R4)] float b,
    [MarshalAs(UnmanagedType.R4)] float c,
    [MarshalAs(UnmanagedType.R4)] float d,
    [MarshalAs(UnmanagedType.R4)] float e,
    [MarshalAs(UnmanagedType.R4)] float f);

  /// <summary>
  /// Set a transformation matrix mapping the coordinate space specified by the shading's domain into the shading’s target coordinate space.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="a">The coefficient "a" of the matrix.</param>
  /// <param name="b">The coefficient "b" of the matrix.</param>
  /// <param name="c">The coefficient "c" of the matrix.</param>
  /// <param name="d">The coefficient "d" of the matrix.</param>
  /// <param name="e">The coefficient "e" of the matrix.</param>
  /// <param name="f">The coefficient "f" of the matrix.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// <note type="note">Only applicable to Type 1 (Function-Based) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.FunctionBasedShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingType1_SetMatrix(
    IntPtr shadding_pattern,
    float a,
    float b,
    float c,
    float d,
    float e,
    float f)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetMatrix_native(shadding_pattern, a, b, c, d, e, f);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetAxisCoords", SetLastError = true)]
  private static extern bool FPDFShadingPattern_GetAxisCoords_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.R4)] out float x0,
    [MarshalAs(UnmanagedType.R4)] out float y0,
    [MarshalAs(UnmanagedType.R4)] out float x1,
    [MarshalAs(UnmanagedType.R4)] out float y1);

  /// <summary>Get the starting and ending coordinates of the axis.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="x0">The X coordinate of the starting point of the axis, expressed in the shading’s target coordinate space</param>
  /// <param name="y0">The Y coordinate of the starting point of the axis, expressed in the shading’s target coordinate space</param>
  /// <param name="x1">The X coordinate of the ending point of the axis, expressed in the shading’s target coordinate space</param>
  /// <param name="y1">The Y coordinate of the ending point of the axis, expressed in the shading’s target coordinate space</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// <note type="note">Only applicable to Type 2 (Axial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingType2_GetCoords(
    IntPtr shadding_pattern,
    out float x0,
    out float y0,
    out float x1,
    out float y1)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_GetAxisCoords_native(shadding_pattern, out x0, out y0, out x1, out y1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetAxisCoords", SetLastError = true)]
  private static extern bool FPDFShadingPattern_SetAxisCoords_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.R4)] float x0,
    [MarshalAs(UnmanagedType.R4)] float y0,
    [MarshalAs(UnmanagedType.R4)] float x1,
    [MarshalAs(UnmanagedType.R4)] float y1);

  /// <summary>Set the starting and ending coordinates of the axis.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="x0">The X coordinate of the starting point of the axis, expressed in the shading’s target coordinate space.</param>
  /// <param name="y0">The Y coordinate of the starting point of the axis, expressed in the shading’s target coordinate space.</param>
  /// <param name="x1">The X coordinate of the ending point of the axis, expressed in the shading’s target coordinate space.</param>
  /// <param name="y1">The Y coordinate of the ending point of the axis, expressed in the shading’s target coordinate space.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// <note type="note">Only applicable to Type 2 (Axial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingType2_SetCoords(
    IntPtr shadding_pattern,
    float x0,
    float y0,
    float x1,
    float y1)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetAxisCoords_native(shadding_pattern, x0, y0, x1, y1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetRadialCoords", SetLastError = true)]
  private static extern bool FPDFShadingPattern_GetRadialCoords_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.R4)] out float x0,
    [MarshalAs(UnmanagedType.R4)] out float y0,
    [MarshalAs(UnmanagedType.R4)] out float r0,
    [MarshalAs(UnmanagedType.R4)] out float x1,
    [MarshalAs(UnmanagedType.R4)] out float y1,
    [MarshalAs(UnmanagedType.R4)] out float r1);

  /// <summary>
  /// Get the centers and radii of the starting and ending circles
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="x0">The X coordinate of the center of starting circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="y0">The Y coordinate of the center of starting circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="r0">The radius of starting circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="x1">The X coordinate of the center of ending circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="y1">The Y coordinate of the center of ending circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="r1">The radius of starting circle, expressed in the shading’s target coordinate space.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// <note type="note">Only applicable to Type 3 (Radial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingType3_GetCoords(
    IntPtr shadding_pattern,
    out float x0,
    out float y0,
    out float r0,
    out float x1,
    out float y1,
    out float r1)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_GetRadialCoords_native(shadding_pattern, out x0, out y0, out r0, out x1, out y1, out r1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetRadialCoords", SetLastError = true)]
  private static extern bool FPDFShadingPattern_SetRadialCoords_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.R4)] float x0,
    [MarshalAs(UnmanagedType.R4)] float y0,
    [MarshalAs(UnmanagedType.R4)] float r0,
    [MarshalAs(UnmanagedType.R4)] float x1,
    [MarshalAs(UnmanagedType.R4)] float y1,
    [MarshalAs(UnmanagedType.R4)] float r1);

  /// <summary>
  /// Set the centers and radii of the starting and ending circles
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="x0">The X coordinate of the center of starting circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="y0">The Y coordinate of the center of starting circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="r0">The radius of starting circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="x1">The X coordinate of the center of ending circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="y1">The Y coordinate of the center of ending circle, expressed in the shading’s target coordinate space.</param>
  /// <param name="r1">The radius of starting circle, expressed in the shading’s target coordinate space.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// The radii r0 and r1 must both be greater than or equal to 0. If one radius is 0, the corresponding circle is treated as a point; if both are 0, nothing is painted.
  /// <note type="note">Only applicable to Type 3 (Radial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingType3_SetCoords(
    IntPtr shadding_pattern,
    float x0,
    float y0,
    float r0,
    float x1,
    float y1,
    float r1)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetRadialCoords_native(shadding_pattern, x0, y0, r0, x1, y1, r1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetExtend", SetLastError = true)]
  private static extern void FPDFShadingPattern_GetExtend_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.Bool)] out bool extendStart,
    [MarshalAs(UnmanagedType.Bool)] out bool extendEnd);

  /// <summary>
  /// Get two boolean values specifying whether to extend the shading beyond the starting and ending points of the axis, respectively.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="isExtendAtStart">The Boolean value specifying whether to extend the shading beyond the starting point of the axis.</param>
  /// <param name="isExtendAtEnd">The Boolean value specifying whether to extend the shading beyond the ending point of the axis.</param>
  /// <remarks>
  /// <note type="note">Only applicable to Type 2 (Axial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFShadingType2_GetExtend(
    IntPtr shadding_pattern,
    out bool isExtendAtStart,
    out bool isExtendAtEnd)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFShadingPattern_GetExtend_native(shadding_pattern, out isExtendAtStart, out isExtendAtEnd);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetExtend", SetLastError = true)]
  private static extern bool FPDFShadingPattern_SetExtend_native(
    IntPtr shadding_pattern,
    [MarshalAs(UnmanagedType.Bool)] bool extendStart,
    [MarshalAs(UnmanagedType.Bool)] bool extendEnd);

  /// <summary>
  /// Set two boolean values specifying whether to extend the shading beyond the starting and ending points of the axis, respectively.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="isExtendAtStart">The Boolean value specifying whether to extend the shading beyond the starting point of the axis.</param>
  /// <param name="isExtendAtEnd">The Boolean value specifying whether to extend the shading beyond the ending point of the axis.</param>
  /// <returns>True on success; False otherwise.</returns>
  /// <remarks>
  /// <note type="note">Only applicable to Type 2 (Axial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingType2_SetExtend(
    IntPtr shadding_pattern,
    bool isExtendAtStart,
    bool isExtendAtEnd)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetExtend_native(shadding_pattern, isExtendAtStart, isExtendAtEnd);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Get two boolean values specifying whether to extend the shading beyond the starting and ending circles, respectively.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="isExtendAtStart">The Boolean value specifying whether to extend the shading beyond the starting circle.</param>
  /// <param name="isExtendAtEnd">The Boolean value specifying whether to extend the shading beyond the ending circle.</param>
  /// <remarks>
  /// <note type="note">Only applicable to Type 3 (Radial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" />).</note>
  /// </remarks>
  public static void FPDFShadingType3_GetExtend(
    IntPtr shadding_pattern,
    out bool isExtendAtStart,
    out bool isExtendAtEnd)
  {
    Pdfium.FPDFShadingType2_GetExtend(shadding_pattern, out isExtendAtStart, out isExtendAtEnd);
  }

  /// <summary>
  /// Set two boolean values specifying whether to extend the shading beyond the starting and ending points of the axis, respectively.
  /// </summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="isExtendAtStart">The Boolean value specifying whether to extend the shading beyond the starting point of the axis.</param>
  /// <param name="isExtendAtEnd">The Boolean value specifying whether to extend the shading beyond the ending point of the axis.</param>
  /// <returns>True on success; False otherwise.</returns>
  /// <remarks>
  /// <note type="note">Only applicable to Type 3 (Radial) shadings (<see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" />).</note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingType3_SetExtend(
    IntPtr shadding_pattern,
    bool isExtendAtStart,
    bool isExtendAtEnd)
  {
    return Pdfium.FPDFShadingType2_SetExtend(shadding_pattern, isExtendAtStart, isExtendAtEnd);
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_GetFunctions", SetLastError = true)]
  private static extern int FPDFShadingPattern_GetFunctions_native(
    IntPtr shadding_pattern,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.SysInt), Out] IntPtr[] functions);

  /// <summary>Get the shading's functions.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <returns>An array of functions depending on the specific type of shading; null if any error has occurred.</returns>
  /// <remarks>
  /// <note type="note">When an application is finished using the function handles, use the <see cref="M:Patagames.Pdf.Pdfium.FPDFFunction_CloseHandle(System.IntPtr)" /> function with each array item to close the handles.</note>
  /// <list type="table">
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.FunctionBasedShading" /></term><description>An array of n 2-in, 1-out functions, where n is the number of color components in the shading’s color space.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. The function(s) are called with values of the parametric variable t in the domain defined by the <see cref="M:Patagames.Pdf.Pdfium.FPDFShadingType2_SetDomain(System.IntPtr,System.Single,System.Single)" /> method.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. The function(s) are called with values of the parametric variable t in the domain defined by the <see cref="M:Patagames.Pdf.Pdfium.FPDFShadingType3_SetDomain(System.IntPtr,System.Single,System.Single)" /> method.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.FreeFormGouraudTriangleMeshShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. If this entry is present, the color data for each vertex must be specified by a single parametric variable rather than by n separate color components. The designated function(s) are called with each interpolated value of the parametric variable to determine the actual color at each point. Each input value is forced into the range interval specified for the corresponding color component in the shading dictionary’s Decode array. Each function’s domain must be a superset of that interval. If the value returned by the function for a given color component is out of range, it is adjusted to the nearest valid value.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.LatticeFormGouraudTriangleMeshShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. If this entry is present, the color data for each vertex must be specified by a single parametric variable rather than by n separate color components. The designated function(s) are called with each interpolated value of the parametric variable to determine the actual color at each point. Each input value is forced into the range interval specified for the corresponding color component in the shading dictionary’s Decode array. Each function’s domain must be a superset of that interval. If the value returned by the function for a given color component is out of range, it is adjusted to the nearest valid value.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.CoonsPatchMeshShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. If this entry is present, the color data for each vertex must be specified by a single parametric variable rather than by n separate color components. The designated function(s) are called with each interpolated value of the parametric variable to determine the actual color at each point. Each input value is forced into the range interval specified for the corresponding color component in the shading dictionary’s Decode array. Each function’s domain must be a superset of that interval. If the value returned by the function for a given color component is out of range, it is adjusted to the nearest valid value.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.TensorProductPatchMeshShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. If this entry is present, the color data for each vertex must be specified by a single parametric variable rather than by n separate color components. The designated function(s) are called with each interpolated value of the parametric variable to determine the actual color at each point. Each input value is forced into the range interval specified for the corresponding color component in the shading dictionary’s Decode array. Each function’s domain must be a superset of that interval. If the value returned by the function for a given color component is out of range, it is adjusted to the nearest valid value.</description></item>
  /// </list>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr[] FPDFShadingPattern_GetFunctions(IntPtr shadding_pattern)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int functionsNative = Pdfium.FPDFShadingPattern_GetFunctions_native(shadding_pattern, 0, (IntPtr[]) null);
        if (functionsNative <= 0)
          return (IntPtr[]) null;
        IntPtr[] functions = new IntPtr[functionsNative];
        return Pdfium.FPDFShadingPattern_GetFunctions_native(shadding_pattern, functionsNative, functions) <= 0 ? (IntPtr[]) null : functions;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFShadingPattern_SetFunctions", SetLastError = true)]
  private static extern bool FPDFShadingPattern_SetFunctions_native(
    IntPtr shadding_pattern,
    int arrSize,
    [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1, ArraySubType = UnmanagedType.SysInt), In] IntPtr[] functions);

  /// <summary>Set the shading's functions.</summary>
  /// <param name="shadding_pattern">The handle to the shading pattern.</param>
  /// <param name="functions">An array of functions depending on the specific type of shading.</param>
  /// <returns>True for successful; false if any error has occurred.</returns>
  /// <remarks>
  /// <list type="table">
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.FunctionBasedShading" /></term><description>An array of n 2-in, 1-out functions, where n is the number of color components in the shading’s color space.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.AxialShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. The function(s) are called with values of the parametric variable t in the domain defined by the <see cref="M:Patagames.Pdf.Pdfium.FPDFShadingType2_SetDomain(System.IntPtr,System.Single,System.Single)" /> method.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.RadialShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. The function(s) are called with values of the parametric variable t in the domain defined by the <see cref="M:Patagames.Pdf.Pdfium.FPDFShadingType3_SetDomain(System.IntPtr,System.Single,System.Single)" /> method.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.FreeFormGouraudTriangleMeshShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. If this entry is present, the color data for each vertex must be specified by a single parametric variable rather than by n separate color components. The designated function(s) are called with each interpolated value of the parametric variable to determine the actual color at each point. Each input value is forced into the range interval specified for the corresponding color component in the shading dictionary’s Decode array. Each function’s domain must be a superset of that interval. If the value returned by the function for a given color component is out of range, it is adjusted to the nearest valid value.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.LatticeFormGouraudTriangleMeshShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. If this entry is present, the color data for each vertex must be specified by a single parametric variable rather than by n separate color components. The designated function(s) are called with each interpolated value of the parametric variable to determine the actual color at each point. Each input value is forced into the range interval specified for the corresponding color component in the shading dictionary’s Decode array. Each function’s domain must be a superset of that interval. If the value returned by the function for a given color component is out of range, it is adjusted to the nearest valid value.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.CoonsPatchMeshShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. If this entry is present, the color data for each vertex must be specified by a single parametric variable rather than by n separate color components. The designated function(s) are called with each interpolated value of the parametric variable to determine the actual color at each point. Each input value is forced into the range interval specified for the corresponding color component in the shading dictionary’s Decode array. Each function’s domain must be a superset of that interval. If the value returned by the function for a given color component is out of range, it is adjusted to the nearest valid value.</description></item>
  /// <item><term><see cref="F:Patagames.Pdf.Enums.ShadingTypes.TensorProductPatchMeshShading" /></term><description>An array of n 1-in, 1-out functions, where n is the number of color components in the shading’s color space. If this entry is present, the color data for each vertex must be specified by a single parametric variable rather than by n separate color components. The designated function(s) are called with each interpolated value of the parametric variable to determine the actual color at each point. Each input value is forced into the range interval specified for the corresponding color component in the shading dictionary’s Decode array. Each function’s domain must be a superset of that interval. If the value returned by the function for a given color component is out of range, it is adjusted to the nearest valid value.</description></item>
  /// </list>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFShadingPattern_SetFunctions(IntPtr shadding_pattern, IntPtr[] functions)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFShadingPattern_SetFunctions_native(shadding_pattern, functions == null ? 0 : functions.Length, functions);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTOOLS_ParseDefaultAppearance", SetLastError = true)]
  private static extern bool FPDFTOOLS_ParseDefaultAppearance_native(
    [MarshalAs(UnmanagedType.LPStr)] string defaultAppearance,
    out bool hasStrokeColor,
    out int strokeColorType,
    IntPtr strokeColor,
    out bool hasFillColor,
    out int fillColorType,
    IntPtr fillColor,
    out bool hasFont,
    IntPtr buffer,
    ref int bufSize,
    out float fontSize,
    out bool hasMatrix,
    IntPtr matrix);

  /// <summary>Parse default appearance string</summary>
  /// <param name="defaultAppearance">Defautl appearance string.</param>
  /// <param name="strokeColor">Gets an array that contains color components or null if default appearance does not contain stroke color. The number of components (array length) depend on color type. (0 - transparent color, 1- gray color, 3 - RGB color, 4 - CMYK color).</param>
  /// <param name="fillColor">Gets an array that contains color components or null if default appearance does not contain fill color. The number of components (array length) depend on color type. (0 - transparent color, 1- gray color, 3 - RGB color, 4 - CMYK color).</param>
  /// <param name="fontName">Gets font name or null if default appearance does not contain font.</param>
  /// <param name="fontSize">Gets font size.</param>
  /// <param name="matrix">Text matrix or null if default appearance does not contain text matrix.</param>
  /// <returns>True if successfull; false otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFTOOLS_ParseDefaultAppearance(
    string defaultAppearance,
    out float[] strokeColor,
    out float[] fillColor,
    out string fontName,
    out float fontSize,
    out FS_MATRIX matrix)
  {
    IntPtr num1 = IntPtr.Zero;
    IntPtr num2 = Marshal.AllocHGlobal(16 /*0x10*/);
    IntPtr num3 = Marshal.AllocHGlobal(16 /*0x10*/);
    IntPtr num4 = Marshal.AllocHGlobal(Marshal.SizeOf<FS_MATRIX>());
    fontName = (string) null;
    fillColor = (float[]) null;
    strokeColor = (float[]) null;
    matrix = (FS_MATRIX) null;
    fontSize = 0.0f;
    bool hasStrokeColor = false;
    int strokeColorType = 0;
    bool hasFillColor = false;
    int fillColorType = 0;
    bool hasFont = false;
    bool hasMatrix = false;
    if ((defaultAppearance ?? "") == "")
      return false;
    using (Lock.SyncMT)
    {
      try
      {
        int bufSize = 0;
        bool appearanceNative = Pdfium.FPDFTOOLS_ParseDefaultAppearance_native(defaultAppearance, out hasStrokeColor, out strokeColorType, num3, out hasFillColor, out fillColorType, num2, out hasFont, IntPtr.Zero, ref bufSize, out fontSize, out hasMatrix, num4);
        if (appearanceNative && bufSize > 0)
        {
          num1 = Marshal.AllocHGlobal(bufSize);
          appearanceNative = Pdfium.FPDFTOOLS_ParseDefaultAppearance_native(defaultAppearance, out hasStrokeColor, out strokeColorType, num3, out hasFillColor, out fillColorType, num2, out hasFont, num1, ref bufSize, out fontSize, out hasMatrix, num4);
          if (!appearanceNative)
            return false;
          byte[] numArray = new byte[bufSize];
          Marshal.Copy(num1, numArray, 0, numArray.Length);
          fontName = Pdfium.DefaultAnsiEncoding.GetString(numArray, 0, numArray.Length - 1);
        }
        if (hasFillColor)
        {
          fillColor = new float[Math.Min(4, fillColorType >= 2 ? fillColorType + 1 : fillColorType)];
          Marshal.Copy(num2, fillColor, 0, fillColor.Length);
        }
        if (hasStrokeColor)
        {
          strokeColor = new float[Math.Min(4, strokeColorType >= 2 ? strokeColorType + 1 : strokeColorType)];
          Marshal.Copy(num3, strokeColor, 0, strokeColor.Length);
        }
        if (hasMatrix)
        {
          matrix = new FS_MATRIX();
          Marshal.PtrToStructure<FS_MATRIX>(num4, matrix);
        }
        return appearanceNative;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
      finally
      {
        if (num1 != IntPtr.Zero)
          Marshal.FreeHGlobal(num1);
        if (num2 != IntPtr.Zero)
          Marshal.FreeHGlobal(num2);
        if (num3 != IntPtr.Zero)
          Marshal.FreeHGlobal(num3);
        if (num4 != IntPtr.Zero)
          Marshal.FreeHGlobal(num4);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTOOLS_GetWaveData", SetLastError = true)]
  private static extern int FPDFTOOLS_GetWaveData_native(
    int sourceLen,
    byte[] waveDataSrc,
    int bufLen,
    byte[] buffer,
    out SoundEncodingFormats audioFormat,
    out int numChannels,
    out int sampleRate,
    out int bitsPerSample);

  /// <summary>Convert audio WAV file to PDF compatible format.</summary>
  /// <param name="waveData">An array of bytes containing audio file.</param>
  /// <param name="format">Gets the encoding format of the returned data.</param>
  /// <param name="chanels">Gets the number of sound channels.</param>
  /// <param name="rate">Gets the sampling rate, in samples per second.</param>
  /// <param name="bps">Gets the number of bits per sample.</param>
  /// <returns>An array of bytes containing audio samples encoded to PDF compatible format.</returns>
  /// <remarks>
  /// <note type="note">Currently supported PCM WAV files only.</note>
  /// </remarks>
  /// <exception cref="T:Patagames.Pdf.Net.Exceptions.PdfiumException">code= ERROR_BAD_FORMAT(11): waveData does not contain RIFF or RIFX section.</exception>
  /// <exception cref="T:Patagames.Pdf.Net.Exceptions.PdfiumException">code= ERROR_UNEXPECTED_FORMAT(536871428): waveData is not in PCM format.</exception>
  /// <exception cref="T:Patagames.Pdf.Net.Exceptions.PdfiumException">code= ERROR_UNEXPECTED_PARAMETER(536871429): bitsPerSample of waveData has wrong value.</exception>
  /// <exception cref="T:Patagames.Pdf.Net.Exceptions.PdfiumException">code= ERROR_DOUBLE_SECTION(536871430): waveData has more than one FMT or DATA section.</exception>
  /// <exception cref="T:Patagames.Pdf.Net.Exceptions.PdfiumException">code=ERROR_UNEXPECTED_DATA_LENGTH(536871433): the length of DATA section is wrong.</exception>
  [HandleProcessCorruptedStateExceptions]
  public static byte[] FPDFTOOLS_GetWaveData(
    byte[] waveData,
    out SoundEncodingFormats format,
    out int chanels,
    out int rate,
    out int bps)
  {
    if (waveData == null)
      throw new ArgumentNullException(nameof (waveData));
    using (Lock.SyncMT)
    {
      try
      {
        int waveDataNative = Pdfium.FPDFTOOLS_GetWaveData_native(waveData.Length, waveData, 0, (byte[]) null, out format, out chanels, out rate, out bps);
        byte[] buffer = waveDataNative > 0 ? new byte[waveDataNative] : throw Pdfium.ProcessLastError();
        if (waveDataNative != Pdfium.FPDFTOOLS_GetWaveData_native(waveData.Length, waveData, waveDataNative, buffer, out format, out chanels, out rate, out bps))
          throw Pdfium.ProcessLastError();
        return buffer;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFTOOLS_GetAnnotsWithoutAP", SetLastError = true)]
  private static extern uint FPDFTOOLS_GetAnnotsWithoutAP_native(
    IntPtr page,
    ref IntPtr handle,
    uint[] arr);

  /// <summary>
  /// Gets the indexes of the annotations which has no appearance stream.
  /// </summary>
  /// <param name="page">The handle to the page.</param>
  /// <returns>An array that contains the indexes of the annotations. If there are no such annotations or an error has occurred, null is returned.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static uint[] FPDFTOOLS_GetAnnotsWithoutAP(IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        IntPtr zero = IntPtr.Zero;
        int annotsWithoutApNative = (int) Pdfium.FPDFTOOLS_GetAnnotsWithoutAP_native(page, ref zero, (uint[]) null);
        uint[] arr = new uint[annotsWithoutApNative];
        if (annotsWithoutApNative != (int) Pdfium.FPDFTOOLS_GetAnnotsWithoutAP_native(page, ref zero, arr))
          throw Pdfium.ProcessLastError();
        return annotsWithoutApNative == 0 ? (uint[]) null : arr;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_GetFocusAnnot", SetLastError = true)]
  private static extern IntPtr FORM_GetFocusAnnot_native(IntPtr form_handle);

  /// <summary>Get the annotation that currently has input focus.</summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <returns>The handle to the annotation dictionary.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FORM_GetFocusAnnot(IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_GetFocusAnnot_native(form_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_SetFocusAnnot", SetLastError = true)]
  private static extern void FORM_SetFocusAnnot_native(
    IntPtr form_handle,
    IntPtr page,
    IntPtr annot,
    int flags);

  /// <summary>Set the input focus to the specified annotation.</summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="annot">Handle to the annotation dictionary.</param>
  /// <param name="page">Handle to PDF page.</param>
  /// <param name="flags">Reserved, must be 0.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FORM_SetFocusAnnot(IntPtr form_handle, IntPtr page, IntPtr annot, int flags = 0)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FORM_SetFocusAnnot_native(form_handle, page, annot, flags);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_GetFocusedText", SetLastError = true)]
  private static extern int FORM_GetFocusedText_native(IntPtr form_handle, [MarshalAs(UnmanagedType.LPArray)] byte[] val, int len);

  /// <summary>
  /// Return the text of the widget that is currently processing the input queue.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <returns>Widget text. An empty string if there is no widget that has input focus, or if the widget does not contain text.</returns>
  /// <remarks>Applicable only to input field widgets.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FORM_GetFocusedText(IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int focusedTextNative = Pdfium.FORM_GetFocusedText_native(form_handle, (byte[]) null, 0);
        if (focusedTextNative <= 0)
          return "";
        byte[] numArray = new byte[focusedTextNative];
        Pdfium.FORM_GetFocusedText_native(form_handle, numArray, focusedTextNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_GetSelectedText", SetLastError = true)]
  private static extern void FORM_GetSelectedText_native(
    IntPtr form_handle,
    out int startIndex,
    out int len);

  /// <summary>
  /// Get the starting index and length of the selected text in the widget that has input focus.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="startIndex">The starting index of the selected text.</param>
  /// <param name="len">The length of the selected text.</param>
  /// <remarks>Applicable only to input field widgets.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FORM_GetSelectedText(IntPtr form_handle, out int startIndex, out int len)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FORM_GetSelectedText_native(form_handle, out startIndex, out len);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_SetSelectedText", SetLastError = true)]
  private static extern bool FORM_SetSelectedText_native(
    IntPtr form_handle,
    int startIndex,
    int len);

  /// <summary>Select text in the widget that has input focus.</summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="startIndex">The character index from which to select the text.</param>
  /// <param name="len">The length of the text in characters to select.</param>
  /// <returns>True on success. False if any error occurred.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FORM_SetSelectedText(IntPtr form_handle, int startIndex, int len)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_SetSelectedText_native(form_handle, startIndex, len);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_GetPageIndexByAnnotDict", SetLastError = true)]
  private static extern int FORM_GetPageIndexByAnnotDict_native(
    IntPtr form_handle,
    IntPtr dict_handle);

  /// <summary>
  /// Get the index of the page on which the specified annotation is located.
  /// </summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <param name="dict_handle">A handle to the annotation dictionary.</param>
  /// <returns>Zero-based page index or -1 if nothing found.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FORM_GetPageIndexByAnnotDict(IntPtr form_handle, IntPtr dict_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FORM_GetPageIndexByAnnotDict_native(form_handle, dict_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FORM_GetInterForm", SetLastError = true)]
  private static extern IntPtr FORM_GetInterForm_native(IntPtr form_handle);

  /// <summary>Initialize the interactive forms</summary>
  /// <param name="form_handle">Handle to the form fill module. Returned by <see cref="O:Patagames.Pdf.Pdfium.FPDFDOC_InitFormFillEnvironment" />.</param>
  /// <returns>The handle to the interactive forms object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FORM_GetInterForm(IntPtr form_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        IntPtr interFormNative = Pdfium.FORM_GetInterForm_native(form_handle);
        if (!Pdfium._interforms.ContainsKey(form_handle))
          Pdfium._interforms.Add(form_handle, interFormNative);
        else
          Pdfium._interforms[form_handle] = interFormNative;
        return interFormNative;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetFormNotify", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetFormNotify_native(IntPtr interForm);

  /// <summary>Gets Form Notify object</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns>Form Notify object which used for notification about changes in forms.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FPDF_FORMFILLNOTIFY FPDFInterForm_GetFormNotify(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        IntPtr formNotifyNative = Pdfium.FPDFInterForm_GetFormNotify_native(interForm);
        if (formNotifyNative == IntPtr.Zero)
          return (FPDF_FORMFILLNOTIFY) null;
        IPointerManagerItem at = PointerManager.GetAt(interForm);
        if (at != null && !((at as PointerManagerItem<FPDF_FORMFILLNOTIFY>)[0] != formNotifyNative))
          return (at as PointerManagerItem<FPDF_FORMFILLNOTIFY>).Obj1;
        FPDF_FORMFILLNOTIFY structure = new FPDF_FORMFILLNOTIFY();
        Marshal.PtrToStructure<FPDF_FORMFILLNOTIFY>(formNotifyNative, structure);
        return structure;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_SetFormNotify", SetLastError = true)]
  private static extern void FPDFInterForm_SetFormNotify_native(IntPtr interForm, IntPtr pNotify);

  /// <summary>Sets Form Notify object</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="pNotify">Handle to Form Notify object which used for notification about changes in forms.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFInterForm_SetFormNotify(IntPtr interForm, FPDF_FORMFILLNOTIFY pNotify)
  {
    PointerManager.Remove(interForm);
    PointerManagerItem<FPDF_FORMFILLNOTIFY> pointerManagerItem = (PointerManagerItem<FPDF_FORMFILLNOTIFY>) null;
    if (pNotify != null)
    {
      pointerManagerItem = new PointerManagerItem<FPDF_FORMFILLNOTIFY>(pNotify);
      pointerManagerItem.Key = interForm;
      PointerManager.Add((IPointerManagerItem) pointerManagerItem);
    }
    Pdfium.FPDFInterForm_SetFormNotify(interForm, pointerManagerItem == null ? IntPtr.Zero : pointerManagerItem[0]);
  }

  /// <summary>Sets Form Notify object</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="pNotify">Handle to Form Notify structure located in the unmanaged memory.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFInterForm_SetFormNotify(IntPtr interForm, IntPtr pNotify)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFInterForm_SetFormNotify_native(interForm, pNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_CountFields", SetLastError = true)]
  private static extern int FPDFInterForm_CountFields_native(IntPtr interForm, [MarshalAs(UnmanagedType.LPWStr)] string csFieldName = null);

  /// <summary>
  /// Recursively calculates the number of Fields in an field's tree of the document
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="csFieldName">The name of the parent field in the hierarchy of fields or null for the root.</param>
  /// <returns>Total number of all child fields for the parent field.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFInterForm_CountFields(IntPtr interForm, string csFieldName = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_CountFields_native(interForm, csFieldName);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetField", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetField_native(
    IntPtr interForm,
    int index,
    [MarshalAs(UnmanagedType.LPWStr)] string csFieldName = null);

  /// <summary>
  /// Gets field specified by a index and a parent field in the hierarchy of fields
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="index">Index of Field ranging from 0 to <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_CountFields(System.IntPtr,System.String)" /></param>
  /// <param name="csFieldName">The name of the parent field in the hierarchy of fields or null for the root.</param>
  /// <returns>The Field object from the hierarchy of document's fields.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetField(IntPtr interForm, int index, string csFieldName = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetField_native(interForm, index, csFieldName);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_IsValidFormField", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFInterForm_IsValidFormField_native(IntPtr interForm, IntPtr field);

  /// <summary>
  /// Determines that specified Field is a valid Field from the hierarchy of documents fields
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="field">Field objects. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>True if the specified Field is present in the list of fields of the document or False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFInterForm_IsValidFormField(IntPtr interForm, IntPtr field)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_IsValidFormField_native(interForm, field);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_CountControls", SetLastError = true)]
  private static extern int FPDFInterForm_CountControls_native(IntPtr interForm, [MarshalAs(UnmanagedType.LPWStr)] string csFieldName = null);

  /// <summary>Get total number of controls in a specified field</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="csFieldName">The name of the field in the hierarchy of fields.</param>
  /// <returns>Total number of controls in the field.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFInterForm_CountControls(IntPtr interForm, string csFieldName = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_CountControls_native(interForm, csFieldName);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetControl", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetControl_native(
    IntPtr interForm,
    int index,
    [MarshalAs(UnmanagedType.LPWStr)] string csFieldName);

  /// <summary>Gets control specified by a index for specified field</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="index">Index of Control ranging from 0 to <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_CountControls(System.IntPtr,System.String)" /></param>
  /// <param name="csFieldName">The name of the field in the hierarchy of fields.</param>
  /// <returns>The Control object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetControl(IntPtr interForm, int index, string csFieldName)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetControl_native(interForm, index, csFieldName);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_IsValidFormControl", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFInterForm_IsValidFormControl_native(
    IntPtr interForm,
    IntPtr control);

  /// <summary>Determines that specified Control is a valid Control</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="control">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>True if the specified Field is present in the list of fields of the document or False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFInterForm_IsValidFormControl(IntPtr interForm, IntPtr control)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_IsValidFormControl_native(interForm, control);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_CountPageControls", SetLastError = true)]
  private static extern int FPDFInterForm_CountPageControls_native(IntPtr interForm, IntPtr page);

  /// <summary>Get total number of controls on a specified page</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" />function.</param>
  /// <returns>Total number of controls on a page.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFInterForm_CountPageControls(IntPtr interForm, IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_CountPageControls_native(interForm, page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetPageControl", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetPageControl_native(
    IntPtr interForm,
    IntPtr page,
    int index);

  /// <summary>Gets control specified by a index for specified page</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" />function.</param>
  /// <param name="index">Index of Control ranging from 0 to <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_CountPageControls(System.IntPtr,System.IntPtr)" /></param>
  /// <returns>The Control object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetPageControl(IntPtr interForm, IntPtr page, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetPageControl_native(interForm, page, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_CountFieldsInCalculationOrder", SetLastError = true)]
  private static extern int FPDFInterForm_CountFieldsInCalculationOrder_native(IntPtr interForm);

  /// <summary>Get total number of fields with calculation actions</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns> Count total number of elements in array of indirect references to field dictionaries with calculation actions, defining the calculation order in which their values will be recalculated when the value of any field changes </returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFInterForm_CountFieldsInCalculationOrder(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_CountFieldsInCalculationOrder_native(interForm);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetFieldInCalculationOrder", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetFieldInCalculationOrder_native(
    IntPtr interForm,
    int index);

  /// <summary>
  /// Gets field with calculation actions specified by a index
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="index">Index of a field ranging from 0 to <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_CountFieldsInCalculationOrder(System.IntPtr)" /></param>
  /// <returns>Field from an array of indirect references to field dictionaries with calculation actions. </returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetFieldInCalculationOrder(IntPtr interForm, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetFieldInCalculationOrder_native(interForm, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_FindFieldInCalculationOrder", SetLastError = true)]
  private static extern int FPDFInterForm_FindFieldInCalculationOrder_native(
    IntPtr interForm,
    IntPtr field);

  /// <summary>
  /// Find specified field in an array of indirect references to field dictionaries with calculation actions.
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="field">Handle to the Field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetFieldInCalculationOrder(System.IntPtr,System.Int32)" /></param>
  /// <returns>Zero based index of a Field in fields array or -1 if no any fields was found.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFInterForm_FindFieldInCalculationOrder(IntPtr interForm, IntPtr field)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_FindFieldInCalculationOrder_native(interForm, field);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_ResetForm", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFInterForm_ResetForm_native(IntPtr interForm, [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Resets forms to their default values</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success or False if action was canceled</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFInterForm_ResetForm(IntPtr interForm, bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_ResetForm_native(interForm, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_ReloadForm", SetLastError = true)]
  private static extern void FPDFInterForm_ReloadForm_native(IntPtr interForm);

  /// <summary>Reload forms</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFInterForm_ReloadForm(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFInterForm_ReloadForm_native(interForm);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_HasXFAForm", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFInterForm_HasXFAForm_native(IntPtr interForm);

  /// <summary>Determines that the document contains XFA Forms</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns>True if PDF document contains XFA Forms, False otherwise</returns>
  /// <remarks>
  /// <para>PDF 1.5 introduces support for interactive forms based on the Adobe XML Forms Architecture (XFA). The XFA entry in the interactive forms dictionary specifies an XFA resource, which is an XML stream that contains the
  /// form information. The format of an XFA resource is described in the XML Data Package (XDP) Specification</para>
  /// <para>
  /// </para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFInterForm_HasXFAForm(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_HasXFAForm_native(interForm);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_FixPageFields", SetLastError = true)]
  private static extern void FPDFInterForm_FixPageFields_native(IntPtr interForm, IntPtr page);

  /// <summary>Fix page fields.</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="page">Handle to the page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" />function.</param>
  /// <remarks>
  /// This method method reload all widget annotations on a page. You may need this if  you are changing the widget annotation through its dictionary.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFInterForm_FixPageFields(IntPtr interForm, IntPtr page)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFInterForm_FixPageFields_native(interForm, page);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_ExportToFDF", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_ExportToFDF_native(
    IntPtr interForm,
    [MarshalAs(UnmanagedType.LPWStr)] string pdf_path,
    [MarshalAs(UnmanagedType.Bool)] bool bSimpleFileSpec = false);

  /// <summary>Export fields into Forms Data Format (FDF) document</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="pdf_path">Path to the source file: the PDF document file that this FDF file was exported from. </param>
  /// <param name="bSimpleFileSpec">True for simple file specification, false otherwise/</param>
  /// <returns>New FDF document</returns>
  /// <remarks>
  /// A PDF file can refer to the contents of another file by using a file specification (PDF 1.1), which can take either of two forms:
  /// <list type="bullet">
  /// <item>
  /// A simple file specification gives just the name of the target file in a standard format, independent of the naming conventions of any particular file system. It
  /// can take the form of either a string or a dictionary
  /// </item>
  /// <item>
  /// A full file specification includes information related to one or more specific file systems. It can only be represented as a dictionary.
  /// </item>
  /// </list>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_ExportToFDF(
    IntPtr interForm,
    string pdf_path,
    bool bSimpleFileSpec = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFInterForm_ExportToFDF_native(interForm, pdf_path, bSimpleFileSpec));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_ImportFromFDF", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFInterForm_ImportFromFDF_native(
    IntPtr interForm,
    IntPtr Doc,
    [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Import fields from Forms Data Format (FDF) document</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="Doc">Handle to FDF Doument</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success or False if action was canceled</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFInterForm_ImportFromFDF(IntPtr interForm, IntPtr Doc, bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_ImportFromFDF_native(interForm, Doc, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetDefaultFormFont", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetDefaultFormFont_native(IntPtr interForm);

  /// <summary>Get the handle to default font</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns>Handle to a font object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetDefaultFormFont(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetDefaultFormFont_native(interForm);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetDefaultAppearance", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetDefaultAppearance_native(IntPtr interForm);

  /// <summary>Get the handle to default appearance</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns>Handle to a default appearance object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetDefaultAppearance(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetDefaultAppearance_native(interForm);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetFormDict", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetFormDict_native(IntPtr interForm);

  /// <summary>Get an AcroForm dictionary</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns>Handle to dictionary.</returns>
  /// <remarks>
  /// An interactive form (PDF 1.2) — sometimes referred to as an AcroForm — is a
  /// collection of fields for gathering information interactively from the user. A PDF
  /// document may contain any number of fields appearing on any combination of
  /// pages, all of which make up a single, global interactive form spanning the entire
  /// document. Arbitrary subsets of these fields can be imported or exported from the
  /// document.
  /// <para>
  /// Each field in a document’s interactive form is defined by a field dictionary.
  /// For purposes of definition and naming, the fields can be organized hierarchically
  /// and can inherit attributes from their ancestors in the field hierarchy.
  /// A field’s children in the hierarchy may also include widget annotations
  /// that define its appearance on the page.
  /// A field whose children are widget annotations is called a terminal field.
  /// </para>
  /// <para>
  /// As a convenience, when a field has only a single associated widget annotation, the
  /// contents of the field dictionary and the annotation dictionary may be merged into a single dictionary containing entries
  /// that pertain to both a field and an annotation. (This presents no ambiguity, since
  /// the contents of the two kinds of dictionaries do not conflict.) If such an object defines an appearance stream, the appearance must be consistent with the object’s
  /// current value as a field.
  /// </para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetFormDict(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFInterForm_GetFormDict_native(interForm));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetControlAtPoint", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetControlAtPoint_native(
    IntPtr interForm,
    IntPtr page,
    [MarshalAs(UnmanagedType.R4)] float x,
    [MarshalAs(UnmanagedType.R4)] float y,
    out int zOrder);

  /// <summary>Find a control at specified point on a document page</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="page">Handle to the document page. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadPage(System.IntPtr,System.Int32)" /> function</param>
  /// <param name="x">The x coordinate of the point, specified in page coordinate system</param>
  /// <param name="y">The y coordinate of the point, specified in page coordinate system</param>
  /// <param name="zOrder">Z-order</param>
  /// <returns>Handle to the control. IntPtr.Zero if there’s no control at that point.</returns>
  /// <remarks>The coordinates are specified in page coordinate system.
  /// You can convert coordinates from screen system to page system using <see cref="M:Patagames.Pdf.Pdfium.FPDF_DeviceToPage(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,Patagames.Pdf.Enums.PageRotate,System.Int32,System.Int32,System.Double@,System.Double@)" /> function</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetControlAtPoint(
    IntPtr interForm,
    IntPtr page,
    float x,
    float y,
    out int zOrder)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetControlAtPoint_native(interForm, page, x, y, out zOrder);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetControlByDict", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetControlByDict_native(IntPtr interForm, IntPtr page);

  /// <summary>Gets the control by its dictionary</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="dictionary">Handle to widget annotation's dictionary</param>
  /// <returns>Handle to the control.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetControlByDict(IntPtr interForm, IntPtr dictionary)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetControlByDict_native(interForm, dictionary);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetFieldByDict", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetFieldByDict_native(IntPtr interForm, IntPtr page);

  /// <summary>Gets the control by its dictionary</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="dictionary">Handle to field's dictionary</param>
  /// <returns>Handle to the field.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetFieldByDict(IntPtr interForm, IntPtr dictionary)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetFieldByDict_native(interForm, dictionary);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetDocument", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetDocument_native(IntPtr interForm);

  /// <summary>Get PDF document.</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns>Handle to the PDF document.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetDocument(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetDocument_native(interForm);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_CountFormFonts", SetLastError = true)]
  private static extern int FPDFInterForm_CountFormFonts_native(IntPtr interForm);

  /// <summary>
  /// Gets the number of fonts contained in the acroform resource dictionary.
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns>Number of fonts in the acroform resource dictionary.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFInterForm_CountFormFonts(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_CountFormFonts_native(interForm);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetFormFont", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetFormFont_native(
    IntPtr interForm,
    uint index,
    [MarshalAs(UnmanagedType.LPArray)] byte[] tagName,
    ref int buflen);

  /// <summary>
  /// Get the font at the specified <paramref name="index" />.
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="index">The zero-based index of the font to get.</param>
  /// <param name="getTag">A flag indicating whether the tag name should also be returned.</param>
  /// <param name="tagName">The tag name under which the font is stored in the resource dictionary.</param>
  /// <returns>Handle to the font object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetFormFont(
    IntPtr interForm,
    int index,
    bool getTag,
    out string tagName)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int buflen = 0;
        byte[] tagName1 = (byte[]) null;
        tagName = (string) null;
        IntPtr formFontNative = Pdfium.FPDFInterForm_GetFormFont_native(interForm, (uint) index, tagName1, ref buflen);
        if (!getTag)
          return formFontNative;
        byte[] numArray = new byte[buflen];
        Pdfium.FPDFInterForm_GetFormFont_native(interForm, (uint) index, numArray, ref buflen);
        tagName = Encoding.UTF8.GetString(numArray);
        tagName = tagName.Trim(new char[1]);
        return formFontNative;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_GetFormFontEx", SetLastError = true)]
  private static extern IntPtr FPDFInterForm_GetFormFont_native(IntPtr interForm, [MarshalAs(UnmanagedType.LPStr)] string tagName);

  /// <summary>
  /// Get the font at the specified <paramref name="tagName" />.
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="tagName">The tag name under which the font is stored in the resource dictionary.</param>
  /// <returns>Handle to the font object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFInterForm_GetFormFont(IntPtr interForm, string tagName)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFInterForm_GetFormFont_native(interForm, tagName);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_InitEmptyFormDict", SetLastError = true)]
  private static extern void FPDFInterForm_InitEmptyFormDict_native(IntPtr interForm);

  /// <summary>Initialize new acroform dictionary</summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFInterForm_InitEmptyFormDict(IntPtr interForm)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFInterForm_InitEmptyFormDict_native(interForm);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_AddFormFont", SetLastError = true)]
  private static extern int FPDFInterForm_AddFormFont_native(
    IntPtr interForm,
    IntPtr font,
    [MarshalAs(UnmanagedType.LPArray)] byte[] tagName,
    int buflen);

  /// <summary>
  /// Add the <paramref name="font" /> to the acroform resource dictionary.
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="font">The font to add to the acroform resourse dictionary.</param>
  /// <param name="tagName">An optional tag name under which the <paramref name="font" /> will be added to the resource dictionary. Four characters max.</param>
  /// <returns>The tag name under which the <paramref name="font" /> was actually added to the resource dictionary.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFInterForm_AddFormFont(IntPtr interForm, IntPtr font, string tagName = null)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] bytes = tagName == null ? (byte[]) null : Pdfium.DefaultAnsiEncoding.GetBytes(tagName);
        int buflen = Pdfium.FPDFInterForm_AddFormFont_native(interForm, font, bytes, bytes == null ? 0 : bytes.Length);
        if (buflen <= 0)
          return (string) null;
        byte[] numArray = new byte[buflen];
        Pdfium.FPDFInterForm_AddFormFont_native(interForm, font, numArray, buflen);
        return Pdfium.DefaultAnsiEncoding.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_RemoveFormFont", SetLastError = true)]
  private static extern void FPDFInterForm_RemoveFormFont_native(IntPtr interForm, IntPtr font);

  /// <summary>
  /// Removes the first occurrence of a specific <paramref name="font" /> from the acroform resource dictionary.
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="font">The font to remove from the resource dictionary.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFInterForm_RemoveFormFont(IntPtr interForm, IntPtr font)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFInterForm_RemoveFormFont_native(interForm, font);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_RemoveFormFontEx", SetLastError = true)]
  private static extern void FPDFInterForm_RemoveFormFontEx_native(IntPtr interForm, [MarshalAs(UnmanagedType.LPStr)] string tagName);

  /// <summary>
  /// Removes the first occurrence of a specific <paramref name="tagName" /> from the acroform resource dictionary.
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="tagName">The font's tag name to remove from the resource dictionary.</param>
  public static void FPDFInterForm_RemoveFormFont(IntPtr interForm, string tagName)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFInterForm_RemoveFormFontEx_native(interForm, tagName);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFInterForm_LoadField", SetLastError = true)]
  private static extern void FPDFInterForm_LoadField_native(IntPtr interForm, IntPtr dict);

  /// <summary>
  /// Load the field into the internal tree of fields. If the field has already been loaded earlier.
  /// </summary>
  /// <param name="interForm">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="dict">The dictionary that represents the field.</param>
  public static void FPDFInterForm_LoadField(IntPtr interForm, IntPtr dict)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFInterForm_LoadField_native(interForm, dict);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetType", SetLastError = true)]
  private static extern FormFieldTypesEx FPDFFormControl_GetType_native(IntPtr frmControl);

  /// <summary>
  /// Get type of a field associated with specified control.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>type of a field associated with specified control.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FormFieldTypesEx FPDFFormControl_GetType(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetType_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetField", SetLastError = true)]
  private static extern IntPtr FPDFFormControl_GetField_native(IntPtr frmControl);

  /// <summary>Get field associated with specified control.</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>Field associated with specified control.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormControl_GetField(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetField_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetRect", SetLastError = true)]
  private static extern void FPDFFormControl_GetRect_native(
    IntPtr frmControl,
    out float left,
    out float bottom,
    out float right,
    out float top);

  /// <summary>Get bounding rectanghle of specified control</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <param name="left">The left of the rectangle.</param>
  /// <param name="bottom">The bottom of the rectangle.</param>
  /// <param name="right">The right of the rectangle.</param>
  /// <param name="top">The top of the rectangle.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormControl_GetRect(
    IntPtr frmControl,
    out float left,
    out float bottom,
    out float right,
    out float top)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormControl_GetRect_native(frmControl, out left, out bottom, out right, out top);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetExportValue", SetLastError = true)]
  private static extern int FPDFFormControl_GetExportValue_native(
    IntPtr frmControl,
    [MarshalAs(UnmanagedType.LPArray)] byte[] val,
    int len);

  /// <summary>
  /// Get a string describing the check status of the Checkbox or Radiobutton.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>string such as "", "Yes", "Off" etc. depended on control and its status.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormControl_GetExportValue(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int exportValueNative = Pdfium.FPDFFormControl_GetExportValue_native(frmControl, (byte[]) null, 0);
        if (exportValueNative == 0)
          return "";
        byte[] numArray = new byte[exportValueNative];
        Pdfium.FPDFFormControl_GetExportValue_native(frmControl, numArray, exportValueNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_IsChecked", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormControl_IsChecked_native(IntPtr frmControl);

  /// <summary>Gets whether the Checkbox or Radiobutton is checked.</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>True if checkbox or Radiobutton is checked, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormControl_IsChecked(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_IsChecked_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_IsDefaultChecked", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormControl_IsDefaultChecked_native(IntPtr frmControl);

  /// <summary>Get a default state of the checkbox or Radiobutton.</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>True if default state is checked, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormControl_IsDefaultChecked(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_IsDefaultChecked_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetHighlightingMode", SetLastError = true)]
  private static extern FormHighlightingMode FPDFFormControl_GetHighlightingMode_native(
    IntPtr frmControl);

  /// <summary>Get the highlighting mode of specified control</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>One of the <see cref="T:Patagames.Pdf.Enums.FormHighlightingMode" /> value</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FormHighlightingMode FPDFFormControl_GetHighlightingMode(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetHighlightingMode_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_HasMKEntry", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormControl_HasMKEntry_native(IntPtr frmControl, [MarshalAs(UnmanagedType.LPStr)] string csEntry);

  /// <summary>Gets whether the control has MK entry.</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <param name="csEntry">MK entry. "R", "BC", "BG" and so on. See detils in <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF reference 1.7.pdf</a></param>
  /// <returns>True if entry exists, False otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormControl_HasMKEntry(IntPtr frmControl, string csEntry)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_HasMKEntry_native(frmControl, csEntry);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetRotation", SetLastError = true)]
  private static extern int FPDFFormControl_GetRotation_native(IntPtr frmControl);

  /// <summary>
  /// Get the number of degrees by which the control is rotated counterclockwise relative to the page. The value must be a multiple of 90.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>number of degrees by which the control is rotated counterclockwise relative to the page. The value must be a multiple of 90.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormControl_GetRotation(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetRotation_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetBorderColor", SetLastError = true)]
  private static extern int FPDFFormControl_GetBorderColor_native(
    IntPtr frmControl,
    out ColorTypes iColorType);

  /// <summary>Get the color of control's border in ARGB format</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <param name="iColorType">Color type.</param>
  /// <returns>Border color of control in ARGB format</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormControl_GetBorderColor(IntPtr frmControl, out ColorTypes iColorType)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetBorderColor_native(frmControl, out iColorType);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetOriginalBorderColor", SetLastError = true)]
  private static extern void FPDFFormControl_GetOriginalBorderColor_native(
    IntPtr frmControl,
    int index,
    out float color);

  /// <summary>
  /// Get the color of control's border in original PDF format
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <param name="index">Index of a color component, depended on color type.</param>
  /// <returns>Numbers in the range 0.0 to 1.0 specifying the color of the control's border</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFFormControl_GetOriginalBorderColor(IntPtr frmControl, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float color = 0.0f;
        Pdfium.FPDFFormControl_GetOriginalBorderColor_native(frmControl, index, out color);
        return color;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetOriginalBorderColorEx", SetLastError = true)]
  private static extern void FPDFFormControl_GetOriginalBorderColorEx_native(
    IntPtr frmControl,
    out ColorTypes iColorType,
    [MarshalAs(UnmanagedType.LPArray, SizeConst = 4, ArraySubType = UnmanagedType.R4)] float[] fc);

  /// <summary>
  /// Get the color of control's border in original PDF format
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <param name="iColorType">Color type</param>
  /// <returns>An array of numbers in the range 0.0 to 1.0 specifying the color of the control's border</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFormControl_GetOriginalBorderColorEx(
    IntPtr frmControl,
    out ColorTypes iColorType)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float[] fc = new float[4];
        Pdfium.FPDFFormControl_GetOriginalBorderColorEx_native(frmControl, out iColorType, fc);
        return fc;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetBackgroundColor", SetLastError = true)]
  private static extern int FPDFFormControl_GetBackgroundColor_native(
    IntPtr frmControl,
    out ColorTypes iColorType);

  /// <summary>Get the color of control's background in ARGB format</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <param name="iColorType">Color type.</param>
  /// <returns>Background color of control in ARGB format</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormControl_GetBackgroundColor(IntPtr frmControl, out ColorTypes iColorType)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetBackgroundColor_native(frmControl, out iColorType);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetOriginalBackgroundColor", SetLastError = true)]
  private static extern void FPDFFormControl_GetOriginalBackgroundColor_native(
    IntPtr frmControl,
    int index,
    out float color);

  /// <summary>
  /// Get the color of control's background in original PDF format
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <param name="index">Index of a color component, depended on color type.</param>
  /// <returns>Numbers in the range 0.0 to 1.0 specifying the color of the control's background</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFFormControl_GetOriginalBackgroundColor(IntPtr frmControl, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float color = 0.0f;
        Pdfium.FPDFFormControl_GetOriginalBackgroundColor_native(frmControl, index, out color);
        return color;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetOriginalBackgroundColorEx", SetLastError = true)]
  private static extern void FPDFFormControl_GetOriginalBackgroundColorEx_native(
    IntPtr frmControl,
    out ColorTypes iColorType,
    [MarshalAs(UnmanagedType.LPArray, SizeConst = 4, ArraySubType = UnmanagedType.R4)] float[] fc);

  /// <summary>
  /// Get the color of control's background in original PDF format
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <param name="iColorType">Color type</param>
  /// <returns>An array of numbers in the range 0.0 to 1.0 specifying the color of the control's background</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float[] FPDFFormControl_GetOriginalBackgroundColorEx(
    IntPtr frmControl,
    out ColorTypes iColorType)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float[] fc = new float[4];
        Pdfium.FPDFFormControl_GetOriginalBackgroundColorEx_native(frmControl, out iColorType, fc);
        return fc;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetNormalCaption", SetLastError = true)]
  private static extern int FPDFFormControl_GetNormalCaption_native(
    IntPtr frmControl,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>
  /// The controls normal caption, displayed when it is not interacting with the user.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>String that represents controls normal caption</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormControl_GetNormalCaption(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int normalCaptionNative = Pdfium.FPDFFormControl_GetNormalCaption_native(frmControl, (byte[]) null, 0);
        if (normalCaptionNative == 0)
          return "";
        byte[] numArray = new byte[normalCaptionNative];
        Pdfium.FPDFFormControl_GetNormalCaption_native(frmControl, numArray, normalCaptionNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetRolloverCaption", SetLastError = true)]
  private static extern int FPDFFormControl_GetRolloverCaption_native(
    IntPtr frmControl,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>
  /// The controls rollover caption, displayed when the user rolls the cursor into its active area without pressing the mouse button.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>String that represents controls rollover caption</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormControl_GetRolloverCaption(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int rolloverCaptionNative = Pdfium.FPDFFormControl_GetRolloverCaption_native(frmControl, (byte[]) null, 0);
        if (rolloverCaptionNative == 0)
          return "";
        byte[] numArray = new byte[rolloverCaptionNative];
        Pdfium.FPDFFormControl_GetRolloverCaption_native(frmControl, numArray, rolloverCaptionNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetDownCaption", SetLastError = true)]
  private static extern int FPDFFormControl_GetDownCaption_native(
    IntPtr frmControl,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>
  /// The controls alternate (down) caption, displayed when the mouse button is pressed within its active area.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>String that represents controls down caption</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormControl_GetDownCaption(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int downCaptionNative = Pdfium.FPDFFormControl_GetDownCaption_native(frmControl, (byte[]) null, 0);
        if (downCaptionNative == 0)
          return "";
        byte[] numArray = new byte[downCaptionNative];
        Pdfium.FPDFFormControl_GetDownCaption_native(frmControl, numArray, downCaptionNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetTextPosition", SetLastError = true)]
  private static extern TextPositions FPDFFormControl_GetTextPosition_native(IntPtr frmControl);

  /// <summary>
  /// Get a code indicating where to position the text of the widget annotation’s caption relative to its icon
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>A code indicating where to position the text ofthe widget annotation’s caption relative to its icon</returns>
  [HandleProcessCorruptedStateExceptions]
  public static TextPositions FPDFFormControl_GetTextPosition(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetTextPosition_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetControlAlignment", SetLastError = true)]
  private static extern JustifyTypes FPDFFormControl_GetControlAlignment_native(IntPtr frmControl);

  /// <summary>
  /// Get a code specifying the form of justification to beused in displaying the text.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>A code specifying the form of justification to be used in displaying the text </returns>
  [HandleProcessCorruptedStateExceptions]
  public static JustifyTypes FPDFFormControl_GetControlAlignment(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetControlAlignment_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetWidget", SetLastError = true)]
  private static extern IntPtr FPDFFormControl_GetWidget_native(IntPtr frmControl);

  /// <summary>Get a dictionary of Widget Annotations</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>Handle to dictionary.</returns>
  /// <remarks>
  /// Interactive forms use widget annotations (PDF 1.2) to represent the appearance of fields
  /// and to manage user interactions. As a convenience, when a field has only a single associated
  /// widget annotation, the contents of the field dictionary and the annotation dictionary
  /// can be merged into a single dictionary containing entries that pertain to both a field and
  /// an annotation. (This presents no ambiguity, since the contents of the two kinds of dictionaries
  /// do not conflict.)
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormControl_GetWidget(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFFormControl_GetWidget_native(frmControl));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetCheckedAPState", SetLastError = true)]
  private static extern int FPDFFormControl_GetCheckedAPState_native(
    IntPtr frmControl,
    byte[] buffer,
    int len);

  /// <summary>
  /// Get check state for CheckBox or RadioButton. Other field's types are not supported.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>String what represent the check state of field.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormControl_GetCheckedAPState(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int checkedApStateNative = Pdfium.FPDFFormControl_GetCheckedAPState_native(frmControl, (byte[]) null, 0);
        if (checkedApStateNative <= 0)
          return (string) null;
        byte[] numArray = new byte[checkedApStateNative];
        Pdfium.FPDFFormControl_GetCheckedAPState_native(frmControl, numArray, checkedApStateNative);
        return (Pdfium.DefaultAnsiEncoding.GetString(numArray) ?? "").Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetNormalIcon", SetLastError = true)]
  private static extern IntPtr FPDFFormControl_GetNormalIcon_native(IntPtr frmControl);

  /// <summary>
  /// Get normal icon, displayed when it is not interacting with the user.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>Handle to a stream containing the icon.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormControl_GetNormalIcon(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetNormalIcon_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetRolloverIcon", SetLastError = true)]
  private static extern IntPtr FPDFFormControl_GetRolloverIcon_native(IntPtr frmControl);

  /// <summary>
  /// Get the widget annotation’s rollover icon, displayed when the user rolls the cursor into its active area without pressing the mouse button.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>Handle to a stream containing the icon.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormControl_GetRolloverIcon(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetRolloverIcon_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetDownIcon", SetLastError = true)]
  private static extern IntPtr FPDFFormControl_GetDownIcon_native(IntPtr frmControl);

  /// <summary>
  /// Get the widget annotation’s alternate(down) icon, displayed when the mouse button is pressed within its active area.
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>Handle to a stream containing the icon.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormControl_GetDownIcon(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetDownIcon_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetDefaultControlFont", SetLastError = true)]
  private static extern IntPtr FPDFFormControl_GetDefaultControlFont_native(IntPtr frmControl);

  /// <summary>Get the handle to default font</summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>Handle to a font object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormControl_GetDefaultControlFont(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetDefaultControlFont_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetDefaultAppearance", SetLastError = true)]
  private static extern IntPtr FPDFFormControl_GetDefaultAppearance_native(IntPtr frmControl);

  /// <summary>
  /// Get the handle to default appearance of widget annotation
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>Handle to a default appearance object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormControl_GetDefaultAppearance(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetDefaultAppearance_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormControl_GetIconFit", SetLastError = true)]
  private static extern IntPtr FPDFFormControl_GetIconFit_native(IntPtr frmControl);

  /// <summary>
  /// Get an icon fit object specifying how to display the widget annotation’s icon within its annotation rectangle.If present, the icon fit dictionary applies to all of the annotation’s icons (normal, rollover, and alternate).
  /// </summary>
  /// <param name="frmControl">Handle to the Control object. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetControl(System.IntPtr,System.Int32,System.String)" /> function.</param>
  /// <returns>Handle to a default appearance object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormControl_GetIconFit(IntPtr frmControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormControl_GetIconFit_native(frmControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetFullName", SetLastError = true)]
  private static extern int FPDFFormField_GetFullName_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>Get the fully qualified field name.</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Field full name</returns>
  /// <remarks>
  /// <para>
  /// The fully qualified field name is not explicitly defined but is constructed from the partial field names of the field and all of its
  /// ancestors. For a field with no parent, the partial and fully qualified names are the same. For a field that is the child of another field, the fully qualified name is
  /// formed by appending the child field’s partial name to the parent’s fully qualified name, separated by a period (.): parent’s_full_name.child’s_partial_name
  /// </para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetFullName(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] buffer = (byte[]) null;
        int fullNameNative = Pdfium.FPDFFormField_GetFullName_native(frmField, buffer, 0);
        if (fullNameNative == 0)
          return "";
        byte[] numArray = new byte[fullNameNative];
        Pdfium.FPDFFormField_GetFullName_native(frmField, numArray, fullNameNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetType", SetLastError = true)]
  private static extern FormFieldTypesEx FPDFFormField_GetType_native(IntPtr frmField);

  /// <summary>Get the type of field</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Field type</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FormFieldTypesEx FPDFFormField_GetType(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetType_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_ResetField", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_ResetField_native(IntPtr frmField, [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Resets field to it default values</summary>
  /// <param name="frmField">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success or False otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_ResetField(IntPtr frmField, bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_ResetField_native(frmField, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_CountControls", SetLastError = true)]
  private static extern int FPDFFormField_CountControls_native(IntPtr frmField);

  /// <summary>Get total number of controls in a specified field</summary>
  /// <param name="frmField">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <returns>Total number of controls in the field.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_CountControls(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_CountControls_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetControl", SetLastError = true)]
  private static extern IntPtr FPDFFormField_GetControl_native(IntPtr frmField, int index);

  /// <summary>Gets control specified by a index for specified field</summary>
  /// <param name="frmField">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="index">Index of Control ranging from 0 to <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_CountControls(System.IntPtr,System.String)" /></param>
  /// <returns>Handle to the Control object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormField_GetControl(IntPtr frmField, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetControl_native(frmField, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetControlIndex", SetLastError = true)]
  private static extern int FPDFFormField_GetControlIndex_native(IntPtr frmField, IntPtr pControl);

  /// <summary>Gets control's index in specified field</summary>
  /// <param name="frmField">Handle to interactive forms. Returned by <see cref="M:Patagames.Pdf.Pdfium.FORM_GetInterForm(System.IntPtr)" /> function.</param>
  /// <param name="pControl">Handle to the control object</param>
  /// <returns>Zero based index of a control in specified field or -1 if no any fields was found.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_GetControlIndex(IntPtr frmField, IntPtr pControl)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetControlIndex_native(frmField, pControl);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetFieldType", SetLastError = true)]
  private static extern FormFieldTypes FPDFFormField_GetFieldType_native(IntPtr frmField);

  /// <summary>Get the type of field</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Field type</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FormFieldTypes FPDFFormField_GetFieldType(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetFieldType_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetAlternateName", SetLastError = true)]
  private static extern int FPDFFormField_GetAlternateName_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>Get alternate field name.</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>String what contains alternate field name.</returns>
  /// <remarks> An alternate field name to be used in place of the actual field name wherever the field must be identified in the user
  /// interface (such as in error or status messages referring to the field). This text is also useful when
  /// extracting the document’s contents in support of accessibility to users with
  /// disabilities or for other purposes.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetAlternateName(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int alternateNameNative = Pdfium.FPDFFormField_GetAlternateName_native(frmField, (byte[]) null, 0);
        if (alternateNameNative == 0)
          return "";
        byte[] numArray = new byte[alternateNameNative];
        Pdfium.FPDFFormField_GetAlternateName_native(frmField, numArray, alternateNameNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetMappingName", SetLastError = true)]
  private static extern int FPDFFormField_GetMappingName_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>Get mapping field name.</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>String what contains mapping field name.</returns>
  /// <remarks>The mapping name to be used when exporting interactive form field data from the document. </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetMappingName(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int mappingNameNative = Pdfium.FPDFFormField_GetMappingName_native(frmField, (byte[]) null, 0);
        if (mappingNameNative == 0)
          return "";
        byte[] numArray = new byte[mappingNameNative];
        Pdfium.FPDFFormField_GetMappingName_native(frmField, numArray, mappingNameNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetFieldFlags", SetLastError = true)]
  private static extern FieldFlagsEx FPDFFormField_GetFieldFlags_native(IntPtr frmField);

  /// <summary>Get field flags</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Field's flags specifying various characteristics of the field.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FieldFlagsEx FPDFFormField_GetFieldFlags(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetFieldFlags_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetDefaultStyle", SetLastError = true)]
  private static extern int FPDFFormField_GetDefaultStyle_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>Get a default style string</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>A default style string</returns>
  /// <remarks>
  /// Beginning with PDF 1.5, the text contents of variable text form fields, as well as
  /// markup annotations, can include formatting (style) information. These rich text
  /// strings are fully-formed XML documents that conform to the rich text conventions
  /// specified for the XML Forms Architecture (XFA) specification, which is itself
  /// a subset of the XHTML 1.0 specification, augmented with a restricted set of
  /// CSS2 style attributes.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetDefaultStyle(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int defaultStyleNative = Pdfium.FPDFFormField_GetDefaultStyle_native(frmField, (byte[]) null, 0);
        if (defaultStyleNative == 0)
          return "";
        byte[] numArray = new byte[defaultStyleNative];
        Pdfium.FPDFFormField_GetDefaultStyle_native(frmField, numArray, defaultStyleNative);
        return Pdfium.DefaultAnsiEncoding.GetString(numArray, 0, numArray.Length - 1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetRichTextString", SetLastError = true)]
  private static extern int FPDFFormField_GetRichTextString_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>Get a rich text string</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>A rich text string</returns>
  /// <remarks>
  /// Beginning with PDF 1.5, the text contents of variable text form fields, as well as
  /// markup annotations, can include formatting (style) information. These rich text
  /// strings are fully-formed XML documents that conform to the rich text conventions
  /// specified for the XML Forms Architecture (XFA) specification, which is itself
  /// a subset of the XHTML 1.0 specification, augmented with a restricted set of
  /// CSS2 style attributes.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetRichTextString(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int textStringNative = Pdfium.FPDFFormField_GetRichTextString_native(frmField, (byte[]) null, 0);
        if (textStringNative == 0)
          return "";
        byte[] numArray = new byte[textStringNative];
        Pdfium.FPDFFormField_GetRichTextString_native(frmField, numArray, textStringNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetValue", SetLastError = true)]
  private static extern int FPDFFormField_GetValue_native(IntPtr frmField, [MarshalAs(UnmanagedType.LPArray)] byte[] buffer, int len);

  /// <summary>Get field's value</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Field's value</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetValue(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int valueNative = Pdfium.FPDFFormField_GetValue_native(frmField, (byte[]) null, 0);
        if (valueNative == 0)
          return "";
        byte[] numArray = new byte[valueNative];
        Pdfium.FPDFFormField_GetValue_native(frmField, numArray, valueNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetDefaultValue", SetLastError = true)]
  private static extern int FPDFFormField_GetDefaultValue_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>Get field's default value</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Field's default value</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetDefaultValue(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int defaultValueNative = Pdfium.FPDFFormField_GetDefaultValue_native(frmField, (byte[]) null, 0);
        if (defaultValueNative == 0)
          return "";
        byte[] numArray = new byte[defaultValueNative];
        Pdfium.FPDFFormField_GetDefaultValue_native(frmField, numArray, defaultValueNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_SetValue", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_SetValue_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.LPWStr)] string value,
    [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Set field's value</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="value">New value</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success or False otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_SetValue(IntPtr frmField, string value, bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_SetValue_native(frmField, value, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_SetDefaultValue", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_SetDefaultValue_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.LPWStr)] string value,
    [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Set the default value of the field.</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="value">New value</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success or False otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_SetDefaultValue(IntPtr frmField, string value, bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_SetDefaultValue_native(frmField, value, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetMaxLen", SetLastError = true)]
  private static extern int FPDFFormField_GetMaxLen_native(IntPtr frmField);

  /// <summary>
  /// Get the maximum length of the field’s text, in characters.
  /// </summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>The maximum length of the field’s text, in characters. </returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_GetMaxLen(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetMaxLen_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_CountSelectedItems", SetLastError = true)]
  private static extern int FPDFFormField_CountSelectedItems_native(IntPtr frmField);

  /// <summary>Get selected items count</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Number of selected items</returns>
  /// <remarks>
  /// For choice fields that allow multiple
  /// selection (MultiSelect flag set), an array of integers, sorted in ascending order, representing
  /// the zero-based indices in the Opt array of the currently selected option items. This
  /// entry is required when two or more elements in the Opt array have different names but
  /// the same export value or when the value of the choice field is an array. In other cases, the
  /// entry is permitted but not required. If the items identified by this entry differ from those
  /// in the V entry of the field dictionary (see below), the V entry takes precedence.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_CountSelectedItems(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_CountSelectedItems_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetSelectedIndex", SetLastError = true)]
  private static extern int FPDFFormField_GetSelectedIndex_native(IntPtr frmField, int index);

  /// <summary>Gets selected index</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="index">Index of item ranging from 0 to <see cref="M:Patagames.Pdf.Pdfium.FPDFFormField_CountSelectedItems(System.IntPtr)" /></param>
  /// <returns>Selected index</returns>
  /// <remarks>
  /// For choice fields that allow multiple
  /// selection (MultiSelect flag set), an array of integers, sorted in ascending order, representing
  /// the zero-based indices in the Opt array of the currently selected option items. This
  /// entry is required when two or more elements in the Opt array have different names but
  /// the same export value or when the value of the choice field is an array. In other cases, the
  /// entry is permitted but not required. If the items identified by this entry differ from those
  /// in the V entry of the field dictionary (see below), the V entry takes precedence.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_GetSelectedIndex(IntPtr frmField, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetSelectedIndex_native(frmField, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_ClearSelection", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_ClearSelection_native(IntPtr frmField, [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Clear field's selection</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success or False otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_ClearSelection(IntPtr frmField, bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_ClearSelection_native(frmField, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_IsItemSelected", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_IsItemSelected_native(IntPtr frmField, int index);

  /// <summary>
  /// Determines that the Combobox's or Listbox's item specified by index is selected
  /// </summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="index">Zero based index of item in Combobox or Listbox.</param>
  /// <returns>True if item selected, False otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_IsItemSelected(IntPtr frmField, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_IsItemSelected_native(frmField, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_SetItemSelection", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_SetItemSelection_native(
    IntPtr frmField,
    int index,
    [MarshalAs(UnmanagedType.Bool)] bool bSelected,
    [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Select or deselect Combobox or Listbox item</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="index">Zero based index of item in Combobox or Listbox.</param>
  /// <param name="bSelected">True for select, False otherwise</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success or False otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_SetItemSelection(
    IntPtr frmField,
    int index,
    bool bSelected,
    bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_SetItemSelection_native(frmField, index, bSelected, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_IsItemDefaultSelected", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_IsItemDefaultSelected_native(IntPtr frmField, int index);

  /// <summary>
  /// Determines that the Combobox's or Listbox's item specified by index is selected by Default
  /// </summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="index">Zero based index of item in Combobox or Listbox.</param>
  /// <returns>True if item selected, False otherwise</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_IsItemDefaultSelected(IntPtr frmField, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_IsItemDefaultSelected_native(frmField, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetDefaultSelectedItem", SetLastError = true)]
  private static extern int FPDFFormField_GetDefaultSelectedItem_native(IntPtr frmField);

  /// <summary>
  /// Get the Combobox's or Listbox's index of item selected by default.
  /// </summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Zero based index.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_GetDefaultSelectedItem(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetDefaultSelectedItem_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_CountOptions", SetLastError = true)]
  private static extern int FPDFFormField_CountOptions_native(IntPtr frmField);

  /// <summary>
  /// Get the total number of options to be presented to the user in choise field.
  /// </summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Number of options to be presented to the user in choice field</returns>
  /// <remarks>
  /// Each element of the choice field is either a text string representing one of the available options or an array consisting of two text strings: the option’s export value and the text to be displayed as the name of the option
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_CountOptions(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_CountOptions_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetOptionLabel", SetLastError = true)]
  private static extern int FPDFFormField_GetOptionLabel_native(
    IntPtr frmField,
    int index,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>Get option's label</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="index">Index of option's item</param>
  /// <returns>Option label</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetOptionLabel(IntPtr frmField, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int optionLabelNative = Pdfium.FPDFFormField_GetOptionLabel_native(frmField, index, (byte[]) null, 0);
        if (optionLabelNative == 0)
          return "";
        byte[] numArray = new byte[optionLabelNative];
        Pdfium.FPDFFormField_GetOptionLabel_native(frmField, index, numArray, optionLabelNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetOptionValue", SetLastError = true)]
  private static extern int FPDFFormField_GetOptionValue_native(
    IntPtr frmField,
    int index,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int len);

  /// <summary>Get option's value</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="index">Index of option's item</param>
  /// <returns>Option value</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFFormField_GetOptionValue(IntPtr frmField, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int optionValueNative = Pdfium.FPDFFormField_GetOptionValue_native(frmField, index, (byte[]) null, 0);
        if (optionValueNative == 0)
          return "";
        byte[] numArray = new byte[optionValueNative];
        Pdfium.FPDFFormField_GetOptionValue_native(frmField, index, numArray, optionValueNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_FindOption", SetLastError = true)]
  private static extern int FPDFFormField_FindOption_native(IntPtr frmField, [MarshalAs(UnmanagedType.LPWStr)] string csOptLabel);

  /// <summary>Find option by label</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="csOptLabel">Option label</param>
  /// <returns>Zero based index of option</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_FindOption(IntPtr frmField, string csOptLabel)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_FindOption_native(frmField, csOptLabel);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_FindOptionValue", SetLastError = true)]
  private static extern int FPDFFormField_FindOptionValue_native(IntPtr frmField, [MarshalAs(UnmanagedType.LPWStr)] string csOptValue);

  /// <summary>Find option by value</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="csOptValue">Option value</param>
  /// <returns>Zero based index of option</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_FindOptionValue(IntPtr frmField, string csOptValue)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_FindOptionValue_native(frmField, csOptValue);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_CheckControl", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_CheckControl_native(
    IntPtr frmField,
    int iControlIndex,
    [MarshalAs(UnmanagedType.Bool)] bool bChecked,
    [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Toggle Checkbox or Radiobutton</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="iControlIndex">Zerobased index of field's control</param>
  /// <param name="bChecked">True for check, False otherwise</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_CheckControl(
    IntPtr frmField,
    int iControlIndex,
    bool bChecked,
    bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_CheckControl_native(frmField, iControlIndex, bChecked, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetTopVisibleIndex", SetLastError = true)]
  private static extern int FPDFFormField_GetTopVisibleIndex_native(IntPtr frmField);

  /// <summary>Get the first visible index for scrollable list boxes</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>For scrollable list boxes, the top index (the index that the first option visible in the list)</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_GetTopVisibleIndex(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetTopVisibleIndex_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_CountSelectedOptions", SetLastError = true)]
  private static extern int FPDFFormField_CountSelectedOptions_native(IntPtr frmField);

  /// <summary>Count of selected options</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Count of selected options</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_CountSelectedOptions(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_CountSelectedOptions_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetSelectedOptionIndex", SetLastError = true)]
  private static extern int FPDFFormField_GetSelectedOptionIndex_native(IntPtr frmField, int index);

  /// <summary>Get index of selected option specified by index</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="index">Index of item in selected list ranging from 0 to <see cref="M:Patagames.Pdf.Pdfium.FPDFFormField_CountSelectedOptions(System.IntPtr)" /></param>
  /// <returns>Zero based index of item in option</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFFormField_GetSelectedOptionIndex(IntPtr frmField, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetSelectedOptionIndex_native(frmField, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_IsOptionSelected", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_IsOptionSelected_native(IntPtr frmField, int iOptIndex);

  /// <summary>
  /// Determines that the option's item specified by index is selected
  /// </summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="iOptIndex">Zero based index of item in option</param>
  /// <returns>True if selected, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_IsOptionSelected(IntPtr frmField, int iOptIndex)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_IsOptionSelected_native(frmField, iOptIndex);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_SelectOption", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_SelectOption_native(
    IntPtr frmField,
    int iOptIndex,
    [MarshalAs(UnmanagedType.Bool)] bool bSelected,
    [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Select or deselect option's item specified by index</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="iOptIndex">Zero based index of item in option</param>
  /// <param name="bSelected">True for select, False otherwise</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success, false otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_SelectOption(
    IntPtr frmField,
    int iOptIndex,
    bool bSelected,
    bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_SelectOption_native(frmField, iOptIndex, bSelected, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_ClearSelectedOptions", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFFormField_ClearSelectedOptions_native(
    IntPtr frmField,
    [MarshalAs(UnmanagedType.Bool)] bool bNotify = false);

  /// <summary>Deselect specified option</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="bNotify">True for notify application about changes in forms</param>
  /// <returns>True for success, False otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFFormField_ClearSelectedOptions(IntPtr frmField, bool bNotify = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_ClearSelectedOptions_native(frmField, bNotify);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetFlags", SetLastError = true)]
  private static extern FieldFlags FPDFFormField_GetFlags_native(IntPtr frmField);

  /// <summary>Get field flags</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Field's flags specifying various characteristics of the field.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FieldFlags FPDFFormField_GetFlags(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFFormField_GetFlags_native(frmField);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_GetFieldDict", SetLastError = true)]
  private static extern IntPtr FPDFFormField_GetFieldDict_native(IntPtr frmField);

  /// <summary>Get field's dictionary</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <returns>Handle to field's dictionary.</returns>
  /// <remarks>
  /// Each field in a document’s interactive form is defined by a field dictionary, which
  /// must be an indirect object. The field dictionaries may be organized hierarchically
  /// into one or more tree structures. Many field attributes are inheritable, meaning
  /// that if they are not explicitly specified for a given field, their values are taken from
  /// those of its parent in the field hierarchy.
  /// The designation(Required; inheritable) means that an
  /// attribute must be defined for every field, whether explicitly in its own field dictionary or
  /// by inheritance from an ancestor in the hierarchy.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFFormField_GetFieldDict(IntPtr frmField)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFFormField_GetFieldDict_native(frmField));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFFormField_SetFieldDict", SetLastError = true)]
  private static extern void FPDFFormField_SetFieldDict_native(IntPtr frmField, IntPtr dictionary);

  /// <summary>Get field's dictionary</summary>
  /// <param name="frmField">Handle to field. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFInterForm_GetField(System.IntPtr,System.Int32,System.String)" /> function./</param>
  /// <param name="dictionary">Handle to dictionary object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFFormField_SetFieldDict(IntPtr frmField, IntPtr dictionary)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFFormField_SetFieldDict_native(frmField, dictionary);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetRoot", SetLastError = true)]
  private static extern IntPtr FPDF_GetRoot_native(IntPtr document);

  /// <summary>
  /// Get the catalog dictionary for the PDF document contained in the file.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>Handle to the PDF dictionary</returns>
  /// <remarks>
  /// The root of a document’s object hierarchy is the catalog dictionary, located by
  /// means of the Root entry in the trailer of the PDF file.
  /// The catalog contains references to other objects defining the
  /// document’s contents, outline, article threads(PDF 1.1), named destinations, and
  /// other attributes.In addition, it contains information about how the document
  /// should be displayed on the screen, such as whether its outline and thumbnail
  /// page images should be displayed automatically and whether some location other
  /// than the first page should be shown when the document is opened.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_GetRoot(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDF_GetRoot_native(document));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetInfo", SetLastError = true)]
  private static extern IntPtr FPDF_GetInfo_native(IntPtr document);

  /// <summary>
  /// Get the document’s information dictionary -  “Document Information Dictionary”.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>Handle to the PDF dictionary</returns>
  /// <remarks>
  /// <para>
  /// The optional Info entry in the trailer of a PDF file can hold a document information dictionary
  /// containing metadata for the document; Any entry whose value is not known should
  /// be omitted from the dictionary rather than included with an empty string as its
  /// value.
  /// </para>
  /// <para>
  /// Some plug-in extensions may choose to permit searches on the contents of the
  /// document information dictionary. To facilitate browsing and editing, all keys in
  /// the dictionary are fully spelled out, not abbreviated. New keys should be chosen
  /// with care so that they make sense to users.
  /// </para>
  /// <note type="note">
  /// Although consumer applications can store custom metadata in the document
  /// information dictionary, it is inappropriate to store private content or structural information there.
  /// Such information should be stored in the document catalog instead.
  /// </note>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_GetInfo(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDF_GetInfo_native(document));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetTrailer", SetLastError = true)]
  private static extern IntPtr FPDF_GetTrailer_native(IntPtr document);

  /// <summary>Get the trailer of the PDF file.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>Handle to the PDF dictionary</returns>
  /// <remarks>
  /// The trailer of a PDF file enables an application reading the file to quickly find the cross-reference
  /// table and certain special objects.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_GetTrailer(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDF_GetTrailer_native(document));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetEncryptDictionary", SetLastError = true)]
  private static extern IntPtr FPDF_GetEncryptDictionary_native(IntPtr document);

  /// <summary>Get document’s encryption dictionary.</summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <returns>Handle to the PDF dictionary</returns>
  /// <remarks>
  /// A PDF document can be encrypted (PDF 1.1) to protect its contents from unauthorized access.
  /// Encryption applies to all strings and streams in the document’s PDF file, but not to other object types such as
  /// integers and boolean values, which are used primarily to convey information about the document’s structure rather
  /// than its content. Leaving these values unencrypted allows random access to the objects within a document, whereas
  /// encrypting the strings and streams protects the document’s substantive contents.
  /// 
  /// <note type="note">When a PDF stream object refers to an external file, the stream’s contents are not encrypted,
  /// since they are not part of the PDF file itself. However, if the contents of the stream are embedded within the PDF file,
  /// they are encrypted like any other stream in the file. Beginning with PDF 1.5, embedded files may be encrypted in an
  /// otherwise unencrypted document.</note>
  /// 
  /// <para>Encryption-related information is stored in a document’s encryption dictionary, which is the value of the Encrypt
  /// entry in the document’s trailer dictionary. The absence of this entry from the trailer dictionary means that the document
  /// is not encrypted.</para>
  /// 
  /// <para>The encryption dictionary’s Filter entry identifies the file’s security handler, a software module that implements
  /// various aspects of the encryption process and controls access to the contents of the encrypted document.
  /// PDF specifies a standard password-based security handler that all consumer applications are expected to support,
  /// but applications may optionally provide security handlers of their own.</para>
  /// 
  /// <para>The SubFilter entry specifies the syntax of the encryption dictionary contents. It allows interoperability between
  /// handlers; that is, a document may be decrypted by a handler other than the preferred one (the Filter entry) if they both
  /// support the format specified by SubFilter.</para>
  /// 
  /// <para>The V entry, in specifying which algorithm to use, determines the length of the encryption key, on which the
  /// encryption(and decryption) of data in a PDF file is based.For V values 2 and 3, the Length entry specifies the exact
  /// length of the encryption key. In PDF 1.5, a value of 4 for V permits the security handler to use its own encryption
  /// and decryption algorithms and to specify crypt filters to use on specific streams.</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_GetEncryptDictionary(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDF_GetEncryptDictionary_native(document));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_GetPageDictionary", SetLastError = true)]
  private static extern IntPtr FPDF_GetPageDictionary_native(IntPtr document, int index);

  /// <summary>
  /// Get specified page tree node that is the root of the document’s page tree.
  /// </summary>
  /// <param name="document">Handle to document. Returned by <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" /> function.</param>
  /// <param name="index"></param>
  /// <returns>Handle to the PDF dictionary</returns>
  /// <remarks>
  /// The pages of a document are accessed through a structure known as the page tree,
  /// which defines the ordering of pages in the document.The tree structure allows
  /// PDF consumer applications, using only limited memory, to quickly open a
  /// document containing thousands of pages.The tree contains nodes of two types—
  /// intermediate nodes, called page tree nodes, and leaf nodes, called page objects—
  /// whose form is described in the sections below.Applications should be prepared
  /// to handle any form of tree structure built of such nodes.The simplest structure
  /// would consist of a single page tree node that references all of the document’s page
  /// objects directly. However, to optimize application performance, the Acrobat
  /// Distiller program constructs trees of a particular form, known as balanced trees
  /// Further information on this form of tree can be found in Data Structures and
  /// Algorithms, by Aho, Hopcroft, and Ullman (see the Bibliography).
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDF_GetPageDictionary(IntPtr document, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDF_GetPageDictionary_native(document, index));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDF_ClearPageCaches", SetLastError = true)]
  private static extern void FPDF_ClearPageCaches_native(IntPtr document, IntPtr pageDictionary);

  /// <summary>
  /// Remove global caches and caches associated with the specified page.
  /// </summary>
  /// <param name="document">The handle to a document.</param>
  /// <param name="pageDictionary">Dictionary of the page.</param>
  /// <remarks>The page must be closed before calling this method. The page dictionary must be retrieved and stored before the page is closed.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDF_ClearPageCaches(IntPtr document, IntPtr pageDictionary)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDF_ClearPageCaches_native(document, pageDictionary);
        Pdfium.PLE();
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetType", SetLastError = true)]
  private static extern IndirectObjectTypes FPDFOBJ_GetType_native(IntPtr obj_handle);

  /// <summary>Get type of an PDF object</summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>One of the ObjectTypes enumerator.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IndirectObjectTypes FPDFOBJ_GetType(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_GetType_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetObjNum", SetLastError = true)]
  private static extern int FPDFOBJ_GetObjNum_native(IntPtr obj_handle);

  /// <summary>
  /// Get a positive integer object number. Indirect objects are often numbered sequentially within a PDF file, but this is not required; object numbers may be assigned in any arbitrary order.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>A positive integer object number.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFOBJ_GetObjNum(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_GetObjNum_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetGenNum", SetLastError = true)]
  private static extern int FPDFOBJ_GetGenNum_native(IntPtr obj_handle);

  /// <summary>
  /// Get a non-negative integer generation number. In a newly created file, all indirect objects have generation numbers of 0. Nonzero generation numbers may be introduced when the file is later updated;
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>A non-negative integer generation number; -1 if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFOBJ_GetGenNum(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_GetGenNum_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_Clone", SetLastError = true)]
  private static extern IntPtr FPDFOBJ_Clone_native(IntPtr obj_handle, bool bDirect);

  /// <summary>Create a new PDF object based on this object.</summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <param name="bDirect">A flag indicating whether indirect objects should be cloned as direct objects.</param>
  /// <returns>Handle to a newly created PDF object.</returns>
  /// <remarks>
  /// <para>Call <see cref="M:Patagames.Pdf.Pdfium.FPDFOBJ_Release(System.IntPtr)" /> method when you no longer need to use a PDF object.</para>
  /// <para>bDirect should be <strong>False</strong> to keep indirect objects as is;
  /// <strong>True</strong> to convert indirect objects to direct objects.</para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFOBJ_Clone(IntPtr obj_handle, bool bDirect = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_Clone_native(obj_handle, bDirect);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetDirect", SetLastError = true)]
  private static extern IntPtr FPDFOBJ_GetDirect_native(IntPtr obj_handle);

  /// <summary>Get inderect object</summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>Handle to inderect object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFOBJ_GetDirect(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_GetDirect_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_Release", SetLastError = true)]
  private static extern void FPDFOBJ_Release_native(IntPtr obj_handle);

  /// <summary>Delete PDF object.</summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFOBJ_Release(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFOBJ_Release_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetString", SetLastError = true)]
  private static extern int FPDFOBJ_GetString_native(IntPtr obj_handle, byte[] buffer, int len);

  /// <summary>Returns a string that represents the current object.</summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>String that represents the current object or null if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFOBJ_GetString(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int stringNative = Pdfium.FPDFOBJ_GetString_native(obj_handle, (byte[]) null, 0);
        if (stringNative <= 0)
          return (string) null;
        byte[] numArray = new byte[stringNative];
        Pdfium.FPDFOBJ_GetString_native(obj_handle, numArray, stringNative);
        return Pdfium.DefaultAnsiEncoding.GetString(numArray, 0, stringNative - 1);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetUnicodeText", SetLastError = true)]
  private static extern int FPDFOBJ_GetUnicodeText_native(
    IntPtr obj_handle,
    byte[] buffer,
    int len);

  /// <summary>
  /// Returns a unicode string that represents the current object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>Unicode string that represents the current object or null if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFOBJ_GetUnicodeText(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        int unicodeTextNative = Pdfium.FPDFOBJ_GetUnicodeText_native(obj_handle, (byte[]) null, 0);
        if (unicodeTextNative <= 0)
          return (string) null;
        byte[] numArray = new byte[unicodeTextNative];
        Pdfium.FPDFOBJ_GetUnicodeText_native(obj_handle, numArray, unicodeTextNative);
        return Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetNumber", SetLastError = true)]
  private static extern void FPDFOBJ_GetNumber_native(IntPtr obj_handle, [MarshalAs(UnmanagedType.R4)] out float num);

  /// <summary>
  /// Returns a floating-point representation of the specified object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>A floating-point representation of the specified object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFOBJ_GetNumber(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float num;
        Pdfium.FPDFOBJ_GetNumber_native(obj_handle, out num);
        return num;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetInteger", SetLastError = true)]
  private static extern int FPDFOBJ_GetInteger_native(IntPtr obj_handle);

  /// <summary>
  /// Returns an integer representation of the specified object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>An integer representation of the specified object.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFOBJ_GetInteger(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_GetInteger_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetDict", SetLastError = true)]
  private static extern IntPtr FPDFOBJ_GetDict_native(IntPtr obj_handle);

  /// <summary>
  /// Returns a Dictionary representation of the specified object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>Handle to the dictionary, IntPtr.Zero if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFOBJ_GetDict(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFOBJ_GetDict_native(obj_handle));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetArray", SetLastError = true)]
  private static extern IntPtr FPDFOBJ_GetArray_native(IntPtr obj_handle);

  /// <summary>
  /// Returns an Array representation of the specified object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>Handle to the PDF Array object, IntPtr.Zero if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFOBJ_GetArray(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_GetArray_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_SetString", SetLastError = true)]
  private static extern void FPDFOBJ_SetString_native(IntPtr obj_handle, [MarshalAs(UnmanagedType.LPStr)] string str);

  /// <summary>Insert string into PDF object</summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <param name="str">The text to be inserted into a object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFOBJ_SetString(IntPtr obj_handle, string str)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFOBJ_SetString_native(obj_handle, str);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsModified", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsModified_native(IntPtr obj_handle);

  /// <summary>Return TRUE if object was modified</summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>Always FALSE in Pdfium</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsModified(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsModified_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_SetIsModified", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_SetIsModified_native(IntPtr obj_handle, [MarshalAs(UnmanagedType.Bool)] bool value);

  /// <summary>Set IsModifed flag for specified object</summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <param name="value">Flags value.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFOBJ_SetIsModified(IntPtr obj_handle, bool value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFOBJ_SetIsModified_native(obj_handle, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsArray", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsArray_native(IntPtr obj_handle);

  /// <summary>
  /// Gets a value that indicates whether the PDF object is an array.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>True if the specified object is an array; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsArray(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsArray_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsBoolean", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsBoolean_native(IntPtr obj_handle);

  /// <summary>
  /// Gets a value that indicates whether the PDF object is a Boolean object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>True if the specified object is a boolean object; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsBoolean(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsBoolean_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsDictionary", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsDictionary_native(IntPtr obj_handle);

  /// <summary>
  /// Gets a value that indicates whether the PDF object is a dictionary.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>True if the specified object is a dictionary object; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsDictionary(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsDictionary_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsName", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsName_native(IntPtr obj_handle);

  /// <summary>
  /// Gets a value that indicates whether the PDF object is a Name object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>True if the specified object is a Name object; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsName(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsName_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsNumber", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsNumber_native(IntPtr obj_handle);

  /// <summary>
  /// Gets a value that indicates whether the PDF object is a Number object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>True if the specified object is a Number object; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsNumber(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsNumber_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsReference", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsReference_native(IntPtr obj_handle);

  /// <summary>
  /// Gets a value that indicates whether the PDF object is a indirect object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>True if the specified object is a indirect object; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsReference(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsReference_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsStream", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsStream_native(IntPtr obj_handle);

  /// <summary>
  /// Gets a value that indicates whether the PDF object is a Stream object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>True if the specified object is a Stream object; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsStream(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsStream_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_IsString", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool FPDFOBJ_IsString_native(IntPtr obj_handle);

  /// <summary>
  /// Gets a value that indicates whether the PDF object is a String object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>True if the specified object is a String object; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFOBJ_IsString(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_IsString_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_GetParentObj", SetLastError = true)]
  private static extern IntPtr FPDFOBJ_GetParentObj_native(IntPtr obj_handle);

  /// <summary>
  /// Returns a handle to the container for specified object.
  /// </summary>
  /// <param name="obj_handle">Handle to the PDF object</param>
  /// <returns>A handle to the dictionary or to the array which contains specified object, IntPtr.Zero if there is no any container.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFOBJ_GetParentObj(IntPtr obj_handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFOBJ_GetParentObj_native(obj_handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_SubscribeOnDestroy", SetLastError = true)]
  private static extern void FPDFOBJ_SetDestroyCallback_native(
    IntPtr obj_handle,
    [MarshalAs(UnmanagedType.FunctionPtr)] Pdfium.InternalObjectDestroyCallback callback);

  /// <summary>
  /// Set a callback that is called immediately before the object is destroyed.
  /// </summary>
  /// <param name="obj_handle">A handle to the object for which the callback should be set.</param>
  /// <param name="callback">A delegate that is called before the object is destroyed.</param>
  public static void FPDFOBJ_SetDestroyCallback(
    IntPtr obj_handle,
    Pdfium.InternalObjectDestroyCallback callback)
  {
    if (callback == null)
      throw new ArgumentNullException(nameof (callback));
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFOBJ_SetDestroyCallback_native(obj_handle, callback);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFOBJ_UnsubscribeOnDestroy", SetLastError = true)]
  private static extern void FPDFOBJ_UnsubscribeOnDestroy_native(
    IntPtr obj_handle,
    [MarshalAs(UnmanagedType.FunctionPtr)] Pdfium.InternalObjectDestroyCallback callback);

  /// <summary>
  /// Delete a callback that is called immediately before the object is destroyed.
  /// </summary>
  /// <param name="obj_handle">A handle to the object for which the callback should be set.</param>
  /// <param name="callback">A delegate that is called before the object is destroyed.</param>
  public static void FPDFOBJ_UnsubscribeOnDestroy(
    IntPtr obj_handle,
    Pdfium.InternalObjectDestroyCallback callback)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFOBJ_UnsubscribeOnDestroy_native(obj_handle, callback);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFBOOLEAN_Create", SetLastError = true)]
  private static extern IntPtr FPDFBOOLEAN_Create_native(bool value);

  /// <summary>Create new Boolean object</summary>
  /// <param name="value">Initial value for this object</param>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFBOOLEAN_Create(bool value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFBOOLEAN_Create_native(value));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFNUMBER_CreateInt", SetLastError = true)]
  private static extern IntPtr FPDFNUMBER_CreateInt_native(int value);

  /// <summary>Create new Number object as an integer</summary>
  /// <param name="value">Initial value for this object</param>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFNUMBER_CreateInt(int value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFNUMBER_CreateInt_native(value));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFNUMBER_CreateFloat", SetLastError = true)]
  private static extern IntPtr FPDFNUMBER_CreateFloat_native([MarshalAs(UnmanagedType.R4)] float value);

  /// <summary>Create new Number object as a float</summary>
  /// <param name="value">Initial value for this object</param>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFNUMBER_CreateFloat(float value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFNUMBER_CreateFloat_native(value));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFNUMBER_IsInteger", SetLastError = true)]
  private static extern bool FPDFNUMBER_IsInteger_native(IntPtr handle);

  /// <summary>
  /// Returns a Boolean value that indicates whether a Number is an integer.
  /// </summary>
  /// <param name="handle">Handle to a number object</param>
  /// <returns>true if the Number object is an integer, otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFNUMBER_IsInteger(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFNUMBER_IsInteger_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTRING_CreateEmpty", SetLastError = true)]
  private static extern IntPtr FPDFSTRING_CreateEmpty_native();

  /// <summary>Create empty String object</summary>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFSTRING_CreateEmpty()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFSTRING_CreateEmpty_native());
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTRING_CreateChar", SetLastError = true)]
  private static extern IntPtr FPDFSTRING_CreateChar_native([MarshalAs(UnmanagedType.LPStr)] string value, bool bHex);

  /// <summary>
  /// Create new String object and initialise it with ANSI string
  /// </summary>
  /// <param name="value">Initial value for this object</param>
  /// <param name="bHex">Indicates whether a value is a HEX</param>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFSTRING_CreateChar(string value, bool bHex)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFSTRING_CreateChar_native(value, bHex));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTRING_CreateUnicode", SetLastError = true)]
  private static extern IntPtr FPDFSTRING_CreateUnicode_native([MarshalAs(UnmanagedType.LPWStr)] string value);

  /// <summary>
  /// Create new String object and initialise it with unicode string
  /// </summary>
  /// <param name="value">Initial value for this object</param>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFSTRING_CreateUnicode(string value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFSTRING_CreateUnicode_native(value));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTRING_IsHex", SetLastError = true)]
  private static extern bool FPDFSTRING_IsHex_native(IntPtr handle);

  /// <summary>
  /// Returns a Boolean value that indicates whether a String is a hex.
  /// </summary>
  /// <param name="handle">Handle to a string object</param>
  /// <returns>true if the String object is a hex, otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFSTRING_IsHex(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFSTRING_IsHex_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFNAME_Create", SetLastError = true)]
  private static extern IntPtr FPDFNAME_Create_native([MarshalAs(UnmanagedType.LPStr)] string value);

  /// <summary>Create new Name object</summary>
  /// <param name="value">Initial value for this object</param>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFNAME_Create(string value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFNAME_Create_native(value));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFNULL_Create", SetLastError = true)]
  private static extern IntPtr FPDFNULL_Create_native();

  /// <summary>Create new Null object</summary>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFNULL_Create()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFNULL_Create_native());
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_Create", SetLastError = true)]
  private static extern IntPtr FPDFSTREAM_Create_native(IntPtr data, int size, IntPtr dictionary);

  /// <summary>Create new Stream object</summary>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFSTREAM_Create()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFSTREAM_Create_native(IntPtr.Zero, 0, IntPtr.Zero));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_GetRawSize", SetLastError = true)]
  private static extern int FPDFSTREAM_GetRawSize_native(IntPtr handle);

  /// <summary>Gets the length in bytes of the stream.</summary>
  /// <param name="handle">Handle to a stream object</param>
  /// <returns>A integer value representing the length of the stream in bytes.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFSTREAM_GetRawSize(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFSTREAM_GetRawSize_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_GetRawData", SetLastError = true)]
  private static extern IntPtr FPDFSTREAM_GetRawData_native(IntPtr handle);

  /// <summary>Get underlying buffer of the stream.</summary>
  /// <param name="handle">Handle to a stream object</param>
  /// <returns>The stream content in an unmanaged memory or IntPtr.Zero if any errors occurs.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFSTREAM_GetRawData(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFSTREAM_GetRawData_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  /// <summary>
  /// Get a managed copy of underlying buffer of the stream.
  /// </summary>
  /// <param name="handle">Handle to a stream object</param>
  /// <returns>A byte array containing the content of the stream.</returns>
  public static byte[] FPDFSTREAM_GetData(IntPtr handle)
  {
    int rawSize = Pdfium.FPDFSTREAM_GetRawSize(handle);
    if (rawSize < 0)
      return (byte[]) null;
    IntPtr rawData = Pdfium.FPDFSTREAM_GetRawData(handle);
    if (rawData == IntPtr.Zero)
      return (byte[]) null;
    byte[] destination = new byte[rawSize];
    if (rawSize == 0)
      return destination;
    Marshal.Copy(rawData, destination, 0, rawSize);
    return destination;
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_GetDecodedData", SetLastError = true)]
  private static extern IntPtr FPDFSTREAM_GetDecodedData_native(IntPtr handle, out int size);

  /// <summary>Decodes stream contents.</summary>
  /// <param name="handle">Handle to a stream object</param>
  /// <param name="size">The lenth of decoded contetnt</param>
  /// <returns>The decoded Stream contents in unmanaged memory or IntPtr.Zero if any errors occurs.</returns>
  /// <remarks>
  /// Returned pointer should be released by calling <see cref="M:Patagames.Pdf.Pdfium.FPDFSTREAM_ReleaseDecodedData(System.IntPtr)" />.
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFSTREAM_GetDecodedData(IntPtr handle, out int size)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFSTREAM_GetDecodedData_native(handle, out size);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_ReleaseDecodedData", SetLastError = true)]
  private static extern void FPDFSTREAM_ReleaseDecodedData_native(IntPtr data);

  /// <summary>Release decoded content</summary>
  /// <param name="data">Pointer to decoded content returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFSTREAM_GetDecodedData(System.IntPtr,System.Int32@)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFSTREAM_ReleaseDecodedData(IntPtr data)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFSTREAM_ReleaseDecodedData_native(data);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_SetData", SetLastError = true)]
  private static extern void FPDFSTREAM_SetData_native(
    IntPtr handle,
    IntPtr data,
    int size,
    bool bCompressed,
    bool bKeepBuf);

  /// <summary>Set specified raw data into current stream</summary>
  /// <param name="handle">Handle to an stream object</param>
  /// <param name="data">The stream raw data in unmanaged memory</param>
  /// <param name="size">The length in bytes of the data</param>
  /// <param name="bCompressed">Indicates whether a passed buffer is compressed or not.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFSTREAM_SetData(IntPtr handle, IntPtr data, int size, bool bCompressed)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFSTREAM_SetData_native(handle, data, size, bCompressed, false);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_SetData", SetLastError = true)]
  private static extern void FPDFSTREAM_SetData_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPArray)] byte[] data,
    int size,
    bool bCompressed,
    bool bKeepBuf);

  /// <summary>Set specified raw data into current stream</summary>
  /// <param name="handle">Handle to an stream object</param>
  /// <param name="data">The stream raw data in managed memory</param>
  /// <param name="bCompressed">Indicates whether a passed buffer is compressed or not.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFSTREAM_SetData(IntPtr handle, byte[] data, bool bCompressed)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFSTREAM_SetData_native(handle, data, data.Length, bCompressed, false);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_InitStream", SetLastError = true)]
  private static extern void FPDFSTREAM_InitStream_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPArray)] byte[] data,
    int size,
    IntPtr dictionary);

  /// <summary>Initialize the stream with a sequence of bytes.</summary>
  /// <param name="handle">Handle to a stream object</param>
  /// <param name="data">An array of bytes. This method copies all bytes from data to the current stream.</param>
  /// <param name="dictionary">Handle to the dictionary object.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFSTREAM_InitStream(IntPtr handle, byte[] data, IntPtr dictionary)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFSTREAM_InitStream_native(handle, data, data.Length, dictionary);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_InitStreamFromFile", SetLastError = true)]
  private static extern void FPDFSTREAM_InitStreamFromFile_native(
    IntPtr handle,
    IntPtr fileHandle,
    IntPtr dictionary);

  /// <summary>
  /// Initialize the stream with a sequence of bytes readed from specified file.
  /// </summary>
  /// <param name="handle">Handle to a stream object</param>
  /// <param name="file">Hanlde to the file opened by <see cref="M:Patagames.Pdf.Pdfium.FPDF_OpenFile(System.String)" /> functiuon.</param>
  /// <param name="dictionary">Handle to the dictionary object.</param>
  /// <remarks>The file should be stay opened while the stream object is used.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFSTREAM_InitStreamFromFile(IntPtr handle, IntPtr file, IntPtr dictionary)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFSTREAM_InitStreamFromFile_native(handle, file, dictionary);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_ReadRawData", SetLastError = true)]
  private static extern bool FPDFSTREAM_ReadRawData_native(
    IntPtr handle,
    int start_pos,
    [MarshalAs(UnmanagedType.LPArray), Out] byte[] buf,
    int buf_len);

  /// <summary>
  /// Reads a specified number of bytes from the current stream from specified position.
  /// </summary>
  /// <param name="handle">Handle to a stream object</param>
  /// <param name="startPos">The ofset from the begining of stream</param>
  /// <param name="count">The number of bytes to read from stream</param>
  /// <param name="buf">An array of readed bytes.</param>
  /// <returns>True for successfull, false otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFSTREAM_ReadRawData(IntPtr handle, int startPos, int count, byte[] buf)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFSTREAM_ReadRawData_native(handle, startPos, buf, count);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFSTREAM_IsMemoryBased", SetLastError = true)]
  private static extern bool FPDFSTREAM_IsMemoryBased_native(IntPtr handle);

  /// <summary>
  /// Returns a Boolean value that indicates whether a Stream was initialized from memory.
  /// </summary>
  /// <param name="handle">Handle to a number object</param>
  /// <returns>true if the Stream object was initialized from the memory, otherwise false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFSTREAM_IsMemoryBased(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFSTREAM_IsMemoryBased_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_GetIndirectObject", SetLastError = true)]
  private static extern IntPtr FPDFHOLDER_GetIndirectObject_native(IntPtr objects_list, int objnum);

  /// <summary>Gets an inderect object from objects list.</summary>
  /// <param name="objects_list">List of indirect objects</param>
  /// <param name="objnum">Object's number</param>
  /// <returns>Hanle to the inderect objects or IntPtr.Zero if any error is occurred.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFHOLDER_GetIndirectObject(IntPtr objects_list, int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFHOLDER_GetIndirectObject_native(objects_list, objnum);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_AddIndirectObject", SetLastError = true)]
  private static extern int FPDFHOLDER_AddIndirectObject_native(
    IntPtr objects_list,
    IntPtr indirect_object);

  /// <summary>Adds an object to the end of the list</summary>
  /// <param name="objects_list">The list of objects to which you want to add an object.</param>
  /// <param name="indirect_object">Handle to the object.</param>
  /// <returns>Return the number of oject which was added or zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFHOLDER_AddIndirectObject(IntPtr objects_list, IntPtr indirect_object)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFHOLDER_AddIndirectObject_native(objects_list, indirect_object);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_ReleaseIndirectObject", SetLastError = true)]
  private static extern void FPDFHOLDER_ReleaseIndirectObject_native(
    IntPtr objects_list,
    int objnum);

  /// <summary>
  /// Destroy specified object and remove its from the list.
  /// </summary>
  /// <param name="objects_list">List of indirect objects</param>
  /// <param name="objnum">Object's number</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFHOLDER_ReleaseIndirectObject(IntPtr objects_list, int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFHOLDER_ReleaseIndirectObject_native(objects_list, objnum);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_InsertIndirectObject", SetLastError = true)]
  private static extern bool FPDFHOLDER_InsertIndirectObject_native(
    IntPtr objects_list,
    int objnum,
    IntPtr indirect_object);

  /// <summary>
  /// Replace the object with the specified number by the specified object
  /// </summary>
  /// <param name="objects_list">The list of objects to which you want to insert an object.</param>
  /// <param name="objnum">The existing number of object in list.</param>
  /// <param name="indirect_object">Handle to the object which should be inserted.</param>
  /// <returns>
  /// True if successfull; false if any error has occured;
  /// <note type="note">This methd release the old object before replece it by new one.</note>
  /// </returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFHOLDER_InsertIndirectObject(
    IntPtr objects_list,
    int objnum,
    IntPtr indirect_object)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFHOLDER_InsertIndirectObject_native(objects_list, objnum, indirect_object);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_GetLastObjNum", SetLastError = true)]
  private static extern int FPDFHOLDER_GetLastObjNum_native(IntPtr objects_list);

  /// <summary>Gets the number of the  last object in the list.</summary>
  /// <param name="objects_list">List of indirect objects.</param>
  /// <returns>The number of the  last object in the list.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFHOLDER_GetLastObjNum(IntPtr objects_list)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFHOLDER_GetLastObjNum_native(objects_list);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_FromPdfDocument", SetLastError = true)]
  private static extern IntPtr FPDFHOLDER_FromPdfDocument_native(IntPtr objects_list);

  /// <summary>
  /// Gets the list of indirect objects from specified PDF document
  /// </summary>
  /// <param name="pdf_doc">Handle to a PDF document</param>
  /// <returns>Handle to the list of Indirect objects or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFHOLDER_FromPdfDocument(IntPtr pdf_doc)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFHOLDER_FromPdfDocument_native(pdf_doc));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_FromFdfDocument", SetLastError = true)]
  private static extern IntPtr FPDFHOLDER_FromFdfDocument_native(IntPtr fdf_doc);

  /// <summary>
  /// Gets the list of indirect objects from specified FDF document
  /// </summary>
  /// <param name="fdf_doc">Handle to a FDF document</param>
  /// <returns>Handle to the list of Indirect objects or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFHOLDER_FromFdfDocument(IntPtr fdf_doc)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFHOLDER_FromFdfDocument_native(fdf_doc));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_GetCount", SetLastError = true)]
  private static extern uint FPDFHOLDER_GetCount_native(IntPtr objects_list);

  /// <summary>Gets the number of elements contained in the list</summary>
  /// <param name="objects_list">List of indirect objects.</param>
  /// <returns>The number of elements or Zero if any error has occured</returns>
  [HandleProcessCorruptedStateExceptions]
  public static uint FPDFHOLDER_GetCount(IntPtr objects_list)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFHOLDER_GetCount_native(objects_list);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_GetItemIterator", SetLastError = true)]
  private static extern IntPtr FPDFHOLDER_GetItemIterator_native(IntPtr objects_list);

  /// <summary>Returns an iterator that iterates through a list.</summary>
  /// <param name="objects_list">List of indirect objects.</param>
  /// <returns>Handle to the iterator, or IntPtr.Zero if any error has occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFHOLDER_GetItemIterator(IntPtr objects_list)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFHOLDER_GetItemIterator_native(objects_list);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_ReleaseItemIterator", SetLastError = true)]
  private static extern void FPDFHOLDER_ReleaseItemIterator_native(IntPtr iterator);

  /// <summary>Delete item iterator</summary>
  /// <param name="iterator">Handle to iterator retrived by <see cref="M:Patagames.Pdf.Pdfium.FPDFHOLDER_GetItemIterator(System.IntPtr)" />\</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFHOLDER_ReleaseItemIterator(IntPtr iterator)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFHOLDER_ReleaseItemIterator_native(iterator);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_GetItem", SetLastError = true)]
  private static extern bool FPDFHOLDER_GetItem_native(
    IntPtr iterator,
    out uint objNum,
    out IntPtr obj);

  /// <summary>Gets the item from iterator</summary>
  /// <param name="iterator">Handle to iterator retrived by <see cref="M:Patagames.Pdf.Pdfium.FPDFHOLDER_GetItemIterator(System.IntPtr)" />\</param>
  /// <param name="objNum">Object number</param>
  /// <param name="obj">Handle to an object</param>
  /// <returns>True if the item was retrieved or false if no more any items or eny error has occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFHOLDER_GetItem(IntPtr iterator, out int objNum, out IntPtr obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        uint objNum1;
        int num = Pdfium.FPDFHOLDER_GetItem_native(iterator, out objNum1, out obj) ? 1 : 0;
        objNum = (int) objNum1;
        return num != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFCROSSREF_Rebuild", SetLastError = true)]
  private static extern bool FPDFCROSSREF_Rebuild_native(IntPtr document);

  /// <summary>Rebuilds cross-reference table</summary>
  /// <param name="document">Handle to pdf document</param>
  /// <returns>True if successfull; false if any error has occured;</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFCROSSREF_Rebuild(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFCROSSREF_Rebuild_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFCROSSREF_Remove", SetLastError = true)]
  private static extern void FPDFCROSSREF_Remove_native(IntPtr document, int objnum);

  /// <summary>
  /// Removes object with specified number from cross-reference table
  /// </summary>
  /// <param name="document">Handle to pdf document</param>
  /// <param name="objnum">Object's number</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFCROSSREF_Remove(IntPtr document, int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFCROSSREF_Remove_native(document, objnum);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFCROSSREF_Shrink", SetLastError = true)]
  private static extern void FPDFCROSSREF_Shrink_native(IntPtr document, int objnum);

  /// <summary>Shrinks cross-reference table</summary>
  /// <param name="document">Handle to pdf document</param>
  /// <param name="objnum">Object's number</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFCROSSREF_Shrink(IntPtr document, int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFCROSSREF_Shrink_native(document, objnum);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFCROSSREF_GetCount", SetLastError = true)]
  private static extern uint FPDFCROSSREF_GetCount_native(IntPtr document);

  /// <summary>
  /// Gets the number of elements contained in the cross-reference table
  /// </summary>
  /// <param name="document">Handle to pdf document</param>
  /// <returns>The number of elements or Zero if any error has occured</returns>
  [HandleProcessCorruptedStateExceptions]
  public static uint FPDFCROSSREF_GetCount(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFCROSSREF_GetCount_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFCROSSREF_GetItemIterator", SetLastError = true)]
  private static extern IntPtr FPDFCROSSREF_GetItemIterator_native(IntPtr document);

  /// <summary>
  /// Returns an iterator that iterates through a cross-reference table.
  /// </summary>
  /// <param name="document">Handle to pdf document</param>
  /// <returns>Handle to the iterator, or IntPtr.Zero if any error has occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFCROSSREF_GetItemIterator(IntPtr document)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFCROSSREF_GetItemIterator_native(document);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFCROSSREF_ReleaseItemIterator", SetLastError = true)]
  private static extern void FPDFCROSSREF_ReleaseItemIterator_native(IntPtr iterator);

  /// <summary>Delete item iterator</summary>
  /// <param name="iterator">Handle to iterator retrived by <see cref="M:Patagames.Pdf.Pdfium.FPDFCROSSREF_GetItemIterator(System.IntPtr)" />\</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFCROSSREF_ReleaseItemIterator(IntPtr iterator)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFCROSSREF_ReleaseItemIterator_native(iterator);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFCROSSREF_GetItem", SetLastError = true)]
  private static extern bool FPDFCROSSREF_GetItem_native(
    IntPtr iterator,
    out uint objNum,
    out int position,
    [MarshalAs(UnmanagedType.I1)] out byte type,
    [MarshalAs(UnmanagedType.I2)] out short gennum);

  /// <summary>Gets the item from iterator</summary>
  /// <param name="iterator">Handle to iterator retrived by <see cref="M:Patagames.Pdf.Pdfium.FPDFCROSSREF_GetItemIterator(System.IntPtr)" />\</param>
  /// <param name="objNum">Object number</param>
  /// <param name="position">Position in PDF body in bytes</param>
  /// <param name="type">Type</param>
  /// <param name="gennum">Generation number</param>
  /// <returns>True if the item was retrieved or false if no more items or eny error has occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFCROSSREF_GetItem(
    IntPtr iterator,
    out int objNum,
    out int position,
    out int type,
    out int gennum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        uint objNum1;
        byte type1;
        short gennum1;
        int num = Pdfium.FPDFCROSSREF_GetItem_native(iterator, out objNum1, out position, out type1, out gennum1) ? 1 : 0;
        objNum = (int) objNum1;
        type = (int) type1;
        gennum = (int) gennum1;
        return num != 0;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_GetRefsToObjects", SetLastError = true)]
  private static extern IntPtr FPDFHOLDER_GetRefsToObjects_native(
    IntPtr document,
    out int count,
    bool parsedOnly);

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_GetRefsToObjectsEx", SetLastError = true)]
  private static extern IntPtr FPDFHOLDER_GetRefsToObjectsEx_native(
    IntPtr document,
    IntPtr root,
    out int count,
    bool parsedOnly);

  /// <summary>
  /// Get an array containing pdf objects which are referenced by other objects from the document catalog.
  /// </summary>
  /// <param name="doc">Handle to a PDF document.</param>
  /// <param name="count">The number of elements actually contained in the array.</param>
  /// <param name="parsedOnly">Flag indicating that only previously parsed objects should be examined.</param>
  /// <param name="root">The root object from which to start parsing the document.</param>
  /// <returns>Handle to an array, or IntPtr.Zero if nothing was found. To get extended error information, call <see cref="M:Patagames.Pdf.Pdfium.FPDF_GetLastError" />.</returns>
  /// <remarks>
  /// <para>This method recursively scans the document catalog, in order to build the array.</para>
  /// <para>This method cannot accept newly created documents.
  /// If you pass such document FPDFHOLDER_GetRefsToObjects would fail and the <see cref="M:Patagames.Pdf.Pdfium.FPDF_GetLastError" />
  /// function would return REQUIRED_DATA_IS_ABSENT (536871427).
  /// To get the handle to the document, that can be passed to the FromPdfDocument method,
  /// you must save the document to a temporary file or an array of bytes, and then open it with the <see cref="M:Patagames.Pdf.Pdfium.FPDF_LoadDocument(System.String,System.String)" />".
  /// </para>
  /// </remarks>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFHOLDER_GetRefsToObjects(
    IntPtr doc,
    out int count,
    bool parsedOnly = false,
    IntPtr root = default (IntPtr))
  {
    using (Lock.SyncMT)
    {
      try
      {
        IntPtr zero = IntPtr.Zero;
        IntPtr num = !(root != IntPtr.Zero) ? Pdfium.PLE(Pdfium.FPDFHOLDER_GetRefsToObjects_native(doc, out count, parsedOnly)) : Pdfium.PLE(Pdfium.FPDFHOLDER_GetRefsToObjectsEx_native(doc, root, out count, parsedOnly));
        if (count == 0)
          return IntPtr.Zero;
        return !(num == IntPtr.Zero) ? num : throw new UnknownErrorException(Error.err0054);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFHOLDER_ReleaseRefsToObjects", SetLastError = true)]
  private static extern void FPDFHOLDER_ReleaseRefsToObjects_native(IntPtr list);

  /// <summary>
  /// Releases all resources allocated by the <see cref="M:Patagames.Pdf.Pdfium.FPDFHOLDER_GetRefsToObjects(System.IntPtr,System.Int32@,System.Boolean,System.IntPtr)" />
  /// </summary>
  /// <param name="arrayHandle">Handle to an array returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFHOLDER_GetRefsToObjects(System.IntPtr,System.Int32@,System.Boolean,System.IntPtr)" /></param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFHOLDER_ReleaseRefsToObjects(IntPtr arrayHandle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFHOLDER_ReleaseRefsToObjects_native(arrayHandle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFREF_Create", SetLastError = true)]
  private static extern IntPtr FPDFREF_Create_native(IntPtr objects_list, int objnum);

  /// <summary>
  /// Creates a Reference object which is linked with an object inside the list of objects.
  /// </summary>
  /// <param name="objects_list">List of indirect objects</param>
  /// <param name="objnum">Object's number in the specified list</param>
  /// <returns>Handle to the newly created Reference object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFREF_Create(IntPtr objects_list, int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFREF_Create_native(objects_list, objnum));
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFREF_GetObjList", SetLastError = true)]
  private static extern IntPtr FPDFREF_GetObjList_native(IntPtr handle);

  /// <summary>
  /// Gets a list of objects in which is linked with the specified reference object.
  /// </summary>
  /// <param name="handle">Handle to the Reference object</param>
  /// <returns>Handle ro the list of objects or IntPtr.Zero if any error is occured</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFREF_GetObjList(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFREF_GetObjList_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFREF_GetRefObjNum", SetLastError = true)]
  private static extern int FPDFREF_GetRefObjNum_native(IntPtr handle);

  /// <summary>
  /// Gets an object number which is linked with the specified reference object.
  /// </summary>
  /// <param name="handle">Handle to the Reference object.</param>
  /// <returns>The object number or -1 if eny error is occured./</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFREF_GetRefObjNum(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFREF_GetRefObjNum_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFREF_SetRef", SetLastError = true)]
  private static extern void FPDFREF_SetRef_native(IntPtr handle, IntPtr objects_list, int objnum);

  /// <summary>
  /// Changes a link of Reference object to the specified object in the specified list.
  /// </summary>
  /// <param name="handle">Handle to the Reference object.</param>
  /// <param name="objects_list">List of indirect objects</param>
  /// <param name="objnum">Object's number in the specified list</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFREF_SetRef(IntPtr handle, IntPtr objects_list, int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFREF_SetRef_native(handle, objects_list, objnum);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_Enum", SetLastError = true)]
  private static extern bool FPDFDICT_Enum_native(IntPtr handle, [MarshalAs(UnmanagedType.FunctionPtr)] Pdfium.DictEnumCallback callback);

  /// <summary>
  /// Enumerates all top-level items in dictionary by passing the Key and Value of each item, in turn, to an application-defined callback function.
  /// FPDFDICT_Enum continues until the last item is enumerated.
  /// </summary>
  /// <param name="handle">Handle to the Dictionary object</param>
  /// <param name="callback">The application-defined callback function</param>
  /// <returns>True if successful; false otherwise.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFDICT_Enum(IntPtr handle, Pdfium.DictEnumCallback callback)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_Enum_native(handle, callback);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_Create", SetLastError = true)]
  private static extern IntPtr FPDFDICT_Create_native();

  /// <summary>Create new Dictionary object</summary>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDICT_Create()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFDICT_Create_native());
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetCount", SetLastError = true)]
  private static extern int FPDFDICT_GetCount_native(IntPtr handle);

  /// <summary>Gets the number of keys contained in the Dictionary.</summary>
  /// <param name="handle">Handle to Dictionary object</param>
  /// <returns>A zero-based number of keys or -1 if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFDICT_GetCount(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetCount_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetObjectBy", SetLastError = true)]
  private static extern IntPtr FPDFDICT_GetObjectBy_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key);

  /// <summary>
  /// Gets the PDF object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A handle to PDF object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDICT_GetObjectBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetObjectBy_native(handle, key);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetDirectObjectBy", SetLastError = true)]
  private static extern IntPtr FPDFDICT_GetDirectObjectBy_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key);

  /// <summary>
  /// Gets the PDF object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A handle to PDF object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDICT_GetDirectObjectBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetDirectObjectBy_native(handle, key);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetStringBy", SetLastError = true)]
  private static extern int FPDFDICT_GetStringBy_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>Gets the string associated with the specified key.</summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A string associated with the specified key or null if any error is occured.</returns>
  /// <remarks>The string is decoding using the <see cref="P:Patagames.Pdf.Pdfium.DefaultAnsiEncoding" /> property.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFDICT_GetStringBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] buffer = (byte[]) null;
        int stringByNative = Pdfium.FPDFDICT_GetStringBy_native(handle, key, buffer, 0);
        if (stringByNative <= 0)
          return (string) null;
        byte[] numArray = new byte[stringByNative];
        return Pdfium.FPDFDICT_GetStringBy_native(handle, key, numArray, stringByNative) <= 0 ? (string) null : Pdfium.DefaultAnsiEncoding.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetStringByEx", SetLastError = true)]
  private static extern int FPDFDICT_GetStringByEx_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen,
    [MarshalAs(UnmanagedType.LPStr)] string default_string);

  /// <summary>Gets the string associated with the specified key.</summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="defaultValue">Default value.</param>
  /// <returns>A string associated with the specified key or null if any error is occured.</returns>
  /// <remarks>The string is decoding using the <see cref="P:Patagames.Pdf.Pdfium.DefaultAnsiEncoding" /> property.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFDICT_GetStringByEx(IntPtr handle, string key, string defaultValue)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] buffer = (byte[]) null;
        int stringByExNative = Pdfium.FPDFDICT_GetStringByEx_native(handle, key, buffer, 0, defaultValue);
        if (stringByExNative <= 0)
          return (string) null;
        byte[] numArray = new byte[stringByExNative];
        return Pdfium.FPDFDICT_GetStringByEx_native(handle, key, numArray, stringByExNative, defaultValue) <= 0 ? (string) null : Pdfium.DefaultAnsiEncoding.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetUnicodeTextBy", SetLastError = true)]
  private static extern int FPDFDICT_GetUnicodeTextBy_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>Gets the string associated with the specified key.</summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A string associated with the specified key or null if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFDICT_GetUnicodeTextBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] buffer = (byte[]) null;
        int unicodeTextByNative = Pdfium.FPDFDICT_GetUnicodeTextBy_native(handle, key, buffer, 0);
        if (unicodeTextByNative <= 0)
          return (string) null;
        byte[] numArray = new byte[unicodeTextByNative];
        return Pdfium.FPDFDICT_GetUnicodeTextBy_native(handle, key, numArray, unicodeTextByNative) <= 0 ? (string) null : Platform.GetUnicode(numArray);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetIntegerBy", SetLastError = true)]
  private static extern int FPDFDICT_GetIntegerBy_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key);

  /// <summary>
  /// Gets the integer value from Number object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>An integer value associated with the specified key. Please see remarks for important details.</returns>
  /// <remarks><note type="note">Please note this method returns 0 if key not found or handle is IntPtr.Zero</note></remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFDICT_GetIntegerBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetIntegerBy_native(handle, key);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetIntegerByEx", SetLastError = true)]
  private static extern int FPDFDICT_GetIntegerByEx_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    int default_value);

  /// <summary>
  /// Gets the integer value from Number object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="defaultValue">Default value.</param>
  /// <returns>An integer value associated with the specified key. Please see remarks for important details.</returns>
  /// <remarks><note type="note">Please note this method returns defaultValue if key not found or 0 if handle is IntPtr.Zero</note></remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFDICT_GetIntegerByEx(IntPtr handle, string key, int defaultValue)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetIntegerByEx_native(handle, key, defaultValue);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetBooleanBy", SetLastError = true)]
  private static extern bool FPDFDICT_GetBooleanBy_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    bool default_value);

  /// <summary>
  /// Gets the boolean value associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="defaultValue">Default value.</param>
  /// <returns>A boolean value associated with the specified key. Please see remarks for important details.</returns>
  /// <remarks><note type="note">Please note this method returns defaultValue if key not found or false if handle is IntPtr.Zero</note></remarks>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFDICT_GetBooleanBy(IntPtr handle, string key, bool defaultValue = false)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetBooleanBy_native(handle, key, defaultValue);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetNumberBy", SetLastError = true)]
  private static extern void FPDFDICT_GetNumberBy_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    [MarshalAs(UnmanagedType.R4)] out float number);

  /// <summary>
  /// Gets the float value rom Number object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A float value associated with the specified key.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFDICT_GetNumberBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float number;
        Pdfium.FPDFDICT_GetNumberBy_native(handle, key, out number);
        return number;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetDictBy", SetLastError = true)]
  private static extern IntPtr FPDFDICT_GetDictBy_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key);

  /// <summary>
  /// Gets the Dictionary object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A handle to Dictionary object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDICT_GetDictBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetDictBy_native(handle, key);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetStreamBy", SetLastError = true)]
  private static extern IntPtr FPDFDICT_GetStreamBy_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key);

  /// <summary>
  /// Gets the Stream object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A handle to Stream object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDICT_GetStreamBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetStreamBy_native(handle, key);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetArrayBy", SetLastError = true)]
  private static extern IntPtr FPDFDICT_GetArrayBy_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key);

  /// <summary>
  /// Gets the Array object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A handle to Array object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFDICT_GetArrayBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_GetArrayBy_native(handle, key);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetRectBy", SetLastError = true)]
  private static extern void FPDFDICT_GetRectBy_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    [MarshalAs(UnmanagedType.Struct)] out FS_RECTF rectangle);

  /// <summary>
  /// Gets a rectangle from an Array object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A Rectangle associated with the specified key.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FS_RECTF FPDFDICT_GetRectBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        FS_RECTF rectangle;
        Pdfium.FPDFDICT_GetRectBy_native(handle, key, out rectangle);
        return rectangle;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_GetMatrixBy", SetLastError = true)]
  private static extern void FPDFDICT_GetMatrixBy_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    [MarshalAs(UnmanagedType.LPStruct), Out] FS_MATRIX rectangle);

  /// <summary>
  /// Gets a Matrix from an Array object associated with the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <returns>A Matrix associated with the specified key.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FS_MATRIX FPDFDICT_GetMatrixBy(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        FS_MATRIX rectangle = new FS_MATRIX();
        Pdfium.FPDFDICT_GetMatrixBy_native(handle, key, rectangle);
        return rectangle;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_KeyExist", SetLastError = true)]
  private static extern bool FPDFDICT_KeyExist_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key);

  /// <summary>
  /// Determines whether the Dictionary contains the specified key.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key to locate in the Dictionary.</param>
  /// <returns>true if the Dictionary contains an element with the specified key; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFDICT_KeyExist(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_KeyExist_native(handle, key);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_IsSignatureDict", SetLastError = true)]
  private static extern bool FPDFDICT_IsSignatureDict_native(IntPtr handle);

  /// <summary>
  /// Determines whether the Dictionary is a signature field.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <returns>true if the Dictionary is a signature field; otherwise, false.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static bool FPDFDICT_IsSignatureDict(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFDICT_IsSignatureDict_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAt", SetLastError = true)]
  private static extern void FPDFDICT_SetAt_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key, IntPtr value);

  /// <summary>
  /// Sets the PDF object at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="value">Handle to the PDF object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAt(IntPtr handle, string key, IntPtr value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAt_native(handle, key, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtName", SetLastError = true)]
  private static extern void FPDFDICT_SetAtName_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key, [MarshalAs(UnmanagedType.LPStr)] string value);

  /// <summary>
  /// Creates a Name object and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="value">Initial value for newly created name object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtName(IntPtr handle, string key, string value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtName_native(handle, key, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtString", SetLastError = true)]
  private static extern void FPDFDICT_SetAtString_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key, [MarshalAs(UnmanagedType.LPStr)] string value);

  /// <summary>
  /// Creates a String object and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="value">Initial value for newly created String object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtString(IntPtr handle, string key, string value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtString_native(handle, key, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtInteger", SetLastError = true)]
  private static extern void FPDFDICT_SetAtInteger_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key, int value);

  /// <summary>
  /// Creates a Number object, initialize it with integer value and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="value">Initial value for newly created Number object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtInteger(IntPtr handle, string key, int value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtInteger_native(handle, key, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtNumber", SetLastError = true)]
  private static extern void FPDFDICT_SetAtNumber_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key, [MarshalAs(UnmanagedType.R4)] float value);

  /// <summary>
  /// Creates a Number object, initialize it with float value and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="value">Initial value for newly created Number object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtNumber(IntPtr handle, string key, float value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtNumber_native(handle, key, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtReference", SetLastError = true)]
  private static extern void FPDFDICT_SetAtReference_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    IntPtr object_list,
    int objnum);

  /// <summary>
  /// Creates a Reference object and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="objectList">List of indirect objects</param>
  /// <param name="objnum">Object's number</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtReference(
    IntPtr handle,
    string key,
    IntPtr objectList,
    int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtReference_native(handle, key, objectList, objnum);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtReferenceEx", SetLastError = true)]
  private static extern void FPDFDICT_SetAtReferenceEx_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    IntPtr object_list,
    IntPtr obj);

  /// <summary>
  /// Creates a Reference object and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="objectList">List of indirect objects</param>
  /// <param name="obj">Handle to PDF object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtReferenceEx(
    IntPtr handle,
    string key,
    IntPtr objectList,
    IntPtr obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtReferenceEx_native(handle, key, objectList, obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_AddReference", SetLastError = true)]
  private static extern void FPDFDICT_AddReference_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    IntPtr object_list,
    int objnum);

  /// <summary>
  /// See <see cref="M:Patagames.Pdf.Pdfium.FPDFDICT_SetAtReferenceEx(System.IntPtr,System.String,System.IntPtr,System.IntPtr)" />
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="objectList">List of indirect objects</param>
  /// <param name="objnum">Object's number</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_AddReference(
    IntPtr handle,
    string key,
    IntPtr objectList,
    int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_AddReference_native(handle, key, objectList, objnum);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtRect", SetLastError = true)]
  private static extern void FPDFDICT_SetAtRect_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    [MarshalAs(UnmanagedType.Struct), In] ref FS_RECTF value);

  /// <summary>
  /// Creates an Array object, initialize it with rectangle values (left, top, right, bottom) and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="value">Initial value for newly created Array object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtRect(IntPtr handle, string key, FS_RECTF value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtRect_native(handle, key, ref value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtMatrix", SetLastError = true)]
  private static extern void FPDFDICT_SetAtMatrix_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string key,
    [MarshalAs(UnmanagedType.LPStruct)] FS_MATRIX value);

  /// <summary>
  /// Creates an Array object, initialize it with matrix values (a, b, c, d, e, f) and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="value">Initial value for newly created Array object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtMatrix(IntPtr handle, string key, FS_MATRIX value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtMatrix_native(handle, key, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_SetAtBoolean", SetLastError = true)]
  private static extern void FPDFDICT_SetAtBoolean_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key, bool value);

  /// <summary>
  /// Creates an Boolean object, initialize it with the value and sets it at the specified key of dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  /// <param name="value">Initial value for newly created Boolean object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_SetAtBoolean(IntPtr handle, string key, bool value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_SetAtBoolean_native(handle, key, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_RemoveAt", SetLastError = true)]
  private static extern void FPDFDICT_RemoveAt_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key);

  /// <summary>
  /// Release th PDF object and removse its from dictionary.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="key">The key contained in the Dictionary.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_RemoveAt(IntPtr handle, string key)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_RemoveAt_native(handle, key);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFDICT_ReplaceKey", SetLastError = true)]
  private static extern void FPDFDICT_ReplaceKey_native(
    IntPtr handle,
    [MarshalAs(UnmanagedType.LPStr)] string oldKey,
    [MarshalAs(UnmanagedType.LPStr)] string newKey);

  /// <summary>
  /// Replace the PDF object at oldKey with object from newKey.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="oldKey">The key contained in the Dictionary.</param>
  /// <param name="newKey">The key contained in the Dictionary.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFDICT_ReplaceKey(IntPtr handle, string oldKey, string newKey)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFDICT_ReplaceKey_native(handle, oldKey, newKey);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_Create", SetLastError = true)]
  private static extern IntPtr FPDFARRAY_Create_native();

  /// <summary>Create new Array object</summary>
  /// <returns>Handle to a newly created object</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFARRAY_Create()
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.PLE(Pdfium.FPDFARRAY_Create_native());
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetCount", SetLastError = true)]
  private static extern int FPDFARRAY_GetCount_native(IntPtr handle);

  /// <summary>Gets the number of keys contained in the Array.</summary>
  /// <param name="handle">Handle to Array object</param>
  /// <returns>A zero-based number of items or -1 if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFARRAY_GetCount(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFARRAY_GetCount_native(handle);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetObjectAt", SetLastError = true)]
  private static extern IntPtr FPDFARRAY_GetObjectAt_native(IntPtr handle, int index);

  /// <summary>Gets the PDF object at a given index.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <returns>A handle to PDF object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFARRAY_GetObjectAt(IntPtr handle, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFARRAY_GetObjectAt_native(handle, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetDirectObjectAt", SetLastError = true)]
  private static extern IntPtr FPDFARRAY_GetDirectObjectAt_native(IntPtr handle, int index);

  /// <summary>Gets the PDF object at a given index.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <returns>A handle to PDF object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFARRAY_GetDirectObjectAt(IntPtr handle, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFARRAY_GetDirectObjectAt_native(handle, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetStringAt", SetLastError = true)]
  private static extern int FPDFARRAY_GetStringAt_native(
    IntPtr handle,
    int index,
    [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
    int buflen);

  /// <summary>Gets the string at a given index.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <returns>A string value currently at this index or null if any error is occured.</returns>
  /// <remarks>The string is decoding using the <see cref="P:Patagames.Pdf.Pdfium.DefaultAnsiEncoding" /> property.</remarks>
  [HandleProcessCorruptedStateExceptions]
  public static string FPDFARRAY_GetStringAt(IntPtr handle, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        byte[] buffer = (byte[]) null;
        int stringAtNative = Pdfium.FPDFARRAY_GetStringAt_native(handle, index, buffer, 0);
        if (stringAtNative <= 0)
          return (string) null;
        byte[] numArray = new byte[stringAtNative];
        return Pdfium.FPDFARRAY_GetStringAt_native(handle, index, numArray, stringAtNative) <= 0 ? (string) null : Pdfium.DefaultAnsiEncoding.GetString(numArray).Trim(new char[1]);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetIntegerAt", SetLastError = true)]
  private static extern int FPDFARRAY_GetIntegerAt_native(IntPtr handle, int index);

  /// <summary>
  /// Gets the integer value from the array at a given index.
  /// </summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <returns>An integer value currently at this index or null if any error is occured.</returns>
  /// <remarks><note type="note">Please note this method returns 0 if key not found or handle is IntPtr.Zero</note></remarks>
  [HandleProcessCorruptedStateExceptions]
  public static int FPDFARRAY_GetIntegerAt(IntPtr handle, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFARRAY_GetIntegerAt_native(handle, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetNumberAt", SetLastError = true)]
  private static extern void FPDFARRAY_GetNumberAt_native(
    IntPtr handle,
    int index,
    [MarshalAs(UnmanagedType.R4)] out float number);

  /// <summary>Gets the float value at a given index.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <returns>A float value currently at this index or null if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static float FPDFARRAY_GetNumberAt(IntPtr handle, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        float number;
        Pdfium.FPDFARRAY_GetNumberAt_native(handle, index, out number);
        return number;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetDictAt", SetLastError = true)]
  private static extern IntPtr FPDFARRAY_GetDictAt_native(IntPtr handle, int index);

  /// <summary>Gets the Dictionary object at a given index.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <returns>A handle to Dictionary object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFARRAY_GetDictAt(IntPtr handle, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFARRAY_GetDictAt_native(handle, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetStreamAt", SetLastError = true)]
  private static extern IntPtr FPDFARRAY_GetStreamAt_native(IntPtr handle, int index);

  /// <summary>Gets the Stream object at a given index.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <returns>A handle to Stream object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFARRAY_GetStreamAt(IntPtr handle, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFARRAY_GetStreamAt_native(handle, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetArrayAt", SetLastError = true)]
  private static extern IntPtr FPDFARRAY_GetArrayAt_native(IntPtr handle, int index);

  /// <summary>Gets the Array object at a given index.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <returns>A handle to Array object or IntPtr.Zero if any error is occured.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static IntPtr FPDFARRAY_GetArrayAt(IntPtr handle, int index)
  {
    using (Lock.SyncMT)
    {
      try
      {
        return Pdfium.FPDFARRAY_GetArrayAt_native(handle, index);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetMatrix", SetLastError = true)]
  private static extern void FPDFARRAY_GetMatrix_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStruct), Out] FS_MATRIX rectangle);

  /// <summary>Gets a Matrix from an Array object.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <returns>A Matrix associated with this Array.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FS_MATRIX FPDFARRAY_GetMatrix(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        FS_MATRIX rectangle = new FS_MATRIX();
        Pdfium.FPDFARRAY_GetMatrix_native(handle, rectangle);
        return rectangle;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_GetRect", SetLastError = true)]
  private static extern void FPDFARRAY_GetRect_native(IntPtr handle, [MarshalAs(UnmanagedType.Struct)] out FS_RECTF rectangle);

  /// <summary>Gets a rectangle from an Array object.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <returns>A Rectangle associated with this Array.</returns>
  [HandleProcessCorruptedStateExceptions]
  public static FS_RECTF FPDFARRAY_GetRect(IntPtr handle)
  {
    using (Lock.SyncMT)
    {
      try
      {
        FS_RECTF rectangle;
        Pdfium.FPDFARRAY_GetRect_native(handle, out rectangle);
        return rectangle;
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_SetAt", SetLastError = true)]
  private static extern void FPDFARRAY_SetAt_native(
    IntPtr handle,
    int index,
    IntPtr value,
    IntPtr object_list);

  /// <summary>Sets the PDF object at the given index.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <param name="value">Handle to the PDF object</param>
  /// <param name="objectList">Handle to objects list. IntPtr.Zero for default</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_SetAt(IntPtr handle, int index, IntPtr value, IntPtr objectList)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_SetAt_native(handle, index, value, objectList);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_InsertAt", SetLastError = true)]
  private static extern void FPDFARRAY_InsertAt_native(
    IntPtr handle,
    int index,
    IntPtr value,
    IntPtr object_list);

  /// <summary>Insert the PDF object into given position.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <param name="value">Handle to the PDF object</param>
  /// <param name="objectList">Handle to objects list. IntPtr.Zero for default</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_InsertAt(IntPtr handle, int index, IntPtr value, IntPtr objectList)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_InsertAt_native(handle, index, value, objectList);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_RemoveAt", SetLastError = true)]
  private static extern void FPDFARRAY_RemoveAt_native(IntPtr handle, int index, int count);

  /// <summary>Release th PDF object and removes its from Array.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="index">An integer index that is greater than or equal to 0 and less than the value returned by <see cref="M:Patagames.Pdf.Pdfium.FPDFARRAY_GetCount(System.IntPtr)" />.</param>
  /// <param name="count">The number of deleted items.</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_RemoveAt(IntPtr handle, int index, int count = 1)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_RemoveAt_native(handle, index, count);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_Add", SetLastError = true)]
  private static extern void FPDFARRAY_Add_native(IntPtr handle, IntPtr value, IntPtr object_list);

  /// <summary>Adds the PDF object at the end of Arrary.</summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="value">Handle to the PDF object</param>
  /// <param name="objectList">Handle to objects list. IntPtr.Zero for default</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_Add(IntPtr handle, IntPtr value, IntPtr objectList)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_Add_native(handle, value, objectList);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_AddNumber", SetLastError = true)]
  private static extern void FPDFARRAY_AddNumber_native(IntPtr handle, [MarshalAs(UnmanagedType.R4)] float value);

  /// <summary>
  /// Creates a Number object, initialize it with float value and add it at the end of Array.
  /// </summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="value">Initial value for newly created Number object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_AddNumber(IntPtr handle, float value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_AddNumber_native(handle, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_AddInteger", SetLastError = true)]
  private static extern void FPDFARRAY_AddInteger_native(IntPtr handle, int value);

  /// <summary>
  /// Creates a Number object, initialize it with integer value and adds it at the end of array.
  /// </summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="value">Initial value for newly created Number object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_AddInteger(IntPtr handle, int value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_AddInteger_native(handle, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_AddString", SetLastError = true)]
  private static extern void FPDFARRAY_AddString_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string value);

  /// <summary>
  /// Creates a String object and adds it at the end of Array.
  /// </summary>
  /// <param name="handle">Handle to Dictionary object.</param>
  /// <param name="value">Initial value for newly created String object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_AddString(IntPtr handle, string value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_AddString_native(handle, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_AddName", SetLastError = true)]
  private static extern void FPDFARRAY_AddName_native(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string value);

  /// <summary>
  /// Creates a Name object and adds it at the end of array.
  /// </summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="value">Initial value for newly created name object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_AddName(IntPtr handle, string value)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_AddName_native(handle, value);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_AddReference", SetLastError = true)]
  private static extern void FPDFARRAY_AddReference_native(
    IntPtr handle,
    IntPtr object_list,
    int objnum);

  /// <summary>
  /// Creates a Reference object and adds it at the end of Array.
  /// </summary>
  /// <param name="handle">Handle to Arrya object.</param>
  /// <param name="objectList">List of indirect objects</param>
  /// <param name="objnum">Object's number</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_AddReference(IntPtr handle, IntPtr objectList, int objnum)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_AddReference_native(handle, objectList, objnum);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [DllImport("pdfium", EntryPoint = "FPDFARRAY_AddReferenceEx", SetLastError = true)]
  private static extern void FPDFARRAY_AddReferenceEx_native(
    IntPtr handle,
    IntPtr object_list,
    IntPtr obj);

  /// <summary>
  /// Creates a Reference object and sets it at the end of Array.
  /// </summary>
  /// <param name="handle">Handle to Array object.</param>
  /// <param name="objectList">List of indirect objects</param>
  /// <param name="obj">Handle to PDF object</param>
  [HandleProcessCorruptedStateExceptions]
  public static void FPDFARRAY_AddReferenceEx(IntPtr handle, IntPtr objectList, IntPtr obj)
  {
    using (Lock.SyncMT)
    {
      try
      {
        Pdfium.FPDFARRAY_AddReferenceEx_native(handle, objectList, obj);
      }
      catch (AccessViolationException ex)
      {
        throw new FatalErrorException((Exception) ex);
      }
    }
  }

  [UnmanagedFunctionPointer(CallingConvention.Cdecl, SetLastError = true)]
  private delegate void ManagedCallbackDelegate(int level, [MarshalAs(UnmanagedType.LPStr)] string pcode);

  /// <summary>
  /// Delegate that reperesents an application-defined callback function used with the
  /// <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GenerateContentEx(System.IntPtr,System.IntPtr,Patagames.Pdf.Pdfium.GenerateContentCallback,System.IntPtr)" /> and
  /// <see cref="M:Patagames.Pdf.Pdfium.FPDF_GenerateContentToStream(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Patagames.Pdf.Pdfium.GenerateContentCallback,System.IntPtr)" /> methods.
  /// </summary>
  /// <param name="userData">The application-defined value given in the <see cref="M:Patagames.Pdf.Pdfium.FPDFPage_GenerateContentEx(System.IntPtr,System.IntPtr,Patagames.Pdf.Pdfium.GenerateContentCallback,System.IntPtr)" /> or <see cref="M:Patagames.Pdf.Pdfium.FPDF_GenerateContentToStream(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Patagames.Pdf.Pdfium.GenerateContentCallback,System.IntPtr)" /> methods.</param>
  /// <param name="current">The sequence number of the object being processed.</param>
  /// <param name="total">The total number of page objects.</param>
  /// <returns>To continue generation, the callback function must return <strong>True</strong>; to stop generation, it must return <strong>False</strong>.</returns>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl, SetLastError = true)]
  public delegate bool GenerateContentCallback(IntPtr userData, int current, int total);

  /// <summary>
  /// Delegate for the application-defined callback function for <see cref="M:Patagames.Pdf.Pdfium.FPDFOBJ_SetDestroyCallback(System.IntPtr,Patagames.Pdf.Pdfium.InternalObjectDestroyCallback)" />
  /// </summary>
  /// <param name="obj_handle">The object that will be destroyed.</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl, SetLastError = true)]
  public delegate void InternalObjectDestroyCallback(IntPtr obj_handle);

  /// <summary>
  /// Delegate for the application-defined callback function for <see cref="M:Patagames.Pdf.Pdfium.FPDFDICT_Enum(System.IntPtr,Patagames.Pdf.Pdfium.DictEnumCallback)" />.
  /// </summary>
  /// <param name="handle">Handle to the dictionary itself.</param>
  /// <param name="key">The key of the value/</param>
  /// <param name="value">The value contained in the dictionary under the key.</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate void DictEnumCallback(IntPtr handle, [MarshalAs(UnmanagedType.LPStr)] string key, IntPtr value);
}
